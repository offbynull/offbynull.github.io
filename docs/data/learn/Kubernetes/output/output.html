<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>Kubernetes</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><p></p>
<div class="toc">
<ul>
<li><a href="#H_Introduction">Introduction</a></li>
<ul>
<li><a href="#H_Containers">Containers</a></li>
<li><a href="#H_Objects">Objects</a></li>
<li><a href="#H_Labels">Labels</a></li>
<li><a href="#H_Configuration">Configuration</a></li>
</ul>
<li><a href="#H_Resources">Resources</a></li>
<ul>
<li><a href="#H_Pods">Pods</a></li>
<ul>
<li><a href="#H1_Resources">Resources</a></li>
<li><a href="#H_Ports">Ports</a></li>
<li><a href="#H_Probes">Probes</a></li>
<li><a href="#H_Volumes">Volumes</a></li>
<li><a href="#H_Image%20Pull%20Policy">Image Pull Policy</a></li>
<li><a href="#H_Restart%20Policy">Restart Policy</a></li>
<li><a href="#H1_Configuration">Configuration</a></li>
<li><a href="#H_Secrets">Secrets</a></li>
</ul>
<li><a href="#H_Nodes">Nodes</a></li>
<li><a href="#H_Services">Services</a></li>
<ul>
<li><a href="#H_Routing">Routing</a></li>
<li><a href="#H1_Ports">Ports</a></li>
<li><a href="#H_Health">Health</a></li>
<li><a href="#H_Exposure">Exposure</a></li>
</ul>
<li><a href="#H_Replica%20Sets">Replica Sets</a></li>
<ul>
<li><a href="#H_Replication">Replication</a></li>
</ul>
<li><a href="#H_Deployments">Deployments</a></li>
<ul>
<li><a href="#H_Upgrade%20Strategy">Upgrade Strategy</a></li>
<li><a href="#H_Undo">Undo</a></li>
<li><a href="#H_Change%20Cause">Change Cause</a></li>
</ul>
<li><a href="#H_Daemon%20Sets">Daemon Sets</a></li>
<li><a href="#H_Jobs">Jobs</a></li>
</ul>
<li><a href="#H_Daemon%20Set">Daemon Set</a></li>
<li><a href="#H1_Daemon%20Sets">Daemon Sets</a></li>
<li><a href="#H_Job">Job</a></li>
<li><a href="#H_Configuration%20Map">Configuration Map</a></li>
<li><a href="#H_Autoscaling">Autoscaling</a></li>
<ul>
<li><a href="#H_Horizontal%20Pod%20Autoscaling">Horizontal Pod Autoscaling</a></li>
<li><a href="#H_Vertical%20Pod%20Autoscaling">Vertical Pod Autoscaling</a></li>
<li><a href="#H_Cluster%20Autoscaler">Cluster Autoscaler</a></li>
</ul>
<li><a href="#H_Kubectl%20Cheatsheet">Kubectl Cheatsheet</a></li>
<ul>
<li><a href="#H_CRUD">CRUD</a></li>
<li><a href="#H_Deployment">Deployment</a></li>
<li><a href="#H_Proxy">Proxy</a></li>
<li><a href="#H_Debug">Debug</a></li>
</ul>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_Introduction"></a><h1>Introduction</h1>
<p><a name="BM_(Introduction)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is a <a href="#BM_(service)%2Fi">service</a> orchestration framework that provides many of the plumbing pieces required for running <a href="#BM_(service)%2Fi">service</a>s. These <a href="#BM_(service)%2Fi">service</a>s include ...</p>
<ul>
<li>DNS for naming and discovery of <a href="#BM_(service)%2Fi">service</a>s,</li>
<li>Load balancer to distribute requests across many instances of a <a href="#BM_(service)%2Fi">service</a>,</li>
<li>Automatic recovery when a <a href="#BM_(service)%2Fi">service</a> crashes,</li>
<li>Automatic scaling when a <a href="#BM_(service)%2Fi">service</a> comes under load,</li>
<li>Password / certificate / secrets management for <a href="#BM_(service)%2Fi">service</a>s,</li>
<li>etc..</li>
</ul>
<a name="H_Containers"></a><h2>Containers</h2>
<p><a name="BM_(Introduction%5C%2FContainers)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is structured around <a href="#BM_(container)%2Fi">container</a>s.</p>
<p><img src="svgbob_f6d6eb5e8cf3c348cd91f60b2ccc3e7c9930dac2.svg" alt="Kroki diagram output"></p>
<p>In the <a href="#BM_(context)%2Fi">context</a> of <a href="#BM_(container)%2Fi">container</a>s, an ...</p>
<ul>
<li>
<p><a href="#BM_(image)%2Fi">image</a> is an application (or set of applications) packaged with all of its dependencies as an immutable and isolated filesystem. The filesystem typically contains all dependencies required for the application(s) run sealed at their correct version:</p>
<ul>
<li>libraries (e.g. correct version of libssh),</li>
<li>applications (e.g. correct version bash and Python),</li>
<li>files (e.g. embedded SQLite databases)</li>
<li>etc..</li>
</ul>
<p><a href="#BM_(image)%2Fi">Image</a>s also typically include metadata describing its needs and operational standards. For example, the metadata may stipulate that the <a href="#BM_(image)%2Fi">image</a> ...</p>
<ul>
<li>launches by running /opt/my_app/run.sh</li>
<li>stops by signalling SIGTERM</li>
<li>requires 4gb of memory, 1.5 CPU cores, etc..A <a href="#BM_(container)%2Fi">container</a> is an instance of an application requires that <a href="#BM_(service)%2Fi">service</a>s be exposed as <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>s. An <a href="#BM_(image)%2Fi">image</a> is</li>
</ul>
</li>
<li>
<p><a href="#BM_(container)%2Fi">container</a> is an instance of an <a href="#BM_(image)%2Fi">image</a>. A <a href="#BM_(container)%2Fi">container</a> creates an isolated copy of the <a href="#BM_(image)%2Fi">image</a>'s filesystem, isolates the <a href="#BM_(resource)%2Fi">resource</a>s required for that <a href="#BM_(image)%2Fi">image</a>, and launches the entrypoint application for that <a href="#BM_(image)%2Fi">image</a>. That <a href="#BM_(container)%2Fi">container</a> can't see or access anything outside of the <a href="#BM_(container)%2Fi">container</a> unless explicitly allowed to by the user. For example, opening a port 8080 on a <a href="#BM_(container)%2Fi">container</a> won't open port 8080 on the host running it, but the user can explicitly ask that port 8080 in the <a href="#BM_(container)%2Fi">container</a> map to some port on the host.</p>
</li>
</ul>
<p>As shown in the entity diagram above, each <a href="#BM_(container)%2Fi">container</a> is created from a single <a href="#BM_(image)%2Fi">image</a>, but that same <a href="#BM_(image)%2Fi">image</a> can be used for to create multiple <a href="#BM_(container)%2Fi">container</a>s. Another way to think about it is that an <a href="#BM_(image)%2Fi">image</a> is the blueprint of a factory and a <a href="#BM_(container)%2Fi">container</a> is the actual factory built from that blueprint. You can build multiple factories from the same blueprint.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> requires two core components to run:</p>
<ul>
<li><a href="#BM_(Open%20Container%20Initiative%20runtime%7COpen%20Container%20Initiative)%2Fi">open container initiative</a> (<a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI</a>) runtime - A runtime responsible for only creating and launching <a href="#BM_(container)%2Fi">container</a>s.</li>
<li><a href="#BM_(container%20runtime%20interface)%2Fi">container runtime interface</a> (<a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>) - A runtime responsible for the high-level management of <a href="#BM_(container)%2Fi">container</a>s and <a href="#BM_(image)%2Fi">image</a>s: <a href="#BM_(image)%2Fi">image</a> management, <a href="#BM_(image)%2Fi">image</a> distribution, <a href="#BM_(container)%2Fi">container</a> mounts / storage, <a href="#BM_(container)%2Fi">container</a> networking, etc..</li>
</ul>
<p>Different vendors provide different implementations of each. For example, certain vendors provide an <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a> that use virtualization technology for isolation instead of standard Linux isolation (e.g. cgroups).</p>
<p><img src="svgbob_a28730c1c9bb6f382bb8e320a51ca1cfa2db0bb2.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI</a>s and OCRs are also the basis for <a href="#BM_(container%20engine)%2Fi">container engine</a>s, tools that are responsible for creating and running <a href="#BM_(container)%2Fi">container</a>s (similar in nature <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> without the orchestration) as well as creating <a href="#BM_(image)%2Fi">image</a>s and other high-level functionality such as local testing of <a href="#BM_(container)%2Fi">container</a>s. Docker Engine is an example of a <a href="#BM_(container%20engine)%2Fi">container engine</a>.</p>
<p><img src="svgbob_3d4187f5433dd286b08d28526577c57afdc47ec0.svg" alt="Kroki diagram output"></p>
<a name="H_Objects"></a><h2>Objects</h2>
<p><a name="BM_(Introduction%5C%2FObjects)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> breaks down its orchestration as a set of objects. Each object is of a specific type (referred to as <a href="#BM_(resource)%2Fi">resource</a>) and those objects coordinate and manage each other through linkages (described in <a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a>). For example, a load balancer object is an instance of <a href="#BM_(resource)%2Fi">resource</a> <a href="#BM_(service)%2Fi">Service</a> and each copy of a running application it pipes requests to is an instance of <a href="#BM_(resource)%2Fi">resource</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>, and the load balancer is decides which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it to route to by searching for <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with a specific <a href="#BM_(label)%2Fi">label</a>.</p>
<p>This is in contrast to a hierarchal setup where objects have ownership or are inherited from others. There is no ownership or parent-child relationship here, only loosely coupled linkages.</p>
<p><img src="svgbob_d1e778081e8cdf9a5a337a08f8f517ac030d2200.svg" alt="Kroki diagram output"></p>
<a name="H_Labels"></a><h2>Labels</h2>
<p><a name="BM_(Introduction%5C%2FLabels)_TOPIC%2Fi"></a><strong></strong></p>
<p>Objects within <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> may be assigned key-value pairs. Two types of key-value pair assignments exist:</p>
<ul>
<li><a href="#BM_(label)%2Fi">Label</a>s - key-value assignments for logical grouping of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects. These allow for organizing objects into groups, such that users can target a group as a whole (e.g. give me all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> designed by the SRE team).</li>
<li><a href="#BM_(annotation%7Cannotate)%2Fi">Annotation</a>s - key-value assignments for metadata on <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects. These allow tools and libraries to gather ancillary information about the object, such that they can perform some task.</li>
</ul>
<p>In other words, <a href="#BM_(label)%2Fi">label</a>s are used to identity objects while <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s are not. For example if you have different classes of <a href="#BM_(worker%20node)%2Fi">worker node</a>s in your cluster, it may be a good idea to <a href="#BM_(label)%2Fi">label</a> each <a href="#BM_(node)%2Fi">node</a> with its class. That way, if you wanted to deprecate a specific class, you'd be able to targe them as a group and shut them down.</p>
<p><a href="#BM_(label)%2Fi">Label</a>s are targeted using a simple language called <a href="#BM_(label%20selector)%2Fi">label selector</a>s.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key=value</code></td>
<td><code>key</code> is set to <code>value</code></td>
</tr>
<tr>
<td><code>key!=value</code></td>
<td><code>key</code> is not set to <code>value</code></td>
</tr>
<tr>
<td><code>key in (value1, value2, ...)</code></td>
<td><code>key</code> is either <code>value1</code>, <code>value2</code>, ...</td>
</tr>
<tr>
<td><code>key notin (value1, value2, ...)</code></td>
<td><code>key</code> is neither <code>value1</code>, <code>value2</code>, ...</td>
</tr>
<tr>
<td><code>key</code></td>
<td>a value is set for <code>key</code></td>
</tr>
<tr>
<td><code>!key</code></td>
<td>a value not set for <code>key</code></td>
</tr>
<tr>
<td><code>key1=value1,key2=value2</code></td>
<td><code>key1</code> is set to <code>value1</code> and <code>key2</code> is set to <code>value2</code></td>
</tr>
</tbody>
</table>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses <a href="#BM_(label)%2Fi">label</a>s for many of its internal <a href="#BM_(service)%2Fi">service</a>s. For example, <a href="#BM_(label%20selector)%2Fi">label selector</a>s are used for deciding ...</p>
<ul>
<li>the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> which a <a href="#BM_(service)%2Fi">service</a> routes traffic to.</li>
<li>which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are allowed to communicate with each other over the internal network.</li>
<li>the <a href="#BM_(node)%2Fi">node</a>s which a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can be scheduled on.</li>
<li>etc..</li>
</ul>
<p>If there are a large number of keys / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s, either because the organization set them directly or because they're being set by external tools, the chance of a collision increases. To combat this, keys for <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s can optionally include a prefix (separated by a slash) that maps to a DNS subdomain to help disambiguate it. For example, <code>company.com/my_key</code> rather than just having <code>my_key</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book states that key name itself can be at most 63 chars. If a prefix is included, it doesn't get included in that limit. A prefix can be up to 253 chars.</p>
</div>
<a name="H_Configuration"></a><h2>Configuration</h2>
<p><a name="BM_(Introduction%5C%2FConfiguration)_TOPIC%2Fi"></a><strong></strong></p>
<p>Objects can either be accessed and mutated through a standard command-line interface called <a href="#BM_(kubectl)%2Fi">kubectl</a> or a REST web interface. Manipulations come in two forms:</p>
<ul>
<li>
<p><a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a> - the mutations to perform on the object (via <a href="#BM_(kubectl)%2Fi">kubectl</a> invocations).</p>
<pre><code>kubectl run my_pod --image=gcr.io/my_company/my_pod:v1
kubectl set pods my_pod --requests='cpu=500m,memory=128Mi'
</code></pre>
</li>
<li>
<p><a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> - the overall description of the object, called a manifest (as YAML or JSON via either <a href="#BM_(kubectl)%2Fi">kubectl</a> or REST).</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
</code></pre>
<pre><code>kubectl apply -f obj.yaml
kubectl delete -f obj.yaml
</code></pre>
</li>
</ul>
<p>Generally, <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a>s are preferred over <a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a>s. When a <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> is submitted, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs a <a href="#BM_(reconciliation%20loop)%2Fi">reconciliation loop</a> in the background to automatically mutate the state of the object to the one in the manifest. Contrast this to the <a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a> method, where the mutations have to be manually submitted by the user one by one.</p>
<a name="H_Resources"></a><h1>Resources</h1>
<p><a name="BM_(Resources)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction)_TOPIC%2Fi">Introduction</a></li>
<li><a href="#BM_(Introduction%5C%2FConfiguration)_TOPIC%2Fi">Introduction/Configuration</a></li>
<li><a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a></li>
</ul>
</div>
<p>The following sub-sections gives a overview of the main <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a>s and example manifests. All manifests, regardless of the <a href="#BM_(resource)%2Fi">resource</a> require the following fields...</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-name</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">author:</span> <span class="hljs-string">"Jimbo D."</span>
    <span class="hljs-attr">created_on:</span> <span class="hljs-string">"Aug 20 2021"</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app_server:</span> <span class="hljs-string">jetty</span>
</code></pre>
<p>... where <code>version</code> is the API version, <code>kind</code> is the <a href="#BM_(resource)%2Fi">resource</a> (e.g. <code>Pod</code>), and <code>metadata.name</code> is the name of the object. In addition, the <code>metadata</code> section can contain <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s to assign to the object via the <code>metadata.labels</code> and <code>metadata.annotations</code> manifest paths respectively.</p>
<a name="H_Pods"></a><h2>Pods</h2>
<p><a name="BM_(Resources%5C%2FPods)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(container)%2Fi">Container</a>s are deployed in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> via <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is is a set of <a href="#BM_(container)%2Fi">container</a>s grouped together, often <a href="#BM_(container)%2Fi">container</a>s that are so tightly coupled or are required to work in close proximity of each other (e.g. on the same host).</p>
<p><img src="svgbob_e74b52a9043c79551911fcf4f001af764adce0b0.svg" alt="Kroki diagram output"></p>
<p>Many copies of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> may be running on the cluster at the same time, often in an effort to distribute load and / or provide redundancy.</p>
<p><img src="svgbob_9e1d1ea6439e4b6734d777b4ef484128af313509.svg" alt="Kroki diagram output"></p>
<p><img src="svgbob_50c156f131a6bbec9cd7f8af4625c3bd265e5dfb.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(container)%2Fi">Container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are isolated in terms of their <a href="#BM_(resource)%2Fi">resource</a> requirements (e.g. CPU, memory, and disk), but they share the same ...</p>
<ul>
<li>network (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> have the same IP, same host, and share the port space).</li>
<li>IPC bus (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can communicate with each other over POSIX message queues / System V IPC channels).</li>
<li>volumes (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> may have shared storage assigned to them in addition to their isolated storage).</li>
</ul>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> orchestrates <a href="#BM_(container)%2Fi">container</a>s over a cluster of machines. The <a href="#BM_(container)%2Fi">container</a>s for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are guaranteed to all be running on the same machine. As such, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are usually structured in a way that their <a href="#BM_(container)%2Fi">container</a>s are tightly coupled and scale together. For example, a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with two <a href="#BM_(container)%2Fi">container</a>s, a WordPress server and its required MySQL database server, is a bad usage example because those two ...</p>
<ol>
<li>don't scale uniformly (e.g. you'll likely need to scale the database up before the WordPress server).</li>
<li>don't communicate over anything other than the network (e.g. they don't need a shared volume).</li>
<li>are intended to be distributed (e.g. it's okay for them to be running on separate machines).</li>
</ol>
<p>Contrast that to an example of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with two <a href="#BM_(container)%2Fi">container</a>s, an application server and an associated log watcher. This is a good example because the two <a href="#BM_(container)%2Fi">container</a>s ...</p>
<ol>
<li>communicate over the filesystem (e.g. application server is writing logs to a shared volume and the log watcher is tailing them).</li>
<li>aren't intended to be distributed (e.g. log watcher is intended for locally produced logs).</li>
<li>are written by different teams (e.g. SRE team wrote the log watcher <a href="#BM_(image)%2Fi">image</a> while another team wrote the application server <a href="#BM_(image)%2Fi">image</a>).</li>
</ol>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1000m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"256Mi"</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/data"</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">"kuard-data"</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/healthy</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data"</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data"</span>  <span class="hljs-comment"># literally mounts a path from the worker node? not persistant if node modes</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data_nfs"</span>
      <span class="hljs-attr">nfs:</span>
        <span class="hljs-attr">server:</span> <span class="hljs-string">nfs.server.location</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/path/on/nfs"</span>
</code></pre>
<a name="H1_Resources"></a><h3>Resources</h3>
<p><a name="BM_(Resources%5C%2FPods%2FResources)_TOPIC%2F"></a><strong></strong></p>
<p></p>
<p><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> resources are controlled via the <code>spec.containers[].resources</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1000m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"256Mi"</span>
    <span class="hljs-string">...</span>
</code></pre>
<p><code>requests</code> are the minimum resources the pod needs to operate while <code>limits</code> are the maximum it can have. Some resources are dynamically adjustable while others require the pod to restart. For example, a pod ...</p>
<ul>
<li>can have its CPU usage dynamically adjusted because <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> can just ask the operating system's CPU scheduler to give it less/more timer.</li>
<li>can't have its memory usage dynamically adjusted because if it loses access to a block of memory the applications running within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> won't know and will likely crash.</li>
</ul>
<p>The example above lists out CPU and memory as viable resource types. The unit of measurement for ...</p>
<ul>
<li>cpu is either in ...
<ul>
<li>whole cores: no suffix</li>
<li><a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a>s: suffix of m (1 core is equivalent to 1000m -- e.g. 0.5 = 5000m).</li>
</ul>
</li>
<li>memory is either in ...
<ul>
<li>bytes: no suffix</li>
<li>1000 scale: suffix of k = 1000, M = 1,000,000, G = 1,000,000,000</li>
<li>power of two scale: suffix of k = 1024, M = 1,048,576, G = 1,073,741,824</li>
</ul>
</li>
</ul>
<p></p>
<a name="H_Ports"></a><h3>Ports</h3>
<p><a name="BM_(Resources%5C%2FPods%2FPorts)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> port exposures are controlled via the <code>spec.containers[].ports[]</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
    <span class="hljs-string">...</span>
</code></pre>
<p>The example above exposes port 8080 to the rest of the cluster (not the outside world). Even with the port exposed, other entities on the cluster don't have a built-in way to discover the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s IP / host or the fact that it has this specific port open. For that, <a href="#BM_(service)%2Fi">service</a>s are required (see <a href="#BM_(Resources%5C%2FServices)_TOPIC%2Fi">Resources/Services</a>).</p>
<a name="H_Probes"></a><h3>Probes</h3>
<p><a name="BM_(Resources%5C%2FPods%2FProbes)_TOPIC%2F"></a><strong></strong></p>
<p>Probes are a way for <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to check the state of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (e.g. alive, ready, started, etc..). The <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> exposes some interfaces to determine state. <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> periodically pings those interfaces to determine what actions to take (e.g. restarting a downed <a href="#BM_(service)%2Fi">service</a>.</p>
<p>Probes are controlled via the <code>spec.containers[].livenessProbe</code> and <code>spec.containers[].readinessProbe</code> manifest paths.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/healthy</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>Different types of probes exists. A ...</p>
<ul>
<li><a href="#BM_(liveness%20probe)%2Fi">liveness probe</a> is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is alive and responsive. If the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails to respond to such checks, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> deems it dead and restarts it.</li>
<li><a href="#BM_(readiness%20probe)%2Fi">readiness probe</a> is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is ready to process requests. When a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> initially comes online, before routing requests to it <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> waits for its <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a> to respond successfully.</li>
</ul>
<p>In the example above, each of the probes check a HTTP server within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> at port 8080 but at different paths. Other types of probes exist as well (e.g. <code>tcpSocket</code> instead of <code>httpGet</code>). The field ...</p>
<ul>
<li><code>initialDelaySeconds</code> is the number of seconds to wait before performing the first probe.</li>
<li><code>timeoutSeconds</code> is the number of seconds to wait before timing out.</li>
<li><code>periodSeconds</code> is the number of seconds to wait before performing a probe.</li>
<li><code>failureThreshold</code> is the maximum number of successive failure before <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> considers the probe failed.</li>
<li><code>successThreshold</code> is the maximum number of successive successes before <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> considers the probe passed.</li>
</ul>
<a name="H_Volumes"></a><h3>Volumes</h3>
<p><a name="BM_(Resources%5C%2FPods%2FVolumes)_TOPIC%2F"></a><strong></strong></p>
<p>Volumes are controlled via the <code>spec.volumes[]</code> and <code>spec.containers[].volumneMounts</code> manifest paths ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/data"</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">"m_data"</span>
      <span class="hljs-string">...</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data"</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data"</span>
</code></pre>
<p><code>spec.volumes[]</code> defines a list of volumes, and those volumes can then go on to be mounted on the individual <a href="#BM_(container)%2Fi">container</a>s that make up the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> using <code>spec.containers[].volumneMounts</code>. In the example above, a volume is mounted on the <a href="#BM_(container)%2Fi">container</a> that points to a directory on the host machine. If other <a href="#BM_(container)%2Fi">container</a>s in that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> had that volume mounted, the directory on the host machine would be shared across all of them.</p>
<p>Multiple types of volumes exist. The volume type of ...</p>
<ul>
<li><code>hostPath</code> is a directory directly on the host machine running the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (shared dir across <a href="#BM_(container)%2Fi">container</a>s in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>).</li>
<li><code>emptyDir</code> is a directory directly on the host machine running the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (unshared temp dir per <a href="#BM_(container)%2Fi">container</a>s in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, guaranteed to be empty).</li>
<li><code>nfs</code> is backed by NFS.</li>
<li><code>cephfs</code> is backed by CephFS.</li>
<li><code>awsElasticBlockStorage</code> is backed by AWS.</li>
<li><code>azureDisk</code> is backed by Azure.</li>
</ul>
<p>Others exist as well. Volume types are added / removed as <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> updates between versions.</p>
<a name="H_Image%20Pull%20Policy"></a><h3>Image Pull Policy</h3>
<p><a name="BM_(Resource%5C%2FPods%2FImage%20Pull%20Policy)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(image)%2Fi">Image</a> pull policy is the policy <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses for downloading a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(image)%2Fi">image</a>s. It's controlled via the <code>spec.containers[].imagePullPolicy</code> manifest paths ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>A value of ...</p>
<ul>
<li><code>IfNotPresent</code> only downloads the <a href="#BM_(image)%2Fi">image</a> if its not already locally present.</li>
<li><code>Always</code> always downloads the <a href="#BM_(image)%2Fi">image</a>.</li>
<li><code>Never</code> never downloads the <a href="#BM_(image)%2Fi">image</a> (will fail if <a href="#BM_(image)%2Fi">image</a> does not exist locally).</li>
</ul>
<p>If unset, the pull policy differs based on the <a href="#BM_(image)%2Fi">image</a> tag. Not specifying a tag or specifying <code>latest</code> as the tag will always pull the <a href="#BM_(image)%2Fi">image</a>. Otherwise, the <a href="#BM_(image)%2Fi">image</a> will be pulled only if it isn't present.</p>
<a name="H_Restart%20Policy"></a><h3>Restart Policy</h3>
<p><a name="BM_(Resources%5C%2FPods%2FRestart%20Policy)_TOPIC%2F"></a><strong></strong></p>
<p>Restart policy is the policy <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses for determining when a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> should be restarted. Its controlled via the <code>spec.containers[].restartPolicy</code> manifest paths ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
    <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>A value of ...</p>
<ul>
<li><code>Always</code> always restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> regardless of how it exists (default).</li>
<li><code>OnFailure</code> only restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> only if it failed execution.</li>
<li><code>Never</code> never restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p>The top one is typically used when running servers that should always be up (e.g. http server) while the latter two are typically used for one-off <a href="#BM_(job)%2Fi">job</a>s.</p>
<a name="H1_Configuration"></a><h3>Configuration</h3>
<p><a name="BM_(Resources%5C%2FPods%2FConfiguration)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FVolumes)_TOPIC%2F">Resources/Pods/Volumes</a></li>
<li><a href="#BM_(Configuration%20Map)_TOPIC%2F">Configuration Map</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Do <strong>NOT</strong> use this for storing secrets such as tokens, certificates, or passwords. See <a href="#BM_(Pods%5C%2FSecrets)_TOPIC%2F">Pods/Secrets</a>.</p>
</div>
<p>Configuring the applications running under a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is done through either command-line arguments, environment variables, files, or a mix of the three. Each has a different configuration method.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"/my-app.sh"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(PARAM1)"</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PARAM2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">key1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PARAM3</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">key2</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
</code></pre>
<p>To set a ...</p>
<ul>
<li>
<p>environment variable to a <a href="#BM_(ConfigMap)%2Fi">ConfigMap</a> key, use the following <code>valueFrom</code> stanza in <code>spec.containers[].env[]</code> ...</p>
<pre class="hljs"><code><span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME</span>
<span class="hljs-attr">valueFrom:</span>
  <span class="hljs-attr">configMapKeyRef:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
  <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY_HERE</span>
</code></pre>
</li>
<li>
<p>command-line argument to a <a href="#BM_(ConfigMap)%2Fi">ConfigMap</a> key, first set ito an environment variable, then set the argument to that environment variable by setting in <code>spec.containers[].command[]</code> using <code>${ENV_VAR_NAME}</code>.</p>
</li>
<li>
<p>file to a <a href="#BM_(ConfigMap)%2Fi">ConfigMap</a> key (value is file's contents), create a <code>configMap</code> type volume and mount it to the <a href="#BM_(container)%2Fi">container</a> ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">CONFIG_MAP_KEY_HERE</span>
</code></pre>
</li>
</ul>
<a name="H_Secrets"></a><h3>Secrets</h3>
<p><a name="BM_(Pods%5C%2FSecrets)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FConfiguration)_TOPIC%2F">Resources/Pods/Configuration</a></li>
<li><a href="#BM_(Resources%5C%2FPods%2FVolumes)_TOPIC%2F">Resources/Pods/Volumes</a></li>
</ul>
</div>
<p>Secrets are the standard way of storing application configurations related to security in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> (e.g. access tokens, passwords, certificates). Secrets can't be added through manifests or configuration maps. Instead, they must be added using <a href="#BM_(kubectl)%2Fi">kubectl</a>. For example, ...</p>
<pre><code>kubectl create secret generic my-tls-cert --from-file=a.crt --from-file=a.key
</code></pre>
<p>To use secrets in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, a specialized <code>secret</code> volume type must be used and mounted. For example, the following volume mounts the secrets created in the example command above ..</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-secrets</span>
        <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/tls"</span>
        <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-secrets</span>
      <span class="hljs-attr">secret:</span>
        <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-tls-cert</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why not use <a href="#BM_(ConfigMap)%2Fi">ConfigMap</a>s for secrets? Apparently there's some extra work going on to make sure this secrets volume is secure / transient.</p>
</div>
<a name="H_Nodes"></a><h2>Nodes</h2>
<p><a name="BM_(Resources%5C%2FNodes)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
</ul>
</div>
<p><a href="#BM_(node)%2Fi">Node</a>s are the machines that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> run on. A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> cluster often contains multiple <a href="#BM_(node)%2Fi">node</a>s, each with a certain amount of <a href="#BM_(resource)%2Fi">resource</a>s. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> get assigned to <a href="#BM_(node)%2Fi">node</a>s based on their <a href="#BM_(resource)%2Fi">resource</a> requirements. For example, if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> A requires 2gb of memory and <a href="#BM_(node)%2Fi">node</a> C has 24 gigs available, that <a href="#BM_(node)%2Fi">node</a> may get assigned to run that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p><img src="svgbob_fc6073ce9dd71ac1b2fa56b7775e45eca6d21eaf.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> typically attempts to schedule multiple instances of the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> on different <a href="#BM_(node)%2Fi">node</a>s, such that a downed <a href="#BM_(node)%2Fi">node</a> won't take out all instances of the <a href="#BM_(service)%2Fi">service</a> that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> runs. In the example above, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances of the same type are spread out across the 3 <a href="#BM_(node)%2Fi">node</a>s.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> has a leader-follower architecture, meaning that of the <a href="#BM_(node)%2Fi">node</a>s a small subset is chosen to lead / manage the others. The leaders are referred to as <a href="#BM_(master%20node)%2Fi">master node</a>s while the followers are referred to as <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
<p><img src="svgbob_90abf3344c1d253481a3a392500782cca41f92fd.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BM_(master%20node)%2Fi">master node</a> can still run <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> just like the <a href="#BM_(worker%20node)%2Fi">worker node</a>s, but some of its <a href="#BM_(resource)%2Fi">resource</a>s will be tied up for the purpose of managing <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
<a name="H_Services"></a><h2>Services</h2>
<p><a name="BM_(Resources%5C%2FServices)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
<li><a href="#BM_(Resources%5C%2FNodes)_TOPIC%2Fi">Resources/Nodes</a></li>
</ul>
</div>
<p><a href="#BM_(service)%2Fi">Service</a>s are a discovery and load balancing mechanism. A <a href="#BM_(service)%2Fi">service</a> exposes a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> under a single fixed unified hostname and IP, routing traffic to that set by load balancing incoming requests across the set. Any external application would need to use a <a href="#BM_(service)%2Fi">service</a>'s hostname because the IP / host of the single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances aren't fixed, exposed, or known. That is, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are transient and aren't guaranteed to always reside on the same <a href="#BM_(node)%2Fi">node</a>. As they shutdown, come up, restart, move between <a href="#BM_(node)%2Fi">node</a>s, etc.., there's no implicit mechanism that requestors can use to route their requests accordingly.</p>
<p>A <a href="#BM_(service)%2Fi">service</a> fixes this my internally tracking such changes and providing a single unified point of access.</p>
<p><img src="svgbob_9fcafa853ed3eccdae11b6e4d860f6208b276d0e.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions why DNS can't be used directly. For example, having a basic DNS <a href="#BM_(service)%2Fi">service</a> which returns a list of all up-and-running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> IPs won't work because ...</p>
<ol>
<li>applications and operating systems often cache DNS results, meaning that changes won't be visible immediately.</li>
<li>applications often only use the first IP given back by a DNS result, meaning that requests won't balance.</li>
</ol>
<p>The <a href="#BM_(service)%2Fi">service</a> fixes this because it acts as a load balancing proxy and its IP / host never changes (DNS caching won't break anything).</p>
</div>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
</code></pre>
<a name="H_Routing"></a><h3>Routing</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> determines which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it should route traffic to via the <code>spec/selector</code> manifest path. This manifest path contains key-value mappings, where these key-value mappings are <a href="#BM_(label)%2Fi">label</a>s that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> needs before being considered for this <a href="#BM_(service)%2Fi">service</a>'s traffic ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span>
    <span class="hljs-attr">key2:</span> <span class="hljs-string">value2</span>
    <span class="hljs-attr">key3:</span> <span class="hljs-string">value3</span>
</code></pre>
<a name="H1_Ports"></a><h3>Ports</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FPorts)_TOPIC%2F">Resources/Pods/Ports</a></li>
</ul>
</div>
<p>Requests are load balanced across the determined set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> using ports defined via the <code>spec/ports</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
    <span class="hljs-string">...</span>
</code></pre>
<p><code>port</code> defines the port that the <a href="#BM_(service)%2Fi">service</a> listens on, while <code>targetPort</code> is the port requests are forwarded to on the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. If <code>targetPort</code> is omitted, the value of <code>port</code> is assigned to it automatically.</p>
<a name="H_Health"></a><h3>Health</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FProbes)_TOPIC%2F">Resources/Pods/Probes</a></li>
</ul>
</div>
<p>The <a href="#BM_(service)%2Fi">service</a> periodically probes the status of each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to determine if it can handle requests or not. Two types of probes are performed:</p>
<ul>
<li><a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s - When an existing instance of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails a user-defined test that checks if it's still running, the <a href="#BM_(service)%2Fi">service</a> stops routing traffic to it.</li>
<li><a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s - When a new instance of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> comes up, the <a href="#BM_(service)%2Fi">service</a> won't route traffic to it until it passes a user-defined test that says it's ready.</li>
</ul>
<p>These probes are defined directly in the <a href="#BM_(pod%20manifest)%2Fi">pod manifest</a>.</p>
<p><img src="svgbob_4db118f49983e7aa72c7b4a50af69abf5161819b.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Internally, an <a href="#BM_(endpoints)%2Fi">EndPoints</a> object is used to track <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. When you create a <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> automatically creates an accompanying <a href="#BM_(endpoints)%2Fi">EndPoints</a> object that the <a href="#BM_(service)%2Fi">service</a> makes use of.</p>
</div>
<a name="H_Exposure"></a><h3>Exposure</h3>
<p>The <a href="#BM_(service)%2Fi">service</a> type defines where and how a <a href="#BM_(service)%2Fi">service</a> gets exposed, controlled via the <code>spec.type</code> manifest pth. For example, a <a href="#BM_(service)%2Fi">service</a> may only be accessible within the cluster, to specific parts of the cluster, to an external network, to the Internet, etc...</p>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>ClusterIP</code> are only accessible from within the cluster. The hostname for a <code>ClusterIP</code> <a href="#BM_(service)%2Fi">service</a> is broken down as follows: NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a>.svc.CLUSTER</p>
<ul>
<li><em>NAME</em> is the name of the <a href="#BM_(service)%2Fi">service</a>.</li>
<li><em><a href="#BM_(namespace)%2Fi">NAMESPACE</a></em> is the <a href="#BM_(namespace)%2Fi">namespace</a> the <a href="#BM_(service)%2Fi">service</a> is in (defaults to <code>default</code>).</li>
<li>svc is a constant that identifies the host is for a <a href="#BM_(service)%2Fi">service</a>.</li>
<li><em>CLUSTER</em> is the name of the cluster (defaults to <code>cluster.local.</code>).</li>
</ul>
<p>Depending on what level you're working in, a hostname may be shortened. For example, if the requestor and the <a href="#BM_(service)%2Fi">service</a> are within ...</p>
<ul>
<li>the same <a href="#BM_(namespace)%2Fi">namespace</a> and cluster, hostname NAME is sufficient.</li>
<li>the same cluster but not the same <a href="#BM_(namespace)%2Fi">namespace</a>, hostname NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a> is sufficient.</li>
<li>different clusters, the full hostname NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a>.svc.CLUSTER is required.</li>
</ul>
<p>The IP for a <code>ClusterIP</code> <a href="#BM_(service)%2Fi">service</a> is stable as well, just like the hostname.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Internally, a <code>ClusterIP</code> <a href="#BM_(service)%2Fi">service</a> uses <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">kube-proxy</a> to route requests to relevant <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (<a href="#BM_(endpoints)%2Fi">EndPoints</a>).</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>
</code></pre>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>NodePort</code> are accessible from outside the cluster. Every <a href="#BM_(worker%20node)%2Fi">worker node</a> opens a port (either user-defined or assigned by the system) that routes requests to the <a href="#BM_(service)%2Fi">service</a>. Since <a href="#BM_(node)%2Fi">node</a>s are transient, there is no single point of access to the <a href="#BM_(service)%2Fi">service</a>.</p>
<p>When <code>NodePort</code> is used as the type, the manifest path <code>spec.ports[].nodePort</code> defines the port on the <a href="#BM_(worker%20node)%2Fi">worker node</a> to open.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
</code></pre>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>LoadBalancer</code> are accessible from outside the cluster. When the <code>LoadBalancer</code> type is used, the cloud provider running the cluster assigning their version of a load balancer to route external HTTP requests to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(ingress)%2Fi">Ingress</a> component. <a href="#BM_(ingress)%2Fi">Ingress</a> then determines what <a href="#BM_(service)%2Fi">service</a> that request should be routed to based on details within the HTTP parameters (e.g. Host).</p>
<p>There is no built-in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> implementation of <a href="#BM_(ingress)%2Fi">Ingress</a>. <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> provides the interface but someone must provide the implementation, called an <a href="#BM_(ingress)%2Fi">Ingress</a> controller, for the functionality to be there. The reason for this is that load balancers come in multiple forms: software load balancers, cloud provider load balancers, and hardware load balancers. When used directly, each has a unique way it needs to be configured, but the <a href="#BM_(ingress)%2Fi">Ingress</a> implementation abstracts that out.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
</code></pre>
<p>Once provisioned, the object will have the manifest path <code>status.loadBalancer.ingress.ip[]</code> added to it, which states the IP of the load balancer forwarding requests to this <a href="#BM_(service)%2Fi">service</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
<span class="hljs-attr">status:</span>
  <span class="hljs-attr">loadBalancer:</span>
    <span class="hljs-attr">ingress:</span>
      <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span>
</code></pre>
<a name="H_Replica%20Sets"></a><h2>Replica Sets</h2>
<p><a name="BM_(Resources%5C%2FReplica%20Sets)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
</ul>
</div>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> is an abstraction that's used to ensure a certain number of copies of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are always up and running. Typical scenarios where <a href="#BM_(replica%20set)%2Fi">replica set</a>s are used include ...</p>
<ul>
<li>sharding (e.g. workers that pull <a href="#BM_(job)%2Fi">job</a> out of a queue for processing).</li>
<li>scale (e.g. micro<a href="#BM_(service)%2Fi">service</a>s that scale horizontally).</li>
<li>redundancy (e.g. leader-follower architectures such as Redis-style replica servers).</li>
</ul>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-replicaset</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.1</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
</code></pre>
<a name="H_Replication"></a><h3>Replication</h3>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> determines how many replicas it needs via the <code>spec.replicas</code> manifest path, and it determines how to create missing replicas using the <code>spec.template</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.1</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
</code></pre>
<p>Recall that, to link objects together, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses loosely coupled linkages via <a href="#BM_(label)%2Fi">label</a>s rather than hierarchial parent-child relationships. As such, the <a href="#BM_(pod%20template)%2Fi">pod template</a> should have a unique set of <a href="#BM_(label)%2Fi">label</a>s assigned that the <a href="#BM_(replica%20set)%2Fi">replica set</a> can look for to determine how many instances are running. Regardless of how those instances were launched (via the <a href="#BM_(replica%20set)%2Fi">replica set</a> or something else), the <a href="#BM_(replica%20set)%2Fi">replica set</a> will account for them.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You can distinguish a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> created by a <a href="#BM_(replica%20set)%2Fi">replica set</a> vs one created manually by checking the <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> key <code>kubernetes.io/create-by</code> on the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p>If deleting a <a href="#BM_(replica%20set)%2Fi">replica set</a>, use <code>--cascade=false</code> in <a href="#BM_(kubectl)%2Fi">kubectl</a> if you don't want the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> created by the <a href="#BM_(replica%20set)%2Fi">replica set</a> to get deleted as well.</p>
</div>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> doesn't have to use the <a href="#BM_(label)%2Fi">label</a>s in the <a href="#BM_(pod%20template)%2Fi">pod template</a>. It can have its own set of <a href="#BM_(label)%2Fi">label</a>s that it looks for via the <code>spec.selector.matchLabels</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
</code></pre>
<a name="H_Deployments"></a><h2>Deployments</h2>
<p><a name="BM_(Resources%5C%2FDeployments)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FServices)_TOPIC%2Fi">Resources/Services</a></li>
<li><a href="#BM_(Resources%5C%2FReplica%20Sets)_TOPIC%2Fi">Resources/Replica Sets</a></li>
</ul>
</div>
<p>A <a href="#BM_(deployment)%2Fi">deployment</a> is an abstraction used to bring together <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, <a href="#BM_(replica%20set)%2Fi">replica set</a>s, and <a href="#BM_(service)%2Fi">service</a>s under a single umbrella. It's intended to represent a single version of some application being deployed on <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>. All of the pieces required for that application to run are housed under one roof.</p>
<p><a href="#BM_(deployment)%2Fi">Deployment</a>s make it easy to upgrade between versions of the applications they represent via a rolling upgrade that keeps the application online during the upgrade. Old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are transitioned to new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> as a stream instead of all at once, ensuring that the application is responsive throughout the upgrade process. Likewise, they allow for rolling back an update should it have any problems.</p>
<p>The manifest for a <a href="#BM_(deployment)%2Fi">deployment</a> builds of the manifest for a <a href="#BM_(replica%20set)%2Fi">replica set</a> (same fields used). Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span> 
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">template:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.1</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my_container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">"gcr.io/my_container:v1"</span>
</code></pre>
<a name="H_Upgrade%20Strategy"></a><h3>Upgrade Strategy</h3>
<p>TODO: <code>spec/strategy</code> defines the way rollouts should occur.</p>
<p>TODO: discuss the recreate strategy + add yaml -- one-shot update, everything shuts down and restarts</p>
<p>TODO: discuss the rolling update strategy + add yaml --</p>
<p>maxUnavailable (num or percent of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that can be down during rollout) / maxSurge (num or percent of EXTRA <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that can be running during the rollout) -- so if you set unavail to 0% and surge to &gt;0% (it'll bring up x% new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> first then shut down x% old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, repeat until all updated), it'll rollout faster vs if you set unavail to &gt; 0% and surge to 0% (it'll shutdown x% old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> first then bring up x% new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, repeat until all updated)</p>
<p>for rolling, it'll always wait till the current iterations new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> probes report healthy + ready before moving to next iteration -- you should have defined these probes otherwise <a href="#BM_(deployment)%2Fi">deployment</a>s are blind</p>
<p>minReadySeconds -- waits at least n seconds till the <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a> reports okay before continuing -- an extra wait to make sure nothing's immediately crashing</p>
<p>progressDeadlineSeconds -- if any stage of the rollout waits for this long, the rollout is marked as failed. each time <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are brought down / up, it's a stage</p>
<a name="H_Undo"></a><h3>Undo</h3>
<p>TODO: discuss <a href="#BM_(kubectl)%2Fi">kubectl</a> rollout undo <a href="#BM_(deployment)%2Fi">deployment</a>s {<a href="#BM_(deployment)%2Fi">DEPLOYMENT</a>} command to roll back</p>
<p>TODO: set spec/revisionHistoryLimit to limit the number of revisions kept for undo -- useful when many frequent updates are happening</p>
<a name="H_Change%20Cause"></a><h3>Change Cause</h3>
<p>TODO: add <code>kubernetes.io/change-cause</code> <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> to add a custom message for the <a href="#BM_(deployment)%2Fi">deployment</a>, viewable when browing the history of the rollout</p>
<a name="H_Daemon%20Sets"></a><h2>Daemon Sets</h2>
<p><a name="BM_(Resources%5C%2FDaemon%20Sets)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FReplica%20Sets)_TOPIC%2Fi">Resources/Replica Sets</a></li>
<li><a href="#BM_(Resources%5C%2FDeployments)_TOPIC%2Fi">Resources/Deployments</a></li>
</ul>
</div>
<p>A <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is an abstraction that's used to ensure that a set of <a href="#BM_(node)%2Fi">node</a>s each have a copy of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> always up and running. Typical scenarios where a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is used include ...</p>
<ul>
<li><a href="#BM_(node)%2Fi">node</a> log collection (e.g. logstash agent).</li>
<li><a href="#BM_(node)%2Fi">node</a> monitoring (e.g. zabbix agent).</li>
</ul>
<p>The above scenarios are ones which break <a href="#BM_(container)%2Fi">container</a> / <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> isolation. That is, a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is intended to run <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that are coupled to <a href="#BM_(node)%2Fi">node</a>s and sometimes those <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will do things such as mount the <a href="#BM_(node)%2Fi">node</a>'s root filesystem and run commands to either install software or gather information.</p>
<p>Similar to how a <a href="#BM_(replica%20set)%2Fi">replica set</a> has a corresponding <a href="#BM_(deployment)%2Fi">deployment</a> that helps with upgrades, a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> has a <a href="#BM_(daemon%20set)%2Fi">daemon set</a>s object that helps manage its upgrades.</p>
<a name="H_Jobs"></a><h2>Jobs</h2>
<p><a name="BM_(Resources%5C%2FJobs)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
<li><a href="#BM_(Resources%5C%2FDeployments)_TOPIC%2Fi">Resources/Deployments</a></li>
</ul>
</div>
<p>A <a href="#BM_(job)%2Fi">job</a> is an abstraction that's used to run a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> performing a one-off task. Unlike a <a href="#BM_(deployment)%2Fi">deployment</a>, the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> running under a <a href="#BM_(job)%2Fi">job</a> don't need the same level of management (e.g. multiple replicas, upgrade strategies, etc..). Once a <a href="#BM_(job)%2Fi">job</a> completes, it's over.</p>
<p>Typical scenarios where a <a href="#BM_(job)%2Fi">job</a> is used include ...</p>
<ul>
<li>database migration</li>
<li>database compaction</li>
<li>log file removal</li>
</ul>
<p><a href="#BM_(job)%2Fi">Job</a>s can also be scheduled to run at specific intervals / times.</p>
<a name="H_Daemon%20Set"></a><h1>Daemon Set</h1>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-ds</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">nodeSelector:</span>
        <span class="hljs-attr">node_label_key1:</span> <span class="hljs-string">value1</span>
        <span class="hljs-attr">node_label_key1:</span> <span class="hljs-string">value2</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">my-app/my-app:v1</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span>
        <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span>
      <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span>
        <span class="hljs-attr">hostPath:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span>
</code></pre>
<p>TODO: spec/template/spec/<a href="#BM_(node)%2Fi">node</a>Selector defines the <a href="#BM_(node)%2Fi">node</a> <a href="#BM_(label)%2Fi">label</a>s to target</p>
<p>TODO: notice how volumes are using hostPath, which goes into the <a href="#BM_(node)%2Fi">node</a> directly</p>
<a name="H1_Daemon%20Sets"></a><h1>Daemon Sets</h1>
<p>TODO: this is the equivalent of <a href="#BM_(deployment)%2Fi">deployment</a> for <a href="#BM_(daemon%20set)%2Fi">daemon set</a>, it has rollingupdates just like a <a href="#BM_(deployment)%2Fi">deployment</a> does</p>
<a name="H_Job"></a><h1>Job</h1>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-job</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">5</span>
  <span class="hljs-attr">completions:</span> <span class="hljs-number">10</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my-app:v1</span>
        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span>
        <span class="hljs-attr">args:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"--arg1"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"--arg2"</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>   <span class="hljs-comment"># restart pod if it didn't complete successfully, can also be Never</span>
</code></pre>
<p>TODO: for one-off tasks, defined using <a href="#BM_(pod%20template)%2Fi">pod template</a>s</p>
<p>TODO: parallelism defines how many of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> run at once, completion is how many need to complete</p>
<p>TODO: <a href="#BM_(kubectl)%2Fi">kubectl</a> is the easiest way to run <a href="#BM_(job)%2Fi">job</a>s? looks confusing see ch12. <a href="#BM_(job)%2Fi">job</a> needs to be explicitly deleted once it's finished</p>
<p>TODO: don't use <a href="#BM_(label)%2Fi">label</a>s, because people create lots of <a href="#BM_(job)%2Fi">job</a>s and if you start <a href="#BM_(label)%2Fi">label</a>ing <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and there's a naming conflict bad/unexpected things happen (ch12)</p>
<p>TODO: don't set restartPolicy to never, because what happens is that the internal component responsible for restarts won't restart it and as such the <a href="#BM_(job)%2Fi">job</a> will see it hasn't restarted and restart it itself. this causes a lot of junk in the cluster.</p>
<p>TODO: <a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s can be used to detect if the a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is dead in a <a href="#BM_(job)%2Fi">job</a> as well</p>
<p>TODO: use Cron<a href="#BM_(job)%2Fi">Job</a> type to have it be scheduled by time</p>
<a name="H_Configuration%20Map"></a><h1>Configuration Map</h1>
<p><a name="BM_(Configuration%20Map)_TOPIC%2F"></a><strong></strong></p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">param1:</span> <span class="hljs-string">another-value</span>
  <span class="hljs-attr">param2:</span> <span class="hljs-string">extra-value</span>
  <span class="hljs-attr">my-config.ini:</span> <span class="hljs-string">|
    # This is a sample config file that I might use to configure an application
    key1 = value1
    ket1 = value2
</span></code></pre>
<a name="H_Autoscaling"></a><h1>Autoscaling</h1>
<a name="H_Horizontal%20Pod%20Autoscaling"></a><h2>Horizontal Pod Autoscaling</h2>
<p>TODO: TALK ABOUT HORIZONTAL AUTOSCALING + yaml</p>
<p>The number of replicas in a <a href="#BM_(replica%20set)%2Fi">replica set</a> can be automatically scaled up an down through <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>'s <a href="#BM_(horizontal%20pod%20autoscaling)%2Fi">horizontal pod autoscaling</a> component. Replicas are scaled based on some user-defined criteria (e.g. high cpu usage).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This feature depends on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> called heapster that tracks metrics. Most <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> installations include it by default.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book warns about setting replicas manual and setting replicas using <a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a> -- they fight with each other.</p>
</div>
<p>TODO: talk about vertical autoscaling + yaml -- it looks like this is in beta?</p>
<a name="H_Vertical%20Pod%20Autoscaling"></a><h2>Vertical Pod Autoscaling</h2>
<p>TODO: figure this out</p>
<a name="H_Cluster%20Autoscaler"></a><h2>Cluster Autoscaler</h2>
<p>TODO: it looks like this is an external component? if not enough <a href="#BM_(resource)%2Fi">resource</a>s to run a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, provision more <a href="#BM_(node)%2Fi">node</a>s from the cloud provider</p>
<a name="H_Kubectl%20Cheatsheet"></a><h1>Kubectl Cheatsheet</h1>
<p><a href="#BM_(kubectl)%2Fi">kubectl</a> commands are typically organized into <a href="#BM_(context)%2Fi">context</a>s, where each <a href="#BM_(context)%2Fi">context</a> is defines <a href="#BM_(context)%2Fi">context</a>ual information about the cluster: cluster location, cluster authentication, and default <a href="#BM_(namespace)%2Fi">namespace</a>. To ...</p>
<ul>
<li>set location, <code>kubectl config set-context {CTX} --cluster={VAL}</code></li>
<li>set user, <code>kubectl config set-context {CTX} --user={VAL}</code></li>
<li>set <a href="#BM_(namespace)%2Fi">namespace</a>, <code>kubectl config set-context {CTX} --namespace={VAL}</code></li>
<li>use a <a href="#BM_(context)%2Fi">context</a>, <code>kubectl config use-context {CTX}</code></li>
</ul>
<p><a href="#BM_(context)%2Fi">Context</a> information is usually stored in <code>$HOME/.kube/config</code>.</p>
<p><a href="#BM_(kubectl)%2Fi">kubectl</a> commands that target an object require a <a href="#BM_(namespace)%2Fi">namespace</a>. That <a href="#BM_(namespace)%2Fi">namespace</a> can either be supplied via ...</p>
<ul>
<li><code>--namespace={NS}</code> argument to target a specific <a href="#BM_(namespace)%2Fi">namespace</a>,</li>
<li><code>--all-namespaces</code> argument to target all <a href="#BM_(namespace)%2Fi">namespace</a>s,</li>
</ul>
<p>, ... or through the default <a href="#BM_(namespace)%2Fi">namespace</a> set for the current <a href="#BM_(context)%2Fi">context</a>. If not set explicitly in the <a href="#BM_(context)%2Fi">context</a>, the <a href="#BM_(namespace)%2Fi">namespace</a> will be <code>default</code>.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API is exposed as a RESTful interface, meaning everything is represented as an object and accessed / mutated using standard REST verbs (GET, PUT, DELETE, etc..). <a href="#BM_(kubectl)%2Fi">kubectl</a> uses this interface to access the cluster. For example, accessing https://cluster/api/v1/<a href="#BM_(namespace)%2Fi">namespace</a>s/default/<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>/obn_pod is equivalent to running <code>kubectl get pod obj_pod</code>. The difference between the two is that by default <a href="#BM_(kubectl)%2Fi">kubectl</a> formats the output in a human friendly manner, often omitting or shortening certain details. That output can be controlled using flags. Specifically, to ...</p>
<ul>
<li>get more detail, use <code>-o wide</code>.</li>
<li>remove headers such that the output can be more easily piped to other tools like <code>wc</code>, use <code>--no-headers</code>.</li>
<li>get JSON output <code>-o json</code></li>
<li>get YAML output <code>-o yaml</code></li>
<li>get JSON output isolated to a specific field or fields <code>-o jsonpath --template={TEMPLATE}</code>, where the template is a JSONPath expression.</li>
</ul>
<a name="H_CRUD"></a><h2>CRUD</h2>
<p><code>get</code> / <code>describe</code> allows you to get details on a specific objects and <a href="#BM_(resource)%2Fi">resource</a>s. To get an overview of a ...</p>
<ul>
<li>list of all objects of a specific <a href="#BM_(resource)%2Fi">resource</a> type using <code>kubectl get {RES}</code>.</li>
<li>a specific object of a specific <a href="#BM_(resource)%2Fi">resource</a> type using <code>kubectl get {RES} {OBJ}</code>.</li>
</ul>
<p><code>describe</code> provides more in-depth information vs <code>get</code>.</p>
<p>Examples of object access:</p>
<ul>
<li><code>kubectl get componentstatuses</code> - basic cluster diagnostics</li>
<li><code>kubectl get nodes</code> - list <a href="#BM_(node)%2Fi">node</a>s</li>
<li><code>kubectl get nodes --selector='class=high-mem'</code> - list <a href="#BM_(node)%2Fi">node</a>s that have <a href="#BM_(label)%2Fi">label</a> class set to high-mem (<a href="#BM_(label%20selector)%2Fi">label selector</a>)</li>
<li><code>kubectl get nodes --selector='class=high-mem,!gpu'</code> - list <a href="#BM_(node)%2Fi">node</a>s that have <a href="#BM_(label)%2Fi">label</a> class set to high-mem but <a href="#BM_(label)%2Fi">label</a> gpu unset (<a href="#BM_(label%20selector)%2Fi">label selector</a>)</li>
<li><code>kubectl describe nodes {NAME}</code> - <a href="#BM_(node)%2Fi">node</a> information</li>
<li><code>kubectl get daemonSets --namespace={NAMESPACE} {NAME}</code></li>
<li><code>kubectl get deployments --namespace={NAMESPACE} {NAME}</code></li>
<li><code>kubectl get services --namespace={NAMESPACE} {NAME}</code></li>
</ul>
<p>Add <code>--watch</code> flag to have <a href="#BM_(kubectl)%2Fi">kubectl</a> continually provide updates.</p>
<p><code>apply</code> allows you to create and update objects. To create or update using ...</p>
<ul>
<li>a YAML file, <code>kubectl apply -f obj.yaml</code>.</li>
<li>a JSON file, <code>kubectl apply -f obj.json</code>.</li>
<li>STDIN, <code>kubectl apply -f -</code>.</li>
</ul>
<p>It will not allow you to delete objects.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Is this true? See <code>kubectl apply</code> with prune flag.</p>
</div>
<p><code>edit</code> is shorthand for <code>get</code> and <code>apply</code> in that it'll open the YAML in an editor and allow you to make changes directly.</p>
<ul>
<li><code>kubectl edit deployment {NAME}</code></li>
<li><code>kubectl edit service {NAME}</code></li>
</ul>
<p><code>delete</code> allows you to delete an object. To delete using ...</p>
<ul>
<li>a YAML file, <code>kubectl delete -f obj.yaml</code>.</li>
<li>a JSON file, <code>kubectl delete -f obj.json</code>.</li>
<li>STDIN, <code>kubectl apply -f -</code>.</li>
<li>command line, <code>kubectl delete {RES} {OBJ}</code></li>
</ul>
<p>In certain cases, the object being deleted has parental links to other objects. For example, a <a href="#BM_(replica%20set)%2Fi">replica set</a> is the parent of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it creates and watches. If you delete these parent objects, by default their children go with it unless the <code>--cascade=false</code> flag is used.</p>
<p><code>label</code> / <code>annotate</code> allows you to <a href="#BM_(label)%2Fi">label</a> / <a href="#BM_(annotation%7Cannotate)%2Fi">annotate</a> an object.</p>
<ul>
<li><code>kubectl label pods {POD} mark=55a</code> - set <a href="#BM_(label)%2Fi">label</a> mark to value 55a on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (no overwrite).</li>
<li><code>kubectl label --overwrite pods {POD} mark=77a</code> - overwrite <a href="#BM_(label)%2Fi">label</a> mark to value 77a on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl label --overwrite pods {POD} mark=77a,end=fff</code> - overwrite <a href="#BM_(label)%2Fi">label</a> mark to value 77a and end to value fff on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl label pods {POD} mark-</code> - remove <a href="#BM_(label)%2Fi">label</a> mark from a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p>When referencing objects, the ...</p>
<ul>
<li><code>--selector</code> flag can be fed in a <a href="#BM_(label%20selector)%2Fi">label selector</a> that filters those objects.</li>
<li><code>--all</code> flag can target everything.</li>
</ul>
<a name="H_Deployment"></a><h2>Deployment</h2>
<p><code>rollout</code> allows you to monitor and control <a href="#BM_(deployment)%2Fi">deployment</a> rollouts.</p>
<ul>
<li><code>kubectl rollout status deployments {DEPLOYMENT}</code> - monitor rollout</li>
<li><code>kubectl rollout pause deployments {DEPLOYMENT}</code> - pause rollout</li>
<li><code>kubectl rollout resume deployments {DEPLOYMENT}</code> - resume rollout</li>
<li><code>kubectl rollout history deployments {DEPLOYMENT}</code> - view rollout history</li>
<li><code>kubectl rollout undo deployments {DEPLOYMENT}</code> - undo rollout (works regardless state -- e.g. if a rollout is currently in progress or not)</li>
<li><code>kubectl rollout undo deployments {DEPLOYMENT} --to-revision={REV}</code> - undo rollout to a previous revision (see rollout history command)</li>
</ul>
<p><code>configmap</code> allows you to create a configuration for applications running in <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<ul>
<li><code>kubectl create configmap {CONFIGMAP} --from-file=my-config.txt --from-literal=key1=value1 --from-literal=key2=value2</code></li>
</ul>
<p><code>secret</code> allows you to create a security related configuration for applications running in <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<ul>
<li><code>kubectl create secret generic my-tls-cert --from-file=a.crt --from-file=a.key</code></li>
</ul>
<a name="H_Proxy"></a><h2>Proxy</h2>
<p><code>proxy</code> allows you to launch a proxy that lets you talk internally with the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server.</p>
<ul>
<li><code>kubectl proxy</code></li>
</ul>
<a name="H_Debug"></a><h2>Debug</h2>
<p><code>logs</code> allows you to view outputs of a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubectl logs {POD}</code> - get logs for a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl logs {POD} -c {CONTAINER}</code> - get logs for a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl logs {POD} -c {CONTAINER} -f</code> - tail logs for a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p><code>exec</code> allows you to run a command on a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubectl exec -it {POD} -- ps uax</code> - execute ps on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl exec -it {POD} -- bash</code> - execute bash on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and interact with it.</li>
<li><code>kubectl exec -it {POD} -c {CONTAINER} -- bash</code> - execute bash on a <a href="#BM_(container)%2Fi">container</a> within <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and interact with it.</li>
</ul>
<p><code>attach</code> allows you to attach to a <a href="#BM_(container)%2Fi">container</a>'s main running process.</p>
<ul>
<li><code>kubectl attach -it {POD}</code> - attach to main process on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl attach -it {POD} -c {CONTAINER}</code> - attach to main process on a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>attach</code> is similar to <code>logs</code> with the tailing flag but also allows you pipe into stdin.</p>
</div>
<p><code>cp</code> allows you to copy files between your machine and a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubetctl cp {POD}:{POD_PATH} {LOCAL_PATH}</code> - copy from single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to local path.</li>
<li><code>kubetctl cp {LOCAL_PATH} {POD}:{POD_PATH}</code> - copy from local path to a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubetctl cp {POD}:{POD_PATH} {LOCAL_PATH} -c {CONTAINER}</code> - copy from a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to local path.</li>
</ul>
<p><code>port-forward</code> allows you to connect to a open port on a <a href="#BM_(container)%2Fi">container</a> or connect to a <a href="#BM_(service)%2Fi">service</a>.</p>
<ul>
<li><code>kubectl port-forward {POD} 8080:80</code> - forward port 8080 locally to port 80 on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl port-forward {POD} 8080:80 -c {CONTAINER}</code> - forward port 8080 locally to port 80 on a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl port-forward services/{SERVICE} 8080:80</code> - forward port 8080 locally to port 80 for some <a href="#BM_(service)%2Fi">service</a>.</li>
</ul>
<p><code>top</code> allows you to see cluster usage.</p>
<ul>
<li><code>kubectl top nodes</code> - view <a href="#BM_(node)%2Fi">node</a> <a href="#BM_(resource)%2Fi">resource</a> usages.</li>
<li><code>kubectl top pods</code> - view <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(resource)%2Fi">resource</a> usages.</li>
</ul>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(resource)%2Fi"></a><strong>resource</strong> - A class of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> object (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, <a href="#BM_(replica%20set)%2Fi">replica set</a>, <a href="#BM_(deployment)%2Fi">deployment</a>, etc..).</p>
</li>
<li>
<p><a name="BM_(image)%2Fi"></a><strong>image</strong> - An application (or set of applications) packaged with all of its dependencies as an immutable and isolated filesystem. The filesystem typically contains all dependencies required for the application(s) run sealed at their correct version.</p>
<p><a href="#BM_(image)%2Fi">Image</a>s also typically include metadata describing its needs and operational standards (e.g. memory requirements).</p>
</li>
<li>
<p><a name="BM_(container)%2Fi"></a><strong>container</strong> - An instance of an <a href="#BM_(image)%2Fi">image</a>. A <a href="#BM_(container)%2Fi">container</a> creates an isolated copy of the <a href="#BM_(image)%2Fi">image</a>'s filesystem, isolates the <a href="#BM_(resource)%2Fi">resource</a>s required for that <a href="#BM_(image)%2Fi">image</a>, and launches the entrypoint application for that <a href="#BM_(image)%2Fi">image</a>. That <a href="#BM_(container)%2Fi">container</a> can't see or access anything outside of the <a href="#BM_(container)%2Fi">container</a> unless explicitly allowed to by the user. For example, opening a port 8080 on a <a href="#BM_(container)%2Fi">container</a> won't open port 8080 on the host running it, but the user can explicitly ask that port 8080 in the <a href="#BM_(container)%2Fi">container</a> map to some port on the host.</p>
</li>
<li>
<p><a name="BM_(registry)%2Fi"></a><strong>registry</strong> - A <a href="#BM_(service)%2Fi">service</a> for storing and retrieving <a href="#BM_(image)%2Fi">image</a>s.</p>
</li>
<li>
<p><a name="BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi"></a><strong>multistage image</strong> - A <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a> produced by merging portions of other <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>s together. For example, to build a <a href="#BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi">multistage image</a> that contains Java as well as compiled C++ binaries, ...</p>
<ol>
<li>an <a href="#BM_(image)%2Fi">image</a> containing the JVM has its Java directory pulled out.</li>
<li>an <a href="#BM_(image)%2Fi">image</a> containing the GNU Compiler toolchain compiles some C++ code, then those compiled binaries are pulled out.</li>
</ol>
<p>The end result is that the <a href="#BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi">multistage build</a> only contains the relevant portions of its "stages" (previous <a href="#BM_(image)%2Fi">image</a>s), leading to a more focused <a href="#BM_(image)%2Fi">image</a> with smaller size.</p>
</li>
<li>
<p><a name="BM_(Open%20Container%20Initiative%20runtime%7COpen%20Container%20Initiative)%2Fi"></a><strong>open container initiative runtime</strong>  <a name="BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F"></a><strong></strong>- A runtime responsible for only creating and launching <a href="#BM_(container)%2Fi">container</a>s. Examples include runC, rkt, runV, gviso, etc.. Some of these use Linux isolation technology (cgroups and <a href="#BM_(namespace)%2Fi">namespace</a>s) while others use virtualization technology.</p>
</li>
<li>
<p><a name="BM_(container%20runtime%20interface)%2Fi"></a><strong>container runtime interface</strong> <a name="BM_%5Cb(CRI)s%3F%5Cb%2F"></a><strong></strong> - A runtime responsible for the high-level management of <a href="#BM_(container)%2Fi">container</a>s and <a href="#BM_(image)%2Fi">image</a>s: <a href="#BM_(image)%2Fi">image</a> management, <a href="#BM_(image)%2Fi">image</a> distribution, <a href="#BM_(container)%2Fi">container</a> mounts / storage, <a href="#BM_(container)%2Fi">container</a> networking, etc..</p>
<p><a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s are also responsible for running <a href="#BM_(container)%2Fi">container</a>s, but typically do so by delegating to an <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>. Examples of <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s include <a href="#BM_(container)%2Fi">container</a>d, and cri-o.</p>
</li>
<li>
<p><a name="BM_(container%20engine)%2Fi"></a><strong>container engine</strong> - A high-level application / cohesive set of applications used for all the things <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>s and <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s are used for as well as building <a href="#BM_(image)%2Fi">image</a>s, signing <a href="#BM_(image)%2Fi">image</a>s, and several other extra features. <a href="#BM_(container%20engine)%2Fi">Container engine</a>s typically delegate to <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>s and <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s for most of their functionality.</p>
<p>Examples include Docker Engine and <a href="#BM_(container)%2Fi">Container</a> Tools (podman for running <a href="#BM_(container)%2Fi">container</a>s, buildah for building <a href="#BM_(image)%2Fi">image</a>s, and skopeo for <a href="#BM_(image)%2Fi">image</a> distribution).</p>
</li>
<li>
<p><a name="BM_(Kubernetes)%2Fi"></a><strong>Kubernetes</strong> - A tool for orchestrating multiple <a href="#BM_(container)%2Fi">container</a>s across a set machines. Provides features such as load balancing, <a href="#BM_(service)%2Fi">service</a> naming, <a href="#BM_(service)%2Fi">service</a> discovery, automated <a href="#BM_(service)%2Fi">service</a> scaling, and automated <a href="#BM_(service)%2Fi">service</a> recovery.</p>
</li>
<li>
<p><a name="BM_(node)%2Fi"></a><strong>node</strong> - A host that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses to run the <a href="#BM_(container)%2Fi">container</a>s its orchestrating.</p>
</li>
<li>
<p><a name="BM_(master%20node)%2Fi"></a><strong>master node</strong> - A <a href="#BM_(node)%2Fi">node</a> responsible for the managing the cluster (scheduling, API server, etc..).</p>
</li>
<li>
<p><a name="BM_(worker%20node)%2Fi"></a><strong>worker node</strong> - A <a href="#BM_(node)%2Fi">node</a> responsible for running application <a href="#BM_(container)%2Fi">container</a>s.</p>
</li>
<li>
<p><a name="BM_%5Cb(pod)s%3F%5Cb%2Fi"></a><strong>pod</strong> - A set of <a href="#BM_(container)%2Fi">container</a>s all bundled together as a single unit, where all <a href="#BM_(container)%2Fi">container</a>s in that bundle are intended to run on the same <a href="#BM_(node)%2Fi">node</a>.</p>
</li>
<li>
<p><a name="BM_(pod%20template)%2Fi"></a><strong>pod template</strong> - The blueprint for creating <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(namespace)%2Fi"></a><strong>namespace</strong> - A user-defined category for objects in a cluster (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>), allowing <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> do things such as apply isolation and access control. By default, the <a href="#BM_(kubectl)%2Fi">kubectl</a> command uses the <a href="#BM_(namespace)%2Fi">namespace</a> <code>default</code> if no <a href="#BM_(namespace)%2Fi">namespace</a> is specified.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book tells you to think of it like it's a folder.</p>
</div>
</li>
<li>
<p><a name="BM_(kube-system)%2Fi"></a><strong>kube-system</strong> - A <a href="#BM_(namespace)%2Fi">namespace</a> for internal cluster components (<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>) that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs for itself. For example, <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">Kubernetes's DNS</a> <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">Kubernetes's proxy</a> <a href="#BM_(service)%2Fi">service</a>, etc.. all run under the <a href="#BM_(kube-system)%2Fi">kube-system</a> <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
</li>
<li>
<p><a name="BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi"></a><strong>kube-proxy</strong> - An internal <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">Kubernetes proxy</a> <a href="#BM_(service)%2Fi">service</a> responsible for routing traffic to the correct <a href="#BM_(service)%2Fi">service</a>s and load balancing between a <a href="#BM_(service)%2Fi">service</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. Runs on every <a href="#BM_(node)%2Fi">node</a> in the cluster.</p>
</li>
<li>
<p><a name="BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi"></a><strong>core-dns</strong> - An internal <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">Kubernetes DNS</a> <a href="#BM_(service)%2Fi">service</a> responsible for naming and discovery of the <a href="#BM_(service)%2Fi">service</a>s running on the cluster. Older versions of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> call this <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">kube-dns</a> instead of <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">core-dns</a>.</p>
</li>
<li>
<p><a name="BM_(kubernetes-dashboard%7CKubernetes%20Dashboard%7CKubernetes%20UI%7CKubernetes%20GUI%7CKubernetes's%20Dashboard%7CKubernetes's%20UI%7CKubernetes's%20GUI)%2Fi"></a><strong>kubernetes-dashboard</strong> - An internal <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(service)%2Fi">service</a> responsible for providing a GUI to interface with and explore the cluster.</p>
</li>
<li>
<p><a name="BM_(kubectl)%2Fi"></a><strong>kubectl</strong> - The standard command-line client for <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>.</p>
</li>
<li>
<p><a name="BM_(context)%2Fi"></a><strong>context</strong> - In reference to <a href="#BM_(kubectl)%2Fi">kubectl</a>, <a href="#BM_(context)%2Fi">context</a> refers to default cluster access settings <a href="#BM_(kubectl)%2Fi">kubectl</a> applies when running some command: cluster location, cluster authentication, and default <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
</li>
<li>
<p><a name="BM_(label)%2Fi"></a><strong>label</strong> - User-defined key-value pairs assigned to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects to group those objects together. <a href="#BM_(label)%2Fi">Label</a>ing objects makes it so they can be accessed as a set (e.g. target all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with authoring team set to SRE). Unlike <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s, <a href="#BM_(label)%2Fi">label</a>s aren't for assigning metadata to objects.</p>
</li>
<li>
<p><a name="BM_(label%20selector)%2Fi"></a><strong>label selector</strong> - An expression language used to find objects with <a href="#BM_(label)%2Fi">label</a>s. For example...</p>
<ul>
<li><code>key=value</code></li>
<li><code>key!=value</code></li>
<li><code>key in (value1, value2)</code></li>
</ul>
</li>
<li>
<p><a name="BM_(annotation%7Cannotate)%2Fi"></a><strong>annotation</strong> - User-defined key-value pairs assigned to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects that acts as metadata for other tools and libraries. Unlike <a href="#BM_(label)%2Fi">label</a>s, <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s aren't for grouping objects together.</p>
</li>
<li>
<p><a name="BM_(declarative%20configuration)%2Fi"></a><strong>declarative configuration</strong> - A form of configuring where the configuration is submitted as a state and the system adjusts itself to match that state.</p>
</li>
<li>
<p><a name="BM_(imperative%20configuration)%2Fi"></a><strong>imperative configuration</strong> - A form of configuring where the configuration is submitted as a set of instructions and the system runs those instructions.</p>
</li>
<li>
<p><a name="BM_(pod%20manifest)%2Fi"></a><strong>pod manifest</strong> - A <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, listing out things like <a href="#BM_(image)%2Fi">image</a>s required and <a href="#BM_(resource)%2Fi">resource</a> mappings (e.g. ports). This is effectively a blueprint for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, similar to how an <a href="#BM_(image)%2Fi">image</a> is a blueprint for a <a href="#BM_(container)%2Fi">container</a>.</p>
</li>
<li>
<p><a name="BM_(health%20check)%2Fi"></a><strong>health check</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> mechanism that checks the state of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and performs corrective action if it deems necessary. This includes both ensuring that the main <a href="#BM_(container)%2Fi">container</a> process is running, <a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s, and <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s.</p>
</li>
<li>
<p><a name="BM_(liveness%20probe)%2Fi"></a><strong>liveness probe</strong> - A user-defined task that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs to ensure that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is running correctly. For example, an HTTP server that stalls when for more than 15 seconds before returning a response may be deemed as no longer live.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> restarts a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> if it deems it as no longer alive.</p>
</li>
<li>
<p><a name="BM_(readiness%20probe)%2Fi"></a><strong>readiness probe</strong> - A user-defined task that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs to ensure that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is in a position to accept requests. For example, an HTTP server that has all of its worker threads busy processing requests may be deemed as not ready.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> stops routing requests to a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> if its no longer ready (removed from load balancer).</p>
</li>
<li>
<p><a name="BM_(utilization)%2Fi"></a><strong>utilization</strong> - A metric that tracks the amount of <a href="#BM_(resource)%2Fi">resource</a>s in use vs the amount of <a href="#BM_(resource)%2Fi">resource</a>s available.</p>
</li>
<li>
<p><a name="BM_(resource%20request)%2Fi"></a><strong>resource request</strong> - The minimum amount of <a href="#BM_(resource)%2Fi">resource</a>s required to run an <a href="#BM_(image)%2Fi">image</a> (not a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>).</p>
</li>
<li>
<p><a name="BM_(resource%20limit)%2Fi"></a><strong>resource limit</strong> - The maximum amount of <a href="#BM_(resource)%2Fi">resource</a>s that an <a href="#BM_(image)%2Fi">image</a> (not a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>) may take up.</p>
<p>If <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> needs to scale down a <a href="#BM_(resource)%2Fi">resource</a> for a <a href="#BM_(container)%2Fi">container</a> that isn't dynamic (e.g. a running process can have its CPU usage reduced but you can't force a running process to give up memory its holding on to), the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> gets restarted with that <a href="#BM_(resource)%2Fi">resource</a> scaled down.</p>
</li>
<li>
<p><a name="BM_(service)%2Fi"></a><strong>service</strong> - A set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> exposed under a single named network <a href="#BM_(service)%2Fi">service</a>. Requests coming in to the <a href="#BM_(service)%2Fi">service</a> and are load balanced across the set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(endpoints)%2Fi"></a><strong>endpoints</strong> - A low-level object that's used by <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to map a <a href="#BM_(service)%2Fi">service</a> to the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it routes to. In other words, an <a href="#BM_(endpoints)%2Fi">endpoints</a> (note the plural) object is an abstraction that references a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(ingress)%2Fi"></a><strong>ingress</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that acts as an HTTP-based frontend that routes and load balances incoming external requests to the correct <a href="#BM_(service)%2Fi">service</a>. This <a href="#BM_(resource)%2Fi">resource</a> is an interface without an implementation, meaning that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> doesn't have anything built-in to handle <a href="#BM_(ingress)%2Fi">ingress</a>. Implementations of this interfaces are referred to as <a href="#BM_(ingress)%2Fi">Ingress</a> controllers and are provided by third-parties.</p>
</li>
<li>
<p><a name="BM_(replica%20set)%2Fi"></a><strong>replica set</strong> <a name="BM_(ReplicaSet)%2F"></a><strong></strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that ensures a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> has a certain number of instances running at any time.</p>
</li>
<li>
<p><a name="BM_(reconciliation%20loop)%2Fi"></a><strong>reconciliation loop</strong> - A loop that continually observes state and attempts to reconcile it to some desired state if it deviates. See <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a>.</p>
</li>
<li>
<p><a name="BM_(horizontal%20pod%20autoscaling)%2Fi"></a><strong>horizontal pod autoscaling</strong> <a name="BM_%5Cb(HPA)%5Cb%2F"></a><strong></strong> - A feature that automatically scales the number of replicas in a <a href="#BM_(replica%20set)%2Fi">replica set</a>s based on user-defined criteria.</p>
</li>
<li>
<p><a name="BM_(vertical%20pod%20autoscaling)%2Fi"></a><strong>vertical pod autoscaling</strong> <a name="BM_%5Cb(VPA)%5Cb%2F"></a><strong></strong> - A feature that automatically scales up the <a href="#BM_(resource)%2Fi">resource</a> requirements for some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> based on user-defined criteria.</p>
</li>
<li>
<p><a name="BM_(cluster%20autoscaler)%2Fi"></a><strong>cluster autoscaler</strong> - A component that automatically scales the number of <a href="#BM_(node)%2Fi">node</a>s in a cluster based on need.</p>
</li>
<li>
<p><a name="BM_(deployment)%2Fi"></a><strong>deployment</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that groups together all objects required for some application (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, <a href="#BM_(service)%2Fi">service</a>s, ...).</p>
</li>
<li>
<p><a name="BM_(daemon%20set)%2Fi"></a><strong>daemon set</strong> <a name="BM_(DaemonSet)%2F"></a><strong></strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that ensures a set of <a href="#BM_(node)%2Fi">node</a>s always have an instance of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> running.</p>
</li>
<li>
<p><a name="BM_(job)%2Fi"></a><strong>job</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that launches as a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to perform some one-of task.</p>
</li>
<li>
<p><a name="BM_(ConfigMap)%2Fi"></a><strong>ConfigMap</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> for configuring the applications running in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(millicpu%7Cmillicore)%2Fi"></a><strong>millicpu</strong> - A <a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a> is 0.001 CPU cores (e.g. 1000 <a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a> = 1 core).</p>
</li>
</ul>
<p></p>
<p></p>

        </body></html>