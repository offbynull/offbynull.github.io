<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>Kubernetes</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><p></p>
<div class="toc">
<ul>
<li><a href="#H_Introduction">Introduction</a></li>
<ul>
<li><a href="#H_Containers">Containers</a></li>
<li><a href="#H_Objects">Objects</a></li>
<li><a href="#H_Labels">Labels</a></li>
<li><a href="#H_Configuration">Configuration</a></li>
</ul>
<li><a href="#H_Resources">Resources</a></li>
<ul>
<li><a href="#H_Pods">Pods</a></li>
<ul>
<li><a href="#H1_Resources">Resources</a></li>
<li><a href="#H_Ports">Ports</a></li>
<li><a href="#H_Arguments">Arguments</a></li>
<li><a href="#H_Environment%20Variables">Environment Variables</a></li>
<li><a href="#H_Probes">Probes</a></li>
<li><a href="#H_Volumes">Volumes</a></li>
<li><a href="#H_Image%20Pull%20Policy">Image Pull Policy</a></li>
<li><a href="#H_Image%20Pull%20Secret">Image Pull Secret</a></li>
<li><a href="#H_Restart%20Policy">Restart Policy</a></li>
<li><a href="#H1_Configuration">Configuration</a></li>
<li><a href="#H_Secrets">Secrets</a></li>
<li><a href="#H_Service%20Discovery">Service Discovery</a></li>
<ul>
<li><a href="#H1_Environment%20Variables">Environment Variables</a></li>
<li><a href="#H_DNS">DNS</a></li>
</ul>
<li><a href="#H_Metadata%20Access">Metadata Access</a></li>
</ul>
<li><a href="#H_Configuration%20Maps">Configuration Maps</a></li>
<li><a href="#H1_Secrets">Secrets</a></li>
<li><a href="#H_Nodes">Nodes</a></li>
<li><a href="#H1_Volumes">Volumes</a></li>
<ul>
<li><a href="#H_Capacity">Capacity</a></li>
<li><a href="#H_Access%20Modes">Access Modes</a></li>
<li><a href="#H_Reclaim%20Policy">Reclaim Policy</a></li>
<li><a href="#H_Types">Types</a></li>
<li><a href="#H_Storage%20Classes">Storage Classes</a></li>
</ul>
<li><a href="#H_Endpoints">Endpoints</a></li>
<li><a href="#H_Services">Services</a></li>
<ul>
<li><a href="#H_Routing">Routing</a></li>
<li><a href="#H1_Ports">Ports</a></li>
<li><a href="#H_Health">Health</a></li>
<li><a href="#H_Headless">Headless</a></li>
<li><a href="#H_Session%20Affinity">Session Affinity</a></li>
<li><a href="#H_Exposure">Exposure</a></li>
<ul>
<li><a href="#H_Local">Local</a></li>
<li><a href="#H_Node%20Port">Node Port</a></li>
<li><a href="#H_Load%20Balancer">Load Balancer</a></li>
</ul>
</ul>
<li><a href="#H_Ingress">Ingress</a></li>
<ul>
<li><a href="#H_Hosts">Hosts</a></li>
<li><a href="#H_Path%20Type">Path Type</a></li>
<li><a href="#H_TLS%20Traffic">TLS Traffic</a></li>
</ul>
<li><a href="#H_Namespace">Namespace</a></li>
<li><a href="#H_Replica%20Sets">Replica Sets</a></li>
<ul>
<li><a href="#H_Replication">Replication</a></li>
</ul>
<li><a href="#H_Deployments">Deployments</a></li>
<ul>
<li><a href="#H_Upgrade%20Strategy">Upgrade Strategy</a></li>
<li><a href="#H_Undo">Undo</a></li>
<li><a href="#H_Change%20Cause">Change Cause</a></li>
</ul>
<li><a href="#H_Daemon%20Sets">Daemon Sets</a></li>
<li><a href="#H_Jobs">Jobs</a></li>
</ul>
<li><a href="#H_Daemon%20Set">Daemon Set</a></li>
<li><a href="#H1_Daemon%20Sets">Daemon Sets</a></li>
<li><a href="#H_Job">Job</a></li>
<li><a href="#H_Autoscaling">Autoscaling</a></li>
<ul>
<li><a href="#H_Horizontal%20Pod%20Autoscaling">Horizontal Pod Autoscaling</a></li>
<li><a href="#H_Vertical%20Pod%20Autoscaling">Vertical Pod Autoscaling</a></li>
<li><a href="#H_Cluster%20Autoscaler">Cluster Autoscaler</a></li>
</ul>
<li><a href="#H_Kubectl%20Cheatsheet">Kubectl Cheatsheet</a></li>
<ul>
<li><a href="#H_CRUD">CRUD</a></li>
<li><a href="#H_Deployment">Deployment</a></li>
<li><a href="#H_Proxy">Proxy</a></li>
<li><a href="#H_Debug">Debug</a></li>
</ul>
<li><a href="#H_Amazon">Amazon</a></li>
<li><a href="#H_Security%20Tips">Security Tips</a></li>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_Introduction"></a><h1>Introduction</h1>
<p><a name="BM_(Introduction)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is a <a href="#BM_(service)%2Fi">service</a> orchestration framework that provides many of the plumbing pieces required for running <a href="#BM_(service)%2Fi">service</a>s. These <a href="#BM_(service)%2Fi">service</a>s include ...</p>
<ul>
<li>DNS for naming and discovery of <a href="#BM_(service)%2Fi">service</a>s,</li>
<li>Load balancer to distribute requests across many instances of a <a href="#BM_(service)%2Fi">service</a>,</li>
<li>Automatic recovery when a <a href="#BM_(service)%2Fi">service</a> crashes,</li>
<li>Automatic scaling when a <a href="#BM_(service)%2Fi">service</a> comes under load,</li>
<li>Password / certificate / secrets management for <a href="#BM_(service)%2Fi">service</a>s,</li>
<li>etc..</li>
</ul>
<a name="H_Containers"></a><h2>Containers</h2>
<p><a name="BM_(Introduction%5C%2FContainers)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is structured around <a href="#BM_(container)%2Fi">container</a>s.</p>
<p><img src="svgbob_f6d6eb5e8cf3c348cd91f60b2ccc3e7c9930dac2.svg" alt="Kroki diagram output"></p>
<p>In the <a href="#BM_(context)%2Fi">context</a> of <a href="#BM_(container)%2Fi">container</a>s, an ...</p>
<ul>
<li>
<p><a href="#BM_(image)%2Fi">image</a> is an application (or set of applications) packaged with all of its dependencies as an immutable and isolated filesystem. The filesystem typically contains all dependencies required for the application(s) run sealed at their correct version:</p>
<ul>
<li>libraries (e.g. correct version of libssh),</li>
<li>applications (e.g. correct version bash and Python),</li>
<li>files (e.g. embedded SQLite databases)</li>
<li>etc..</li>
</ul>
<p><a href="#BM_(image)%2Fi">Image</a>s also typically include metadata describing its needs and operational standards. For example, the metadata may stipulate that the <a href="#BM_(image)%2Fi">image</a> ...</p>
<ul>
<li>launches by running /opt/my_app/run.sh</li>
<li>stops by signalling SIGTERM</li>
<li>requires 4gb of memory, 1.5 CPU cores, etc..A <a href="#BM_(container)%2Fi">container</a> is an instance of an application requires that <a href="#BM_(service)%2Fi">service</a>s be exposed as <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>s. An <a href="#BM_(image)%2Fi">image</a> is</li>
</ul>
</li>
<li>
<p><a href="#BM_(container)%2Fi">container</a> is an instance of an <a href="#BM_(image)%2Fi">image</a>. A <a href="#BM_(container)%2Fi">container</a> creates an isolated copy of the <a href="#BM_(image)%2Fi">image</a>'s filesystem, isolates the <a href="#BM_(resource)%2Fi">resource</a>s required for that <a href="#BM_(image)%2Fi">image</a>, and launches the entrypoint application for that <a href="#BM_(image)%2Fi">image</a>. That <a href="#BM_(container)%2Fi">container</a> can't see or access anything outside of the <a href="#BM_(container)%2Fi">container</a> unless explicitly allowed to by the user. For example, opening a port 8080 on a <a href="#BM_(container)%2Fi">container</a> won't open port 8080 on the host running it, but the user can explicitly ask that port 8080 in the <a href="#BM_(container)%2Fi">container</a> map to some port on the host.</p>
</li>
</ul>
<p>As shown in the entity diagram above, each <a href="#BM_(container)%2Fi">container</a> is created from a single <a href="#BM_(image)%2Fi">image</a>, but that same <a href="#BM_(image)%2Fi">image</a> can be used for to create multiple <a href="#BM_(container)%2Fi">container</a>s. Another way to think about it is that an <a href="#BM_(image)%2Fi">image</a> is the blueprint of a factory and a <a href="#BM_(container)%2Fi">container</a> is the actual factory built from that blueprint. You can build multiple factories from the same blueprint.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> requires two core components to run:</p>
<ul>
<li><a href="#BM_(Open%20Container%20Initiative%20runtime%7COpen%20Container%20Initiative)%2Fi">open container initiative</a> (<a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI</a>) runtime - A runtime responsible for only creating and launching <a href="#BM_(container)%2Fi">container</a>s.</li>
<li><a href="#BM_(container%20runtime%20interface)%2Fi">container runtime interface</a> (<a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>) - A runtime responsible for the high-level management of <a href="#BM_(container)%2Fi">container</a>s and <a href="#BM_(image)%2Fi">image</a>s: <a href="#BM_(image)%2Fi">image</a> management, <a href="#BM_(image)%2Fi">image</a> distribution, <a href="#BM_(container)%2Fi">container</a> mounts / storage, <a href="#BM_(container)%2Fi">container</a> networking, etc..</li>
</ul>
<p>Different vendors provide different implementations of each. For example, certain vendors provide an <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a> that use virtualization technology for isolation instead of standard Linux isolation (e.g. cgroups).</p>
<p><img src="svgbob_a28730c1c9bb6f382bb8e320a51ca1cfa2db0bb2.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI</a>s and OCRs are also the basis for <a href="#BM_(container%20engine)%2Fi">container engine</a>s, tools that are responsible for creating and running <a href="#BM_(container)%2Fi">container</a>s (similar in nature <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> without the orchestration) as well as creating <a href="#BM_(image)%2Fi">image</a>s and other high-level functionality such as local testing of <a href="#BM_(container)%2Fi">container</a>s. Docker Engine is an example of a <a href="#BM_(container%20engine)%2Fi">container engine</a>.</p>
<p><img src="svgbob_3d4187f5433dd286b08d28526577c57afdc47ec0.svg" alt="Kroki diagram output"></p>
<a name="H_Objects"></a><h2>Objects</h2>
<p><a name="BM_(Introduction%5C%2FObjects)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> breaks down its orchestration as a set of objects. Each object is of a specific type (referred to as <a href="#BM_(resource)%2Fi">resource</a>) and those objects coordinate and manage each other through linkages (described in <a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a>). For example, a load balancer object is an instance of <a href="#BM_(resource)%2Fi">resource</a> <a href="#BM_(service)%2Fi">Service</a> and each copy of a running application it pipes requests to is an instance of <a href="#BM_(resource)%2Fi">resource</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>, and the load balancer is decides which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it to route to by searching for <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with a specific <a href="#BM_(label)%2Fi">label</a>.</p>
<p>This is in contrast to a hierarchal setup where objects have ownership or are inherited from others. There is no ownership or parent-child relationship here, only loosely coupled linkages.</p>
<p><img src="svgbob_d1e778081e8cdf9a5a337a08f8f517ac030d2200.svg" alt="Kroki diagram output"></p>
<a name="H_Labels"></a><h2>Labels</h2>
<p><a name="BM_(Introduction%5C%2FLabels)_TOPIC%2Fi"></a><strong></strong></p>
<p>Objects within <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> may be assigned key-value pairs. Two types of key-value pair assignments exist:</p>
<ul>
<li><a href="#BM_(label)%2Fi">Label</a>s - key-value assignments for logical grouping of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects. These allow for organizing objects into groups, such that users can target a group as a whole (e.g. give me all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> designed by the SRE team).</li>
<li><a href="#BM_(annotation%7Cannotate)%2Fi">Annotation</a>s - key-value assignments for metadata on <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects. These allow tools and libraries to gather ancillary information about the object, such that they can perform some task.</li>
</ul>
<p>In other words, <a href="#BM_(label)%2Fi">label</a>s are used to identity objects while <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s are not. For example if you have different classes of <a href="#BM_(worker%20node)%2Fi">worker node</a>s in your cluster, it may be a good idea to <a href="#BM_(label)%2Fi">label</a> each <a href="#BM_(node)%2Fi">node</a> with its class. That way, if you wanted to deprecate a specific class, you'd be able to targe them as a group and shut them down.</p>
<p><a href="#BM_(label)%2Fi">Label</a>s are targeted using a simple language called <a href="#BM_(label%20selector)%2Fi">label selector</a>s.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key=value</code></td>
<td><code>key</code> is set to <code>value</code></td>
</tr>
<tr>
<td><code>key!=value</code></td>
<td><code>key</code> is not set to <code>value</code></td>
</tr>
<tr>
<td><code>key in (value1, value2, ...)</code></td>
<td><code>key</code> is either <code>value1</code>, <code>value2</code>, ...</td>
</tr>
<tr>
<td><code>key notin (value1, value2, ...)</code></td>
<td><code>key</code> is neither <code>value1</code>, <code>value2</code>, ...</td>
</tr>
<tr>
<td><code>key</code></td>
<td>a value is set for <code>key</code></td>
</tr>
<tr>
<td><code>!key</code></td>
<td>a value not set for <code>key</code></td>
</tr>
<tr>
<td><code>key1=value1,key2=value2</code></td>
<td><code>key1</code> is set to <code>value1</code> and <code>key2</code> is set to <code>value2</code></td>
</tr>
</tbody>
</table>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses <a href="#BM_(label)%2Fi">label</a>s for many of its internal <a href="#BM_(service)%2Fi">service</a>s. For example, <a href="#BM_(label%20selector)%2Fi">label selector</a>s are used for deciding ...</p>
<ul>
<li>the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> which a <a href="#BM_(service)%2Fi">service</a> routes traffic to.</li>
<li>which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are allowed to communicate with each other over the internal network.</li>
<li>the <a href="#BM_(node)%2Fi">node</a>s which a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can be scheduled on.</li>
<li>etc..</li>
</ul>
<p>If there are a large number of keys / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s, either because the organization set them directly or because they're being set by external tools, the chance of a collision increases. To combat this, keys for <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s can optionally include a prefix (separated by a slash) that maps to a DNS subdomain to help disambiguate it. For example, <code>company.com/my_key</code> rather than just having <code>my_key</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book states that key name itself can be at most 63 chars. If a prefix is included, it doesn't get included in that limit. A prefix can be up to 253 chars.</p>
</div>
<a name="H_Configuration"></a><h2>Configuration</h2>
<p><a name="BM_(Introduction%5C%2FConfiguration)_TOPIC%2Fi"></a><strong></strong></p>
<p>Objects can either be accessed and mutated through a standard command-line interface called <a href="#BM_(kubectl)%2Fi">kubectl</a> or a REST web interface. Manipulations come in two forms:</p>
<ul>
<li>
<p><a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a> - the mutations to perform on the object (via <a href="#BM_(kubectl)%2Fi">kubectl</a> invocations).</p>
<pre><code>kubectl run my_pod --image=gcr.io/my_company/my_pod:v1
kubectl set pods my_pod --requests='cpu=500m,memory=128Mi'
</code></pre>
</li>
<li>
<p><a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> - the overall description of the object, called a manifest (as YAML or JSON via either <a href="#BM_(kubectl)%2Fi">kubectl</a> or REST).</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
</code></pre>
<pre><code>kubectl apply -f obj.yaml
kubectl delete -f obj.yaml
</code></pre>
</li>
</ul>
<p>Generally, <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a>s are preferred over <a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a>s. When a <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> is submitted, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs a <a href="#BM_(reconciliation%20loop)%2Fi">reconciliation loop</a> in the background to automatically mutate the state of the object to the one in the manifest. Contrast this to the <a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a> method, where the mutations have to be manually submitted by the user one by one.</p>
<a name="H_Resources"></a><h1>Resources</h1>
<p><a name="BM_(Resources)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction)_TOPIC%2Fi">Introduction</a></li>
<li><a href="#BM_(Introduction%5C%2FConfiguration)_TOPIC%2Fi">Introduction/Configuration</a></li>
<li><a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a></li>
</ul>
</div>
<p>The following sub-sections gives a overview of the main <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a>s and example manifests. All manifests, regardless of the <a href="#BM_(resource)%2Fi">resource</a> require the following fields...</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-name</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">author:</span> <span class="hljs-string">"Jimbo D."</span>
    <span class="hljs-attr">created_on:</span> <span class="hljs-string">"Aug 20 2021"</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app_server:</span> <span class="hljs-string">jetty</span>
</code></pre>
<p>... where <code>version</code> is the API version, <code>kind</code> is the <a href="#BM_(resource)%2Fi">resource</a> (e.g. <code>Pod</code>), and <code>metadata.name</code> is the name of the object. In addition, the <code>metadata</code> section can contain <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s to assign to the object via the <code>metadata.labels</code> and <code>metadata.annotations</code> manifest paths respectively.</p>
<a name="H_Pods"></a><h2>Pods</h2>
<p><a name="BM_(Resources%5C%2FPods)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(container)%2Fi">Container</a>s are deployed in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> via <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is is a set of <a href="#BM_(container)%2Fi">container</a>s grouped together, often <a href="#BM_(container)%2Fi">container</a>s that are so tightly coupled or are required to work in close proximity of each other (e.g. on the same host).</p>
<p><img src="svgbob_e74b52a9043c79551911fcf4f001af764adce0b0.svg" alt="Kroki diagram output"></p>
<p>Many copies of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> may be running on the cluster at the same time, often in an effort to distribute load and / or provide redundancy.</p>
<p><img src="svgbob_9e1d1ea6439e4b6734d777b4ef484128af313509.svg" alt="Kroki diagram output"></p>
<p><img src="svgbob_50c156f131a6bbec9cd7f8af4625c3bd265e5dfb.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(container)%2Fi">Container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are isolated in terms of their <a href="#BM_(resource)%2Fi">resource</a> requirements (e.g. CPU, memory, and disk), but they share the same ...</p>
<ul>
<li>network (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> have the same IP, same host, and share the port space).</li>
<li>IPC bus (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can communicate with each other over POSIX message queues / System V IPC channels).</li>
<li>volumes (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> may have shared storage assigned to them in addition to their isolated storage).</li>
</ul>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> orchestrates <a href="#BM_(container)%2Fi">container</a>s over a cluster of machines. The <a href="#BM_(container)%2Fi">container</a>s for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are guaranteed to all be running on the same machine. As such, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are usually structured in a way that their <a href="#BM_(container)%2Fi">container</a>s are tightly coupled and scale together. For example, a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with two <a href="#BM_(container)%2Fi">container</a>s, a WordPress server and its required MySQL database server, is a bad usage example because those two ...</p>
<ol>
<li>don't scale uniformly (e.g. you'll likely need to scale the database up before the WordPress server).</li>
<li>don't communicate over anything other than the network (e.g. they don't need a shared volume).</li>
<li>are intended to be distributed (e.g. it's okay for them to be running on separate machines).</li>
</ol>
<p>Contrast that to an example of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with two <a href="#BM_(container)%2Fi">container</a>s, an application server and an associated log watcher. This is a good example because the two <a href="#BM_(container)%2Fi">container</a>s ...</p>
<ol>
<li>communicate over the filesystem (e.g. application server is writing logs to a shared volume and the log watcher is tailing them).</li>
<li>aren't intended to be distributed (e.g. log watcher is intended for locally produced logs).</li>
<li>are written by different teams (e.g. SRE team wrote the log watcher <a href="#BM_(image)%2Fi">image</a> while another team wrote the application server <a href="#BM_(image)%2Fi">image</a>).</li>
</ol>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1000m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"256Mi"</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/data"</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">"kuard-data"</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/healthy</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">readinessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data"</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data"</span>  <span class="hljs-comment"># literally mounts a path from the worker node? not persistant if node modes</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data_nfs"</span>
      <span class="hljs-attr">nfs:</span>
        <span class="hljs-attr">server:</span> <span class="hljs-string">nfs.server.location</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/path/on/nfs"</span>
</code></pre>
<a name="H1_Resources"></a><h3>Resources</h3>
<p><a name="BM_(Resources%5C%2FPods%2FResources)_TOPIC%2F"></a><strong></strong></p>
<p></p>
<p><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> resources are controlled via the <code>spec.containers[].resources</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1000m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"256Mi"</span>
    <span class="hljs-string">...</span>
</code></pre>
<p><code>requests</code> are the minimum resources the pod needs to operate while <code>limits</code> are the maximum it can have. Some resources are dynamically adjustable while others require the pod to restart. For example, a pod ...</p>
<ul>
<li>can have its CPU usage dynamically adjusted because <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> can just ask the operating system's CPU scheduler to give it less/more timer.</li>
<li>can't have its memory usage dynamically adjusted because if it loses access to a block of memory the applications running within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> won't know and will likely crash.</li>
</ul>
<p>The example above lists out CPU and memory as viable resource types. The unit of measurement for ...</p>
<ul>
<li>cpu is either in ...
<ul>
<li>whole cores: no suffix</li>
<li><a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a>s: suffix of m (1 core is equivalent to 1000m -- e.g. 0.5 = 5000m).</li>
</ul>
</li>
<li>memory is either in ...
<ul>
<li>bytes: no suffix</li>
<li>1000 scale: suffix of k = 1000, M = 1,000,000, G = 1,000,000,000</li>
<li>power of two scale: suffix of k = 1024, M = 1,048,576, G = 1,073,741,824</li>
</ul>
</li>
</ul>
<p></p>
<a name="H_Ports"></a><h3>Ports</h3>
<p><a name="BM_(Resources%5C%2FPods%2FPorts)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> port exposures are controlled via the <code>spec.containers[].ports[]</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
    <span class="hljs-string">...</span>
</code></pre>
<p>The example above exposes port 8080 to the rest of the cluster (not the outside world). Even with the port exposed, other entities on the cluster don't have a built-in way to discover the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s IP / host or the fact that it has this specific port open. For that, <a href="#BM_(service)%2Fi">service</a>s are required (see <a href="#BM_(Resources%5C%2FServices)_TOPIC%2Fi">Resources/Services</a>).</p>
<a name="H_Arguments"></a><h3>Arguments</h3>
<p><a name="BM_(Resources%5C%2FPods%2FArguments)_TOPIC%2F"></a><strong></strong></p>
<p>The <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>'s default entrypoint (process that gets started) can be updated via the <code>spec.containers[].command[]</code> manifest path. Likewise, the default command line arguments that hte <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a> starts with can be updated via <code>spec.containers[].args[]</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">command:</span> [<span class="hljs-string">/opt/app/my-app</span>]
      <span class="hljs-attr">args:</span> [<span class="hljs-string">--no-logging</span>, <span class="hljs-string">--dry-run</span>]
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The Dockerfile used to create the <a href="#BM_(image)%2Fi">image</a> had an <code>ENTRYPOINT</code> and a <code>CMD</code>. <code>command</code> essentially overrides the Dockerfile <code>ENTRYPOINT</code> and <code>args</code> overrides the Dockerfile's <code>CMD</code>.</p>
</div>
<a name="H_Environment%20Variables"></a><h3>Environment Variables</h3>
<p><a name="BM_(Resources%5C%2FPods%2FEnvironment%20Variables)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FEnvironment%20Variables)_TOPIC%2F">Resources/Pods/Environment Variables</a></li>
</ul>
</div>
<p>Environment variables can be hardcoded via the <code>spec.containers[].env[]</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_LEVEL</span>
          <span class="hljs-attr">value:</span> <span class="hljs-string">"OFF"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DRY_RUN</span>
          <span class="hljs-attr">value:</span> <span class="hljs-string">"true"</span>
</code></pre>
<p>Once defined, an environment variables value can be used in other parts of the manifest using the syntax <code>$(VAR_NAME)</code>. For example, an environment variable's value may be placed directly within an argument.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my_company/my_pod:v1</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_LEVEL</span>
          <span class="hljs-attr">value:</span> <span class="hljs-string">"OFF"</span>
      <span class="hljs-attr">args:</span> [<span class="hljs-string">--logging_telemetry=$(LOG_LEVEL)</span>]
</code></pre>
<a name="H_Probes"></a><h3>Probes</h3>
<p><a name="BM_(Resources%5C%2FPods%2FProbes)_TOPIC%2F"></a><strong></strong></p>
<p>Probes are a way for <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to check the state of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (e.g. alive, ready, started, etc..). The <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> exposes some interfaces to determine state. <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> periodically pings those interfaces to determine what actions to take (e.g. restarting a downed <a href="#BM_(service)%2Fi">service</a>.</p>
<p>Probes are controlled via the <code>spec.containers[].livenessProbe</code> and <code>spec.containers[].readinessProbe</code> manifest paths.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/healthy</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">readinessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>Different types of probes exists. A ...</p>
<ul>
<li><a href="#BM_(liveness%20probe)%2Fi">liveness probe</a> is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is alive and responsive. If a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails its liveness check, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> deems it dead and restarts it.</li>
<li><a href="#BM_(readiness%20probe)%2Fi">readiness probe</a> is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is able to process requests. If a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails its readiness check, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> will stop routing requests to it until a readiness subsequent check passes.</li>
</ul>
<p>In the example above, each of the probes check a HTTP server within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> at port 8080 but at different paths. The field ...</p>
<ul>
<li><code>initialDelaySeconds</code> is the number of seconds to wait before performing the first probe.</li>
<li><code>timeoutSeconds</code> is the number of seconds to wait before timing out.</li>
<li><code>periodSeconds</code> is the number of seconds to wait before performing a probe.</li>
<li><code>failureThreshold</code> is the maximum number of successive failure before <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> considers the probe failed.</li>
<li><code>successThreshold</code> is the maximum number of successive successes before <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> considers the probe passed.</li>
</ul>
<p>There are types of probes other than <code>httpGet</code>. A probe of type <code>tcpSocket</code> will simply test to see if a <code>tcpSocket</code> is empty and a probe of type <code>exec</code> will run a command on the <a href="#BM_(container)%2Fi">container</a> and fail if it gets a non-zero exit code.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">readinessProbe:</span>
        <span class="hljs-attr">exec:</span>
          <span class="hljs-attr">command:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/some_file_here</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
</code></pre>
<a name="H_Volumes"></a><h3>Volumes</h3>
<p><a name="BM_(Resources%5C%2FPods%2FVolumes)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FVolumes)_TOPIC%2Fi">Resources/Volumes</a></li>
</ul>
</div>
<p>Volumes are controlled through <code>spec.volumes[]</code> and <code>spec.containers[].volumneMounts</code> ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-data</span>
      <span class="hljs-string">...</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-data</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data"</span>
</code></pre>
<p><code>spec.volumes[]</code> defines a list of volumes, and those volumes can then go on to be mounted on the individual <a href="#BM_(container)%2Fi">container</a>s that make up the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> through <code>spec.containers[].volumneMounts</code>. Each entry in <code>spec.volumes[]</code> can either directly refer to a volume type and its parameters or it can refer to a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</p>
<p>In the example above, a volume type is used directly within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (<code>hostPath</code>). This is discouraged because it binds the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to a specific volume type and parameters, thereby making the volume and the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> tightly coupled. The better way to use volumes within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is to use <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s and <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s. Assuming that you have a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> already created, it can be referenced in <code>spec.volumes[]</code> by using the <code>persistentVolumeClaim</code> as the volume type.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-data</span>
      <span class="hljs-attr">persistentVolumeClaim:</span>
        <span class="hljs-attr">claimName:</span> <span class="hljs-string">my-data-pv-claim</span>
</code></pre>
<a name="H_Image%20Pull%20Policy"></a><h3>Image Pull Policy</h3>
<p><a name="BM_(Resource%5C%2FPods%2FImage%20Pull%20Policy)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(image)%2Fi">Image</a> pull policy is the policy <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses for downloading a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(image)%2Fi">image</a>s.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>A value of ...</p>
<ul>
<li><code>IfNotPresent</code> only downloads the <a href="#BM_(image)%2Fi">image</a> if its not already locally present.</li>
<li><code>Always</code> always downloads the <a href="#BM_(image)%2Fi">image</a>.</li>
<li><code>Never</code> never downloads the <a href="#BM_(image)%2Fi">image</a> (will fail if <a href="#BM_(image)%2Fi">image</a> does not exist locally).</li>
</ul>
<p>If unset, the pull policy differs based on the <a href="#BM_(image)%2Fi">image</a> tag. Not specifying a tag or specifying <code>latest</code> as the tag will always pull the <a href="#BM_(image)%2Fi">image</a>. Otherwise, the <a href="#BM_(image)%2Fi">image</a> will be pulled only if it isn't present.</p>
<a name="H_Image%20Pull%20Secret"></a><h3>Image Pull Secret</h3>
<p><a name="BM_(Resource%5C%2FPods%2FImage%20Pull%20Secrets)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FSecrets)_TOPIC%2F">Resources/Secrets</a></li>
</ul>
</div>
<p><a href="#BM_(image)%2Fi">Image</a> pull secret is the credentials <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses for downloading a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(image)%2Fi">image</a>s from a <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(registry)%2Fi">registry</a>. It requires that a secret object of type  <code>kubernetes.io/dockerconfigjson</code> exist with those credentials in the same format as Docker's <code>config.json</code> file.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-docker-creds</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/dockerconfigjson</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-string">.dockerconfigjson:</span> <span class="hljs-string">|
        "&lt;base64 encoded ~/.docker/config.json file&gt;"
</span></code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you don't want to supply the above manifest, you can also use <code>kubectl</code> to create a secret object with the appropriate credentials: <code>kubectl create secret docker-registry secret-tiger-docker --docker-email=tiger@acme.example --docker-username=tiger --docker-password=pass1234 --docker-server=my-registry.example:5000</code>.</p>
</div>
<p>This secret should be referenced at the top-level of your <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s specification.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">imagePullSecrets:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-docker-creds</span>  <span class="hljs-comment"># Place secret here. This is a list, so you can have many docker</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>                    <span class="hljs-comment"># credential secrets here.</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-registry.example/tiger/my-container:1.0.1</span>
</code></pre>
<a name="H_Restart%20Policy"></a><h3>Restart Policy</h3>
<p><a name="BM_(Resources%5C%2FPods%2FRestart%20Policy)_TOPIC%2F"></a><strong></strong></p>
<p>Restart policy is the policy <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses for determining when a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> should be restarted. Its controlled via the <code>spec.containers[].restartPolicy</code> manifest paths ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
    <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>A value of ...</p>
<ul>
<li><code>Always</code> always restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> regardless of how it exists (default).</li>
<li><code>OnFailure</code> only restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> only if it failed execution.</li>
<li><code>Never</code> never restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p>The top one is typically used when running servers that should always be up (e.g. http server) while the latter two are typically used for one-off <a href="#BM_(job)%2Fi">job</a>s.</p>
<a name="H1_Configuration"></a><h3>Configuration</h3>
<p><a name="BM_(Resources%5C%2FPods%2FConfiguration)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FConfiguration%20Maps)_TOPIC%2F">Resources/Configuration Maps</a></li>
<li><a href="#BM_(Resources%5C%2FSecrets)_TOPIC%2F">Resources/Secrets</a></li>
<li><a href="#BM_(Resources%5C%2FPods%2FVolumes)_TOPIC%2F">Resources/Pods/Volumes</a></li>
</ul>
</div>
<p>Configuration can come from both config maps and secrets. A config map's key-value pairs can be accessed by a <a href="#BM_(container)%2Fi">container</a> via environment variables, command-line arguments, or volume mounts. To set a ...</p>
<ul>
<li>
<p>environment variable:</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-comment"># Under each "env" entry to come from a config map, add a "valueFrom" that contains</span>
      <span class="hljs-comment"># the config map to pull an entry from and the key for the config map entry to pull.</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>  <span class="hljs-comment"># Env var to assign value to.</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>       <span class="hljs-comment"># Config map to pull from</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>  <span class="hljs-comment"># Config map entry to get value from</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>
</code></pre>
<p>In certain cases, you may want to map all entries within a config map directly as a set of environment variables. This is useful when many entries of a config map are required for configuration, so many that becomes tedious and error-prone to map them all to environment variables by hand.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-comment"># "envFrom" maps all entries of a config map as env vars.</span>
      <span class="hljs-attr">envFrom:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">prefix:</span> <span class="hljs-string">CONFIG_</span>    <span class="hljs-comment"># Prefix to tack on to each config map entry (optional).</span>
          <span class="hljs-attr">configMapRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If a config map name can't map to an environment variable, it's silently omitted. For example, env names can't contain dashes.</p>
</div>
</li>
<li>
<p>command-line argument:</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-comment"># You can't pass in config map entries directly as command-line arguments, but what</span>
      <span class="hljs-comment"># you can do is load them up first as environment variables and then reference the</span>
      <span class="hljs-comment"># environment variables in the "command" (or "args") field.</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"/my-app.sh"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME1)"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME2)"</span>
</code></pre>
</li>
<li>
<p>volume mount:</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Place a "configMap" type volume into the pod.</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
        <span class="hljs-comment"># "items" lists out specific config map entries to include and mounts each as</span>
        <span class="hljs-comment"># a specific filename. If you don't include this, all config map entries will</span>
        <span class="hljs-comment"># be included (filenames will map to config map entry names).</span>
        <span class="hljs-attr">items:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">file1.cfg</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">file2.cfg</span>
  <span class="hljs-comment"># In the container, mount that volume to whichever containers you want.</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>       <span class="hljs-comment"># Make the mount read-only (optional).</span>
          <span class="hljs-attr">defaultMode:</span> <span class="hljs-string">"6600"</span>  <span class="hljs-comment"># File access permissions of mounted files (optional).</span>
</code></pre>
<p>If the directory you're mounting to already exists on the <a href="#BM_(container)%2Fi">container</a>, that existing directory is entirely replaced. In the example above, if the <a href="#BM_(container)%2Fi">container</a> already has a "/config" directory, it'll get replaced entirely with the config map mount (this is bad because the <a href="#BM_(container)%2Fi">container</a>'s "/config" might have other necessary files required for the <a href="#BM_(container)%2Fi">container</a> to work). A workaround to this is to use the volume mount's "subPath" property, which allows you to mount a single file / directory from a volume.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-comment"># The use of "subPath" here ensures that that original "/config" directory on the</span>
      <span class="hljs-comment"># container doesn't go away. It remains in place, and files / directories are just</span>
      <span class="hljs-comment"># added to it.</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config/file1.cfg</span>  <span class="hljs-comment"># Destination file to mount to.</span>
          <span class="hljs-attr">subPath:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>      <span class="hljs-comment"># Source config map entry name.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config/file2.cfg</span>  <span class="hljs-comment"># Destination file to mount to.</span>
          <span class="hljs-attr">subPath:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>      <span class="hljs-comment"># Source config map entry name.</span>
</code></pre>
</li>
</ul>
<p>A secret object's key-value pairs can be accessed in almost exactly the same way with almost exactly the same set of options and restrictions. To set a ...</p>
<ul>
<li>
<p>environment variable:</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY2</span>
</code></pre>
</li>
<li>
<p>command-line argument:</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY2</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"/my-app.sh"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME1)"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME2)"</span>
</code></pre>
</li>
<li>
<p>volume mount:</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span>
      <span class="hljs-attr">secret:</span>  <span class="hljs-comment"># This has been changed from "configMap" to "secret"</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/secrets</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
</code></pre>
</li>
</ul>
<p>Both config maps and secret objects can be dynamically updated. If a running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is running when an update gets issued, it may or may not receive those updates depending on the configuration usage method:</p>
<ul>
<li>environment variables <em>don't</em> receive updates.</li>
<li>command-line arguments <em>don't</em> receive updates.</li>
<li>individual volume mounts <em>don't</em> receive updates.</li>
<li>whole volume mounts do receive updates.</li>
</ul>
<p>Command-line arguments and environment variables don't update because an application's command-line arguments and environment variables can't be changed from the outside once a process launches. Individual files/directories mounted from a volume don't update because of technical limitations related to how Linux filesystems work (see <a href="here">https://github.com/</a><a href="#BM_(Kubernetes)%2Fi">kubernetes</a>/<a href="#BM_(Kubernetes)%2Fi">kubernetes</a>/issues/50345#issuecomment-656947594). Whole volume mounts <em>do</em> update files under the mount, but it's up to the application to detect and reload those changed files.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>All files in a volume mount get updated at once. This is possible because of symlinks. New directory get loaded in and the symlink is updated to use that new directory.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For individual files/directories mounted from a volume, one workaround to receiving updates is to use symlinks. Essentially, mount the whole volume to path that doesn't conflict with an existing path in the <a href="#BM_(container)%2Fi">container</a>. Then, as a part of the <a href="#BM_(container)%2Fi">container</a>'s start-up process, add symlinks to the whole volume mount wherever needed.</p>
<p>For example, if the application requires a configuration file at /etc/my_config.conf, you can mount all configurations to /config and then symlink /etc/my_config.conf to /config/my_config.conf. That way, you can still receive updates.</p>
</div>
<p>The typical workaround to config map dynamic updates is to use <a href="#BM_(deployment)%2Fi">deployment</a>s. In <a href="#BM_(deployment)%2Fi">deployment</a>s, secret objects / config maps and <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are bound together as a single unit, meaning that all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> restart automatically on any change.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FDeployments)_TOPIC%2Fi">Resources/Deployments</a></li>
</ul>
</div>
<a name="H_Secrets"></a><h3>Secrets</h3>
<p><a name="BM_(Pods%5C%2FSecrets)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FSecrets)_TOPIC%2F">Resources/Secrets</a></li>
</ul>
</div>
<p>To use secrets in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, a specialized <code>secret</code> volume type must be used and mounted. For example, the following volume mounts the secrets created in the example command above ..</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">volumeMounts:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-secrets</span>
        <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/tls"</span>
        <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-secrets</span>
      <span class="hljs-attr">secret:</span>
        <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-tls-cert</span>
</code></pre>
<a name="H_Service%20Discovery"></a><h3>Service Discovery</h3>
<p><a name="BM_(Pods%5C%2FService%20Discovery)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FServices)_TOPIC%2Fi">Resources/Services</a></li>
</ul>
</div>
<p>For a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to be able to communicate with other <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> in the cluster, it needs to be able to discover the IPs of those other <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> / <a href="#BM_(service)%2Fi">service</a>s first. The mechanism for this is <a href="#BM_(service)%2Fi">service</a>s, and there's two ways in which a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can discover <a href="#BM_(service)%2Fi">service</a>s in the cluster: environment variables and DNS.</p>
<p>These <a href="#BM_(service)%2Fi">service</a> discovery mechanisms are details in the subsections below.</p>
<a name="H1_Environment%20Variables"></a><h4>Environment Variables</h4>
<p><a name="BM_(Pods%5C%2FService%20Discovery%2FEnvironment%20Variables)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FEnvironment%20Variables)_TOPIC%2F">Resources/Pods/Environment Variables</a></li>
</ul>
</div>
<p>When a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> launches, all IP and port combinations for <a href="#BM_(service)%2Fi">service</a>s within the same <a href="#BM_(namespace)%2Fi">namespace</a> are stored as environment variables which the <a href="#BM_(container)%2Fi">container</a>(s) within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can query. A <a href="#BM_(service)%2Fi">service</a>'s  The environment variable names are in the format <code>{SVCNAME}_SERVICE_HOST</code> / <code>{SVCNAME}_SERVICE_PORT</code>, where <code>{SVCNAME}</code> is the <a href="#BM_(service)%2Fi">service</a> converted to uppercase and dashes swapped with underscores. For example, two <a href="#BM_(service)%2Fi">service</a>s <code>service-a</code> and <code>service-b</code> as environment variables:</p>
<pre><code>SERVICE_A_SERVICE_HOST=10.111.240.1
SERVICE_A_SERVICE_PORT=443
SERVICE_B_SERVICE_HOST=10.111.249.153
SERVICE_B_SERVICE_PORT=80
</code></pre>
<p>If a <a href="#BM_(service)%2Fi">service</a> exposes multiple ports, only the first port goes in <code>{SVCNAME}_SERVICE_PORT</code>. When multiple ports are present, additional environment variables get created in the format  <code>{SVCNAME}_SERVICE_PORT_{PORTNAME}</code>, where <code>{PORTNAME}</code> is the name of <a href="#BM_(service)%2Fi">service</a>'s port modified the same way that <code>{SVCNAME}</code> is. For example, the <a href="#BM_(service)%2Fi">service</a> <code>service-c</code> exposes two ports named <code>web-1</code> and <code>metrics-1</code>:</p>
<pre><code>SERVICE_A_SERVICE_HOST=10.111.240.1
SERVICE_A_SERVICE_PORT=443
SERVICE_A_SERVICE_PORT_WEB_1=443
SERVICE_A_SERVICE_PORT_METRICS_1=8080
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Looking at the k8s code, it looks like for a <a href="#BM_(service)%2Fi">service</a> port needs to be named for it as an environment variable. <a href="#BM_(service)%2Fi">Service</a> ports that don't have a name won't show up as environment variables. See <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/envvars/envvars.go#L51-L55">here</a>.</p>
</div>
<p>Aside from the only listing <a href="#BM_(service)%2Fi">service</a>s within the same <a href="#BM_(namespace)%2Fi">namespace</a> and potential naming conflicts that happen during name normalization (uppercase-ing and dash to underscore -- e.g. <code>My-name</code> and <code>my_namE</code> both end up as <code>MY_NAME</code>), another problem with using environment variables for <a href="#BM_(service)%2Fi">service</a> discovery is that the <a href="#BM_(service)%2Fi">service</a>s required by a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> need to be active before the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> starts. The reason for this is that environment variables can only be set prior to the launch of a <a href="#BM_(container)%2Fi">container</a> process. If a process launches and a <a href="#BM_(service)%2Fi">service</a> comes up afterwards, that process's environment variables won't include that <a href="#BM_(service)%2Fi">service</a>'s host and port.</p>
<a name="H_DNS"></a><h4>DNS</h4>
<p><a name="BM_(Pods%5C%2FService%20Discovery%2FDNS)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(resource)%2Fi">Resource</a>s/<a href="#BM_(Pods%5C%2FService%20Discovery%2FDNS)_TOPIC%2F">Pods/Service Discovery/DNS</a></li>
</ul>
</div>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> provides a DNS server which is used for <a href="#BM_(service)%2Fi">service</a> discovery. Each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> in the cluster is automatically configured to use this DNS server and simply has to query it for a <a href="#BM_(service)%2Fi">service</a>'s name. If the queried <a href="#BM_(service)%2Fi">service</a> is present in the cluster, the DNS server will return the stable IP for the <a href="#BM_(service)%2Fi">service</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The DNS server runs as an internal <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> application called 'coredns<code>or</code><a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">kube-dns</a><code>. This is usually in the </code><a href="#BM_(kube-system)%2Fi">kube-system</a>` <a href="#BM_(namespace)%2Fi">namespace</a>. Recall that the IP of a <a href="#BM_(service)%2Fi">service</a> is stable for the entire lifetime of the <a href="#BM_(service)%2Fi">service</a>, meaning that <a href="#BM_(service)%2Fi">service</a> restarts and DNS caching by the application and / or OS isn't an issue here.</p>
</div>
<p>The general domain query format is <code>{SVCNAME}.{NAMESPACE}.svc.{CLUSTERDOMAIN}</code>, where ...</p>
<ul>
<li><code>{SVCNAME}</code> is the name of the <a href="#BM_(service)%2Fi">service</a>.</li>
<li><code>{NAMESPACE}</code> is the name of the <a href="#BM_(namespace)%2Fi">namespace</a> that <code>{SVCNAME}</code> is in.</li>
<li><code>{CLUSTERDOMAIN}</code> is the cluster domain suffix of the cluster that <code>{SVCNAME}</code> and <code>{NAMESPACE}</code> are in.</li>
</ul>
<p>For example, to query for the IP of <a href="#BM_(service)%2Fi">service</a> <code>serviceA</code> in <a href="#BM_(namespace)%2Fi">namespace</a> <code>ns1</code> within a cluster with the domain name suffix <code>cluster.local</code>, the domain name to query is <code>serviceA.ns1.svc.cluster.local</code>. Alternatively, if the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> doing the querying is ...</p>
<ul>
<li>within the same cluster, the cluster domain suffix can be omitted: <code>serviceA.ns1</code>.</li>
<li>within the same cluster and <a href="#BM_(namespace)%2Fi">namespace</a>, both the <a href="#BM_(namespace)%2Fi">namespace</a> and the cluster domain suffix can be omitted: <code>serviceA</code>.</li>
</ul>
<p>Compared to environment variable <a href="#BM_(service)%2Fi">service</a> discovery, using DNS to discover <a href="#BM_(service)%2Fi">service</a>s won't include information about ports.</p>
<a name="H_Metadata%20Access"></a><h3>Metadata Access</h3>
<p><a name="BM_(Pods%5C%2FMetadata%20Access)_TOPIC%2F"></a><strong></strong></p>
<p>Metadata such as a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s name, IP address, which <a href="#BM_(node)%2Fi">node</a> it's running on <a href="#BM_(node)%2Fi">node</a>, what <a href="#BM_(namespace)%2Fi">namespace</a> it's under, etc.. can be accessed within a <a href="#BM_(container)%2Fi">container</a>.</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<p>TODO: START FROM CH8</p>
<a name="H_Configuration%20Maps"></a><h2>Configuration Maps</h2>
<p><a name="BM_(Resources%5C%2FConfiguration%20Maps)_TOPIC%2F"></a><strong></strong></p>
<p>A configuration map is a type of <a href="#BM_(resource)%2Fi">resource</a> comprised of key-value pairs intended to configure the main application of a <a href="#BM_(container)%2Fi">container</a> (or many <a href="#BM_(container)%2Fi">container</a>s). By decoupling configurations from the <a href="#BM_(container)%2Fi">container</a>s themselves, the same configuration map (or parts of it) could be used to configure multiple <a href="#BM_(container)%2Fi">container</a>s within <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Do <strong>NOT</strong> use this for storing secrets such as tokens, certificates, or passwords. See <a href="#BM_(Resources%5C%2FSecrets)_TOPIC%2F">Resources/Secrets</a> instead.</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">param1:</span> <span class="hljs-string">another-value</span>
  <span class="hljs-attr">param2:</span> <span class="hljs-string">extra-value</span>
  <span class="hljs-attr">my-config.ini:</span> <span class="hljs-string">|
    # This is a sample config file that I might use to configure an application
    key1 = value1
    ket1 = value2
</span></code></pre>
<p>The key-value pairs of a configuration map <a href="#BM_(resource)%2Fi">resource</a> typically get exposed to a <a href="#BM_(container)%2Fi">container</a> either as environment variables, files, or command-line arguments. Keys are limited to certain characters: alphabet, numbers, dashes, underscores, and dots.</p>
<a name="H1_Secrets"></a><h2>Secrets</h2>
<p><a name="BM_(Resources%5C%2FSecrets)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FConfiguration%20Maps)_TOPIC%2F">Resources/Configuration Maps</a></li>
</ul>
</div>
<p>A secret object is a type of <a href="#BM_(resource)%2Fi">resource</a> comprised of key-value pairs, similar to a config map, but oriented towards security rather than just configuration (e.g. for storing things like access tokens, passwords, certificates). As opposed to a config map, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> takes extra precautions to ensure that a secret object is stored and used in a secure manner.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>  <span class="hljs-comment"># "Opaque" is the default type (can be omitted)</span>
<span class="hljs-comment"># Both text and binary data are supported. To insert a text entry, place it under</span>
<span class="hljs-comment"># "stringData". To insert a binary entry, base64 the value and place it under "data". </span>
<span class="hljs-attr">stringData:</span>
  <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">pepsi_one</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">key_file:</span> <span class="hljs-string">eWFiYmFkYWJiYWRvbw==</span>  
</code></pre>
<p>Many types of secrets exist. Each type either does some level of verification on the entries and / or acts as a tag to convey what data is contained within (e.g. SSH data, TLS data, etc..). In general <code>Opaque</code> is the secret type used by most applications.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Certain sources are claiming that a secret object can be 1 megabyte at most.</p>
</div>
<a name="H_Nodes"></a><h2>Nodes</h2>
<p><a name="BM_(Resources%5C%2FNodes)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
</ul>
</div>
<p><a href="#BM_(node)%2Fi">Node</a>s are the machines that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> run on. A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> cluster often contains multiple <a href="#BM_(node)%2Fi">node</a>s, each with a certain amount of <a href="#BM_(resource)%2Fi">resource</a>s. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> get assigned to <a href="#BM_(node)%2Fi">node</a>s based on their <a href="#BM_(resource)%2Fi">resource</a> requirements. For example, if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> A requires 2gb of memory and <a href="#BM_(node)%2Fi">node</a> C has 24 gigs available, that <a href="#BM_(node)%2Fi">node</a> may get assigned to run that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p><img src="svgbob_fc6073ce9dd71ac1b2fa56b7775e45eca6d21eaf.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> typically attempts to schedule multiple instances of the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> on different <a href="#BM_(node)%2Fi">node</a>s, such that a downed <a href="#BM_(node)%2Fi">node</a> won't take out all instances of the <a href="#BM_(service)%2Fi">service</a> that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> runs. In the example above, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances of the same type are spread out across the 3 <a href="#BM_(node)%2Fi">node</a>s.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> has a leader-follower architecture, meaning that of the <a href="#BM_(node)%2Fi">node</a>s a small subset is chosen to lead / manage the others. The leaders are referred to as <a href="#BM_(master%20node)%2Fi">master node</a>s while the followers are referred to as <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
<p><img src="svgbob_90abf3344c1d253481a3a392500782cca41f92fd.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BM_(master%20node)%2Fi">master node</a> can still run <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> just like the <a href="#BM_(worker%20node)%2Fi">worker node</a>s, but some of its <a href="#BM_(resource)%2Fi">resource</a>s will be tied up for the purpose of managing <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
<a name="H1_Volumes"></a><h2>Volumes</h2>
<p><a name="BM_(Resources%5C%2FVolumes)_TOPIC%2Fi"></a><strong></strong></p>
<p>Volumes are disks where data can be persisted across <a href="#BM_(container)%2Fi">container</a> restarts. Normally, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> resets a <a href="#BM_(container)%2Fi">container</a>'s filesystem each time that <a href="#BM_(container)%2Fi">container</a> restarts (e.g. after a crash or a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> getting moved to a different <a href="#BM_(node)%2Fi">node</a>). While that works for some types of applications, other application types such as database servers need to retain state across restarts.</p>
<p>Volumes in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> are broken down into "<a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s" and "<a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s". A ...</p>
<ul>
<li><a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is the volume itself.</li>
<li><a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> is the assignment of a volume.</li>
</ul>
<p>The idea is that a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> itself is just a floating block of disk space. Only when its claimed does it have an assignment. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a> can then latch on to those assignments.</p>
<p><img src="svgbob_245492e803e908f1ed349aac70d29be295b2b5a1.svg" alt="Kroki diagram output"></p>
<p>In the example above, there are 4 volumes in total but only 3 of those volumes are claimed. podA latches on to claim1 and claim2 while podB latches on to claim3 and claim2 (both <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can access the volume claimed in claim2).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(persistent%20volume)%2Fi">Persistent volume</a>s themselves are cluster-level <a href="#BM_(resource)%2Fi">resource</a>s while <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s are <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(resource)%2Fi">resource</a>s. All volumes are available for claims regardless of the <a href="#BM_(namespace)%2Fi">namespace</a> that claim is in. Maybe you can limit which volumes can be claimed by using <a href="#BM_(label)%2Fi">label</a>s / <a href="#BM_(label%20selector)%2Fi">label selector</a>s?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Part of the reasoning for doing it like this is decoupling: volumes are independent from <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and a volume can be have shared access across <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p>Another reasons is that a developer should only be responsible for claiming a volume while the cluster administrator should be responsible for setting up those volumes and dealing with backend details like the specifics of the volume type and how large each volume is. As a developer, you only have to make a "claim" while the administrator is responsible for ensuring those <a href="#BM_(resource)%2Fi">resource</a>s exist.</p>
</div>
<p>Example <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vol</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">capacity:</span>
    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadOnlyMany</span>
  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span>  <span class="hljs-comment"># once a claim on this volume is given up, delete the files on disk</span>
  <span class="hljs-attr">awsElasticBlockStore:</span>
    <span class="hljs-attr">volumeID:</span> <span class="hljs-string">volume-id</span>
    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span>
</code></pre>
<p>Example <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vol-claim</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>  <span class="hljs-comment"># volume must have at least this much space</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-comment"># volume must have this access mode</span>
  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">""</span>  <span class="hljs-comment"># MUST BE EMPTY STRING to claim test-vol described above (if set, uses dynamic provisioning)</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why must <code>spec.storageClassName</code> be an empty string instead of being removed entirely? Being removed entirely would cause <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to use a default storage class name (if one exists), which is not what you want. Storage classes are described in the next few paragraphs below.</p>
</div>
<p>There are two types of volume provisioning available:</p>
<ul>
<li>static provisioning - a claim is assigned a pre-created <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>.</li>
<li>dynamic provisioning - a claim triggers a new <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> to get created and is assigned to it.</li>
</ul>
<p>Dynamic provisioning only requires that you make a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> with a specific <code>spec.storageClassName</code>. The administrator is responsible for ensuring a provisioner exists for that storage class and it automatically creates a volume of that type when a claim comes in. Each storage class can have different characteristics such as volume type (e.g. HDD vs SSD), volume read/write speeds, backup policies, etc.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">standard</span>
<span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span>
<span class="hljs-attr">parameters:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">gp2</span>
</code></pre>
<a name="H_Capacity"></a><h3>Capacity</h3>
<p><a name="BM_(Resources%5C%2FVolumes%2FCapacity)_TOPIC%2Fi"></a><strong></strong></p>
<p>The capacity of a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is set through <code>spec.capacity.storage</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">capacity:</span>
    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span>
</code></pre>
<p>A <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> can then be set to require a specific amount of capacity via <code>spec.resources.request.storage</code>. Specifically, <code>requests</code> defines the minimum required capacity and <code>limits</code> defines the maximum required capacity.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>  <span class="hljs-comment"># volume must have at least this much space</span>
    <span class="hljs-attr">limits:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span>  <span class="hljs-comment"># volume can't have more than this much space</span>
</code></pre>
<a name="H_Access%20Modes"></a><h3>Access Modes</h3>
<p><a name="BM_(Resources%5C%2FVolumes%2FAccess%20Modes)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> can support multiple access modes:</p>
<ul>
<li><code>ReadWriteOnce</code> - volume is mountable by a single <a href="#BM_(node)%2Fi">node</a> in read-write mode.</li>
<li><code>ReadWriteOncePod</code> - volume is mountable by a single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> in read-write mode.</li>
<li><code>ReadWriteMany</code> - volume is mountable by many <a href="#BM_(node)%2Fi">node</a>s in read-write mode.</li>
<li><code>ReadOnlyMany</code> - volume is mountable by many <a href="#BM_(node)%2Fi">node</a>s in read-only mode.</li>
</ul>
<p>The available access modes of a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is set through <code>spec.accessModes</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadOnlyMany</span>
</code></pre>
<p>A <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> can then be set to target on or more access modes.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-comment"># volume must have this access mode</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A claim takes a list of access modes, so is it that a claim needs to get a volume with all access modes present or just one of the access modes present?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not all <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> types support all access modes. Types are discussed further below.</p>
</div>
<a name="H_Reclaim%20Policy"></a><h3>Reclaim Policy</h3>
<p><a name="BM_(Resources%5C%2FVolumes%2FReclaim%20Policy)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>, once released, may or may not make the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>able again depending on what <code>spec.persistentVolumeReclaimPolicy</code> was set to.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span> 
</code></pre>
<p>The options available are ...</p>
<ul>
<li><code>Retain</code> - keep all existing data on the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> and prevent a new <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> from claiming it again.</li>
<li><code>Recycle</code> - delete all existing data on the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> and allow a new <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> to claim it again.</li>
<li><code>Delete</code> - delete the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> object itself.</li>
</ul>
<p>If the data on disk is critical to operations, the option to choose will likely be <code>Retain</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For retain specifically, once the existing <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> is released, the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> itself goes into "Released" status. If it were available reclamation, it would go into "Available" status. The book mentions that there is no way to "recycle" a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> that's in "Released" status without destroying and recreating it.</p>
<p>According to the k8s docs, this is the way it is so that users have a chance to manually pull out data considered precious before it gets destroyed.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not all <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> types support all reclaim policies. Types are discussed further below.</p>
</div>
<a name="H_Types"></a><h3>Types</h3>
<p><a name="BM_(Resources%5C%2FVolumes%2FTypes)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> needs to come from somewhere, either via a cloud provider or using some internally networked (or even local) disks. There are many volume types: AWS elastic block storage, Azure file, Azure Disk, GCE persistent disk, etc.. Each type has its own set of restrictions such as what access modes it supports or the types of <a href="#BM_(node)%2Fi">node</a>s it can be mounted.</p>
<p>The configuration for each type is unique and goes directly under <code>spec</code>. The following are sample configurations for popular types...</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The documentation says that a lot of these types are deprecated and being moved over to something called CSI (<a href="#BM_(container)%2Fi">container</a> storage interface), so these examples may need to be updated in the future</p>
</div>
<pre class="hljs"><code><span class="hljs-comment"># Amazon Elastic Block Storage</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">awsElasticBlockStore:</span>
    <span class="hljs-attr">volumeID:</span> <span class="hljs-string">volume-id</span>  <span class="hljs-comment"># a volume with this ID must already exist in AWS</span>
    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># Google Compute Engine Persistent Disk</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">gcePersistentDisk:</span>
    <span class="hljs-attr">pdName:</span> <span class="hljs-string">test-vol</span>  <span class="hljs-comment"># a disk with this name must already exist in GCE</span>
    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># Azure Disk</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">azureDisk:</span>
    <span class="hljs-comment"># a volume with this name and URI must already exist in Azure</span>
    <span class="hljs-attr">diskName:</span> <span class="hljs-string">test.vhd</span>
    <span class="hljs-attr">diskURI:</span> <span class="hljs-string">https://someaccount.blob.microsoft.net/vhds/test.vhd</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># Host path</span>
<span class="hljs-comment">#   -- this is a path on the node that the pod gets scheduled on, useful</span>
<span class="hljs-comment">#      for debugging purposes.</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hostPath:</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">/data</span>
</code></pre>
<a name="H_Storage%20Classes"></a><h3>Storage Classes</h3>
<p><a name="BM_(Resources%5C%2FVolumes%2FStorage%20Classes)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FVolumes%2FReclaim%20Policy)_TOPIC%2Fi">Resources/Volumes/Reclaim Policy</a></li>
<li><a href="#BM_(Resources%5C%2FVolumes%2FTypes)_TOPIC%2Fi">Resources/Volumes/Types</a></li>
</ul>
</div>
<p>Defining a storage class allows for dynamic provisioning of <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s per <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">standard</span>
<span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span>
<span class="hljs-attr">parameters:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">gp2</span>
<span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Retain</span>
<span class="hljs-attr">allowVolumeExpansion:</span> <span class="hljs-literal">true</span>
</code></pre>
<p><code>provisioner</code> and <code>parameters</code> define how <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s are to be created and are unique to each volume type. In the example above, the storage class is named <code>standard</code> and it provisions new <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s on AWS. Any <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> with <code>spec.storageClassName</code> set to <code>standard</code> will call out to this AWS elastic store provisioner to create a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> of type <code>awsElasticBlockStore</code> which gets assigned to it.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vol-claim</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>
  <span class="hljs-attr">accessModes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">standard</span>  <span class="hljs-comment"># use the storage class described above for this claim</span>
</code></pre>
<p>If <code>allowVolumeExpansion</code> is set to <code>true</code>, the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> can be resized by editing the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> object. Only some volume types support volume expansion. The example above will work because AWS elastic block store volume types do support volume expansion.</p>
<p><code>reclaimPolicy</code> maps to a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>'s <code>spec.persistentVolumeReclaimPolicy</code>, except that <code>Recycle</code> isn't one of the allowed options: only <code>Delete</code> and <code>Retain</code> are allowed.If unset, the reclaim policy of a dynamically provisioned <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is <code>Delete</code>. The example above overrides the reclaim policy to <code>Retain</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Since these <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s are being dynamically provisioned, it doesn't make sense to have <code>Recycle</code>. You can just <code>Delete</code> and if a new claim comes in it'll automatically provision a new volume. It's essentially the same thing as <code>Recycle</code>.</p>
</div>
<p>If a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> leaves <code>spec.storageClassName</code> unset, the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> will use whatever storage class <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> has set as its default. Recall that leaving <code>spec.storageClassName</code> unset is <em>not</em> the same as leaving it as an empty string. To leave unset means to keep it out of the declaration entirely. If <code>spec.storageClassName</code> is ...</p>
<ul>
<li>set to an empty string, it tells <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to find any <em>existing</em> <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> for the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</li>
<li>set to a non-empty string, it tells <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to use that storage class to dynamically provision a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> for the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</li>
<li>unset, it tells <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to use the default storage class to dynamically provision a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> for the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</li>
</ul>
<p>Most <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> installations have a default storage class available, identified by the storage class having the <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> <code>storageclass.kubernetes.io/is-default-class=true</code>.</p>
<pre><code># kubectl get sc
# Note how the name identifies it as the default.
NAME                          PROVISIONER            RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
microk8s-hostpath (default)   microk8s.io/hostpath   Delete          WaitForFirstConsumer   false                  6s
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># kubectl get sc microk8s-hostpath -o yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="hljs-string">|
      {"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"},"name":"microk8s-hostpath"},"provisioner":"microk8s.io/hostpath","volumeBindingMode":"WaitForFirstConsumer"}
</span>    <span class="hljs-attr">storageclass.kubernetes.io/is-default-class:</span> <span class="hljs-string">"true"</span>
  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">"2022-07-22T19:41:28Z"</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">microk8s-hostpath</span>
  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">"2775"</span>
  <span class="hljs-attr">uid:</span> <span class="hljs-string">1df92cbc-6e2f-4726-a487-a81b1fcd8d2b</span>
<span class="hljs-attr">provisioner:</span> <span class="hljs-string">microk8s.io/hostpath</span>
<span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span>
<span class="hljs-attr">volumeBindingMode:</span> <span class="hljs-string">WaitForFirstConsumer</span>
</code></pre>
<a name="H_Endpoints"></a><h2>Endpoints</h2>
<p><a name="BM_(Resources%5C%2FEndpoints)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(endpoints)%2Fi">Endpoints</a> (plural) is a <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that simply holds a list of IP addresses and ports. It's used by higher-level <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a>s to simplify routing. For example, an <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(resource)%2Fi">resource</a> may direct to all the <a href="#BM_(node)%2Fi">node</a>s that make up a sharded database server.</p>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">database</span>
<span class="hljs-attr">subsets:</span> 
  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5432</span> 
        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-comment"># TCP or UDP, default: TCP</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">pg</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.13</span><span class="hljs-number">.4</span><span class="hljs-number">.101</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.13</span><span class="hljs-number">.4</span><span class="hljs-number">.102</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.13</span><span class="hljs-number">.4</span><span class="hljs-number">.103</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">12345</span>
        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-comment"># TCP or UDP, default: TCP</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">pg2</span>
</code></pre>
<p>The <a href="#BM_(endpoints)%2Fi">endpoints</a> in the example YAML above points to [10.10.1.1:5432, 10.10.1.2:5432, 10.10.1.3:5432, 10.13.4.101:12345, 10.13.4.102:12345, 10.13.4.103:12345].</p>
<a name="H_Services"></a><h2>Services</h2>
<p><a name="BM_(Resources%5C%2FServices)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(service)%2Fi">Service</a>s are a discovery and load balancing mechanism. A <a href="#BM_(service)%2Fi">service</a> exposes a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> under a single fixed unified hostname and IP, routing traffic to that set by load balancing incoming requests across the set. Any external application would need to use a <a href="#BM_(service)%2Fi">service</a>'s hostname because the IP / host of the single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances aren't fixed, exposed, or known. That is, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are transient and aren't guaranteed to always reside on the same <a href="#BM_(node)%2Fi">node</a>. As they shutdown, come up, restart, move between <a href="#BM_(node)%2Fi">node</a>s, etc.., there's no implicit mechanism that requestors can use to route their requests accordingly.</p>
<p>A <a href="#BM_(service)%2Fi">service</a> fixes this my internally tracking such changes and providing a single unified point of access.</p>
<p><img src="svgbob_9fcafa853ed3eccdae11b6e4d860f6208b276d0e.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions why DNS can't be used directly. For example, having a basic DNS <a href="#BM_(service)%2Fi">service</a> which returns a list of all up-and-running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> IPs won't work because ...</p>
<ol>
<li>applications and operating systems often cache DNS results, meaning that changes won't be visible immediately.</li>
<li>applications often only use the first IP given back by a DNS result, meaning that requests won't balance.</li>
</ol>
<p>The <a href="#BM_(service)%2Fi">service</a> fixes this because it acts as a load balancing proxy and its IP / host never changes (DNS caching won't break anything).</p>
</div>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Internally, an <a href="#BM_(endpoints)%2Fi">EndPoints</a> object is used to track <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. When you create a <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> automatically creates an accompanying <a href="#BM_(endpoints)%2Fi">EndPoints</a> object that the <a href="#BM_(service)%2Fi">service</a> makes use of.</p>
</div>
<a name="H_Routing"></a><h3>Routing</h3>
<p><a name="BM_(Resources%5C%2FServices%2FRouting)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a></li>
<li><a href="#BM_(Resources%5C%2FEndpoints)_TOPIC%2Fi">Resources/Endpoints</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> determines which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it should route traffic to via the <code>spec.selector</code> manifest path. This manifest path contains key-value mappings, where these key-value mappings are <a href="#BM_(label)%2Fi">label</a>s that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> needs before being considered for this <a href="#BM_(service)%2Fi">service</a>'s traffic ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span>
    <span class="hljs-attr">key2:</span> <span class="hljs-string">value2</span>
    <span class="hljs-attr">key3:</span> <span class="hljs-string">value3</span>
</code></pre>
<p>Internally, the <a href="#BM_(service)%2Fi">service</a> creates and manages an <a href="#BM_(endpoints)%2Fi">endpoints</a> object containing the IP and port for each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> captured by the selector. If no selectors are present, the <a href="#BM_(service)%2Fi">service</a> expects an <a href="#BM_(endpoints)%2Fi">endpoints</a> object with the same name to exist, where that <a href="#BM_(endpoints)%2Fi">endpoints</a> object contains the list of IP and port pairs that the <a href="#BM_(service)%2Fi">service</a> should route to.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">database</span>  <span class="hljs-comment"># must be same name as the service</span>
<span class="hljs-attr">subsets:</span> 
  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5432</span>
</code></pre>
<p>If no selectors are present but <code>spec.type</code> is set to <code>ExternalName</code>, the <a href="#BM_(service)%2Fi">service</a> will route to the host specified in <code>spec.externalName</code>. This is useful for situations where you want to hide the destination, such as an external API that you also want to mock for development / testing.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ExternalName</span>
  <span class="hljs-attr">externalName:</span> <span class="hljs-string">api.externalcompany.com</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">api-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5000</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If not set, <code>spec.type</code> defaults to <code>ClusterIP</code>. That's the type used when selectors are used to create an <a href="#BM_(endpoints)%2Fi">endpoints</a> / a custom <a href="#BM_(endpoints)%2Fi">endpoints</a> is used.</p>
</div>
<a name="H1_Ports"></a><h3>Ports</h3>
<p><a name="BM_(Resources%5C%2FServices%2FPorts)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FPorts)_TOPIC%2F">Resources/Pods/Ports</a></li>
<li><a href="#BM_(Resources%5C%2FServices%2FRouting)_TOPIC%2Fi">Resources/Services/Routing</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> can listen on multiple ports, controlled via the <code>spec.ports</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">api-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">1111</span>
    <span class="hljs-string">...</span>
</code></pre>
<ul>
<li><code>name</code> is a friendly name to identify the port (optional)</li>
<li><code>protocol</code> is either <code>TCP</code> or <code>UDP</code> (defaults to <code>TCP</code>).</li>
<li><code>port</code> is the port that the <a href="#BM_(service)%2Fi">service</a> listens on.</li>
<li><code>targetPort</code> is the port that requests are forwarded to on the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>  (defaults to value set for <code>port</code>).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not having a name makes it more difficult for <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to discover a <a href="#BM_(service)%2Fi">service</a>. Discussed further in the <a href="#BM_(service)%2Fi">service</a> discovery section.</p>
</div>
<p>The example above forwards requests on two ports. Requests on port ...</p>
<ul>
<li>80 of the <a href="#BM_(service)%2Fi">service</a> get forwarded to port 9376 of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> assigned to that <a href="#BM_(service)%2Fi">service</a>.</li>
<li>8080 of the <a href="#BM_(service)%2Fi">service</a> get forwarded to port 1111 of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> assigned to that <a href="#BM_(service)%2Fi">service</a>.</li>
</ul>
<p>Ports may also reference the names of ports in a <a href="#BM_(pod%20manifest)%2Fi">pod manifest</a>. For example, imagine the <a href="#BM_(pod%20manifest)%2Fi">pod manifest</a> for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> assigned to a <a href="#BM_(service)%2Fi">service</a> provides names for its ports.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my_pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-http-port</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-string">...</span>
</code></pre>
<p>In the <a href="#BM_(service)%2Fi">service</a> for that targets this <a href="#BM_(pod%20manifest)%2Fi">pod manifest</a>, you can use <code>my_http_port</code> as a <code>targetPort</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-string">my-http-port</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Does this work for manual <a href="#BM_(endpoints)%2Fi">endpoints</a> as well? When a selector isn't used with a <a href="#BM_(service)%2Fi">service</a>, it looks for an <a href="#BM_(endpoints)%2Fi">endpoints</a> object of the same name as the <a href="#BM_(service)%2Fi">service</a> to figure out where the <a href="#BM_(service)%2Fi">service</a> should route to. That <a href="#BM_(endpoints)%2Fi">endpoints</a> object can have names associated with its ports as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A <a href="#BM_(service)%2Fi">service</a> decides which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it routes to based key-value pairs in on <code>spec.selector</code>. What happens if the key-value pairs identify a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances where some of those instances don't have a port named <code>my-http-port</code>. For example, a <a href="#BM_(service)%2Fi">service</a> may be forwarding to two applications rather than a single application which just could be sharing the same set of key-value <a href="#BM_(label)%2Fi">label</a>s (<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances are heterogenous).</p>
<p>Maybe this isn't possible with <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>?</p>
</div>
<a name="H_Health"></a><h3>Health</h3>
<p><a name="BM_(Resources%5C%2FServices%2FHealth)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods%2FProbes)_TOPIC%2F">Resources/Pods/Probes</a></li>
<li><a href="#BM_(Resources%5C%2FServices%2FRouting)_TOPIC%2Fi">Resources/Services/Routing</a></li>
</ul>
</div>
<p>The <a href="#BM_(service)%2Fi">service</a> periodically probes the status of each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to determine if it can handle requests or not. Two types of probes are performed:</p>
<ul>
<li><a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s - When an existing instance of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails a user-defined test that checks if it's still running, the <a href="#BM_(service)%2Fi">service</a> stops routing traffic to it.</li>
<li><a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s - When a new instance of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> comes up, the <a href="#BM_(service)%2Fi">service</a> won't route traffic to it until it passes a user-defined test that says it's ready.</li>
</ul>
<p>These probes are defined directly in the <a href="#BM_(pod%20manifest)%2Fi">pod manifest</a>.</p>
<p><img src="svgbob_4db118f49983e7aa72c7b4a50af69abf5161819b.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that, when a <a href="#BM_(service)%2Fi">service</a> has selectors assigned, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> internally maintains an <a href="#BM_(endpoints)%2Fi">EndPoints</a> object that contains the addresses of ready and healthy <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. The addresses in this <a href="#BM_(endpoints)%2Fi">endpoints</a> object is what the <a href="#BM_(service)%2Fi">service</a> routes to.</p>
</div>
<a name="H_Headless"></a><h3>Headless</h3>
<p><a name="BM_(Resources%5C%2FServices%2FHeadless)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FServices%2FRouting)_TOPIC%2Fi">Resources/Services/Routing</a></li>
<li><a href="#BM_(Resources%5C%2FServices%2FHealth)_TOPIC%2Fi">Resources/Services/Health</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> that's headless is one which there is no load balancer forwarding requests to <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> / <a href="#BM_(endpoints)%2Fi">endpoints</a>. Instead, the domain for the <a href="#BM_(service)%2Fi">service</a> will resolve a list of ready IPs for the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (or <a href="#BM_(endpoints)%2Fi">endpoints</a>) that the <a href="#BM_(service)%2Fi">service</a> is for.</p>
<p>To create a headless <a href="#BM_(service)%2Fi">service</a>, set <code>spec.clusterIP</code> manifest path to <code>None</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span>
</code></pre>
<p>Generally, headless <a href="#BM_(service)%2Fi">service</a>s shouldn't be used because DNS queries are typically cached by the operating system. If the IPs that a <a href="#BM_(service)%2Fi">service</a> forwards to change, apps that have recently queried the <a href="#BM_(service)%2Fi">service</a>'s DNS will continue to use the old (cached) set of IPs until the operating system purges its DNS cache.</p>
<a name="H_Session%20Affinity"></a><h3>Session Affinity</h3>
<p><a name="BM_(Resources%5C%2FServices%2FSession%20Affinity)_TOPIC%2Fi"></a><strong></strong></p>
<p>How a <a href="#BM_(service)%2Fi">service</a> decides to forward incoming requests to the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances assigned to it is controlled via <code>spec.sessionAffinity</code> manifest path. Assigning a value of ...</p>
<ul>
<li><code>None</code> forwards each request to a randomly selected <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instance (default behaviour).</li>
<li><code>ClientIP</code> forwards each request originating from the same IP to the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instance.</li>
</ul>
<p>When using <code>ClientIP</code>, you may also provide a maximum session "sticky time" via the manifest path <code>spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>. By default, this value is set to 108300 (around 3 hours).</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">ClientIP</span>
  <span class="hljs-attr">sessionAffinityConfig:</span>
    <span class="hljs-attr">clientIP:</span>
      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">10000</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>When using <code>ClientIP</code>? What happens when the <a href="#BM_(service)%2Fi">service</a> runs out memory to track client IPs? LRU algorithm to decide which to keep / discard?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions that because <a href="#BM_(service)%2Fi">service</a>s work on the TCP/UDP level and not at HTTP/HTTPS level, forwarding requests by tracking session cookies isn't a thing.</p>
</div>
<a name="H_Exposure"></a><h3>Exposure</h3>
<p><a name="BM_(Resources%5C%2FServices%2FExposure)_TOPIC%2Fi"></a><strong></strong></p>
<p>The <a href="#BM_(service)%2Fi">service</a> type defines where and how a <a href="#BM_(service)%2Fi">service</a> gets exposed, controlled via the <code>spec.type</code> manifest path. For example, a <a href="#BM_(service)%2Fi">service</a> may only be accessible within the cluster, to specific parts of the cluster, to an external network, or to the public Internet.</p>
<p>If not specified, the <code>spec.type</code> of a <a href="#BM_(resource)%2Fi">resource</a> is <code>ClusterIP</code>, meaning that it's exposed only locally within the cluster.</p>
<a name="H_Local"></a><h4>Local</h4>
<p><a name="BM_(Resources%5C%2FServices%2FExposure%2FLocal)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FServices%2FRouting)_TOPIC%2Fi">Resources/Services/Routing</a></li>
</ul>
</div>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>ClusterIP</code> / <code>ExternalName</code> are only accessible from within the cluster. The hostname of such <a href="#BM_(service)%2Fi">service</a>s are broken down as follows: NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a>.svc.CLUSTER</p>
<ul>
<li><em>NAME</em> is the name of the <a href="#BM_(service)%2Fi">service</a>.</li>
<li><em><a href="#BM_(namespace)%2Fi">NAMESPACE</a></em> is the <a href="#BM_(namespace)%2Fi">namespace</a> the <a href="#BM_(service)%2Fi">service</a> is in (defaults to <code>default</code>).</li>
<li>svc is a constant that identifies the host is for a <a href="#BM_(service)%2Fi">service</a>.</li>
<li><em>CLUSTER</em> is the name of the cluster (defaults to <code>cluster.local.</code>).</li>
</ul>
<p>Depending on what level you're working in, a hostname may be shortened. For example, if the requestor and the <a href="#BM_(service)%2Fi">service</a> are within ...</p>
<ul>
<li>the same <a href="#BM_(namespace)%2Fi">namespace</a> and cluster, hostname NAME is sufficient.</li>
<li>the same cluster but not the same <a href="#BM_(namespace)%2Fi">namespace</a>, hostname NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a> is sufficient.</li>
<li>different clusters, the full hostname NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a>.svc.CLUSTER is required.</li>
</ul>
<p>The IP for a <code>ClusterIP</code> / <code>ExternalName</code> <a href="#BM_(service)%2Fi">service</a> is stable as well, just like the hostname.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Internally, a <code>ClusterIP</code> <a href="#BM_(service)%2Fi">service</a> uses <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">kube-proxy</a> to route requests to relevant <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (<a href="#BM_(endpoints)%2Fi">EndPoints</a>).</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>
</code></pre>
<a name="H_Node%20Port"></a><h4>Node Port</h4>
<p><a name="BM_(Resources%5C%2FServices%2FExposure%2FNode%20Port)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>NodePort</code> are accessible from outside the cluster. Every <a href="#BM_(worker%20node)%2Fi">worker node</a> opens a port (either user-defined or assigned by the system) that routes requests to the <a href="#BM_(service)%2Fi">service</a>. Since <a href="#BM_(node)%2Fi">node</a>s are transient, there is no single point of access to the <a href="#BM_(service)%2Fi">service</a>.</p>
<p>When <code>NodePort</code> is used as the type, the manifest path <code>spec.ports[].nodePort</code> defines the port on the <a href="#BM_(worker%20node)%2Fi">worker node</a> to open.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
</code></pre>
<a name="H_Load%20Balancer"></a><h4>Load Balancer</h4>
<p><a name="BM_(Resources%5C%2FServices%2FExposure%2FLoad%20Balancer)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>LoadBalancer</code> are accessible from outside the cluster. When the <code>LoadBalancer</code> type is used, the cloud provider running the cluster assigns their version of a load balancer to route external HTTP requests to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(ingress)%2Fi">Ingress</a> component. <a href="#BM_(ingress)%2Fi">Ingress</a> then determines what <a href="#BM_(service)%2Fi">service</a> that request should be routed to based on details within the HTTP parameters (e.g. Host).</p>
<p>There is no built-in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> implementation of <a href="#BM_(ingress)%2Fi">Ingress</a>. <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> provides the interface but someone must provide the implementation, called an <a href="#BM_(ingress)%2Fi">Ingress</a> controller, for the functionality to be there. The reason for this is that load balancers come in multiple forms: software load balancers, cloud provider load balancers, and hardware load balancers. When used directly, each has a unique way it needs to be configured, but the <a href="#BM_(ingress)%2Fi">Ingress</a> implementation abstracts that out.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
</code></pre>
<p>Once provisioned, the object will have the manifest path <code>status.loadBalancer.ingress.ip[]</code> added to it, which states the IP of the load balancer forwarding requests to this <a href="#BM_(service)%2Fi">service</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
<span class="hljs-attr">status:</span>
  <span class="hljs-attr">loadBalancer:</span>
    <span class="hljs-attr">ingress:</span>
      <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You can also use <code>kubectl</code> to get a list of <a href="#BM_(service)%2Fi">service</a>s and it'll also list out the public IP.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book says that a load balancer type is a special case of <a href="#BM_(node)%2Fi">node</a> port type.</p>
</div>
<a name="H_Ingress"></a><h2>Ingress</h2>
<p><a name="BM_(Resources%5C%2FIngress)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FServices)_TOPIC%2Fi">Resources/Services</a></li>
</ul>
</div>
<p>Similar to a <a href="#BM_(service)%2Fi">service</a> of type <code>LoadBalancer</code>, An <a href="#BM_(ingress)%2Fi">Ingress</a> object is a load balancer with a publicly exposed IP. However, rather than load balancing at the TCP/UDP level, an <a href="#BM_(ingress)%2Fi">Ingress</a> object acts as a load balancing HTTP proxy server. An HTTP request coming into an <a href="#BM_(ingress)%2Fi">Ingress</a> object gets routed to one of many existing <a href="#BM_(service)%2Fi">service</a>s based on host and path HTTP headers. This is useful because the cluster can expose several <a href="#BM_(service)%2Fi">service</a>s under a single public IP address.</p>
<p><img src="svgbob_c46d77a103ab5604a9b3449315c51ef9e97a8f5d.svg" alt="Kroki diagram output"></p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-ingress</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">stats.myhost.com</span>
    <span class="hljs-attr">http:</span>
      <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/graphana</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">graphana-service</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">api.myhost.com</span>
    <span class="hljs-attr">http:</span>
      <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/v2</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/v1</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v1</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>According to the book, most if not all implementations of <a href="#BM_(ingress)%2Fi">Ingress</a> simply query the <a href="#BM_(service)%2Fi">service</a> for its <a href="#BM_(endpoints)%2Fi">endpoints</a> and directly load balance across them vs forwarding the request through that <a href="#BM_(service)%2Fi">service</a>. Note that the port in the example above is still the port that the <em><a href="#BM_(service)%2Fi">service</a></em> is listening on, not the port of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is listening on.</p>
</div>
<a name="H_Hosts"></a><h3>Hosts</h3>
<p><a name="BM_(Resources%5C%2FIngress%2FHosts)_TOPIC%2Fi"></a><strong></strong></p>
<p>The host in each rule can be either an exact host or it could contain wildcards (e.g. <code>*.api.myhost.com</code>). Each name in the host (split by dot) intended for a wildcard should explicitly have an asterisk in its place. The portion the asterisk is in must exist and it only covers that name. For example, the rule below will match <code>ONE.api.myhost.com</code>, but not <code>TWO.THREE.api.myhost.com</code> or <code>api.myhost.com</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">"*.api.myhost.com"</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/v2</span>
      <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
      <span class="hljs-attr">backend:</span>
        <span class="hljs-attr">service:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
          <span class="hljs-attr">port:</span>
            <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<a name="H_Path%20Type"></a><h3>Path Type</h3>
<p>Each rule entry should have a path type associated with it. It can be set to any of the following values:</p>
<ul>
<li><code>Exact</code> - Matches the URL path exactly (case sensitive).</li>
<li><code>Prefix</code> - Matches the URL path prefix (case sensitive).</li>
<li><code>ImplementationSpecific</code> - Based on the class of the <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(resource)%2Fi">resource</a>.</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">api.myhost.com</span>
    <span class="hljs-attr">http:</span>
      <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/my/prefix/path</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<p>The most common path type is <code>Prefix</code>. A type of <code>Prefix</code> splits the path using <code>/</code> and matches the rule if the incoming request's path starts with the same path elements as the rule's path. Trailing slashes are ignored (e.g. <code>/p1/p2/p3/</code> and <code>/p1/p2/p3</code> are equivalent).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What about <code>ImplementationSpecific</code>? There are different types of <a href="#BM_(ingress)%2Fi">Ingress</a> controllers, each of which has its own configuration options. An <a href="#BM_(ingress)%2Fi">Ingress</a> class is something you can put into your <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(resource)%2Fi">resource</a> that contains "configuration including the name of the controller that should implement the class." It seems like an advanced topic and I don't know enough to write about it. Probably not something you have to pat attention to if you're doing basic cloud stuff.</p>
</div>
<a name="H_TLS%20Traffic"></a><h3>TLS Traffic</h3>
<p><a name="BM_(Resources%5C%2FIngress%2FTLS%20Traffic)_TOPIC%2Fi"></a><strong></strong></p>
<p><a name="BM_(Ingress%5C%2FTLS%20Traffic)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(resource)%2Fi">Resource</a>s/<a href="#BM_(Pods%5C%2FSecrets)_TOPIC%2F">Pods/Secrets</a></li>
</ul>
</div>
<p>Assuming you have a TLS certificate and key files for the host configured on the <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(resource)%2Fi">resource</a>, you can add those into <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> as a secret and configure the <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(resource)%2Fi">resource</a> to make use of it.</p>
<pre class="hljs"><code><span class="hljs-comment"># openssl genrsa -out tls.key 2048</span>
<span class="hljs-comment"># openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj /CN=api.myhost.com</span>
<span class="hljs-comment"># kubectl create secret tls my-api-tls --cert=tls.crt --key=tls.key</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-api-tls</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/tls</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">tls.crt:</span> <span class="hljs-string">base64</span> <span class="hljs-string">encoded</span> <span class="hljs-string">cert</span>
  <span class="hljs-attr">tls.key:</span> <span class="hljs-string">base64</span> <span class="hljs-string">encoded</span> <span class="hljs-string">key</span>
</code></pre>
<p>For each certificate secret intended to be used by the <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(resource)%2Fi">resource</a>, there should be an array entry under the <code>spec.tls[]</code> manifest path. The certificate secret name must be placed under <code>secretName</code> and the domain(s) supported by that certificate must be listed under <code>hosts</code>. Hosts must match hosts explicitly listed un the <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(resource)%2Fi">resource</a>'s rules.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">tls:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">api.myhost.com</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-api-tls</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">stats.myhost.com</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-stats-tls</span>
</code></pre>
<p>Once an encrypted request comes in to the <a href="#BM_(ingress)%2Fi">Ingress</a> controller, it's decrypted. That decrypted request then gets forwarded to the <a href="#BM_(service)%2Fi">service</a> it was intended for.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>From the k8s website:</p>
<blockquote>
<p>You need to make sure the TLS secret you created came from a certificate that contains a Common Name (CN), also known as a Fully Qualified Domain Name (FQDN) for https-example.foo.com.</p>
</blockquote>
<blockquote>
<p>Keep in mind that TLS will not work on the default rule because the certificates would have to be issued for all the possible sub-domains. Therefore, hosts in the tls section need to explicitly match the host in the rules section.</p>
</blockquote>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions that <code>CertificateSigningRequest</code> is a special type of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that will sign certificates for you, if it was set up. You can issue requests via <code>kubectl certificate approve csr_name</code> and it'll either automate it somehow or a human will process it? Not sure exactly what's going on here.</p>
</div>
<a name="H_Namespace"></a><h2>Namespace</h2>
<p><a name="BM_(Resources%5C%2FNamespace)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(namespace)%2Fi">namespace</a> is a <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> used to avoid <a href="#BM_(resource)%2Fi">resource</a> naming conflicts. For example, it's typical for a <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> cluster to be split up into development, testing, and production <a href="#BM_(namespace)%2Fi">namespace</a>s. Each <a href="#BM_(namespace)%2Fi">namespace</a> can have <a href="#BM_(resource)%2Fi">resource</a>s with the same names as those in the other two <a href="#BM_(namespace)%2Fi">namespace</a>s.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">production</span>
</code></pre>
<p><a href="#BM_(namespace)%2Fi">Namespace</a>s are cluster-level <a href="#BM_(resource)%2Fi">resource</a>s. This is contrary to most other <a href="#BM_(resource)%2Fi">resource</a> types in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>, which are <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(resource)%2Fi">resource</a>s, meaning that a <a href="#BM_(namespace)%2Fi">namespace</a> can be used to disambiguate <a href="#BM_(resource)%2Fi">resource</a>s of that type with the same name...</p>
<pre class="hljs"><code><span class="hljs-comment"># These are namespace-level resources</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">testing</span>  <span class="hljs-comment"># put into the testing namespace</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">my_image:v2_alpha5</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">production</span>  <span class="hljs-comment"># put into the production namespace</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">my_image:v1</span>
</code></pre>
<p>If a <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(resource)%2Fi">resource</a> doesn't set a <a href="#BM_(namespace)%2Fi">namespace</a>, the <a href="#BM_(namespace)%2Fi">namespace</a> defaults to <code>default</code>.</p>
<a name="H_Replica%20Sets"></a><h2>Replica Sets</h2>
<p><a name="BM_(Resources%5C%2FReplica%20Sets)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
</ul>
</div>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> is an abstraction that's used to ensure a certain number of copies of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are always up and running. Typical scenarios where <a href="#BM_(replica%20set)%2Fi">replica set</a>s are used include ...</p>
<ul>
<li>sharding (e.g. workers that pull <a href="#BM_(job)%2Fi">job</a> out of a queue for processing).</li>
<li>scale (e.g. micro<a href="#BM_(service)%2Fi">service</a>s that scale horizontally).</li>
<li>redundancy (e.g. leader-follower architectures such as Redis-style replica servers).</li>
</ul>
<p>Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-replicaset</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.1</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
</code></pre>
<a name="H_Replication"></a><h3>Replication</h3>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> determines how many replicas it needs via the <code>spec.replicas</code> manifest path, and it determines how to create missing replicas using the <code>spec.template</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.1</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
</code></pre>
<p>Recall that, to link objects together, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses loosely coupled linkages via <a href="#BM_(label)%2Fi">label</a>s rather than hierarchial parent-child relationships. As such, the <a href="#BM_(pod%20template)%2Fi">pod template</a> should have a unique set of <a href="#BM_(label)%2Fi">label</a>s assigned that the <a href="#BM_(replica%20set)%2Fi">replica set</a> can look for to determine how many instances are running. Regardless of how those instances were launched (via the <a href="#BM_(replica%20set)%2Fi">replica set</a> or something else), the <a href="#BM_(replica%20set)%2Fi">replica set</a> will account for them.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You can distinguish a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> created by a <a href="#BM_(replica%20set)%2Fi">replica set</a> vs one created manually by checking the <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> key <code>kubernetes.io/create-by</code> on the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p>If deleting a <a href="#BM_(replica%20set)%2Fi">replica set</a>, use <code>--cascade=false</code> in <a href="#BM_(kubectl)%2Fi">kubectl</a> if you don't want the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> created by the <a href="#BM_(replica%20set)%2Fi">replica set</a> to get deleted as well.</p>
</div>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> doesn't have to use the <a href="#BM_(label)%2Fi">label</a>s in the <a href="#BM_(pod%20template)%2Fi">pod template</a>. It can have its own set of <a href="#BM_(label)%2Fi">label</a>s that it looks for via the <code>spec.selector.matchLabels</code> manifest path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
</code></pre>
<a name="H_Deployments"></a><h2>Deployments</h2>
<p><a name="BM_(Resources%5C%2FDeployments)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FServices)_TOPIC%2Fi">Resources/Services</a></li>
<li><a href="#BM_(Resources%5C%2FReplica%20Sets)_TOPIC%2Fi">Resources/Replica Sets</a></li>
</ul>
</div>
<p>A <a href="#BM_(deployment)%2Fi">deployment</a> is an abstraction used to bring together <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, <a href="#BM_(replica%20set)%2Fi">replica set</a>s, and <a href="#BM_(service)%2Fi">service</a>s under a single umbrella. It's intended to represent a single version of some application being deployed on <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>. All of the pieces required for that application to run are housed under one roof.</p>
<p><a href="#BM_(deployment)%2Fi">Deployment</a>s make it easy to upgrade between versions of the applications they represent via a rolling upgrade that keeps the application online during the upgrade. Old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are transitioned to new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> as a stream instead of all at once, ensuring that the application is responsive throughout the upgrade process. Likewise, they allow for rolling back an update should it have any problems.</p>
<p>The manifest for a <a href="#BM_(deployment)%2Fi">deployment</a> builds of the manifest for a <a href="#BM_(replica%20set)%2Fi">replica set</a> (same fields used). Example manifest:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span> 
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">template:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.1</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my_container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">"gcr.io/my_container:v1"</span>
</code></pre>
<a name="H_Upgrade%20Strategy"></a><h3>Upgrade Strategy</h3>
<p>TODO: <code>spec/strategy</code> defines the way rollouts should occur.</p>
<p>TODO: discuss the recreate strategy + add yaml -- one-shot update, everything shuts down and restarts</p>
<p>TODO: discuss the rolling update strategy + add yaml --</p>
<p>maxUnavailable (num or percent of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that can be down during rollout) / maxSurge (num or percent of EXTRA <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that can be running during the rollout) -- so if you set unavail to 0% and surge to &gt;0% (it'll bring up x% new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> first then shut down x% old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, repeat until all updated), it'll rollout faster vs if you set unavail to &gt; 0% and surge to 0% (it'll shutdown x% old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> first then bring up x% new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, repeat until all updated)</p>
<p>for rolling, it'll always wait till the current iterations new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> probes report healthy + ready before moving to next iteration -- you should have defined these probes otherwise <a href="#BM_(deployment)%2Fi">deployment</a>s are blind</p>
<p>minReadySeconds -- waits at least n seconds till the <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a> reports okay before continuing -- an extra wait to make sure nothing's immediately crashing</p>
<p>progressDeadlineSeconds -- if any stage of the rollout waits for this long, the rollout is marked as failed. each time <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are brought down / up, it's a stage</p>
<a name="H_Undo"></a><h3>Undo</h3>
<p>TODO: discuss <a href="#BM_(kubectl)%2Fi">kubectl</a> rollout undo <a href="#BM_(deployment)%2Fi">deployment</a>s {<a href="#BM_(deployment)%2Fi">DEPLOYMENT</a>} command to roll back</p>
<p>TODO: set spec/revisionHistoryLimit to limit the number of revisions kept for undo -- useful when many frequent updates are happening</p>
<a name="H_Change%20Cause"></a><h3>Change Cause</h3>
<p>TODO: add <code>kubernetes.io/change-cause</code> <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> to add a custom message for the <a href="#BM_(deployment)%2Fi">deployment</a>, viewable when browing the history of the rollout</p>
<a name="H_Daemon%20Sets"></a><h2>Daemon Sets</h2>
<p><a name="BM_(Resources%5C%2FDaemon%20Sets)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FReplica%20Sets)_TOPIC%2Fi">Resources/Replica Sets</a></li>
<li><a href="#BM_(Resources%5C%2FDeployments)_TOPIC%2Fi">Resources/Deployments</a></li>
</ul>
</div>
<p>A <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is an abstraction that's used to ensure that a set of <a href="#BM_(node)%2Fi">node</a>s each have a copy of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> always up and running. Typical scenarios where a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is used include ...</p>
<ul>
<li><a href="#BM_(node)%2Fi">node</a> log collection (e.g. logstash agent).</li>
<li><a href="#BM_(node)%2Fi">node</a> monitoring (e.g. zabbix agent).</li>
</ul>
<p>The above scenarios are ones which break <a href="#BM_(container)%2Fi">container</a> / <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> isolation. That is, a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is intended to run <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that are coupled to <a href="#BM_(node)%2Fi">node</a>s and sometimes those <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will do things such as mount the <a href="#BM_(node)%2Fi">node</a>'s root filesystem and run commands to either install software or gather information.</p>
<p>Similar to how a <a href="#BM_(replica%20set)%2Fi">replica set</a> has a corresponding <a href="#BM_(deployment)%2Fi">deployment</a> that helps with upgrades, a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> has a <a href="#BM_(daemon%20set)%2Fi">daemon set</a>s object that helps manage its upgrades.</p>
<a name="H_Jobs"></a><h2>Jobs</h2>
<p><a name="BM_(Resources%5C%2FJobs)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Resources%5C%2FPods)_TOPIC%2Fi">Resources/Pods</a></li>
<li><a href="#BM_(Resources%5C%2FDeployments)_TOPIC%2Fi">Resources/Deployments</a></li>
</ul>
</div>
<p>A <a href="#BM_(job)%2Fi">job</a> is an abstraction that's used to run a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> performing a one-off task. Unlike a <a href="#BM_(deployment)%2Fi">deployment</a>, the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> running under a <a href="#BM_(job)%2Fi">job</a> don't need the same level of management (e.g. multiple replicas, upgrade strategies, etc..). Once a <a href="#BM_(job)%2Fi">job</a> completes, it's over.</p>
<p>Typical scenarios where a <a href="#BM_(job)%2Fi">job</a> is used include ...</p>
<ul>
<li>database migration</li>
<li>database compaction</li>
<li>log file removal</li>
</ul>
<p><a href="#BM_(job)%2Fi">Job</a>s can also be scheduled to run at specific intervals / times.</p>
<a name="H_Daemon%20Set"></a><h1>Daemon Set</h1>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-ds</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">nodeSelector:</span>
        <span class="hljs-attr">node_label_key1:</span> <span class="hljs-string">value1</span>
        <span class="hljs-attr">node_label_key1:</span> <span class="hljs-string">value2</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">my-app/my-app:v1</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span>
        <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span>
      <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span>
        <span class="hljs-attr">hostPath:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span>
</code></pre>
<p>TODO: spec/template/spec/<a href="#BM_(node)%2Fi">node</a>Selector defines the <a href="#BM_(node)%2Fi">node</a> <a href="#BM_(label)%2Fi">label</a>s to target</p>
<p>TODO: notice how volumes are using hostPath, which goes into the <a href="#BM_(node)%2Fi">node</a> directly</p>
<a name="H1_Daemon%20Sets"></a><h1>Daemon Sets</h1>
<p>TODO: this is the equivalent of <a href="#BM_(deployment)%2Fi">deployment</a> for <a href="#BM_(daemon%20set)%2Fi">daemon set</a>, it has rollingupdates just like a <a href="#BM_(deployment)%2Fi">deployment</a> does</p>
<a name="H_Job"></a><h1>Job</h1>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-job</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">5</span>
  <span class="hljs-attr">completions:</span> <span class="hljs-number">10</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-app</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/my-app:v1</span>
        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span>
        <span class="hljs-attr">args:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"--arg1"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"--arg2"</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>   <span class="hljs-comment"># restart pod if it didn't complete successfully, can also be Never</span>
</code></pre>
<p>TODO: for one-off tasks, defined using <a href="#BM_(pod%20template)%2Fi">pod template</a>s</p>
<p>TODO: parallelism defines how many of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> run at once, completion is how many need to complete</p>
<p>TODO: <a href="#BM_(kubectl)%2Fi">kubectl</a> is the easiest way to run <a href="#BM_(job)%2Fi">job</a>s? looks confusing see ch12. <a href="#BM_(job)%2Fi">job</a> needs to be explicitly deleted once it's finished</p>
<p>TODO: don't use <a href="#BM_(label)%2Fi">label</a>s, because people create lots of <a href="#BM_(job)%2Fi">job</a>s and if you start <a href="#BM_(label)%2Fi">label</a>ing <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and there's a naming conflict bad/unexpected things happen (ch12)</p>
<p>TODO: don't set restartPolicy to never, because what happens is that the internal component responsible for restarts won't restart it and as such the <a href="#BM_(job)%2Fi">job</a> will see it hasn't restarted and restart it itself. this causes a lot of junk in the cluster.</p>
<p>TODO: <a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s can be used to detect if the a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is dead in a <a href="#BM_(job)%2Fi">job</a> as well</p>
<p>TODO: use Cron<a href="#BM_(job)%2Fi">Job</a> type to have it be scheduled by time</p>
<a name="H_Autoscaling"></a><h1>Autoscaling</h1>
<a name="H_Horizontal%20Pod%20Autoscaling"></a><h2>Horizontal Pod Autoscaling</h2>
<p>TODO: TALK ABOUT HORIZONTAL AUTOSCALING + yaml</p>
<p>The number of replicas in a <a href="#BM_(replica%20set)%2Fi">replica set</a> can be automatically scaled up an down through <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>'s <a href="#BM_(horizontal%20pod%20autoscaling)%2Fi">horizontal pod autoscaling</a> component. Replicas are scaled based on some user-defined criteria (e.g. high cpu usage).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This feature depends on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> called heapster that tracks metrics. Most <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> installations include it by default.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book warns about setting replicas manual and setting replicas using <a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a> -- they fight with each other.</p>
</div>
<p>TODO: talk about vertical autoscaling + yaml -- it looks like this is in beta?</p>
<a name="H_Vertical%20Pod%20Autoscaling"></a><h2>Vertical Pod Autoscaling</h2>
<p>TODO: figure this out</p>
<a name="H_Cluster%20Autoscaler"></a><h2>Cluster Autoscaler</h2>
<p>TODO: it looks like this is an external component? if not enough <a href="#BM_(resource)%2Fi">resource</a>s to run a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, provision more <a href="#BM_(node)%2Fi">node</a>s from the cloud provider</p>
<a name="H_Kubectl%20Cheatsheet"></a><h1>Kubectl Cheatsheet</h1>
<p><a href="#BM_(kubectl)%2Fi">kubectl</a> commands are typically organized into <a href="#BM_(context)%2Fi">context</a>s, where each <a href="#BM_(context)%2Fi">context</a> is defines <a href="#BM_(context)%2Fi">context</a>ual information about the cluster: cluster location, cluster authentication, and default <a href="#BM_(namespace)%2Fi">namespace</a>. To ...</p>
<ul>
<li>set location, <code>kubectl config set-context {CTX} --cluster={VAL}</code></li>
<li>set user, <code>kubectl config set-context {CTX} --user={VAL}</code></li>
<li>set <a href="#BM_(namespace)%2Fi">namespace</a>, <code>kubectl config set-context {CTX} --namespace={VAL}</code></li>
<li>use a <a href="#BM_(context)%2Fi">context</a>, <code>kubectl config use-context {CTX}</code></li>
</ul>
<p><a href="#BM_(context)%2Fi">Context</a> information is usually stored in <code>$HOME/.kube/config</code>.</p>
<p><a href="#BM_(kubectl)%2Fi">kubectl</a> commands that target an object require a <a href="#BM_(namespace)%2Fi">namespace</a>. That <a href="#BM_(namespace)%2Fi">namespace</a> can either be supplied via ...</p>
<ul>
<li><code>--namespace={NS}</code> argument to target a specific <a href="#BM_(namespace)%2Fi">namespace</a>,</li>
<li><code>--all-namespaces</code> argument to target all <a href="#BM_(namespace)%2Fi">namespace</a>s,</li>
</ul>
<p>, ... or through the default <a href="#BM_(namespace)%2Fi">namespace</a> set for the current <a href="#BM_(context)%2Fi">context</a>. If not set explicitly in the <a href="#BM_(context)%2Fi">context</a>, the <a href="#BM_(namespace)%2Fi">namespace</a> will be <code>default</code>.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API is exposed as a RESTful interface, meaning everything is represented as an object and accessed / mutated using standard REST verbs (GET, PUT, DELETE, etc..). <a href="#BM_(kubectl)%2Fi">kubectl</a> uses this interface to access the cluster. For example, accessing https://cluster/api/v1/<a href="#BM_(namespace)%2Fi">namespace</a>s/default/<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>/obn_pod is equivalent to running <code>kubectl get pod obj_pod</code>. The difference between the two is that by default <a href="#BM_(kubectl)%2Fi">kubectl</a> formats the output in a human friendly manner, often omitting or shortening certain details. That output can be controlled using flags. Specifically, to ...</p>
<ul>
<li>get more detail, use <code>-o wide</code>.</li>
<li>remove headers such that the output can be more easily piped to other tools like <code>wc</code>, use <code>--no-headers</code>.</li>
<li>get JSON output <code>-o json</code></li>
<li>get YAML output <code>-o yaml</code></li>
<li>get JSON output isolated to a specific field or fields <code>-o jsonpath --template={TEMPLATE}</code>, where the template is a JSONPath expression.</li>
</ul>
<a name="H_CRUD"></a><h2>CRUD</h2>
<p><code>get</code> / <code>describe</code> allows you to get details on a specific objects and <a href="#BM_(resource)%2Fi">resource</a>s. To get an overview of a ...</p>
<ul>
<li>list of all objects of a specific <a href="#BM_(resource)%2Fi">resource</a> type using <code>kubectl get {RES}</code>.</li>
<li>a specific object of a specific <a href="#BM_(resource)%2Fi">resource</a> type using <code>kubectl get {RES} {OBJ}</code>.</li>
</ul>
<p><code>describe</code> provides more in-depth information vs <code>get</code>.</p>
<p>Examples of object access:</p>
<ul>
<li><code>kubectl get componentstatuses</code> - basic cluster diagnostics</li>
<li><code>kubectl get nodes</code> - list <a href="#BM_(node)%2Fi">node</a>s</li>
<li><code>kubectl get nodes --selector='class=high-mem'</code> - list <a href="#BM_(node)%2Fi">node</a>s that have <a href="#BM_(label)%2Fi">label</a> class set to high-mem (<a href="#BM_(label%20selector)%2Fi">label selector</a>)</li>
<li><code>kubectl get nodes --selector='class=high-mem,!gpu'</code> - list <a href="#BM_(node)%2Fi">node</a>s that have <a href="#BM_(label)%2Fi">label</a> class set to high-mem but <a href="#BM_(label)%2Fi">label</a> gpu unset (<a href="#BM_(label%20selector)%2Fi">label selector</a>)</li>
<li><code>kubectl describe nodes {NAME}</code> - <a href="#BM_(node)%2Fi">node</a> information</li>
<li><code>kubectl get daemonSets --namespace={NAMESPACE} {NAME}</code></li>
<li><code>kubectl get deployments --namespace={NAMESPACE} {NAME}</code></li>
<li><code>kubectl get services --namespace={NAMESPACE} {NAME}</code></li>
</ul>
<p>Add <code>--watch</code> flag to have <a href="#BM_(kubectl)%2Fi">kubectl</a> continually provide updates.</p>
<p><code>apply</code> allows you to create and update objects. To create or update using ...</p>
<ul>
<li>a YAML file, <code>kubectl apply -f obj.yaml</code>.</li>
<li>a JSON file, <code>kubectl apply -f obj.json</code>.</li>
<li>STDIN, <code>kubectl apply -f -</code>.</li>
</ul>
<p>It will not allow you to delete objects.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Is this true? See <code>kubectl apply</code> with prune flag.</p>
</div>
<p><code>edit</code> is shorthand for <code>get</code> and <code>apply</code> in that it'll open the YAML in an editor and allow you to make changes directly.</p>
<ul>
<li><code>kubectl edit deployment {NAME}</code></li>
<li><code>kubectl edit service {NAME}</code></li>
</ul>
<p><code>delete</code> allows you to delete an object. To delete using ...</p>
<ul>
<li>a YAML file, <code>kubectl delete -f obj.yaml</code>.</li>
<li>a JSON file, <code>kubectl delete -f obj.json</code>.</li>
<li>STDIN, <code>kubectl apply -f -</code>.</li>
<li>command line, <code>kubectl delete {RES} {OBJ}</code></li>
</ul>
<p>In certain cases, the object being deleted has parental links to other objects. For example, a <a href="#BM_(replica%20set)%2Fi">replica set</a> is the parent of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it creates and watches. If you delete these parent objects, by default their children go with it unless the <code>--cascade=false</code> flag is used.</p>
<p><code>label</code> / <code>annotate</code> allows you to <a href="#BM_(label)%2Fi">label</a> / <a href="#BM_(annotation%7Cannotate)%2Fi">annotate</a> an object.</p>
<ul>
<li><code>kubectl label pods {POD} mark=55a</code> - set <a href="#BM_(label)%2Fi">label</a> mark to value 55a on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (no overwrite).</li>
<li><code>kubectl label --overwrite pods {POD} mark=77a</code> - overwrite <a href="#BM_(label)%2Fi">label</a> mark to value 77a on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl label --overwrite pods {POD} mark=77a,end=fff</code> - overwrite <a href="#BM_(label)%2Fi">label</a> mark to value 77a and end to value fff on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl label pods {POD} mark-</code> - remove <a href="#BM_(label)%2Fi">label</a> mark from a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p>When referencing objects, the ...</p>
<ul>
<li><code>--selector</code> flag can be fed in a <a href="#BM_(label%20selector)%2Fi">label selector</a> that filters those objects.</li>
<li><code>--all</code> flag can target everything.</li>
</ul>
<a name="H_Deployment"></a><h2>Deployment</h2>
<p><code>rollout</code> allows you to monitor and control <a href="#BM_(deployment)%2Fi">deployment</a> rollouts.</p>
<ul>
<li><code>kubectl rollout status deployments {DEPLOYMENT}</code> - monitor rollout</li>
<li><code>kubectl rollout pause deployments {DEPLOYMENT}</code> - pause rollout</li>
<li><code>kubectl rollout resume deployments {DEPLOYMENT}</code> - resume rollout</li>
<li><code>kubectl rollout history deployments {DEPLOYMENT}</code> - view rollout history</li>
<li><code>kubectl rollout undo deployments {DEPLOYMENT}</code> - undo rollout (works regardless state -- e.g. if a rollout is currently in progress or not)</li>
<li><code>kubectl rollout undo deployments {DEPLOYMENT} --to-revision={REV}</code> - undo rollout to a previous revision (see rollout history command)</li>
</ul>
<p><code>configmap</code> allows you to create a configuration for applications running in <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<ul>
<li><code>kubectl create configmap {CONFIGMAP} --from-file=my-config.txt --from-literal=key1=value1 --from-literal=key2=value2</code></li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The option <code>--from-file</code> can also point to a directory, in which case an entry will get created for each file in the directory provided that the filenames don't have any disallowed characters.</p>
</div>
<p><code>secret</code> allows you to create a security related configuration for applications running in <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<ul>
<li><code>kubectl create secret generic my-tls-cert --from-file=a.crt --from-file=a.key</code></li>
</ul>
<a name="H_Proxy"></a><h2>Proxy</h2>
<p><code>proxy</code> allows you to launch a proxy that lets you talk internally with the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server.</p>
<ul>
<li><code>kubectl proxy</code></li>
</ul>
<a name="H_Debug"></a><h2>Debug</h2>
<p><code>logs</code> allows you to view outputs of a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubectl logs {POD}</code> - get logs for a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl logs {POD} -c {CONTAINER}</code> - get logs for a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl logs {POD} -c {CONTAINER} -f</code> - tail logs for a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p><code>exec</code> allows you to run a command on a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubectl exec -it {POD} -- ps uax</code> - execute ps on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl exec -it {POD} -- bash</code> - execute bash on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and interact with it.</li>
<li><code>kubectl exec -it {POD} -c {CONTAINER} -- bash</code> - execute bash on a <a href="#BM_(container)%2Fi">container</a> within <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and interact with it.</li>
</ul>
<p><code>attach</code> allows you to attach to a <a href="#BM_(container)%2Fi">container</a>'s main running process.</p>
<ul>
<li><code>kubectl attach -it {POD}</code> - attach to main process on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl attach -it {POD} -c {CONTAINER}</code> - attach to main process on a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>attach</code> is similar to <code>logs</code> with the tailing flag but also allows you pipe into stdin.</p>
</div>
<p><code>cp</code> allows you to copy files between your machine and a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubetctl cp {POD}:{POD_PATH} {LOCAL_PATH}</code> - copy from single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to local path.</li>
<li><code>kubetctl cp {LOCAL_PATH} {POD}:{POD_PATH}</code> - copy from local path to a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubetctl cp {POD}:{POD_PATH} {LOCAL_PATH} -c {CONTAINER}</code> - copy from a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to local path.</li>
</ul>
<p><code>port-forward</code> allows you to connect to a open port on a <a href="#BM_(container)%2Fi">container</a> or connect to a <a href="#BM_(service)%2Fi">service</a>.</p>
<ul>
<li><code>kubectl port-forward {POD} 8080:80</code> - forward port 8080 locally to port 80 on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl port-forward {POD} 8080:80 -c {CONTAINER}</code> - forward port 8080 locally to port 80 on a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl port-forward services/{SERVICE} 8080:80</code> - forward port 8080 locally to port 80 for some <a href="#BM_(service)%2Fi">service</a>.</li>
</ul>
<p><code>top</code> allows you to see cluster usage.</p>
<ul>
<li><code>kubectl top nodes</code> - view <a href="#BM_(node)%2Fi">node</a> <a href="#BM_(resource)%2Fi">resource</a> usages.</li>
<li><code>kubectl top pods</code> - view <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(resource)%2Fi">resource</a> usages.</li>
</ul>
<a name="H_Amazon"></a><h1>Amazon</h1>
<p>The managed <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(service)%2Fi">service</a> on Amazon Web <a href="#BM_(service)%2Fi">Service</a>s (AWS) is called Elastic <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(service)%2Fi">Service</a> (EKS). The quickest way to get an EKS instance running on AWS is to use the third-party <code>eksctl</code> tool, which uses AWS's CloudFormation <a href="#BM_(service)%2Fi">service</a> to set up all required networking, VMs, roles, etc.. to get EKS up and running. Assuming you're working in AWS region <code>us-east-2</code> and you want your cluster to be called <code>my-cluster</code>, the command to create a new cluster is ...</p>
<pre><code>eksctl create cluster --name my-cluster --region us-east-2 --fargate

eksctl create cluster --name my-cluster --region us-east-2 --fargate



</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Original guide can be found <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-ug.pdf#getting-started-eksctl">here</a></p>
</div>
<p>https://aws-controllers-k8s.github.io/community/docs/tutorials/rds-example/</p>
<a name="H_Security%20Tips"></a><h1>Security Tips</h1>
<p>SEE section 7.5.2 -- disable implicit binding of k8s api tokens into the system if you don't need to access k8s api (automount<a href="#BM_(service)%2Fi">Service</a>-AccountToken)</p>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(resource)%2Fi"></a><strong>resource</strong> - A class of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> object (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, <a href="#BM_(replica%20set)%2Fi">replica set</a>, <a href="#BM_(deployment)%2Fi">deployment</a>, etc..).</p>
</li>
<li>
<p><a name="BM_(image)%2Fi"></a><strong>image</strong> - An application (or set of applications) packaged with all of its dependencies as an immutable and isolated filesystem. The filesystem typically contains all dependencies required for the application(s) run sealed at their correct version.</p>
<p><a href="#BM_(image)%2Fi">Image</a>s also typically include metadata describing its needs and operational standards (e.g. memory requirements).</p>
</li>
<li>
<p><a name="BM_(container)%2Fi"></a><strong>container</strong> - An instance of an <a href="#BM_(image)%2Fi">image</a>. A <a href="#BM_(container)%2Fi">container</a> creates an isolated copy of the <a href="#BM_(image)%2Fi">image</a>'s filesystem, isolates the <a href="#BM_(resource)%2Fi">resource</a>s required for that <a href="#BM_(image)%2Fi">image</a>, and launches the entrypoint application for that <a href="#BM_(image)%2Fi">image</a>. That <a href="#BM_(container)%2Fi">container</a> can't see or access anything outside of the <a href="#BM_(container)%2Fi">container</a> unless explicitly allowed to by the user. For example, opening a port 8080 on a <a href="#BM_(container)%2Fi">container</a> won't open port 8080 on the host running it, but the user can explicitly ask that port 8080 in the <a href="#BM_(container)%2Fi">container</a> map to some port on the host.</p>
</li>
<li>
<p><a name="BM_(registry)%2Fi"></a><strong>registry</strong> - A <a href="#BM_(service)%2Fi">service</a> for storing and retrieving <a href="#BM_(image)%2Fi">image</a>s.</p>
</li>
<li>
<p><a name="BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi"></a><strong>multistage image</strong> - A <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a> produced by merging portions of other <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>s together. For example, to build a <a href="#BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi">multistage image</a> that contains Java as well as compiled C++ binaries, ...</p>
<ol>
<li>an <a href="#BM_(image)%2Fi">image</a> containing the JVM has its Java directory pulled out.</li>
<li>an <a href="#BM_(image)%2Fi">image</a> containing the GNU Compiler toolchain compiles some C++ code, then those compiled binaries are pulled out.</li>
</ol>
<p>The end result is that the <a href="#BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi">multistage build</a> only contains the relevant portions of its "stages" (previous <a href="#BM_(image)%2Fi">image</a>s), leading to a more focused <a href="#BM_(image)%2Fi">image</a> with smaller size.</p>
</li>
<li>
<p><a name="BM_(Open%20Container%20Initiative%20runtime%7COpen%20Container%20Initiative)%2Fi"></a><strong>open container initiative runtime</strong>  <a name="BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F"></a><strong></strong>- A runtime responsible for only creating and launching <a href="#BM_(container)%2Fi">container</a>s. Examples include runC, rkt, runV, gviso, etc.. Some of these use Linux isolation technology (cgroups and <a href="#BM_(namespace)%2Fi">namespace</a>s) while others use virtualization technology.</p>
</li>
<li>
<p><a name="BM_(container%20runtime%20interface)%2Fi"></a><strong>container runtime interface</strong> <a name="BM_%5Cb(CRI)s%3F%5Cb%2F"></a><strong></strong> - A runtime responsible for the high-level management of <a href="#BM_(container)%2Fi">container</a>s and <a href="#BM_(image)%2Fi">image</a>s: <a href="#BM_(image)%2Fi">image</a> management, <a href="#BM_(image)%2Fi">image</a> distribution, <a href="#BM_(container)%2Fi">container</a> mounts / storage, <a href="#BM_(container)%2Fi">container</a> networking, etc..</p>
<p><a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s are also responsible for running <a href="#BM_(container)%2Fi">container</a>s, but typically do so by delegating to an <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>. Examples of <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s include <a href="#BM_(container)%2Fi">container</a>d, and cri-o.</p>
</li>
<li>
<p><a name="BM_(container%20engine)%2Fi"></a><strong>container engine</strong> - A high-level application / cohesive set of applications used for all the things <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>s and <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s are used for as well as building <a href="#BM_(image)%2Fi">image</a>s, signing <a href="#BM_(image)%2Fi">image</a>s, and several other extra features. <a href="#BM_(container%20engine)%2Fi">Container engine</a>s typically delegate to <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>s and <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s for most of their functionality.</p>
<p>Examples include Docker Engine and <a href="#BM_(container)%2Fi">Container</a> Tools (podman for running <a href="#BM_(container)%2Fi">container</a>s, buildah for building <a href="#BM_(image)%2Fi">image</a>s, and skopeo for <a href="#BM_(image)%2Fi">image</a> distribution).</p>
</li>
<li>
<p><a name="BM_(Kubernetes)%2Fi"></a><strong>Kubernetes</strong> - A tool for orchestrating multiple <a href="#BM_(container)%2Fi">container</a>s across a set machines. Provides features such as load balancing, <a href="#BM_(service)%2Fi">service</a> naming, <a href="#BM_(service)%2Fi">service</a> discovery, automated <a href="#BM_(service)%2Fi">service</a> scaling, and automated <a href="#BM_(service)%2Fi">service</a> recovery.</p>
</li>
<li>
<p><a name="BM_(node)%2Fi"></a><strong>node</strong> - A host that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses to run the <a href="#BM_(container)%2Fi">container</a>s its orchestrating.</p>
</li>
<li>
<p><a name="BM_(master%20node)%2Fi"></a><strong>master node</strong> - A <a href="#BM_(node)%2Fi">node</a> responsible for the managing the cluster (scheduling, API server, etc..).</p>
</li>
<li>
<p><a name="BM_(worker%20node)%2Fi"></a><strong>worker node</strong> - A <a href="#BM_(node)%2Fi">node</a> responsible for running application <a href="#BM_(container)%2Fi">container</a>s.</p>
</li>
<li>
<p><a name="BM_%5Cb(pod)s%3F%5Cb%2Fi"></a><strong>pod</strong> - A set of <a href="#BM_(container)%2Fi">container</a>s all bundled together as a single unit, where all <a href="#BM_(container)%2Fi">container</a>s in that bundle are intended to run on the same <a href="#BM_(node)%2Fi">node</a>.</p>
</li>
<li>
<p><a name="BM_(pod%20template)%2Fi"></a><strong>pod template</strong> - The blueprint for creating <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(namespace)%2Fi"></a><strong>namespace</strong> - A user-defined category for objects in a cluster (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>), allowing <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> do things such as apply isolation and access control. By default, the <a href="#BM_(kubectl)%2Fi">kubectl</a> command uses the <a href="#BM_(namespace)%2Fi">namespace</a> <code>default</code> if no <a href="#BM_(namespace)%2Fi">namespace</a> is specified.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book tells you to think of it like it's a folder.</p>
</div>
</li>
<li>
<p><a name="BM_(kube-system)%2Fi"></a><strong>kube-system</strong> - A <a href="#BM_(namespace)%2Fi">namespace</a> for internal cluster components (<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>) that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs for itself. For example, <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">Kubernetes's DNS</a> <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">Kubernetes's proxy</a> <a href="#BM_(service)%2Fi">service</a>, etc.. all run under the <a href="#BM_(kube-system)%2Fi">kube-system</a> <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
</li>
<li>
<p><a name="BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi"></a><strong>kube-proxy</strong> - An internal <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">Kubernetes proxy</a> <a href="#BM_(service)%2Fi">service</a> responsible for routing traffic to the correct <a href="#BM_(service)%2Fi">service</a>s and load balancing between a <a href="#BM_(service)%2Fi">service</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. Runs on every <a href="#BM_(node)%2Fi">node</a> in the cluster.</p>
</li>
<li>
<p><a name="BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi"></a><strong>core-dns</strong> - An internal <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">Kubernetes DNS</a> <a href="#BM_(service)%2Fi">service</a> responsible for naming and discovery of the <a href="#BM_(service)%2Fi">service</a>s running on the cluster. Older versions of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> call this <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">kube-dns</a> instead of <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">core-dns</a>.</p>
</li>
<li>
<p><a name="BM_(kubernetes-dashboard%7CKubernetes%20Dashboard%7CKubernetes%20UI%7CKubernetes%20GUI%7CKubernetes's%20Dashboard%7CKubernetes's%20UI%7CKubernetes's%20GUI)%2Fi"></a><strong>kubernetes-dashboard</strong> - An internal <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(service)%2Fi">service</a> responsible for providing a GUI to interface with and explore the cluster.</p>
</li>
<li>
<p><a name="BM_(kubectl)%2Fi"></a><strong>kubectl</strong> - The standard command-line client for <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>.</p>
</li>
<li>
<p><a name="BM_(context)%2Fi"></a><strong>context</strong> - In reference to <a href="#BM_(kubectl)%2Fi">kubectl</a>, <a href="#BM_(context)%2Fi">context</a> refers to default cluster access settings <a href="#BM_(kubectl)%2Fi">kubectl</a> applies when running some command: cluster location, cluster authentication, and default <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
</li>
<li>
<p><a name="BM_(label)%2Fi"></a><strong>label</strong> - User-defined key-value pairs assigned to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects to group those objects together. <a href="#BM_(label)%2Fi">Label</a>ing objects makes it so they can be accessed as a set (e.g. target all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with authoring team set to SRE). Unlike <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s, <a href="#BM_(label)%2Fi">label</a>s aren't for assigning metadata to objects.</p>
</li>
<li>
<p><a name="BM_(label%20selector)%2Fi"></a><strong>label selector</strong> - An expression language used to find objects with <a href="#BM_(label)%2Fi">label</a>s. For example...</p>
<ul>
<li><code>key=value</code></li>
<li><code>key!=value</code></li>
<li><code>key in (value1, value2)</code></li>
</ul>
</li>
<li>
<p><a name="BM_(annotation%7Cannotate)%2Fi"></a><strong>annotation</strong> - User-defined key-value pairs assigned to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> objects that acts as metadata for other tools and libraries. Unlike <a href="#BM_(label)%2Fi">label</a>s, <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s aren't for grouping objects together.</p>
</li>
<li>
<p><a name="BM_(declarative%20configuration)%2Fi"></a><strong>declarative configuration</strong> - A form of configuring where the configuration is submitted as a state and the system adjusts itself to match that state.</p>
</li>
<li>
<p><a name="BM_(imperative%20configuration)%2Fi"></a><strong>imperative configuration</strong> - A form of configuring where the configuration is submitted as a set of instructions and the system runs those instructions.</p>
</li>
<li>
<p><a name="BM_(pod%20manifest)%2Fi"></a><strong>pod manifest</strong> - A <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, listing out things like <a href="#BM_(image)%2Fi">image</a>s required and <a href="#BM_(resource)%2Fi">resource</a> mappings (e.g. ports). This is effectively a blueprint for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, similar to how an <a href="#BM_(image)%2Fi">image</a> is a blueprint for a <a href="#BM_(container)%2Fi">container</a>.</p>
</li>
<li>
<p><a name="BM_(health%20check)%2Fi"></a><strong>health check</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> mechanism that checks the state of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and performs corrective action if it deems necessary. This includes both ensuring that the main <a href="#BM_(container)%2Fi">container</a> process is running, <a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s, and <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s.</p>
</li>
<li>
<p><a name="BM_(liveness%20probe)%2Fi"></a><strong>liveness probe</strong> - A user-defined task that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs to ensure that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is running correctly. For example, an HTTP server that stalls when for more than 15 seconds before returning a response may be deemed as no longer live.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> restarts a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> if it deems it as no longer alive.</p>
</li>
<li>
<p><a name="BM_(readiness%20probe)%2Fi"></a><strong>readiness probe</strong> - A user-defined task that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs to ensure that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is in a position to accept requests. For example, an HTTP server that has all of its worker threads busy processing requests may be deemed as not ready.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> stops routing requests to a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> if its no longer ready (removed from load balancer).</p>
</li>
<li>
<p><a name="BM_(utilization)%2Fi"></a><strong>utilization</strong> - A metric that tracks the amount of <a href="#BM_(resource)%2Fi">resource</a>s in use vs the amount of <a href="#BM_(resource)%2Fi">resource</a>s available.</p>
</li>
<li>
<p><a name="BM_(resource%20request)%2Fi"></a><strong>resource request</strong> - The minimum amount of <a href="#BM_(resource)%2Fi">resource</a>s required to run an <a href="#BM_(image)%2Fi">image</a> (not a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>).</p>
</li>
<li>
<p><a name="BM_(resource%20limit)%2Fi"></a><strong>resource limit</strong> - The maximum amount of <a href="#BM_(resource)%2Fi">resource</a>s that an <a href="#BM_(image)%2Fi">image</a> (not a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>) may take up.</p>
<p>If <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> needs to scale down a <a href="#BM_(resource)%2Fi">resource</a> for a <a href="#BM_(container)%2Fi">container</a> that isn't dynamic (e.g. a running process can have its CPU usage reduced but you can't force a running process to give up memory its holding on to), the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> gets restarted with that <a href="#BM_(resource)%2Fi">resource</a> scaled down.</p>
</li>
<li>
<p><a name="BM_(service)%2Fi"></a><strong>service</strong> - A set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> exposed under a single named network <a href="#BM_(service)%2Fi">service</a>. Requests coming in to the <a href="#BM_(service)%2Fi">service</a> and are load balanced across the set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(endpoints)%2Fi"></a><strong>endpoints</strong> - A low-level object that's used by <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to map a <a href="#BM_(service)%2Fi">service</a> to the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> it routes to. In other words, an <a href="#BM_(endpoints)%2Fi">endpoints</a> (note the plural) object is an abstraction that references a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(ingress)%2Fi"></a><strong>ingress</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that acts as an HTTP-based frontend that routes and load balances incoming external requests to the correct <a href="#BM_(service)%2Fi">service</a>. This <a href="#BM_(resource)%2Fi">resource</a> is an interface without an implementation, meaning that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> doesn't have anything built-in to handle <a href="#BM_(ingress)%2Fi">ingress</a>. Implementations of this interfaces are referred to as <a href="#BM_(ingress)%2Fi">Ingress</a> controllers and are provided by third-parties.</p>
</li>
<li>
<p><a name="BM_(replica%20set)%2Fi"></a><strong>replica set</strong> <a name="BM_(ReplicaSet)%2F"></a><strong></strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that ensures a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> has a certain number of instances running at any time.</p>
</li>
<li>
<p><a name="BM_(reconciliation%20loop)%2Fi"></a><strong>reconciliation loop</strong> - A loop that continually observes state and attempts to reconcile it to some desired state if it deviates. See <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a>.</p>
</li>
<li>
<p><a name="BM_(horizontal%20pod%20autoscaling)%2Fi"></a><strong>horizontal pod autoscaling</strong> <a name="BM_%5Cb(HPA)%5Cb%2F"></a><strong></strong> - A feature that automatically scales the number of replicas in a <a href="#BM_(replica%20set)%2Fi">replica set</a>s based on user-defined criteria.</p>
</li>
<li>
<p><a name="BM_(vertical%20pod%20autoscaling)%2Fi"></a><strong>vertical pod autoscaling</strong> <a name="BM_%5Cb(VPA)%5Cb%2F"></a><strong></strong> - A feature that automatically scales up the <a href="#BM_(resource)%2Fi">resource</a> requirements for some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> based on user-defined criteria.</p>
</li>
<li>
<p><a name="BM_(cluster%20autoscaler)%2Fi"></a><strong>cluster autoscaler</strong> - A component that automatically scales the number of <a href="#BM_(node)%2Fi">node</a>s in a cluster based on need.</p>
</li>
<li>
<p><a name="BM_(deployment)%2Fi"></a><strong>deployment</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that is similar to a <a href="#BM_(replica%20set)%2Fi">replica set</a> but provides extra functionality for gracefully updating <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to a new version and rolling them back to previous versions.</p>
</li>
<li>
<p><a name="BM_(daemon%20set)%2Fi"></a><strong>daemon set</strong> <a name="BM_(DaemonSet)%2F"></a><strong></strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that ensures a set of <a href="#BM_(node)%2Fi">node</a>s always have an instance of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> running.</p>
</li>
<li>
<p><a name="BM_(job)%2Fi"></a><strong>job</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that launches as a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to perform some one-of task.</p>
</li>
<li>
<p><a name="BM_(ConfigMap)%2Fi"></a><strong>ConfigMap</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> for configuring the applications running in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(millicpu%7Cmillicore)%2Fi"></a><strong>millicpu</strong> - A <a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a> is 0.001 CPU cores (e.g. 1000 <a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a> = 1 core).</p>
</li>
<li>
<p><a name="BM_(persistent%20volume)%2Fi"></a><strong>persistent volume</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that represents non-ephemeral disk space.</p>
</li>
<li>
<p><a name="BM_(persistent%20volume%20claim)%2Fi"></a><strong>persistent volume claim</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(resource)%2Fi">resource</a> that claims a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>, essentially acting as a marker that the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is claimed and ready to use by <a href="#BM_(container)%2Fi">container</a>s within the cluster.</p>
</li>
</ul>
<p></p>
<p></p>

        </body></html>