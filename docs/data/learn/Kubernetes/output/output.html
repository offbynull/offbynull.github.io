<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>Kubernetes</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><p></p>
<div class="toc">
<ul>
<li><a href="#H_Introduction">Introduction</a></li>
<ul>
<li><a href="#H_Containers">Containers</a></li>
<li><a href="#H_Objects">Objects</a></li>
<li><a href="#H_Labels">Labels</a></li>
<li><a href="#H_Configuration">Configuration</a></li>
</ul>
<li><a href="#H_Kinds">Kinds</a></li>
<ul>
<li><a href="#H_Pod">Pod</a></li>
<ul>
<li><a href="#H_Images">Images</a></li>
<ul>
<li><a href="#H_Pull%20Policy">Pull Policy</a></li>
<li><a href="#H_Private%20Container%20Registries">Private Container Registries</a></li>
</ul>
<li><a href="#H_Resources">Resources</a></li>
<li><a href="#H_Ports">Ports</a></li>
<li><a href="#H_Command-line%20Arguments">Command-line Arguments</a></li>
<li><a href="#H_Environment%20Variables">Environment Variables</a></li>
<li><a href="#H1_Configuration">Configuration</a></li>
<li><a href="#H_Volume%20Mounts">Volume Mounts</a></li>
<li><a href="#H_Probes">Probes</a></li>
<li><a href="#H_Restart%20Policy">Restart Policy</a></li>
<li><a href="#H_Service%20Discovery">Service Discovery</a></li>
<ul>
<li><a href="#H1_Environment%20Variables">Environment Variables</a></li>
<li><a href="#H_DNS">DNS</a></li>
</ul>
<li><a href="#H_Metadata">Metadata</a></li>
<ul>
<li><a href="#H2_Environment%20Variables">Environment Variables</a></li>
<li><a href="#H_Volume%20Mount">Volume Mount</a></li>
</ul>
<li><a href="#H_API%20Access">API Access</a></li>
</ul>
<li><a href="#H_Configuration%20Map">Configuration Map</a></li>
<li><a href="#H_Secret">Secret</a></li>
<li><a href="#H_Node">Node</a></li>
<li><a href="#H_Volume">Volume</a></li>
<ul>
<li><a href="#H_Capacity">Capacity</a></li>
<li><a href="#H_Access%20Modes">Access Modes</a></li>
<li><a href="#H_Reclaim%20Policy">Reclaim Policy</a></li>
<li><a href="#H_Types">Types</a></li>
<li><a href="#H_Storage%20Classes">Storage Classes</a></li>
</ul>
<li><a href="#H_Endpoints">Endpoints</a></li>
<li><a href="#H_Service">Service</a></li>
<ul>
<li><a href="#H_Routing">Routing</a></li>
<li><a href="#H1_Ports">Ports</a></li>
<li><a href="#H_Health">Health</a></li>
<li><a href="#H_Headless">Headless</a></li>
<li><a href="#H_Session%20Affinity">Session Affinity</a></li>
<li><a href="#H_Exposure">Exposure</a></li>
<ul>
<li><a href="#H_Local">Local</a></li>
<li><a href="#H_Node%20Port">Node Port</a></li>
<li><a href="#H_Load%20Balancer">Load Balancer</a></li>
</ul>
</ul>
<li><a href="#H_Ingress">Ingress</a></li>
<ul>
<li><a href="#H_Hosts">Hosts</a></li>
<li><a href="#H_Path%20Type">Path Type</a></li>
<li><a href="#H_TLS%20Traffic">TLS Traffic</a></li>
</ul>
<li><a href="#H_Namespace">Namespace</a></li>
<li><a href="#H_Replica%20Set">Replica Set</a></li>
<li><a href="#H_Deployment">Deployment</a></li>
<ul>
<li><a href="#H_Updates">Updates</a></li>
<li><a href="#H_Rollbacks">Rollbacks</a></li>
</ul>
<li><a href="#H_Stateful%20Set">Stateful Set</a></li>
<ul>
<li><a href="#H_Scaling">Scaling</a></li>
<li><a href="#H1_Updates">Updates</a></li>
<li><a href="#H_Peer%20Discovery">Peer Discovery</a></li>
</ul>
<li><a href="#H_Job">Job</a></li>
<ul>
<li><a href="#H_Cleanup">Cleanup</a></li>
<li><a href="#H_User-defined%20Labels">User-defined Labels</a></li>
</ul>
<li><a href="#H_Cron%20Job">Cron Job</a></li>
<li><a href="#H_Daemon%20Set">Daemon Set</a></li>
<li><a href="#H_Service%20Account">Service Account</a></li>
<li><a href="#H_Horizontal%20Pod%20Autoscaler">Horizontal Pod Autoscaler</a></li>
<li><a href="#H_Cluster%20Autoscaler">Cluster Autoscaler</a></li>
<li><a href="#H_Pod%20Disruption%20Budget">Pod Disruption Budget</a></li>
</ul>
<li><a href="#H_Custom%20Kinds">Custom Kinds</a></li>
<li><a href="#H_API%20Security">API Security</a></li>
<ul>
<li><a href="#H_Role-based%20Access%20Control">Role-based Access Control</a></li>
<li><a href="#H_Disable%20Credentials">Disable Credentials</a></li>
</ul>
<li><a href="#H_Kubectl%20Cheatsheet">Kubectl Cheatsheet</a></li>
<ul>
<li><a href="#H_CRUD">CRUD</a></li>
<li><a href="#H1_Deployment">Deployment</a></li>
<li><a href="#H_Proxy">Proxy</a></li>
<li><a href="#H_Debug">Debug</a></li>
</ul>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_Introduction"></a><h1>Introduction</h1>
<p><a name="BM_(Introduction)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is a <a href="#BM_(service)%2Fi">service</a> orchestration framework that provides many of the plumbing pieces required for running <a href="#BM_(service)%2Fi">service</a>s. These <a href="#BM_(service)%2Fi">service</a>s include ...</p>
<ul>
<li>DNS for naming and discovery of <a href="#BM_(service)%2Fi">service</a>s,</li>
<li>Load balancer to distribute requests across many instances of a <a href="#BM_(service)%2Fi">service</a>,</li>
<li>Automatic recovery when a <a href="#BM_(service)%2Fi">service</a> crashes,</li>
<li>Automatic scaling when a <a href="#BM_(service)%2Fi">service</a> comes under load,</li>
<li>Password / certificate / <a href="#BM_(secret)%2Fi">secret</a>s management for <a href="#BM_(service)%2Fi">service</a>s,</li>
<li>etc..</li>
</ul>
<a name="H_Containers"></a><h2>Containers</h2>
<p><a name="BM_(Introduction%5C%2FContainers)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is structured around <a href="#BM_(container)%2Fi">container</a>s.</p>
<p><img src="svgbob_f6d6eb5e8cf3c348cd91f60b2ccc3e7c9930dac2.svg" alt="Kroki diagram output"></p>
<p>In the <a href="#BM_(context)%2Fi">context</a> of <a href="#BM_(container)%2Fi">container</a>s, an ...</p>
<ul>
<li>
<p><a href="#BM_(image)%2Fi">image</a> is an application (or set of applications) packaged with all of its dependencies as an immutable and isolated filesystem. The filesystem typically contains all dependencies required for the application(s) run sealed at their correct version:</p>
<ul>
<li>libraries (e.g. correct version of libssh),</li>
<li>applications (e.g. correct version bash and Python),</li>
<li>files (e.g. embedded SQLite databases)</li>
<li>etc..</li>
</ul>
<p><a href="#BM_(image)%2Fi">Image</a>s also typically include metadata describing its needs and operational standards. For example, the metadata may stipulate that the <a href="#BM_(image)%2Fi">image</a> ...</p>
<ul>
<li>launches by running /opt/my_app/run.sh</li>
<li>stops by signalling SIGTERM</li>
<li>requires 4gb of memory, 1.5 CPU cores, etc..A <a href="#BM_(container)%2Fi">container</a> is an instance of an application requires that <a href="#BM_(service)%2Fi">service</a>s be exposed as <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>s. An <a href="#BM_(image)%2Fi">image</a> is</li>
</ul>
</li>
<li>
<p><a href="#BM_(container)%2Fi">container</a> is an instance of an <a href="#BM_(image)%2Fi">image</a>. A <a href="#BM_(container)%2Fi">container</a> creates an isolated copy of the <a href="#BM_(image)%2Fi">image</a>'s filesystem, isolates the resources required for that <a href="#BM_(image)%2Fi">image</a>, and launches the entrypoint application for that <a href="#BM_(image)%2Fi">image</a>. That <a href="#BM_(container)%2Fi">container</a> can't see or access anything outside of the <a href="#BM_(container)%2Fi">container</a> unless explicitly allowed to by the user. For example, opening a port 8080 on a <a href="#BM_(container)%2Fi">container</a> won't open port 8080 on the host running it, but the user can explicitly ask that port 8080 in the <a href="#BM_(container)%2Fi">container</a> map to some port on the host.</p>
</li>
</ul>
<p>As shown in the entity diagram above, each <a href="#BM_(container)%2Fi">container</a> is created from a single <a href="#BM_(image)%2Fi">image</a>, but that same <a href="#BM_(image)%2Fi">image</a> can be used for to create multiple <a href="#BM_(container)%2Fi">container</a>s. Another way to think about it is that an <a href="#BM_(image)%2Fi">image</a> is the blueprint of a factory and a <a href="#BM_(container)%2Fi">container</a> is the actual factory built from that blueprint. You can build multiple factories from the same blueprint.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> requires two core components to run:</p>
<ul>
<li><a href="#BM_(Open%20Container%20Initiative%20runtime%7COpen%20Container%20Initiative)%2Fi">open container initiative</a> (<a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI</a>) runtime - A runtime responsible for only creating and launching <a href="#BM_(container)%2Fi">container</a>s.</li>
<li><a href="#BM_(container%20runtime%20interface)%2Fi">container runtime interface</a> (<a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>) - A runtime responsible for the high-level management of <a href="#BM_(container)%2Fi">container</a>s and <a href="#BM_(image)%2Fi">image</a>s: <a href="#BM_(image)%2Fi">image</a> management, <a href="#BM_(image)%2Fi">image</a> distribution, <a href="#BM_(container)%2Fi">container</a> mounts / storage, <a href="#BM_(container)%2Fi">container</a> networking, etc..</li>
</ul>
<p>Different vendors provide different implementations of each. For example, certain vendors provide an <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a> that use virtualization technology for isolation instead of standard Linux isolation (e.g. cgroups).</p>
<p><img src="svgbob_a28730c1c9bb6f382bb8e320a51ca1cfa2db0bb2.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI</a>s and OCRs are also the basis for <a href="#BM_(container%20engine)%2Fi">container engine</a>s, tools that are responsible for creating and running <a href="#BM_(container)%2Fi">container</a>s (similar in nature <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> without the orchestration) as well as creating <a href="#BM_(image)%2Fi">image</a>s and other high-level functionality such as local testing of <a href="#BM_(container)%2Fi">container</a>s. Docker Engine is an example of a <a href="#BM_(container%20engine)%2Fi">container engine</a>.</p>
<p><img src="svgbob_3d4187f5433dd286b08d28526577c57afdc47ec0.svg" alt="Kroki diagram output"></p>
<a name="H_Objects"></a><h2>Objects</h2>
<p><a name="BM_(Introduction%5C%2FObjects)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> breaks down its orchestration as a set of <a href="#BM_(object)%2Fi">object</a>s. Each <a href="#BM_(object)%2Fi">object</a> is of a specific type, referred to as <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>. The main <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s are ...</p>
<ul>
<li><a href="#BM_(node)%2Fi">Node</a>: A physical worker machine that runs <a href="#BM_(container)%2Fi">container</a>s.</li>
<li><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>: A set of <a href="#BM_(container)%2Fi">container</a>s tightly coupled to run in unison on a single <a href="#BM_(node)%2Fi">node</a>.</li>
<li>Volume: A storage mechanism that lets <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s persist and / or share data.</li>
<li><a href="#BM_(service)%2Fi">Service</a>: A load balancer that routes traffic to <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</li>
<li><a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">Configuration Map</a> - A configuration mechanism for applications running within <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (non-security related configurations).</li>
<li><a href="#BM_(secret)%2Fi">Secret</a> - A security configuration mechanism for applications running within <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (e.g. passwords as certificates).</li>
<li><a href="#BM_(ingress)%2Fi">Ingress</a> - A access point in which traffic comes in from the outside world to the internal <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> network.</li>
</ul>
<p>Of these <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, the two main ones are <a href="#BM_(node)%2Fi">node</a>s and <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. <a href="#BM_(node)%2Fi">Node</a>s, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, and other important <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s are discussed in this document.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The terminology here is a bit wishy-washy. Some places call them <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, other places call them resources, other places call them classes, and yet other places call them straight-up <a href="#BM_(object)%2Fi">object</a>s (in this case, they mean <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> but they're saying <a href="#BM_(object)%2Fi">object</a>). None of it seems consistent, which is why it's been difficult piecing together how <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> works.</p>
<p>I'm using <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> to refer to the different types of <a href="#BM_(object)%2Fi">object</a>s, and <a href="#BM_(object)%2Fi">object</a> to refer to an instance of a <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>.</p>
</div>
<a name="H_Labels"></a><h2>Labels</h2>
<p><a name="BM_(Introduction%5C%2FLabels)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction%5C%2FObjects)_TOPIC%2Fi">Introduction/Objects</a></li>
</ul>
</div>
<p>An <a href="#BM_(object)%2Fi">object</a> can have two types of key-value pairs associated with it:</p>
<ul>
<li><a href="#BM_(label)%2Fi">Label</a>s - These key-value pairs organize <a href="#BM_(object)%2Fi">object</a>s into logical groups, such that those groups can be targeted as a whole (e.g. give me all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s designed by the SRE team).</li>
<li><a href="#BM_(annotation%7Cannotate)%2Fi">Annotation</a>s - These key-value pairs allow tools to gather and share information about an <a href="#BM_(object)%2Fi">object</a> (e.g. when was this <a href="#BM_(object)%2Fi">object</a> created).</li>
</ul>
<p>Finding <a href="#BM_(object)%2Fi">object</a>s based on <a href="#BM_(label)%2Fi">label</a>s is done via <a href="#BM_(label%20selector)%2Fi">label selector</a>s, described in the following table.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key=value</code></td>
<td><code>key</code> is set to <code>value</code></td>
</tr>
<tr>
<td><code>key!=value</code></td>
<td><code>key</code> is not set to <code>value</code></td>
</tr>
<tr>
<td><code>key in (value1, value2, ...)</code></td>
<td><code>key</code> is either <code>value1</code>, <code>value2</code>, ...</td>
</tr>
<tr>
<td><code>key notin (value1, value2, ...)</code></td>
<td><code>key</code> is neither <code>value1</code>, <code>value2</code>, ...</td>
</tr>
<tr>
<td><code>key</code></td>
<td>a value is set for <code>key</code></td>
</tr>
<tr>
<td><code>!key</code></td>
<td>a value not set for <code>key</code></td>
</tr>
<tr>
<td><code>key1=value1,key2=value2</code></td>
<td><code>key1</code> is set to <code>value1</code> and <code>key2</code> is set to <code>value2</code></td>
</tr>
</tbody>
</table>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses <a href="#BM_(label)%2Fi">label</a>s to orchestrate. <a href="#BM_(label)%2Fi">Label</a>s allow <a href="#BM_(object)%2Fi">object</a>s to have loosely-coupled linkages to each other as opposed to tightly-coupled parent-child / hierarchy relationships. For example, a load balancer decides which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s it routes requests to by searching for <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s using <a href="#BM_(label%20selector)%2Fi">label selector</a>.</p>
<p><img src="svgbob_d1e778081e8cdf9a5a337a08f8f517ac030d2200.svg" alt="Kroki diagram output"></p>
<p>If there are a large number of keys / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s, either because the organization set them directly or because they're being set by external tools, the chance of a collision increases. To combat this, keys for <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s can optionally include a prefix (separated by a slash) that maps to a DNS subdomain to help disambiguate it. For example, <code>company.com/my_key</code> rather than just having <code>my_key</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book states that key name itself can be at most 63 chars. If a prefix is included, it doesn't get included in that limit. A prefix can be up to 253 chars.</p>
</div>
<a name="H_Configuration"></a><h2>Configuration</h2>
<p><a name="BM_(Introduction%5C%2FConfiguration)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(object)%2Fi">Object</a>s can either be accessed and mutated through a standard command-line interface called <a href="#BM_(kubectl)%2Fi">kubectl</a> or a REST web interface. Manipulations come in two forms:</p>
<ul>
<li>
<p><a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a> - the mutations to perform on the <a href="#BM_(object)%2Fi">object</a> (via <a href="#BM_(kubectl)%2Fi">kubectl</a> invocations).</p>
<pre><code>kubectl run my_pod --image=my-image:1.0
kubectl set pods my_pod --requests='cpu=500m,memory=128Mi'
</code></pre>
</li>
<li>
<p><a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> - the overall description of the <a href="#BM_(object)%2Fi">object</a>, called a <a href="#BM_(manifest)%2Fi">manifest</a> (as YAML or JSON via either <a href="#BM_(kubectl)%2Fi">kubectl</a> or REST).</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
</code></pre>
<pre><code>kubectl apply -f obj.yaml
kubectl delete -f obj.yaml
</code></pre>
</li>
</ul>
<p>Generally, <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a>s are preferred over <a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a>s. When a <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> is submitted, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs a <a href="#BM_(reconciliation%20loop)%2Fi">reconciliation loop</a> in the background to automatically mutate the state of the <a href="#BM_(object)%2Fi">object</a> to the one in the <a href="#BM_(manifest)%2Fi">manifest</a>. Contrast this to the <a href="#BM_(imperative%20configuration)%2Fi">imperative configuration</a> method, where the mutations have to be manually submitted by the user one by one.</p>
<a name="H_Kinds"></a><h1>Kinds</h1>
<p><a name="BM_(Kinds)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction)_TOPIC%2Fi">Introduction</a></li>
<li><a href="#BM_(Introduction%5C%2FConfiguration)_TOPIC%2Fi">Introduction/Configuration</a></li>
<li><a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a></li>
</ul>
</div>
<p>The following sub-sections gives a overview of <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s and example <a href="#BM_(manifest)%2Fi">manifest</a>s. All <a href="#BM_(manifest)%2Fi">manifest</a>s, regardless of the <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>, require the following fields ...</p>
<ul>
<li><code>apiVersion</code>: API version.</li>
<li><code>kind</code>: Class of <a href="#BM_(object)%2Fi">object</a> (<a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>).</li>
<li><code>metadata.name</code>: Name of <a href="#BM_(object)%2Fi">object</a>.</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-name</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">author:</span> <span class="hljs-string">"Jimbo D."</span>
    <span class="hljs-attr">created_on:</span> <span class="hljs-string">"Aug 20 2021"</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app_server:</span> <span class="hljs-string">jetty</span>
</code></pre>
<p>In addition, the <code>metadata.labels</code> and <code>metadata.annotations</code> <a href="#BM_(manifest)%2Fi">manifest</a> paths contain the <a href="#BM_(object)%2Fi">object</a>'s <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s (respective).</p>
<a name="H_Pod"></a><h2>Pod</h2>
<p><a name="BM_(Kinds%5C%2FPod)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(container)%2Fi">Container</a>s are deployed in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> via <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is is a set of <a href="#BM_(container)%2Fi">container</a>s grouped together, often <a href="#BM_(container)%2Fi">container</a>s that are tightly coupled and / or are required to work in close proximity of each other (e.g. on the same host).</p>
<p><img src="svgbob_e74b52a9043c79551911fcf4f001af764adce0b0.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(container)%2Fi">Container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are isolated in terms of their resource requirements (e.g. CPU, memory, and disk), but they share the same ...</p>
<ul>
<li>network (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> have the same IP, same host, and share the port space).</li>
<li>IPC bus (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can communicate with each other over POSIX message queues / System V IPC channels).</li>
<li>volumes (<a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> may have shared storage assigned to them in addition to their isolated storage).</li>
</ul>
<p>While the point of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is to orchestrate <a href="#BM_(container)%2Fi">container</a>s over a set of <a href="#BM_(node)%2Fi">node</a>s, the <a href="#BM_(container)%2Fi">container</a>s for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are all guaranteed to run on the same <a href="#BM_(node)%2Fi">node</a>. As such, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are usually structured in a way where their <a href="#BM_(container)%2Fi">container</a>s are tightly coupled and uniformly scale together. For example, imagine a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with comprised of a <a href="#BM_(container)%2Fi">container</a> running a WordPress server and a <a href="#BM_(container)%2Fi">container</a> running the MySQL database for that WordPress server. This would be a poor example of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> because the two <a href="#BM_(container)%2Fi">container</a>s within it ...</p>
<ol>
<li>don't scale uniformly (e.g. you may need to scale the database up before the WordPress server, or vice versa).</li>
<li>don't communicate over anything other than the network (e.g. they don't need a shared volume).</li>
<li>are intended to be distributed (e.g. it's okay for them to be running on separate machines).</li>
</ol>
<p>Contrast that to a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with a <a href="#BM_(container)%2Fi">container</a> running a WordPress server and a <a href="#BM_(container)%2Fi">container</a> that pushes that WordPress server's logs to a monitoring <a href="#BM_(service)%2Fi">service</a>. This would be a good example of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> because the two <a href="#BM_(container)%2Fi">container</a>s within ...</p>
<ol>
<li>communicate over the filesystem (e.g. application server is writing logs to a shared volume and the log watcher is tailing them).</li>
<li>aren't intended to be distributed (e.g. log watcher is intended for locally produced logs).</li>
<li>are written by different teams (e.g. SRE team wrote the log watcher <a href="#BM_(image)%2Fi">image</a> while another team wrote the application server <a href="#BM_(image)%2Fi">image</a>).</li>
</ol>
<p>Example <a href="#BM_(manifest)%2Fi">manifest</a>:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my_container</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1000m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"256Mi"</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/data"</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data"</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">livenessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/healthy</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">readinessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data"</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data"</span>  <span class="hljs-comment"># literally mounts a path from the worker node? not persistent if node modes</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"my_data_nfs"</span>
      <span class="hljs-attr">nfs:</span>
        <span class="hljs-attr">server:</span> <span class="hljs-string">nfs.server.location</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/path/on/nfs"</span>
</code></pre>
<a name="H_Images"></a><h3>Images</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FImages)_TOPIC%2F"></a><strong></strong></p>
<p>Each <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> must have an <a href="#BM_(image)%2Fi">image</a> associated with. <a href="#BM_(image)%2Fi">Image</a>s are specified in the Docker <a href="#BM_(image)%2Fi">image</a> specification format, where a name and a tag are separated by a colon (e.g. <code>my-image:1.0.1</code>).</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container1</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container2</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:2.4</span>
</code></pre>
<a name="H_Pull%20Policy"></a><h4>Pull Policy</h4>
<p><a name="BM_(Kinds%5C%2FPod%2FImages%2FPull%20Policy)_TOPIC%2F"></a><strong></strong></p>
<p>Each <a href="#BM_(container)%2Fi">container</a> in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> has to reference an <a href="#BM_(image)%2Fi">image</a> to use. How <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> loads a <a href="#BM_(container)%2Fi">container</a>'s <a href="#BM_(image)%2Fi">image</a> is dependent on that <a href="#BM_(container)%2Fi">container</a>'s <a href="#BM_(image)%2Fi">image</a> pull policy.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>  <span class="hljs-comment"># Only download if the image isn't present</span>
</code></pre>
<p>A value of ...</p>
<ul>
<li><code>IfNotPresent</code> only downloads the <a href="#BM_(image)%2Fi">image</a> if its not already locally present on the <a href="#BM_(node)%2Fi">node</a>.</li>
<li><code>Always</code> always downloads the <a href="#BM_(image)%2Fi">image</a>.</li>
<li><code>Never</code> never downloads the <a href="#BM_(image)%2Fi">image</a> (will fail if <a href="#BM_(image)%2Fi">image</a> does not exist locally on the <a href="#BM_(node)%2Fi">node</a>).</li>
</ul>
<p>If unset, the <a href="#BM_(image)%2Fi">image</a> pull policy differs based on the <a href="#BM_(image)%2Fi">image</a> tag. Not specifying a tag or specifying <code>latest</code> as the tag will always pull the <a href="#BM_(image)%2Fi">image</a>. Otherwise, the <a href="#BM_(image)%2Fi">image</a> will be pulled only if it isn't present.</p>
<a name="H_Private%20Container%20Registries"></a><h4>Private Container Registries</h4>
<p><a name="BM_(Kinds%5C%2FPod%2FImages%2FPrivate%20Container%20Registries)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FSecret)_TOPIC%2F">Kinds/Secret</a></li>
</ul>
</div>
<p><a href="#BM_(image)%2Fi">Image</a>s that sit in private <a href="#BM_(container)%2Fi">container</a> registries require credentials to pull. Private <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(registry)%2Fi">registry</a> credentials are stored in <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a>s of type <code>kubernetes.io/dockerconfigjson</code> in the format of Docker's <code>config.json</code> file.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-docker-creds</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/dockerconfigjson</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-string">.dockerconfigjson:</span> <span class="hljs-string">...</span> <span class="hljs-comment"># base64 encoded ~/.docker/config.json goes here</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you don't want to supply the above <a href="#BM_(manifest)%2Fi">manifest</a>, you can also use <code>kubectl</code> to create a <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a> with the appropriate credentials: <code>kubectl create secret docker-registry secret-tiger-docker --docker-email=tiger@acme.example --docker-username=tiger --docker-password=pass1234 --docker-server=my-registry.example:5000</code>.</p>
</div>
<p>Those <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a>s are then referenced in the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(image)%2Fi">image</a> pull <a href="#BM_(secret)%2Fi">secret</a>s list.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Place secret here. This is a list, so you can have many container registry credentials</span>
  <span class="hljs-comment"># here.</span>
  <span class="hljs-attr">imagePullSecrets:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-docker-creds</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-registry.example/tiger/my-container:1.0.1</span>  <span class="hljs-comment"># Image references registry.</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService%20Account)_TOPIC%2Fi">Kinds/Service Account</a> (<a href="#BM_(image)%2Fi">Image</a> pull <a href="#BM_(secret)%2Fi">secret</a>s may be assigned to <a href="#BM_(service%20account)%2Fi">service account</a>s, where any <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> using that <a href="#BM_(service%20account)%2Fi">service account</a> inherits them)</li>
</ul>
</div>
<a name="H_Resources"></a><h3>Resources</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FResources)_TOPIC%2F"></a><strong></strong></p>
<p>Each <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can optionally declare a ...</p>
<ul>
<li>minimum set of resources that it needs to operate,</li>
<li>maximum set of resources that it will ever need to operate.</li>
</ul>
<p>Setting these options allows <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to choose a <a href="#BM_(node)%2Fi">node</a> with enough available resources to run that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>  <span class="hljs-comment"># Minimum CPU and memory for this container</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"500m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"128Mi"</span>
        <span class="hljs-attr">limits:</span>    <span class="hljs-comment"># Maximum CPU and memory for this container</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1000m"</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">"256Mi"</span>
</code></pre>
<p><code>requests</code> are the minimum resources the <a href="#BM_(container)%2Fi">container</a> needs to operate while <code>limits</code> are the maximum resources the <a href="#BM_(container)%2Fi">container</a> can have. Some resources are dynamically adjustable while others require the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to restart. For example, a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> ...</p>
<ul>
<li>can have its CPU usage dynamically adjusted because <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> can just ask the operating system's CPU scheduler to give it less/more time.</li>
<li>can't have its memory usage dynamically adjusted because if it loses access to a block of memory, the applications running within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> won't know and will likely crash.</li>
</ul>
<p>The example above lists out CPU and memory as viable resource types. The unit of measurement for ...</p>
<ul>
<li>cpu is either in ...
<ul>
<li>whole cores: no suffix</li>
<li><a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a>s: suffix of m (1 core is equivalent to 1000m -- e.g. 0.5 = 5000m).</li>
</ul>
</li>
<li>memory is either in ...
<ul>
<li>bytes: no suffix</li>
<li>1000 scale: suffix of k = 1000, M = 1,000,000, G = 1,000,000,000</li>
<li>power of two scale: suffix of k = 1024, M = 1,048,576, G = 1,073,741,824</li>
</ul>
</li>
</ul>
<a name="H_Ports"></a><h3>Ports</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FPorts)_TOPIC%2F"></a><strong></strong></p>
<p>Each <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can expose ports to the cluster.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
</code></pre>
<p>The example above exposes port 8080 to the rest of the cluster (not to the outside world). Even with the port exposed, other entities on the cluster don't have a built-in way to discover the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s IP / host or the fact that it has this specific port open. For that, <a href="#BM_(service)%2Fi">service</a>s are required.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService)_TOPIC%2Fi">Kinds/Service</a> (Exposing <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to the outside world)</li>
</ul>
</div>
<p>A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can have many <a href="#BM_(container)%2Fi">container</a>s within it, and since all <a href="#BM_(container)%2Fi">container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> share the same IP, the ports exposed by those <a href="#BM_(container)%2Fi">container</a>s can't conflict. For example, only one <a href="#BM_(container)%2Fi">container</a> within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> expose port 8080.</p>
<a name="H_Command-line%20Arguments"></a><h3>Command-line Arguments</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FCommand-line%20Arguments)_TOPIC%2F"></a><strong></strong></p>
<p>An <a href="#BM_(image)%2Fi">image</a> typically provides a default entrypoint (process that gets started) and default set of arguments to run with. Each <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can override these defaults.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-attr">command:</span> [<span class="hljs-string">/opt/app/my-app</span>]
      <span class="hljs-attr">args:</span> [<span class="hljs-string">--no-logging</span>, <span class="hljs-string">--dry-run</span>]
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The Dockerfile used to create the <a href="#BM_(image)%2Fi">image</a> had an <code>ENTRYPOINT</code> and a <code>CMD</code>. <code>command</code> essentially overrides the Dockerfile <code>ENTRYPOINT</code> and <code>args</code> overrides the Dockerfile's <code>CMD</code>.</p>
</div>
<a name="H_Environment%20Variables"></a><h3>Environment Variables</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FEnvironment%20Variables)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FCommand-line%20Arguments)_TOPIC%2F">Kinds/Pod/Command-line Arguments</a></li>
</ul>
</div>
<p>Each <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can be assigned a set of environment variables.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_LEVEL</span>
          <span class="hljs-attr">value:</span> <span class="hljs-string">"OFF"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DRY_RUN</span>
          <span class="hljs-attr">value:</span> <span class="hljs-string">"true"</span>
</code></pre>
<p>Once defined, an environment variables value can be used in other parts of the <a href="#BM_(manifest)%2Fi">manifest</a> using the syntax <code>$(VAR_NAME)</code>. For example, an environment variable's value may be placed directly within an argument.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_LEVEL</span>
          <span class="hljs-attr">value:</span> <span class="hljs-string">"OFF"</span>
      <span class="hljs-attr">args:</span> [<span class="hljs-string">--logging_telemetry=$(LOG_LEVEL)</span>]
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FConfiguration)_TOPIC%2F">Kinds/Pod/Configuration</a> (Set configurations to environment variables)</li>
<li><a href="#BM_(Kinds%5C%2FPod%2FMetadata)_TOPIC%2F">Kinds/Pod/Metadata</a> (Set <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> details to environment variables)</li>
<li><a href="#BM_(Kinds%5C%2FPod%2FService%20Discovery%2FEnvironment%20Variables)_TOPIC%2F">Kinds/Pod/Service Discovery/Environment Variables</a> (Find <a href="#BM_(service)%2Fi">service</a>s using environment variables)</li>
</ul>
</div>
<a name="H1_Configuration"></a><h3>Configuration</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FConfiguration)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FConfiguration%20Map)_TOPIC%2F">Kinds/Configuration Map</a></li>
<li><a href="#BM_(Kinds%5C%2FSecret)_TOPIC%2F">Kinds/Secret</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FEnvironment%20Variables)_TOPIC%2F">Kinds/Pod/Environment Variables</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FCommand-line%20Arguments)_TOPIC%2F">Kinds/Pod/Command-line Arguments</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FVolume%20Mounts)_TOPIC%2F">Kinds/Pod/Volume Mounts</a></li>
</ul>
</div>
<p>A <a href="#BM_(container)%2Fi">container</a>'s configuration can come from both <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s and <a href="#BM_(secret)%2Fi">secret</a>s. For <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s, a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>'s key-value pairs can be accessed by a <a href="#BM_(container)%2Fi">container</a> via environment variables, command-line arguments, or volume mounts. To set a ...</p>
<ul>
<li>
<p>environment variable:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-comment"># Under each "env" entry to come from a config map, add a "valueFrom" that contains</span>
      <span class="hljs-comment"># the config map to pull an entry from and the key for the config map entry to pull.</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>  <span class="hljs-comment"># Env var to assign value to.</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>       <span class="hljs-comment"># Config map to pull from</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>  <span class="hljs-comment"># Config map entry to get value from</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>
</code></pre>
<p>In certain cases, you may want to map all entries within a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a> directly as a set of environment variables. This is useful when many entries of a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a> are required for configuration, so many that becomes tedious and error-prone to map them all to environment variables by hand.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-comment"># "envFrom" maps all entries of a config map as env vars.</span>
      <span class="hljs-attr">envFrom:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">prefix:</span> <span class="hljs-string">CONFIG_</span>    <span class="hljs-comment"># Prefix to tack on to each config map entry (optional).</span>
          <span class="hljs-attr">configMapRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a> name can't map to an environment variable, it's silently omitted. For example, env names can't contain dashes.</p>
</div>
</li>
<li>
<p>command-line argument:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-comment"># You can't pass in config map entries directly as command-line arguments, but what</span>
      <span class="hljs-comment"># you can do is load them up first as environment variables and then reference the</span>
      <span class="hljs-comment"># environment variables in the "command" (or "args") field.</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">configMapKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"/my-app.sh"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME1)"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME2)"</span>
</code></pre>
</li>
<li>
<p>volume mount:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Place a "configMap" type volume into the pod.</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
        <span class="hljs-comment"># "items" lists out specific config map entries to include and mounts each as</span>
        <span class="hljs-comment"># a specific filename. If you don't include this, all config map entries will</span>
        <span class="hljs-comment"># be included (filenames will map to config map entry names).</span>
        <span class="hljs-attr">items:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">file1.cfg</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">file2.cfg</span>
  <span class="hljs-comment"># In the container, mount that volume to whichever containers you want.</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>       <span class="hljs-comment"># Make the mount read-only (optional).</span>
          <span class="hljs-attr">defaultMode:</span> <span class="hljs-string">"6600"</span>  <span class="hljs-comment"># File access permissions of mounted files (optional).</span>
</code></pre>
<p>If the directory you're mounting to already exists on the <a href="#BM_(container)%2Fi">container</a>, that existing directory is entirely replaced. In the example above, if the <a href="#BM_(container)%2Fi">container</a> already has a "/config" directory, it'll get replaced entirely with the <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a> mount (this is bad because the <a href="#BM_(container)%2Fi">container</a>'s "/config" might have other necessary files required for the <a href="#BM_(container)%2Fi">container</a> to work). A workaround to this is to use the volume mount's "subPath" property, which allows you to mount a single file / directory from a volume.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-comment"># The use of "subPath" here ensures that that original "/config" directory on the</span>
      <span class="hljs-comment"># container doesn't go away. It remains in place, and files / directories are just</span>
      <span class="hljs-comment"># added to it.</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config/file1.cfg</span>  <span class="hljs-comment"># Destination file to mount to.</span>
          <span class="hljs-attr">subPath:</span> <span class="hljs-string">CONFIG_MAP_KEY1</span>      <span class="hljs-comment"># Source config map entry name.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/config/file2.cfg</span>  <span class="hljs-comment"># Destination file to mount to.</span>
          <span class="hljs-attr">subPath:</span> <span class="hljs-string">CONFIG_MAP_KEY2</span>      <span class="hljs-comment"># Source config map entry name.</span>
</code></pre>
</li>
</ul>
<p>For <a href="#BM_(secret)%2Fi">secret</a>s, a <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a>'s key-value pairs can be accessed in almost exactly the same way as <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s with almost exactly the same set of options and restrictions. To set a ...</p>
<ul>
<li>
<p>environment variable:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY2</span>
</code></pre>
</li>
<li>
<p>command-line argument:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME1</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_VAR_NAME2</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>  <span class="hljs-comment"># This has been changed from "configMapKeyRef" to "secretKeyRef".</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">SECRET_KEY2</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"/my-app.sh"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME1)"</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">"$(ENV_VAR_NAME2)"</span>
</code></pre>
</li>
<li>
<p>volume mount:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span>
      <span class="hljs-attr">secret:</span>  <span class="hljs-comment"># This has been changed from "configMap" to "secret"</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/secrets</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
</code></pre>
</li>
</ul>
<p>Both <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s and <a href="#BM_(secret)%2Fi">secret</a>s can be dynamically updated. If a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is running when an update gets issued, it may or may not receive those updates depending on the configurations are exposed to the <a href="#BM_(container)%2Fi">container</a>:</p>
<ul>
<li>environment variables <em>don't</em> receive updates.</li>
<li>command-line arguments <em>don't</em> receive updates.</li>
<li>individual volume mounts <em>don't</em> receive updates.</li>
<li>whole volume mounts do receive updates.</li>
</ul>
<p>Command-line arguments and environment variables don't update because an application's command-line arguments and environment variables can't be changed from the outside once a process launches. Individual files/directories mounted from a volume don't update because of technical limitations related to how Linux filesystems work (see <a href="https://github.com/kubernetes/kubernetes/issues/50345#issuecomment-656947594%5D">here</a>). Whole volume mounts <em>do</em> update files under the mount, but it's up to the application to detect and reload those changed files.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>All files in a volume mount get updated at once. This is possible because of symlinks. New directory get loaded in and the symlink is updated to use that new directory.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For individual files/directories mounted from a volume, one workaround to receiving updates is to use symlinks. Essentially, mount the whole volume to path that doesn't conflict with an existing path in the <a href="#BM_(container)%2Fi">container</a>. Then, as a part of the <a href="#BM_(container)%2Fi">container</a>'s start-up process, add symlinks to the whole volume mount wherever needed.</p>
<p>For example, if the application requires a configuration file at /etc/my_config.conf, you can mount all configurations to /config and then symlink /etc/my_config.conf to /config/my_config.conf. That way, you can still receive updates.</p>
</div>
<p>The typical workaround to <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a> dynamic updates is to use <a href="#BM_(deployment)%2Fi">deployment</a>s. In <a href="#BM_(deployment)%2Fi">deployment</a>s, <a href="#BM_(secret)%2Fi">secret</a>s / <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s and <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are bound together as a single unit, meaning that all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s restart automatically on any change.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi">Kinds/Deployment</a></li>
</ul>
</div>
<a name="H_Volume%20Mounts"></a><h3>Volume Mounts</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FVolume%20Mounts)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FVolume)_TOPIC%2Fi">Kinds/Volume</a></li>
</ul>
</div>
<p>A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is able to supply multiple volumes, where those volumes may be mounted to different <a href="#BM_(container)%2Fi">container</a>s within that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Volumes supplied are listed here.</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-data1</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data1"</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-data2</span>
      <span class="hljs-attr">hostPath:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/lib/my_data2"</span>
  <span class="hljs-comment"># Each container in the pod can mount any of the above volumes by referencing its name.</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-comment"># Mount "my-data1" volume to /data1 in the container's filesystem.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data1</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-data1</span>
        <span class="hljs-comment"># Mount "my-data2" volume to /data2 in the container's filesystem.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data2</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-data2</span>
</code></pre>
<p>In the example above, the two volumes supplied by the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are both of type <code>hostPath</code>. <code>hostPath</code> volume types reference a directory on the <a href="#BM_(node)%2Fi">node</a> that the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is running on, meaning that if two <a href="#BM_(container)%2Fi">container</a>s within the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are assigned the same <code>hostPath</code> volume, they see each other's changes on that volume. The type of volume supplied defines the characteristics of that volume. Depending on the volume type, data on that volume ...</p>
<ul>
<li>may be shared across <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, shared across <a href="#BM_(container)%2Fi">container</a>s within a single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, or not shared at all</li>
<li>may be encrypted or unencrypted</li>
<li>if shared, may have delayed and / or unreliable read-write consistency</li>
<li>if not shared, may be transient or persistent across <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> or <a href="#BM_(container)%2Fi">container</a> restarts</li>
<li>if not shared, may be transient or persistent when a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is moved to a new <a href="#BM_(node)%2Fi">node</a></li>
<li>etc..</li>
</ul>
<p>Each supplied volume within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can either reference a direct piece of storage or it can reference a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>. In most cases, directly referencing a piece of storage (as done in the above example) is discouraged because it tightly couples the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to that storage and its parameters. The better way is to use <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s, where volumes are assigned from a pool (or dynamically created and assigned) to <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s as required. Assuming that you have a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> already created, it can be referenced by using <code>persistentVolumeClaim</code> as the volume type.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-data</span>
      <span class="hljs-attr">persistentVolumeClaim:</span>  <span class="hljs-comment"># Volume type of "persistentVolumeClaim"</span>
        <span class="hljs-attr">claimName:</span> <span class="hljs-string">my-data-pv-claim</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-data</span>
</code></pre>
<a name="H_Probes"></a><h3>Probes</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FProbes)_TOPIC%2F"></a><strong></strong></p>
<p>Probes are a way for <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to check the state of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. <a href="#BM_(container)%2Fi">Container</a>s within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> expose interfaces which <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> periodically pings to determine what actions to take (e.g. restarting a non-responsive <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>).</p>
<p>Different types of probes exists. A ...</p>
<ul>
<li><a href="#BM_(liveness%20probe)%2Fi">liveness probe</a> is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if a <a href="#BM_(container)%2Fi">container</a> is alive and responsive (typical action on failure: restart <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>).</li>
<li><a href="#BM_(readiness%20probe)%2Fi">readiness probe</a> is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if a <a href="#BM_(container)%2Fi">container</a> is able to accept traffic (typical action on failure: stop traffic until <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s on all <a href="#BM_(container)%2Fi">container</a>s pass).</li>
<li>startup probe is something that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> pings to check if a <a href="#BM_(container)%2Fi">container</a> has started (typical action on failure: retry until startup probes on all <a href="#BM_(container)%2Fi">container</a>s pass before allowing liveness and <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService)_TOPIC%2Fi">Kinds/Service</a> (<a href="#BM_(readiness%20probe)%2Fi">Readiness probe</a>s are used by <a href="#BM_(service)%2Fi">service</a>s for routing traffic).</li>
</ul>
</div>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-comment"># Probe to check if a container is alive or dead. Performs an HTTP GET with path</span>
      <span class="hljs-comment"># /healthy at port 8080.</span>
      <span class="hljs-attr">livenessProbe:</span> 
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/healthy</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
      <span class="hljs-comment"># Probe to check if a container is able to service requests. Performs an HTTP GET</span>
      <span class="hljs-comment"># with path /ready at port 8080.</span>
      <span class="hljs-attr">readinessProbe:</span>
        <span class="hljs-attr">httpGet:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
  <span class="hljs-string">...</span>
</code></pre>
<p>In the example above, each of the probes check a HTTP server within the <a href="#BM_(container)%2Fi">container</a> at port 8080 but at different paths. The field ...</p>
<ul>
<li><code>initialDelaySeconds</code> is the number of seconds to wait before performing the first probe.</li>
<li><code>timeoutSeconds</code> is the number of seconds to wait before timing out.</li>
<li><code>periodSeconds</code> is the number of seconds to wait before performing a probe.</li>
<li><code>failureThreshold</code> is the maximum number of successive failure before <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> considers the probe failed.</li>
<li><code>successThreshold</code> is the maximum number of successive successes before <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> considers the probe passed.</li>
</ul>
<p>There are types of probes other than <code>httpGet</code>. A probe of type ...</p>
<ul>
<li><code>httpGet</code> will perform an HTTP GET operation to a server on the <a href="#BM_(container)%2Fi">container</a> and fail it its non-responsive.</li>
<li><code>tcpSocket</code> will attempt to connect a TCP socket to the <a href="#BM_(container)%2Fi">container</a> and  fail if the <a href="#BM_(container)%2Fi">container</a> doesn't accept.</li>
<li><code>exec</code> will run a command on the <a href="#BM_(container)%2Fi">container</a> and fail if it gets a non-zero exit code.</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
      <span class="hljs-attr">readinessProbe:</span>
        <span class="hljs-attr">exec:</span>
          <span class="hljs-attr">command:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/some_file_here</span>
        <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>
        <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>
        <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>
</code></pre>
<a name="H_Restart%20Policy"></a><h3>Restart Policy</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FRestart%20Policy)_TOPIC%2F"></a><strong></strong></p>
<p>Restart policy is the policy <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses for determining when a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> should be restarted.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0.1</span>
</code></pre>
<p>A value of ...</p>
<ul>
<li><code>Always</code> always restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> regardless of how it exists (default).</li>
<li><code>OnFailure</code> only restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> only if it failed execution.</li>
<li><code>Never</code> never restarts the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p><code>Always</code> is typically used when running servers that should always be up (e.g. http server) while the others are typically used for one-off <a href="#BM_(job)%2Fi">job</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FJob)_TOPIC%2Fi">Kinds/Job</a></li>
</ul>
</div>
<a name="H_Service%20Discovery"></a><h3>Service Discovery</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FService%20Discovery)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService)_TOPIC%2Fi">Kinds/Service</a></li>
</ul>
</div>
<p>For a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to communicate with <a href="#BM_(service)%2Fi">service</a>s, it needs to be able to discover the IP(s) of those <a href="#BM_(service)%2Fi">service</a>s. The mechanisms for discovering <a href="#BM_(service)%2Fi">service</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are environment variables and DNS.</p>
<p>These <a href="#BM_(service)%2Fi">service</a> discovery mechanisms are details in the subsections below.</p>
<a name="H1_Environment%20Variables"></a><h4>Environment Variables</h4>
<p><a name="BM_(Kinds%5C%2FPod%2FService%20Discovery%2FEnvironment%20Variables)_TOPIC%2F"></a><strong></strong></p>
<p>When a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> launches, all <a href="#BM_(service)%2Fi">service</a>s within the same <a href="#BM_(namespace)%2Fi">namespace</a> have their IP and port combinations added as environment variables within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(container)%2Fi">container</a>s. The environment variable names are in the format <code>{SVCNAME}_SERVICE_HOST</code> / <code>{SVCNAME}_SERVICE_PORT</code>, where <code>{SVCNAME}</code> is the <a href="#BM_(service)%2Fi">service</a> converted to uppercase and dashes swapped with underscores. For example, <code>service-a</code> would get converted to <code>SERVICE_A</code>.</p>
<pre><code>SERVICE_A_SERVICE_HOST=10.111.240.1
SERVICE_A_SERVICE_PORT=443
SERVICE_B_SERVICE_HOST=10.111.249.153
SERVICE_B_SERVICE_PORT=80
</code></pre>
<p>If a <a href="#BM_(service)%2Fi">service</a> exposes multiple ports, only the first port goes in <code>{SVCNAME}_SERVICE_PORT</code>. When multiple ports are present, additional environment variables get created in the format <code>{SVCNAME}_SERVICE_PORT_{PORTNAME}</code>, where <code>{PORTNAME}</code> is the name of <a href="#BM_(service)%2Fi">service</a>'s port modified the same way that <code>{SVCNAME}</code> is. For example, <code>service-c</code> with two exposed ports named <code>web-1</code> and <code>metrics-1</code> would get converted to <code>SERVICE_C_SERVICE_PORT_WEB_1</code> and <code>SERVICE_C_SERVICE_PORT_METRICS_1</code> respectively.</p>
<pre><code>SERVICE_C_SERVICE_HOST=10.111.240.1
SERVICE_C_SERVICE_PORT=443
SERVICE_C_SERVICE_PORT_WEB_1=443
SERVICE_C_SERVICE_PORT_METRICS_1=8080
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Looking at the k8s code, it looks like for a <a href="#BM_(service)%2Fi">service</a> port needs to be named for it as an environment variable. <a href="#BM_(service)%2Fi">Service</a> ports that don't have a name won't show up as environment variables. See (here)[https://github.com/<a href="#BM_(Kubernetes)%2Fi">kubernetes</a>/<a href="#BM_(Kubernetes)%2Fi">kubernetes</a>/blob/master/pkg/kubelet/envvars/envvars.go#L51-L55].</p>
</div>
<p>Using environment variables for <a href="#BM_(service)%2Fi">service</a> discovery has the following pitfalls:</p>
<ul>
<li><a href="#BM_(service)%2Fi">Service</a>s outside of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(namespace)%2Fi">namespace</a> aren't provided.</li>
<li><a href="#BM_(service)%2Fi">Service</a>s added to the <a href="#BM_(namespace)%2Fi">namespace</a> after the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> launches won't be picked up (env vars can only be changed prior to the launch of a <a href="#BM_(container)%2Fi">container</a> process).</li>
<li><a href="#BM_(service)%2Fi">Service</a>s removed from the name after the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> launches won't be picked up (env vars can only be changed prior to the launch of a <a href="#BM_(container)%2Fi">container</a> process).</li>
<li><a href="#BM_(service)%2Fi">Service</a> naming conflicts can happen during normalization (e.g. uppercase-ing and converting dashes to underscores can cause conflict: <code>My-name</code> and <code>my_namE</code> both end up as <code>MY_NAME</code>).</li>
</ul>
<p>On the plus side, inspecting environment variables within a <a href="#BM_(container)%2Fi">container</a> essentially enumerates all <a href="#BM_(service)%2Fi">service</a>s within the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(namespace)%2Fi">namespace</a>. Enumerating <a href="#BM_(service)%2Fi">service</a>s isn't possible when using DNS for <a href="#BM_(service)%2Fi">service</a> discovery, discussed in the next section.</p>
<a name="H_DNS"></a><h4>DNS</h4>
<p><a name="BM_(Kinds%5C%2FPod%2FService%20Discovery%2FDNS)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FService%20Discovery%2FEnvironment%20Variables)_TOPIC%2F">Kinds/Pod/Service Discovery/Environment Variables</a></li>
</ul>
</div>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> provides a global DNS server which is used for <a href="#BM_(service)%2Fi">service</a> discovery. Each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is automatically configured to use this DNS server and simply has to query it for a <a href="#BM_(service)%2Fi">service</a>'s name. If the queried <a href="#BM_(service)%2Fi">service</a> is present, the DNS server will return the stable IP of that <a href="#BM_(service)%2Fi">service</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The DNS server runs as an internal <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> application called 'coredns<code>or</code><a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">kube-dns</a><code>. This is usually in the </code><a href="#BM_(kube-system)%2Fi">kube-system</a>` <a href="#BM_(namespace)%2Fi">namespace</a>. Recall that the IP of a <a href="#BM_(service)%2Fi">service</a> is stable for the entire lifetime of the <a href="#BM_(service)%2Fi">service</a>, meaning that <a href="#BM_(service)%2Fi">service</a> restarts and DNS caching by the application and / or OS isn't an issue here.</p>
</div>
<p>The general domain query format is <code>{SVCNAME}.{NAMESPACE}.svc.{CLUSTERDOMAIN}</code>, where ...</p>
<ul>
<li><code>{SVCNAME}</code> is the name of the <a href="#BM_(service)%2Fi">service</a>.</li>
<li><code>{NAMESPACE}</code> is the name of the <a href="#BM_(namespace)%2Fi">namespace</a> that <code>{SVCNAME}</code> is in.</li>
<li><code>{CLUSTERDOMAIN}</code> is the cluster domain suffix of the cluster that <code>{SVCNAME}</code> and <code>{NAMESPACE}</code> are in.</li>
</ul>
<p>For example, to query for the IP of <a href="#BM_(service)%2Fi">service</a> <code>serviceA</code> in <a href="#BM_(namespace)%2Fi">namespace</a> <code>ns1</code> within a cluster that has the domain name suffix <code>cluster.local</code>, the domain name to query is <code>serviceA.ns1.svc.cluster.local</code>. Alternatively, if the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> doing the querying is ...</p>
<ul>
<li>within the same cluster, the cluster domain suffix can be omitted: <code>serviceA.ns1</code>.</li>
<li>within the same cluster and <a href="#BM_(namespace)%2Fi">namespace</a>, both the <a href="#BM_(namespace)%2Fi">namespace</a> and the cluster domain suffix can be omitted: <code>serviceA</code>.</li>
</ul>
<p>Using DNS for <a href="#BM_(service)%2Fi">service</a> discovery has the following pitfalls:</p>
<ul>
<li><a href="#BM_(service)%2Fi">Service</a> port information isn't included in queries.</li>
<li>Enumerating <a href="#BM_(service)%2Fi">service</a>s isn't possible with DNS.</li>
</ul>
<p>On the plus side, DNS queries can extend outside the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s <a href="#BM_(namespace)%2Fi">namespace</a> and <a href="#BM_(service)%2Fi">service</a>s started after a <a href="#BM_(container)%2Fi">container</a> launches are queryable. These aren't possible when using environment variables for <a href="#BM_(service)%2Fi">service</a> discovery, discussed in the previous section.</p>
<a name="H_Metadata"></a><h3>Metadata</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FMetadata)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FResources)_TOPIC%2F">Kinds/Pod/Resources</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FEnvironment%20Variables)_TOPIC%2F">Kinds/Pod/Environment Variables</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FVolume%20Mounts)_TOPIC%2F">Kinds/Pod/Volume Mounts</a></li>
</ul>
</div>
<p>Information about a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and its <a href="#BM_(container)%2Fi">container</a>s such as ...</p>
<ul>
<li><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> name,</li>
<li><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s,</li>
<li><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> IP,</li>
<li><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(namespace)%2Fi">namespace</a>,</li>
<li><a href="#BM_(node)%2Fi">node</a> running the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>,</li>
<li><a href="#BM_(container)%2Fi">container</a> <a href="#BM_(resource%20limit)%2Fi">resource limit</a>s,</li>
<li>etc..</li>
</ul>
<p>... can all be accessed within the <a href="#BM_(container)%2Fi">container</a> via either a file system mount or environment variables.</p>
<a name="H2_Environment%20Variables"></a><h4>Environment Variables</h4>
<p><a name="BM_(Pods%5C%2FMetadata%20Access%2FEnvironment%20Variables)_TOPIC%2F"></a><strong></strong></p>
<p>All <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> information except for <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s can be assigned to environment variables. The reason for this is that a running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can have its <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s updated but the environment variables within a running <a href="#BM_(container)%2Fi">container</a> can't be updated once that <a href="#BM_(container)%2Fi">container</a> starts (updated <a href="#BM_(label)%2Fi">label</a>s / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s won't show up to the <a href="#BM_(container)%2Fi">container</a>).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>CPU resources can also be dynamically updated without restarting the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> / <a href="#BM_(container)%2Fi">container</a> process. The environment variable for this likely won't update either, but it isn't restricted like <a href="#BM_(label)%2Fi">label</a>s / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s are. There may be other reasons that <a href="#BM_(label)%2Fi">label</a>s / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s aren't allowed. Maybe Linux has a cap on how large a environment variable can be, and there's a realistic possibility that <a href="#BM_(label)%2Fi">label</a>s / <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s can exceed that limit?</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">15m</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">100Ki</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">4Mi</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-comment"># These entries reference values that would normal be "fields" under a running pod</span>
        <span class="hljs-comment"># in Kubernetes. That is, these entries reference paths that you would normally see</span>
        <span class="hljs-comment"># when you inspect a pod in Kubernetes by dumping out its YAML/JSON. For example,</span>
        <span class="hljs-comment"># by running "kubectl get pod my_pod -o yaml" -- it produces a manifest but with</span>
        <span class="hljs-comment"># many more fields (dynamically assigned fields and fields with default values</span>
        <span class="hljs-comment"># filled out).</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAME</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span>  <span class="hljs-comment"># Pulls in "my_pod".</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAMESPACE</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span>  <span class="hljs-comment"># Pulls in the default namespace supplied by Kubernetes.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_IP</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">status.podIP</span>  <span class="hljs-comment"># Pulls in the pod's IP.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NODE_NAME</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">spec.nodeName</span>  <span class="hljs-comment"># Pulls in the name of the node that the pod's running on.</span>
        <span class="hljs-comment"># When referencing resource requests / limits for a container, if you're requesting those</span>
        <span class="hljs-comment"># for a different container than the one the container you're assigning the env var to,</span>
        <span class="hljs-comment"># you'll need to supply a "containerName" field. Otherwise, you can omit the</span>
        <span class="hljs-comment"># "containerName" field.</span>
        <span class="hljs-comment">#</span>
        <span class="hljs-comment"># Resource requests / limits by optionally be provided a "divisor" field, which will</span>
        <span class="hljs-comment"># divide the value before assigning it.</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CPU_REQUEST</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">requests.cpu</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># If you omit this, it'll default to "my-container" anyways.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">5m</span>  <span class="hljs-comment"># Divide by 5 millicores before assigning (15millicores/5millicores=3)</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CPU_LIMIT</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">limits.cpu</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># If you omit this, it'll default to "my-container" anyways.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">5m</span>  <span class="hljs-comment"># Divide by 5 millicores before assigning (100millicores/5millicores=20)</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MEM_REQUEST</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">requests.memory</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># If you omit this, it'll default to "my-container" anyways.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">1Ki</span>  <span class="hljs-comment"># Divide by 1 kibibyte before assigning (100Kebibytes/1Kibibyte=100)</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MEM_LIMIT</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">limits.memory</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># If you omit this, it'll default to "my-container" anyways.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">1Ki</span>  <span class="hljs-comment"># Divide by 1 kibibyte before assigning (4Mebibytes/1Kibibyte=4096)</span>
</code></pre>
<a name="H_Volume%20Mount"></a><h4>Volume Mount</h4>
<p><a name="BM_(Pods%5C%2FMetadata%20Access%2FVolume%20Mount)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Pods%5C%2FMetadata%20Access%2FEnvironment%20Variables)_TOPIC%2F">Pods/Metadata Access/Environment Variables</a></li>
</ul>
</div>
<p>All <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> information can be exposed as a volume mount, where files in that mount map to pieces of information. Unlike with environment variables, a volume mount can contain <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s. If those <a href="#BM_(label)%2Fi">label</a>s and <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s are updated, the relevant files within the mount update to reflect the changes. It's up to the application running within the <a href="#BM_(container)%2Fi">container</a> to detect and reload those updated files.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">drink:</span> <span class="hljs-string">Pepsi</span>
    <span class="hljs-attr">car:</span> <span class="hljs-string">Volvo</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span>
    <span class="hljs-attr">key2:</span> <span class="hljs-string">|
      Good morning,
      Today is Sunday.
</span><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-comment"># A volume of type downwardAPI will populate with files, where each file contains the</span>
    <span class="hljs-comment"># value for a specific field. Fields are specified in a similar manner to the</span>
    <span class="hljs-comment"># environment variable version above.</span>
    <span class="hljs-comment">#</span>
    <span class="hljs-comment"># Each "path" under "items" is file within the volume.</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">downward_vol</span>
      <span class="hljs-attr">downwardAPI:</span>
        <span class="hljs-attr">items:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">podName</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">podNamespace</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">podIp</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">status.podIP</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">nodeName</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">spec.nodeName</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">cpuRequest</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">requests.cpu</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># MUST BE INCLUDED, otherwise it's impossible to know which container.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">5m</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">cpuLimit</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">limits.cpu</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># MUST BE INCLUDED, otherwise it's impossible to know which container.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">5m</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">memRequest</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">requests.memory</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># MUST BE INCLUDED, otherwise it's impossible to know which container.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">1Ki</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">memLimit</span>
            <span class="hljs-attr">resourceFieldRef:</span>
              <span class="hljs-attr">resource:</span> <span class="hljs-string">limits.memory</span>
              <span class="hljs-attr">containerName:</span> <span class="hljs-string">my-container</span>  <span class="hljs-comment"># MUST BE INCLUDED, otherwise it's impossible to know which container.</span>
              <span class="hljs-attr">divisor:</span> <span class="hljs-string">1Ki</span>
          <span class="hljs-comment"># The following two entries supplies labels and annotations. Note that, if labels</span>
          <span class="hljs-comment"># or annotations change for the pod, the files in this volume will be updated to</span>
          <span class="hljs-comment"># reflect those changes.</span>
          <span class="hljs-comment">#</span>
          <span class="hljs-comment"># Each file below will contain multiple key-value entries. One key-value entry per line, where</span>
          <span class="hljs-comment"># the key and value are delimited by an equal sign (=). Values are escaped, so the new lines in</span>
          <span class="hljs-comment"># the multiline example annotation in this pod (see key2, where the value is a good morning</span>
          <span class="hljs-comment"># message) will be appropriately escaped.</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">"labels"</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.labels</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">"annotations"</span>
            <span class="hljs-attr">fieldRef:</span>
              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.annotations</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">requests:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">15m</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">100Ki</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">4Mi</span>
      <span class="hljs-comment"># Mount the volume declared above into the container. The application in the container</span>
      <span class="hljs-comment"># will be able to access the metadata as files within the volume mount.</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">downward_vol</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/metadata</span>
</code></pre>
<a name="H_API%20Access"></a><h3>API Access</h3>
<p><a name="BM_(Kinds%5C%2FPod%2FAPI%20Access)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FService%20Discovery)_TOPIC%2F">Kinds/Pod/Service Discovery</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FConfiguration)_TOPIC%2F">Kinds/Pod/Configuration</a></li>
</ul>
</div>
<p><a href="#BM_(container)%2Fi">Container</a>s within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can access the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server via a <a href="#BM_(service)%2Fi">service</a> called <code>kubernetes</code>, typically found on the default <a href="#BM_(namespace)%2Fi">namespace</a>. Communicating with this <a href="#BM_(service)%2Fi">service</a> requires a certificate check (to verify server isn't a man-in-the-middle box) as well as an access token (to authentication with the <a href="#BM_(service)%2Fi">service</a>). By default, <a href="#BM_(container)%2Fi">container</a>s have a <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a> mounted as a volume at <code>/var/run/secrets/kubernetes.io/serviceaccount</code> that contains both these pieces of data as files:</p>
<ul>
<li><code>ca.crt</code> - certificate used for verifying the server's identity.</li>
<li><code>token</code> - bearer token used for authenticating with the server.</li>
<li><code>namespace</code> - <a href="#BM_(namespace)%2Fi">namespace</a> of the <em><a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a></em> itself (not the <a href="#BM_(namespace)%2Fi">namespace</a> of the <code>kubernetes</code> <a href="#BM_(service)%2Fi">service</a>).</li>
</ul>
<p>In most cases, the credentials provided likely won't provide unfettered access to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/25843058">here</a> for an explanation of bearer tokens. You typically just need to include a HTTP header with the token in it.</p>
<p>Third-party libraries that interface with <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> are available for various languages (e.g. Python, Java, etc..), meaning you don't have to do direct HTTP requests and do things like fiddle with headers.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService%20Account)_TOPIC%2Fi">Kinds/Service Account</a> (Credentials map to a <a href="#BM_(service%20account)%2Fi">service account</a>)</li>
<li><a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">Kind</a>s/<a href="#BM_(API%20Security%5C%2FDisable%20Credentials)_TOPIC%2Fi">API Security/Disable Credentials</a> (Disable mounting of credentials within <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>)</li>
</ul>
</div>
<a name="H_Configuration%20Map"></a><h2>Configuration Map</h2>
<p><a name="BM_(Kinds%5C%2FConfiguration%20Map)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">configuration map</a> is a type of resource comprised of key-value pairs intended to configure the main application of a <a href="#BM_(container)%2Fi">container</a> (or many <a href="#BM_(container)%2Fi">container</a>s). By decoupling configurations from the <a href="#BM_(container)%2Fi">container</a>s themselves, the same <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">configuration map</a> (or parts of it) could be used to configure multiple <a href="#BM_(container)%2Fi">container</a>s within <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FSecret)_TOPIC%2F">Kinds/Secret</a> (Do <strong>NOT</strong> use <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s for storing <a href="#BM_(secret)%2Fi">secret</a>s such as tokens, certificates, or password).</li>
</ul>
</div>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">param1:</span> <span class="hljs-string">another-value</span>
  <span class="hljs-attr">param2:</span> <span class="hljs-string">extra-value</span>
  <span class="hljs-attr">my-config.ini:</span> <span class="hljs-string">|
    # This is a sample config file that I might use to configure an application
    key1 = value1
    ket1 = value2
</span></code></pre>
<p>The key-value pairs of a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">configuration map</a> resource typically get exposed to a <a href="#BM_(container)%2Fi">container</a> either as environment variables, files, or command-line arguments. Keys are limited to certain characters: alphabet, numbers, dashes, underscores, and dots.</p>
<a name="H_Secret"></a><h2>Secret</h2>
<p><a name="BM_(Kinds%5C%2FSecret)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FConfiguration%20Map)_TOPIC%2F">Kinds/Configuration Map</a></li>
</ul>
</div>
<p>A <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a> is a type of resource comprised of key-value pairs, similar to a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>, but oriented towards security rather than just configuration (e.g. for storing things like access tokens, passwords, certificates). As opposed to a <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> takes extra precautions to ensure that a <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a> is stored and used in a secure manner.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>  <span class="hljs-comment"># "Opaque" is the default type (can be omitted)</span>
<span class="hljs-comment"># Both text and binary data are supported. To insert a text entry, place it under</span>
<span class="hljs-comment"># "stringData". To insert a binary entry, base64 the value and place it under "data". </span>
<span class="hljs-attr">stringData:</span>
  <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">pepsi_one</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">key_file:</span> <span class="hljs-string">eWFiYmFkYWJiYWRvbw==</span>  
</code></pre>
<p>Many types of <a href="#BM_(secret)%2Fi">secret</a>s exist. Each type either does some level of verification on the entries and / or acts as a tag to convey what data is contained within (e.g. SSH data, TLS data, etc..). In general <code>Opaque</code> is the <a href="#BM_(secret)%2Fi">secret</a> type used by most applications.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Certain sources are claiming that a <a href="#BM_(secret)%2Fi">secret</a> <a href="#BM_(object)%2Fi">object</a> can be 1 megabyte at most.</p>
</div>
<a name="H_Node"></a><h2>Node</h2>
<p><a name="BM_(Kinds%5C%2FNode)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod)_TOPIC%2Fi">Kinds/Pod</a></li>
</ul>
</div>
<p><a href="#BM_(node)%2Fi">Node</a>s are the machines that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s run on. A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> environment often contains multiple <a href="#BM_(node)%2Fi">node</a>s, each with a certain amount of resources. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>s get assigned to <a href="#BM_(node)%2Fi">node</a>s based on their resource requirements. For example, if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> A requires 2gb of memory and <a href="#BM_(node)%2Fi">node</a> C has 24 gigs available, that <a href="#BM_(node)%2Fi">node</a> may get assigned to run that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p><img src="svgbob_fc6073ce9dd71ac1b2fa56b7775e45eca6d21eaf.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> typically attempts to schedule multiple instances of the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> on different <a href="#BM_(node)%2Fi">node</a>s, such that a downed <a href="#BM_(node)%2Fi">node</a> won't take out all instances of the <a href="#BM_(service)%2Fi">service</a> that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> runs. In the example above, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances of the same type are spread out across the 3 <a href="#BM_(node)%2Fi">node</a>s.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> has a leader-follower architecture, meaning that of the <a href="#BM_(node)%2Fi">node</a>s a small subset is chosen to lead / manage the others. The leaders are referred to as <a href="#BM_(master%20node)%2Fi">master node</a>s while the followers are referred to as <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
<p><img src="svgbob_90abf3344c1d253481a3a392500782cca41f92fd.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BM_(master%20node)%2Fi">master node</a> can still run <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s just like the <a href="#BM_(worker%20node)%2Fi">worker node</a>s, but some of its resources will be tied up for the purpose of managing <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
<a name="H_Volume"></a><h2>Volume</h2>
<p><a name="BM_(Kinds%5C%2FVolume)_TOPIC%2Fi"></a><strong></strong></p>
<p>Volumes are disks where data can be persisted across <a href="#BM_(container)%2Fi">container</a> restarts. Normally, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> resets a <a href="#BM_(container)%2Fi">container</a>'s filesystem each time that <a href="#BM_(container)%2Fi">container</a> restarts (e.g. after a crash or a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> getting moved to a different <a href="#BM_(node)%2Fi">node</a>). While that works for some types of applications, other application types such as database servers need to retain state across restarts.</p>
<p>Volumes in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> are broken down into "<a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s" and "<a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s". A ...</p>
<ul>
<li><a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is the volume itself.</li>
<li><a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> is the assignment of a volume.</li>
</ul>
<p>The idea is that a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> itself is just a floating block of disk space. Only when its claimed does it have an assignment. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>s can then latch on to those assignments.</p>
<p><img src="svgbob_245492e803e908f1ed349aac70d29be295b2b5a1.svg" alt="Kroki diagram output"></p>
<p>In the example above, there are 4 volumes in total but only 3 of those volumes are claimed. podA latches on to claim1 and claim2 while podB latches on to claim3 and claim2 (both <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s can access the volume claimed in claim2).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(persistent%20volume)%2Fi">Persistent volume</a>s themselves are cluster-level resources while <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s are <a href="#BM_(namespace)%2Fi">namespace</a>-level resources. All volumes are available for claims regardless of the <a href="#BM_(namespace)%2Fi">namespace</a> that claim is in. Maybe you can limit which volumes can be claimed by using <a href="#BM_(label)%2Fi">label</a>s / <a href="#BM_(label%20selector)%2Fi">label selector</a>s?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Part of the reasoning for doing it like this is decoupling: volumes are independent from <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s and a volume can be have shared access across <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
<p>Another reasons is that a developer should only be responsible for claiming a volume while the cluster administrator should be responsible for setting up those volumes and dealing with backend details like the specifics of the volume type and how large each volume is. As a developer, you only have to make a "claim" while the administrator is responsible for ensuring those resources exist.</p>
</div>
<p>Example <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> <a href="#BM_(manifest)%2Fi">manifest</a>:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vol</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">capacity:</span>
    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadOnlyMany</span>
  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span>  <span class="hljs-comment"># once a claim on this volume is given up, delete the files on disk</span>
  <span class="hljs-attr">awsElasticBlockStore:</span>
    <span class="hljs-attr">volumeID:</span> <span class="hljs-string">volume-id</span>
    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span>
</code></pre>
<p>Example <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> <a href="#BM_(manifest)%2Fi">manifest</a>:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vol-claim</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>  <span class="hljs-comment"># volume must have at least this much space</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-comment"># volume must have this access mode</span>
  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">""</span>  <span class="hljs-comment"># MUST BE EMPTY STRING to claim test-vol described above (if set, uses dynamic provisioning)</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why must <code>spec.storageClassName</code> be an empty string instead of being removed entirely? Being removed entirely would cause <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to use a default storage class name (if one exists), which is not what you want. Storage classes are described in the next few paragraphs below.</p>
</div>
<p>There are two types of volume provisioning available:</p>
<ul>
<li>static provisioning - a claim is assigned a pre-created <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>.</li>
<li>dynamic provisioning - a claim triggers a new <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> to get created and is assigned to it.</li>
</ul>
<p>Dynamic provisioning only requires that you make a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> with a specific <code>spec.storageClassName</code>. The administrator is responsible for ensuring a provisioner exists for that storage class and it automatically creates a volume of that type when a claim comes in. Each storage class can have different characteristics such as volume type (e.g. HDD vs SSD), volume read/write speeds, backup policies, etc.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">standard</span>
<span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span>
<span class="hljs-attr">parameters:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">gp2</span>
</code></pre>
<a name="H_Capacity"></a><h3>Capacity</h3>
<p><a name="BM_(Kinds%5C%2FVolume%2FCapacity)_TOPIC%2Fi"></a><strong></strong></p>
<p>The capacity of a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is set through <code>spec.capacity.storage</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">capacity:</span>
    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span>
</code></pre>
<p>A <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> can then be set to require a specific amount of capacity via <code>spec.resources.request.storage</code>. Specifically, <code>requests</code> defines the minimum required capacity and <code>limits</code> defines the maximum required capacity.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>  <span class="hljs-comment"># volume must have at least this much space</span>
    <span class="hljs-attr">limits:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span>  <span class="hljs-comment"># volume can't have more than this much space</span>
</code></pre>
<a name="H_Access%20Modes"></a><h3>Access Modes</h3>
<p><a name="BM_(Kinds%5C%2FVolume%2FAccess%20Modes)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> can support multiple access modes:</p>
<ul>
<li><code>ReadWriteOnce</code> - volume is mountable by a single <a href="#BM_(node)%2Fi">node</a> in read-write mode.</li>
<li><code>ReadWriteOncePod</code> - volume is mountable by a single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> in read-write mode.</li>
<li><code>ReadWriteMany</code> - volume is mountable by many <a href="#BM_(node)%2Fi">node</a>s in read-write mode.</li>
<li><code>ReadOnlyMany</code> - volume is mountable by many <a href="#BM_(node)%2Fi">node</a>s in read-only mode.</li>
</ul>
<p>The available access modes of a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is set through <code>spec.accessModes</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadOnlyMany</span>
</code></pre>
<p>A <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> can then be set to target on or more access modes.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">accessModes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-comment"># volume must have this access mode</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A claim takes a list of access modes, so is it that a claim needs to get a volume with all access modes present or just one of the access modes present?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not all <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> types support all access modes. Types are discussed further below.</p>
</div>
<a name="H_Reclaim%20Policy"></a><h3>Reclaim Policy</h3>
<p><a name="BM_(Kinds%5C%2FVolume%2FReclaim%20Policy)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>, once released, may or may not make the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>able again depending on what <code>spec.persistentVolumeReclaimPolicy</code> was set to.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span> 
</code></pre>
<p>The options available are ...</p>
<ul>
<li><code>Retain</code> - keep all existing data on the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> and prevent a new <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> from claiming it again.</li>
<li><code>Recycle</code> - delete all existing data on the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> and allow a new <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> to claim it again.</li>
<li><code>Delete</code> - delete the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> <a href="#BM_(object)%2Fi">object</a> itself.</li>
</ul>
<p>If the data on disk is critical to operations, the option to choose will likely be <code>Retain</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For retain specifically, once the existing <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> is released, the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> itself goes into "Released" status. If it were available reclamation, it would go into "Available" status. The book mentions that there is no way to "recycle" a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> that's in "Released" status without destroying and recreating it.</p>
<p>According to the k8s docs, this is the way it is so that users have a chance to manually pull out data considered precious before it gets destroyed.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not all <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> types support all reclaim policies. Types are discussed further below.</p>
</div>
<a name="H_Types"></a><h3>Types</h3>
<p><a name="BM_(Kinds%5C%2FVolume%2FTypes)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> needs to come from somewhere, either via a cloud provider or using some internally networked (or even local) disks. There are many volume types: AWS elastic block storage, Azure file, Azure Disk, GCE persistent disk, etc.. Each type has its own set of restrictions such as what access modes it supports or the types of <a href="#BM_(node)%2Fi">node</a>s it can be mounted.</p>
<p>The configuration for each type is unique and goes directly under <code>spec</code>. The following are sample configurations for popular types...</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The documentation says that a lot of these types are deprecated and being moved over to something called CSI (<a href="#BM_(container)%2Fi">container</a> storage interface), so these examples may need to be updated in the future</p>
</div>
<pre class="hljs"><code><span class="hljs-comment"># Amazon Elastic Block Storage</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">awsElasticBlockStore:</span>
    <span class="hljs-attr">volumeID:</span> <span class="hljs-string">volume-id</span>  <span class="hljs-comment"># a volume with this ID must already exist in AWS</span>
    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># Google Compute Engine Persistent Disk</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">gcePersistentDisk:</span>
    <span class="hljs-attr">pdName:</span> <span class="hljs-string">test-vol</span>  <span class="hljs-comment"># a disk with this name must already exist in GCE</span>
    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># Azure Disk</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">azureDisk:</span>
    <span class="hljs-comment"># a volume with this name and URI must already exist in Azure</span>
    <span class="hljs-attr">diskName:</span> <span class="hljs-string">test.vhd</span>
    <span class="hljs-attr">diskURI:</span> <span class="hljs-string">https://someaccount.blob.microsoft.net/vhds/test.vhd</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># Host path</span>
<span class="hljs-comment">#   -- this is a path on the node that the pod gets scheduled on, useful</span>
<span class="hljs-comment">#      for debugging purposes.</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hostPath:</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">/data</span>
</code></pre>
<a name="H_Storage%20Classes"></a><h3>Storage Classes</h3>
<p><a name="BM_(Kinds%5C%2FVolume%2FStorage%20Classes)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FVolume%2FReclaim%20Policy)_TOPIC%2Fi">Kinds/Volume/Reclaim Policy</a></li>
<li><a href="#BM_(Kinds%5C%2FVolume%2FTypes)_TOPIC%2Fi">Kinds/Volume/Types</a></li>
</ul>
</div>
<p>Defining a storage class allows for dynamic provisioning of <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s per <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">standard</span>
<span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span>
<span class="hljs-attr">parameters:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">gp2</span>
<span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Retain</span>
<span class="hljs-attr">allowVolumeExpansion:</span> <span class="hljs-literal">true</span>
</code></pre>
<p><code>provisioner</code> and <code>parameters</code> define how <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s are to be created and are unique to each volume type. In the example above, the storage class is named <code>standard</code> and it provisions new <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s on AWS. Any <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> with <code>spec.storageClassName</code> set to <code>standard</code> will call out to this AWS elastic store provisioner to create a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> of type <code>awsElasticBlockStore</code> which gets assigned to it.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vol-claim</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>
  <span class="hljs-attr">accessModes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">standard</span>  <span class="hljs-comment"># use the storage class described above for this claim</span>
</code></pre>
<p>If <code>allowVolumeExpansion</code> is set to <code>true</code>, the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> can be resized by editing the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> <a href="#BM_(object)%2Fi">object</a>. Only some volume types support volume expansion. The example above will work because AWS elastic block store volume types do support volume expansion.</p>
<p><code>reclaimPolicy</code> maps to a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>'s <code>spec.persistentVolumeReclaimPolicy</code>, except that <code>Recycle</code> isn't one of the allowed options: only <code>Delete</code> and <code>Retain</code> are allowed.If unset, the reclaim policy of a dynamically provisioned <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is <code>Delete</code>. The example above overrides the reclaim policy to <code>Retain</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Since these <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s are being dynamically provisioned, it doesn't make sense to have <code>Recycle</code>. You can just <code>Delete</code> and if a new claim comes in it'll automatically provision a new volume. It's essentially the same thing as <code>Recycle</code>.</p>
</div>
<p>If a <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> leaves <code>spec.storageClassName</code> unset, the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> will use whatever storage class <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> has set as its default. Recall that leaving <code>spec.storageClassName</code> unset is <em>not</em> the same as leaving it as an empty string. To leave unset means to keep it out of the declaration entirely. If <code>spec.storageClassName</code> is ...</p>
<ul>
<li>set to an empty string, it tells <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to find any <em>existing</em> <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> for the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</li>
<li>set to a non-empty string, it tells <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to use that storage class to dynamically provision a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> for the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</li>
<li>unset, it tells <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> to use the default storage class to dynamically provision a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> for the <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>.</li>
</ul>
<p>Most <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> installations have a default storage class available, identified by the storage class having the <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> <code>storageclass.kubernetes.io/is-default-class=true</code>.</p>
<pre><code># kubectl get sc
# Note how the name identifies it as the default.
NAME                          PROVISIONER            RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
microk8s-hostpath (default)   microk8s.io/hostpath   Delete          WaitForFirstConsumer   false                  6s
</code></pre>
<pre class="hljs"><code><span class="hljs-comment"># kubectl get sc microk8s-hostpath -o yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="hljs-string">|
      {"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"},"name":"microk8s-hostpath"},"provisioner":"microk8s.io/hostpath","volumeBindingMode":"WaitForFirstConsumer"}
</span>    <span class="hljs-attr">storageclass.kubernetes.io/is-default-class:</span> <span class="hljs-string">"true"</span>
  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">"2022-07-22T19:41:28Z"</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">microk8s-hostpath</span>
  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">"2775"</span>
  <span class="hljs-attr">uid:</span> <span class="hljs-string">1df92cbc-6e2f-4726-a487-a81b1fcd8d2b</span>
<span class="hljs-attr">provisioner:</span> <span class="hljs-string">microk8s.io/hostpath</span>
<span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span>
<span class="hljs-attr">volumeBindingMode:</span> <span class="hljs-string">WaitForFirstConsumer</span>
</code></pre>
<a name="H_Endpoints"></a><h2>Endpoints</h2>
<p><a name="BM_(Kinds%5C%2FEndpoints)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(endpoints)%2Fi">Endpoints</a> (plural) is a <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that simply holds a list of IP addresses and ports. It's used by higher-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s to simplify routing. For example, an <a href="#BM_(endpoints)%2Fi">endpoints</a> resource may direct to all the <a href="#BM_(node)%2Fi">node</a>s that make up a sharded database server.</p>
<p>Example <a href="#BM_(manifest)%2Fi">manifest</a>:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">database</span>
<span class="hljs-attr">subsets:</span> 
  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5432</span> 
        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-comment"># TCP or UDP, default: TCP</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">pg</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.13</span><span class="hljs-number">.4</span><span class="hljs-number">.101</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.13</span><span class="hljs-number">.4</span><span class="hljs-number">.102</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.13</span><span class="hljs-number">.4</span><span class="hljs-number">.103</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">12345</span>
        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-comment"># TCP or UDP, default: TCP</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">pg2</span>
</code></pre>
<p>The <a href="#BM_(endpoints)%2Fi">endpoints</a> example above points to ...</p>
<ul>
<li><code>10.10.1.1:5432</code></li>
<li><code>10.10.1.2:5432</code></li>
<li><code>10.10.1.3:5432</code></li>
<li><code>10.13.4.101:12345</code></li>
<li><code>10.13.4.102:12345</code></li>
<li><code>10.13.4.103:12345</code></li>
</ul>
<a name="H_Service"></a><h2>Service</h2>
<p><a name="BM_(Kinds%5C%2FService)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(service)%2Fi">Service</a>s are a discovery and load balancing mechanism. A <a href="#BM_(service)%2Fi">service</a> exposes a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s under a single fixed unified hostname and IP, routing traffic to that set by load balancing incoming requests across the set. Any external application would need to use a <a href="#BM_(service)%2Fi">service</a>'s hostname because the IP / host of the single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances aren't fixed, exposed, or known. That is, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are transient and aren't guaranteed to always reside on the same <a href="#BM_(node)%2Fi">node</a>. As they shutdown, come up, restart, move between <a href="#BM_(node)%2Fi">node</a>s, etc.., there's no implicit mechanism that requestors can use to route their requests accordingly.</p>
<p>A <a href="#BM_(service)%2Fi">service</a> fixes this my internally tracking such changes and providing a single unified point of access.</p>
<p><img src="svgbob_9fcafa853ed3eccdae11b6e4d860f6208b276d0e.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions why DNS can't be used directly. For example, having a basic DNS <a href="#BM_(service)%2Fi">service</a> which returns a list of all up-and-running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> IPs won't work because ...</p>
<ol>
<li>applications and operating systems often cache DNS results, meaning that changes won't be visible immediately.</li>
<li>applications often only use the first IP given back by a DNS result, meaning that requests won't balance.</li>
</ol>
<p>The <a href="#BM_(service)%2Fi">service</a> fixes this because it acts as a load balancing proxy and its IP / host never changes (DNS caching won't break anything).</p>
</div>
<p>Example <a href="#BM_(manifest)%2Fi">manifest</a>:</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Internally, an <a href="#BM_(endpoints)%2Fi">EndPoints</a> <a href="#BM_(object)%2Fi">object</a> is used to track <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. When you create a <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> automatically creates an accompanying <a href="#BM_(endpoints)%2Fi">EndPoints</a> <a href="#BM_(object)%2Fi">object</a> that the <a href="#BM_(service)%2Fi">service</a> makes use of.</p>
</div>
<a name="H_Routing"></a><h3>Routing</h3>
<p><a name="BM_(Kinds%5C%2FService%2FRouting)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Introduction%5C%2FLabels)_TOPIC%2Fi">Introduction/Labels</a></li>
<li><a href="#BM_(Kinds%5C%2FEndpoints)_TOPIC%2Fi">Kinds/Endpoints</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> determines which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s it should route traffic to via the <code>spec.selector</code> <a href="#BM_(manifest)%2Fi">manifest</a> path. This <a href="#BM_(manifest)%2Fi">manifest</a> path contains key-value mappings, where these key-value mappings are <a href="#BM_(label)%2Fi">label</a>s that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> needs before being considered for this <a href="#BM_(service)%2Fi">service</a>'s traffic ...</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">key1:</span> <span class="hljs-string">value1</span>
    <span class="hljs-attr">key2:</span> <span class="hljs-string">value2</span>
    <span class="hljs-attr">key3:</span> <span class="hljs-string">value3</span>
</code></pre>
<p>Internally, the <a href="#BM_(service)%2Fi">service</a> creates and manages an <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(object)%2Fi">object</a> containing the IP and port for each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> captured by the selector. If no selectors are present, the <a href="#BM_(service)%2Fi">service</a> expects an <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(object)%2Fi">object</a> with the same name to exist, where that <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(object)%2Fi">object</a> contains the list of IP and port pairs that the <a href="#BM_(service)%2Fi">service</a> should route to.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">database</span>  <span class="hljs-comment"># must be same name as the service</span>
<span class="hljs-attr">subsets:</span> 
  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5432</span>
</code></pre>
<p>If no selectors are present but <code>spec.type</code> is set to <code>ExternalName</code>, the <a href="#BM_(service)%2Fi">service</a> will route to the host specified in <code>spec.externalName</code>. This is useful for situations where you want to hide the destination, such as an external API that you also want to mock for development / testing.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ExternalName</span>
  <span class="hljs-attr">externalName:</span> <span class="hljs-string">api.externalcompany.com</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">api-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5000</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If not set, <code>spec.type</code> defaults to <code>ClusterIP</code>. That's the type used when selectors are used to create an <a href="#BM_(endpoints)%2Fi">endpoints</a> / a custom <a href="#BM_(endpoints)%2Fi">endpoints</a> is used.</p>
</div>
<a name="H1_Ports"></a><h3>Ports</h3>
<p><a name="BM_(Kinds%5C%2FService%2FPorts)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FPorts)_TOPIC%2F">Kinds/Pod/Ports</a></li>
<li><a href="#BM_(Kinds%5C%2FService%2FRouting)_TOPIC%2Fi">Kinds/Service/Routing</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> can listen on multiple ports, controlled via the <code>spec.ports</code> <a href="#BM_(manifest)%2Fi">manifest</a> path.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">api-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">1111</span>
    <span class="hljs-string">...</span>
</code></pre>
<ul>
<li><code>name</code> is a friendly name to identify the port (optional)</li>
<li><code>protocol</code> is either <code>TCP</code> or <code>UDP</code> (defaults to <code>TCP</code>).</li>
<li><code>port</code> is the port that the <a href="#BM_(service)%2Fi">service</a> listens on.</li>
<li><code>targetPort</code> is the port that requests are forwarded to on the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>  (defaults to value set for <code>port</code>).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not having a name makes it more difficult for <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to discover a <a href="#BM_(service)%2Fi">service</a>. Discussed further in the <a href="#BM_(service)%2Fi">service</a> discovery section.</p>
</div>
<p>The example above forwards requests on two ports. Requests on port ...</p>
<ul>
<li>80 of the <a href="#BM_(service)%2Fi">service</a> get forwarded to port 9376 of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> assigned to that <a href="#BM_(service)%2Fi">service</a>.</li>
<li>8080 of the <a href="#BM_(service)%2Fi">service</a> get forwarded to port 1111 of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> assigned to that <a href="#BM_(service)%2Fi">service</a>.</li>
</ul>
<p>Ports may also reference the names of ports in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(manifest)%2Fi">manifest</a>. For example, imagine the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(manifest)%2Fi">manifest</a> for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> assigned to a <a href="#BM_(service)%2Fi">service</a> provides names for its ports.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-http-port</span>
          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-string">...</span>
</code></pre>
<p>In the <a href="#BM_(service)%2Fi">service</a> for that targets this <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(manifest)%2Fi">manifest</a>, you can use <code>my_http_port</code> as a <code>targetPort</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp-port</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-string">my-http-port</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Does this work for manual <a href="#BM_(endpoints)%2Fi">endpoints</a> as well? When a selector isn't used with a <a href="#BM_(service)%2Fi">service</a>, it looks for an <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(object)%2Fi">object</a> of the same name as the <a href="#BM_(service)%2Fi">service</a> to figure out where the <a href="#BM_(service)%2Fi">service</a> should route to. That <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(object)%2Fi">object</a> can have names associated with its ports as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A <a href="#BM_(service)%2Fi">service</a> decides which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s it routes to based key-value pairs in on <code>spec.selector</code>. What happens if the key-value pairs identify a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances where some of those instances don't have a port named <code>my-http-port</code>. For example, a <a href="#BM_(service)%2Fi">service</a> may be forwarding to two applications rather than a single application which just could be sharing the same set of key-value <a href="#BM_(label)%2Fi">label</a>s (<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances are heterogenous).</p>
<p>Maybe this isn't possible with <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>?</p>
</div>
<a name="H_Health"></a><h3>Health</h3>
<p><a name="BM_(Kinds%5C%2FService%2FHealth)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FProbes)_TOPIC%2F">Kinds/Pod/Probes</a></li>
<li><a href="#BM_(Kinds%5C%2FService%2FRouting)_TOPIC%2Fi">Kinds/Service/Routing</a></li>
</ul>
</div>
<p>The <a href="#BM_(service)%2Fi">service</a> periodically probes the status of each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to determine if it can handle requests or not. Two types of probes are performed:</p>
<ul>
<li><a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s - When an existing instance of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails a user-defined test that checks if it's still running, the <a href="#BM_(service)%2Fi">service</a> stops routing traffic to it.</li>
<li><a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s - When a new instance of a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> comes up, the <a href="#BM_(service)%2Fi">service</a> won't route traffic to it until it passes a user-defined test that says it's ready.</li>
</ul>
<p>These probes are defined directly in the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(manifest)%2Fi">manifest</a>.</p>
<p><img src="svgbob_4db118f49983e7aa72c7b4a50af69abf5161819b.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that, when a <a href="#BM_(service)%2Fi">service</a> has selectors assigned, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> internally maintains an <a href="#BM_(endpoints)%2Fi">EndPoints</a> <a href="#BM_(object)%2Fi">object</a> that contains the addresses of ready and healthy <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. The addresses in this <a href="#BM_(endpoints)%2Fi">endpoints</a> <a href="#BM_(object)%2Fi">object</a> is what the <a href="#BM_(service)%2Fi">service</a> routes to.</p>
</div>
<a name="H_Headless"></a><h3>Headless</h3>
<p><a name="BM_(Kinds%5C%2FService%2FHeadless)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService%2FRouting)_TOPIC%2Fi">Kinds/Service/Routing</a></li>
<li><a href="#BM_(Kinds%5C%2FService%2FHealth)_TOPIC%2Fi">Kinds/Service/Health</a></li>
</ul>
</div>
<p>A <a href="#BM_(service)%2Fi">service</a> that's headless is one which there is no load balancer forwarding requests to <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s / <a href="#BM_(endpoints)%2Fi">endpoints</a>. Instead, the domain for the <a href="#BM_(service)%2Fi">service</a> will resolve a list of ready IPs for the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (or <a href="#BM_(endpoints)%2Fi">endpoints</a>) that the <a href="#BM_(service)%2Fi">service</a> is for.</p>
<p>To create a headless <a href="#BM_(service)%2Fi">service</a>, set <code>spec.clusterIP</code> <a href="#BM_(manifest)%2Fi">manifest</a> path to <code>None</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span>
</code></pre>
<p>Generally, headless <a href="#BM_(service)%2Fi">service</a>s shouldn't be used because DNS queries are typically cached by the operating system. If the IPs that a <a href="#BM_(service)%2Fi">service</a> forwards to change, apps that have recently queried the <a href="#BM_(service)%2Fi">service</a>'s DNS will continue to use the old (cached) set of IPs until the operating system purges its DNS cache.</p>
<a name="H_Session%20Affinity"></a><h3>Session Affinity</h3>
<p><a name="BM_(Kinds%5C%2FService%2FSession%20Affinity)_TOPIC%2Fi"></a><strong></strong></p>
<p>How a <a href="#BM_(service)%2Fi">service</a> decides to forward incoming requests to the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances assigned to it is controlled via <code>spec.sessionAffinity</code> <a href="#BM_(manifest)%2Fi">manifest</a> path. Assigning a value of ...</p>
<ul>
<li><code>None</code> forwards each request to a randomly selected <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instance (default behaviour).</li>
<li><code>ClientIP</code> forwards each request originating from the same IP to the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instance.</li>
</ul>
<p>When using <code>ClientIP</code>, you may also provide a maximum session "sticky time" via the <a href="#BM_(manifest)%2Fi">manifest</a> path <code>spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>. By default, this value is set to 108300 (around 3 hours).</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">ClientIP</span>
  <span class="hljs-attr">sessionAffinityConfig:</span>
    <span class="hljs-attr">clientIP:</span>
      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">10000</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>When using <code>ClientIP</code>? What happens when the <a href="#BM_(service)%2Fi">service</a> runs out memory to track client IPs? LRU algorithm to decide which to keep / discard?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions that because <a href="#BM_(service)%2Fi">service</a>s work on the TCP/UDP level and not at HTTP/HTTPS level, forwarding requests by tracking session cookies isn't a thing.</p>
</div>
<a name="H_Exposure"></a><h3>Exposure</h3>
<p><a name="BM_(Kinds%5C%2FService%2FExposure)_TOPIC%2Fi"></a><strong></strong></p>
<p>The <a href="#BM_(service)%2Fi">service</a> type defines where and how a <a href="#BM_(service)%2Fi">service</a> gets exposed, controlled via the <code>spec.type</code> <a href="#BM_(manifest)%2Fi">manifest</a> path. For example, a <a href="#BM_(service)%2Fi">service</a> may only be accessible within the cluster, to specific parts of the cluster, to an external network, or to the public Internet.</p>
<p>If not specified, the <code>spec.type</code> of a resource is <code>ClusterIP</code>, meaning that it's exposed only locally within the cluster.</p>
<a name="H_Local"></a><h4>Local</h4>
<p><a name="BM_(Kinds%5C%2FService%2FExposure%2FLocal)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService%2FRouting)_TOPIC%2Fi">Kinds/Service/Routing</a></li>
</ul>
</div>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>ClusterIP</code> / <code>ExternalName</code> are only accessible from within the cluster. The hostname of such <a href="#BM_(service)%2Fi">service</a>s are broken down as follows: NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a>.svc.CLUSTER</p>
<ul>
<li><em>NAME</em> is the name of the <a href="#BM_(service)%2Fi">service</a>.</li>
<li><em><a href="#BM_(namespace)%2Fi">NAMESPACE</a></em> is the <a href="#BM_(namespace)%2Fi">namespace</a> the <a href="#BM_(service)%2Fi">service</a> is in (defaults to <code>default</code>).</li>
<li>svc is a constant that identifies the host is for a <a href="#BM_(service)%2Fi">service</a>.</li>
<li><em>CLUSTER</em> is the name of the cluster (defaults to <code>cluster.local.</code>).</li>
</ul>
<p>Depending on what level you're working in, a hostname may be shortened. For example, if the requestor and the <a href="#BM_(service)%2Fi">service</a> are within ...</p>
<ul>
<li>the same <a href="#BM_(namespace)%2Fi">namespace</a> and cluster, hostname NAME is sufficient.</li>
<li>the same cluster but not the same <a href="#BM_(namespace)%2Fi">namespace</a>, hostname NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a> is sufficient.</li>
<li>different clusters, the full hostname NAME.<a href="#BM_(namespace)%2Fi">NAMESPACE</a>.svc.CLUSTER is required.</li>
</ul>
<p>The IP for a <code>ClusterIP</code> / <code>ExternalName</code> <a href="#BM_(service)%2Fi">service</a> is stable as well, just like the hostname.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Internally, a <code>ClusterIP</code> <a href="#BM_(service)%2Fi">service</a> uses <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">kube-proxy</a> to route requests to relevant <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (<a href="#BM_(endpoints)%2Fi">EndPoints</a>).</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>
</code></pre>
<a name="H_Node%20Port"></a><h4>Node Port</h4>
<p><a name="BM_(Kinds%5C%2FService%2FExposure%2FNode%20Port)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>NodePort</code> are accessible from outside the cluster. Every <a href="#BM_(worker%20node)%2Fi">worker node</a> opens a port (either user-defined or assigned by the system) that routes requests to the <a href="#BM_(service)%2Fi">service</a>. Since <a href="#BM_(node)%2Fi">node</a>s are transient, there is no single point of access to the <a href="#BM_(service)%2Fi">service</a>.</p>
<p>When <code>NodePort</code> is used as the type, the <a href="#BM_(manifest)%2Fi">manifest</a> path <code>spec.ports[].nodePort</code> defines the port on the <a href="#BM_(worker%20node)%2Fi">worker node</a> to open.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
</code></pre>
<a name="H_Load%20Balancer"></a><h4>Load Balancer</h4>
<p><a name="BM_(Kinds%5C%2FService%2FExposure%2FLoad%20Balancer)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(service)%2Fi">Service</a>s of type <code>LoadBalancer</code> are accessible from outside the cluster. When the <code>LoadBalancer</code> type is used, the cloud provider running the cluster assigns their version of a load balancer to route external HTTP requests to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(ingress)%2Fi">Ingress</a> component. <a href="#BM_(ingress)%2Fi">Ingress</a> then determines what <a href="#BM_(service)%2Fi">service</a> that request should be routed to based on details within the HTTP parameters (e.g. Host).</p>
<p>There is no built-in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> implementation of <a href="#BM_(ingress)%2Fi">Ingress</a>. <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> provides the interface but someone must provide the implementation, called an <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(controller)%2Fi">controller</a>, for the functionality to be there. The reason for this is that load balancers come in multiple forms: software load balancers, cloud provider load balancers, and hardware load balancers. When used directly, each has a unique way it needs to be configured, but the <a href="#BM_(ingress)%2Fi">Ingress</a> implementation abstracts that out.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
</code></pre>
<p>Once provisioned, the <a href="#BM_(object)%2Fi">object</a> will have the <a href="#BM_(manifest)%2Fi">manifest</a> path <code>status.loadBalancer.ingress.ip[]</code> added to it, which states the IP of the load balancer forwarding requests to this <a href="#BM_(service)%2Fi">service</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span>
    <span class="hljs-string">...</span>
<span class="hljs-attr">status:</span>
  <span class="hljs-attr">loadBalancer:</span>
    <span class="hljs-attr">ingress:</span>
      <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You can also use <code>kubectl</code> to get a list of <a href="#BM_(service)%2Fi">service</a>s and it'll also list out the public IP.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book says that a load balancer type is a special case of <a href="#BM_(node)%2Fi">node</a> port type.</p>
</div>
<a name="H_Ingress"></a><h2>Ingress</h2>
<p><a name="BM_(Kinds%5C%2FIngress)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService)_TOPIC%2Fi">Kinds/Service</a></li>
</ul>
</div>
<p>Similar to a <a href="#BM_(service)%2Fi">service</a> of type <code>LoadBalancer</code>, An <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(object)%2Fi">object</a> is a load balancer with a publicly exposed IP. However, rather than load balancing at the TCP/UDP level, an <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(object)%2Fi">object</a> acts as a load balancing HTTP proxy server. An HTTP request coming into an <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(object)%2Fi">object</a> gets routed to one of many existing <a href="#BM_(service)%2Fi">service</a>s based on host and path HTTP headers. This is useful because the cluster can expose several <a href="#BM_(service)%2Fi">service</a>s under a single public IP address.</p>
<p><img src="svgbob_c46d77a103ab5604a9b3449315c51ef9e97a8f5d.svg" alt="Kroki diagram output"></p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-ingress</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">stats.myhost.com</span>
    <span class="hljs-attr">http:</span>
      <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/graphana</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">graphana-service</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">api.myhost.com</span>
    <span class="hljs-attr">http:</span>
      <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/v2</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/v1</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v1</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>According to the book, most if not all implementations of <a href="#BM_(ingress)%2Fi">Ingress</a> simply query the <a href="#BM_(service)%2Fi">service</a> for its <a href="#BM_(endpoints)%2Fi">endpoints</a> and directly load balance across them vs forwarding the request through that <a href="#BM_(service)%2Fi">service</a>. Note that the port in the example above is still the port that the <em><a href="#BM_(service)%2Fi">service</a></em> is listening on, not the port of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is listening on.</p>
</div>
<a name="H_Hosts"></a><h3>Hosts</h3>
<p><a name="BM_(Kinds%5C%2FIngress%2FHosts)_TOPIC%2Fi"></a><strong></strong></p>
<p>The host in each rule can be either an exact host or it could contain wildcards (e.g. <code>*.api.myhost.com</code>). Each name in the host (split by dot) intended for a wildcard should explicitly have an asterisk in its place. The portion the asterisk is in must exist and it only covers that name. For example, the rule below will match <code>ONE.api.myhost.com</code>, but not <code>TWO.THREE.api.myhost.com</code> or <code>api.myhost.com</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">"*.api.myhost.com"</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/v2</span>
      <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
      <span class="hljs-attr">backend:</span>
        <span class="hljs-attr">service:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
          <span class="hljs-attr">port:</span>
            <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<a name="H_Path%20Type"></a><h3>Path Type</h3>
<p>Each rule entry should have a path type associated with it. It can be set to any of the following values:</p>
<ul>
<li><code>Exact</code> - Matches the URL path exactly (case sensitive).</li>
<li><code>Prefix</code> - Matches the URL path prefix (case sensitive).</li>
<li><code>ImplementationSpecific</code> - Based on the class of the <a href="#BM_(ingress)%2Fi">Ingress</a> resource.</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">api.myhost.com</span>
    <span class="hljs-attr">http:</span>
      <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/my/prefix/path</span>
        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
        <span class="hljs-attr">backend:</span>
          <span class="hljs-attr">service:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">api-service-v2</span>
            <span class="hljs-attr">port:</span>
              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<p>The most common path type is <code>Prefix</code>. A type of <code>Prefix</code> splits the path using <code>/</code> and matches the rule if the incoming request's path starts with the same path elements as the rule's path. Trailing slashes are ignored (e.g. <code>/p1/p2/p3/</code> and <code>/p1/p2/p3</code> are equivalent).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What about <code>ImplementationSpecific</code>? There are different types of <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(controller)%2Fi">controller</a>s, each of which has its own configuration options. An <a href="#BM_(ingress)%2Fi">Ingress</a> class is something you can put into your <a href="#BM_(ingress)%2Fi">Ingress</a> resource that contains "configuration including the name of the <a href="#BM_(controller)%2Fi">controller</a> that should implement the class." It seems like an advanced topic and I don't know enough to write about it. Probably not something you have to pat attention to if you're doing basic cloud stuff.</p>
</div>
<a name="H_TLS%20Traffic"></a><h3>TLS Traffic</h3>
<p><a name="BM_(Kinds%5C%2FIngress%2FTLS%20Traffic)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FConfiguration)_TOPIC%2F">Kinds/Pod/Configuration</a></li>
</ul>
</div>
<p>Assuming you have a TLS certificate and key files for the host configured on the <a href="#BM_(ingress)%2Fi">Ingress</a> resource, you can add those into <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> as a <a href="#BM_(secret)%2Fi">secret</a> and configure the <a href="#BM_(ingress)%2Fi">Ingress</a> resource to make use of it.</p>
<pre class="hljs"><code><span class="hljs-comment"># openssl genrsa -out tls.key 2048</span>
<span class="hljs-comment"># openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj /CN=api.myhost.com</span>
<span class="hljs-comment"># kubectl create secret tls my-api-tls --cert=tls.crt --key=tls.key</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-api-tls</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/tls</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">tls.crt:</span> <span class="hljs-string">base64</span> <span class="hljs-string">encoded</span> <span class="hljs-string">cert</span>
  <span class="hljs-attr">tls.key:</span> <span class="hljs-string">base64</span> <span class="hljs-string">encoded</span> <span class="hljs-string">key</span>
</code></pre>
<p>For each certificate <a href="#BM_(secret)%2Fi">secret</a> intended to be used by the <a href="#BM_(ingress)%2Fi">Ingress</a> resource, there should be an array entry under the <code>spec.tls[]</code> <a href="#BM_(manifest)%2Fi">manifest</a> path. The certificate <a href="#BM_(secret)%2Fi">secret</a> name must be placed under <code>secretName</code> and the domain(s) supported by that certificate must be listed under <code>hosts</code>. Hosts must match hosts explicitly listed un the <a href="#BM_(ingress)%2Fi">Ingress</a> resource's rules.</p>
<pre class="hljs"><code><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">tls:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">api.myhost.com</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-api-tls</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">stats.myhost.com</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-stats-tls</span>
</code></pre>
<p>Once an encrypted request comes in to the <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(controller)%2Fi">controller</a>, it's decrypted. That decrypted request then gets forwarded to the <a href="#BM_(service)%2Fi">service</a> it was intended for.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>From the k8s website:</p>
<blockquote>
<p>You need to make sure the TLS <a href="#BM_(secret)%2Fi">secret</a> you created came from a certificate that contains a Common Name (CN), also known as a Fully Qualified Domain Name (FQDN) for https-example.foo.com.</p>
</blockquote>
<blockquote>
<p>Keep in mind that TLS will not work on the default rule because the certificates would have to be issued for all the possible sub-domains. Therefore, hosts in the tls section need to explicitly match the host in the rules section.</p>
</blockquote>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions that <code>CertificateSigningRequest</code> is a special type of <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that will sign certificates for you, if it was set up. You can issue requests via <code>kubectl certificate approve csr_name</code> and it'll either automate it somehow or a human will process it? Not sure exactly what's going on here.</p>
</div>
<a name="H_Namespace"></a><h2>Namespace</h2>
<p><a name="BM_(Kinds%5C%2FNamespace)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(namespace)%2Fi">namespace</a> is a <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> used to avoid resource naming conflicts. For example, it's typical for a <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> cluster to be split up into development, testing, and production <a href="#BM_(namespace)%2Fi">namespace</a>s. Each <a href="#BM_(namespace)%2Fi">namespace</a> can have resources with the same names as those in the other two <a href="#BM_(namespace)%2Fi">namespace</a>s.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">production</span>
</code></pre>
<p><a href="#BM_(namespace)%2Fi">Namespace</a>s are cluster-level resources. This is contrary to most other resource types in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>, which are <a href="#BM_(namespace)%2Fi">namespace</a>-level resources, meaning that a <a href="#BM_(namespace)%2Fi">namespace</a> can be used to disambiguate resources of that type with the same name...</p>
<pre class="hljs"><code><span class="hljs-comment"># These are namespace-level resources</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">testing</span>  <span class="hljs-comment"># put into the testing namespace</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">my_image:v2_alpha5</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">production</span>  <span class="hljs-comment"># put into the production namespace</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">my_image:v1</span>
</code></pre>
<p>If a <a href="#BM_(namespace)%2Fi">namespace</a>-level resource doesn't set a <a href="#BM_(namespace)%2Fi">namespace</a>, the <a href="#BM_(namespace)%2Fi">namespace</a> defaults to <code>default</code>.</p>
<a name="H_Replica%20Set"></a><h2>Replica Set</h2>
<p><a name="BM_(Kinds%5C%2FReplica%20Set)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod)_TOPIC%2Fi">Kinds/Pod</a></li>
<li><a href="#BM_(Kinds%5C%2FVolume)_TOPIC%2Fi">Kinds/Volume</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(replica%20set)%2Fi">Replica set</a>s deprecate a replication <a href="#BM_(controller)%2Fi">controller</a>s.</p>
</div>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a> is an abstraction that's used to ensure a certain number of copies of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> are always up and running. Typical scenarios where <a href="#BM_(replica%20set)%2Fi">replica set</a>s are used include ...</p>
<ul>
<li>sharding (e.g. workers that pull <a href="#BM_(job)%2Fi">job</a> out of a queue for processing).</li>
<li>scale (e.g. micro<a href="#BM_(service)%2Fi">service</a>s that scale horizontally).</li>
<li>redundancy (e.g. leader-follower architectures such as Redis-style replica servers).</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-replicaset</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>  <span class="hljs-comment"># Number of pod copies to run.</span>
  <span class="hljs-comment"># Selectors are label selectors used to identify pods, which match the key-value pairs</span>
  <span class="hljs-comment"># used for pod template labels further down.</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-comment"># A template of the pod to launch when there aren't enough copies currently running.</span>
  <span class="hljs-comment"># Everything under "template" is essentially a pod manifest, except the "apiVersion" and</span>
  <span class="hljs-comment"># "kind" aren't included.</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
      <span class="hljs-comment"># These labels are how this replicate set will determine how many copies are running. It</span>
      <span class="hljs-comment"># will look around for pods with this set of labels.</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
</code></pre>
<p>Recall that, to link <a href="#BM_(object)%2Fi">object</a>s together, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses loosely coupled linkages via <a href="#BM_(label)%2Fi">label</a>s rather than hierarchial parent-child relationships. As such, the <a href="#BM_(pod%20template)%2Fi">pod template</a> should have a unique set of <a href="#BM_(label)%2Fi">label</a>s assigned that the <a href="#BM_(replica%20set)%2Fi">replica set</a> can look for to determine how many instances are running. Regardless of how those instances were launched (via the <a href="#BM_(replica%20set)%2Fi">replica set</a> or something else), the <a href="#BM_(replica%20set)%2Fi">replica set</a> will account for them. In the example above, the <a href="#BM_(replica%20set)%2Fi">replica set</a> determines <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> instances it's responsible for by looking for the <a href="#BM_(label)%2Fi">label</a> named <code>app</code> and ensuring its set to <code>my-app</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>According to the k8s docs, it may be a parent-child relationship. Apparently looking for <a href="#BM_(label)%2Fi">label</a>s is just a initial step to permanently bringing <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s under the control of a specific <a href="#BM_(replica%20set)%2Fi">replica set</a>:</p>
<blockquote>
<p>A ReplicaSet is linked to its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>s via the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>s' metadata.ownerReferences field, which specifies what resource the current <a href="#BM_(object)%2Fi">object</a> is owned by. All <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>s acquired by a ReplicaSet have their owning ReplicaSet's identifying information within their ownerReferences field. It's through this link that the ReplicaSet knows of the state of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>s it is maintaining and plans accordingly.</p>
</blockquote>
<p>What happens when two <a href="#BM_(replica%20set)%2Fi">replica set</a>s try "owning" the same <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>?</p>
</div>
<p>A <a href="#BM_(replica%20set)%2Fi">replica set</a>'s <a href="#BM_(job)%2Fi">job</a> is to ensure that a certain number of copies of a <a href="#BM_(pod%20template)%2Fi">pod template</a> are running. It won't retain state between its copies or do any advanced orchestration. Specifically, a <a href="#BM_(replica%20set)%2Fi">replica set</a> ...</p>
<ul>
<li>won't retain <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> IPs / hostnames across time. Each launched <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will have its own unique IP / hostname, even if it's replacing a downed <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (it won't inherit that downed <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>'s IP / hostname).</li>
<li>will force all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to use a single <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> (if one was specified in the <a href="#BM_(pod%20template)%2Fi">pod template</a>), meaning all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s will use a single volume. For horizontally scalable applications (e.g. micro<a href="#BM_(service)%2Fi">service</a>s, databases, etc..), each running instance of an application typically needs its own persistent storage.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You can distinguish a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> created by a <a href="#BM_(replica%20set)%2Fi">replica set</a> vs one created manually by checking the <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> key <code>kubernetes.io/create-by</code> on the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
<p>If deleting a <a href="#BM_(replica%20set)%2Fi">replica set</a>, use <code>--cascade=false</code> in <code>kubectl</code> if you don't want the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s created by the <a href="#BM_(replica%20set)%2Fi">replica set</a> to get deleted as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi">Kinds/Deployment</a> (Like <a href="#BM_(replica%20set)%2Fi">replica set</a>s but supports rolling updates of an application)</li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi">Kinds/Stateful Set</a> (Like <a href="#BM_(replica%20set)%2Fi">replica set</a>s but supports individual <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s)</li>
</ul>
</div>
<a name="H_Deployment"></a><h2>Deployment</h2>
<p><a name="BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FReplica%20Set)_TOPIC%2Fi">Kinds/Replica Set</a></li>
</ul>
</div>
<p><a href="#BM_(deployment)%2Fi">Deployment</a> are similar to <a href="#BM_(replica%20set)%2Fi">replica set</a>s but make it easy to do rolling updates, where the update happens while the application remains online and still <a href="#BM_(service)%2Fi">service</a>s requests. Old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are transitioned to new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s as a stream instead of all at once, ensuring that the application is responsive throughout the upgrade process. Likewise, they allow for rolling back should an update encounter any problems.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-deployment</span>
<span class="hljs-comment"># The manifest for a deployment builds off the manifest for a replica set. Most replica set</span>
<span class="hljs-comment"># fields are present: Number of copies, label selectors, pod template, etc... In addition,</span>
<span class="hljs-comment"># it supports several other fields specific to doing updates.</span>
<span class="hljs-attr">spec:</span> 
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-attr">template:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my_container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
  <span class="hljs-attr">strategy:</span> <span class="hljs-string">RollingUpdate</span>  <span class="hljs-comment"># How the deployment should perform updates (default value)</span>
</code></pre>
<p>A <a href="#BM_(deployment)%2Fi">deployment</a> provides mechanisms to control how an update happens (e.g. all at once vs gradual), if an update is deemed successful (e.g. maximum amount of time a rollout can take), fail-fast for bad updates, and rollbacks to revert to previous versions. These features are discussed in the subsections below.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The same gotchas with <a href="#BM_(replica%20set)%2Fi">replica set</a>s also apply to <a href="#BM_(deployment)%2Fi">deployment</a>s: all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s will use the same <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> and IPs / hosts aren't retained when <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are replaced.</p>
<p>Like with <a href="#BM_(replica%20set)%2Fi">replica set</a>, you might have to use <code>--cascade=false</code> in <code>kubectl</code> if you don't want the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s created by the <a href="#BM_(deployment)%2Fi">deployment</a> to get deleted as well (unsure about this).</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi">Kinds/Stateful Set</a> (Like <a href="#BM_(replica%20set)%2Fi">replica set</a>s but supports individual <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s)</li>
</ul>
</div>
<a name="H_Updates"></a><h3>Updates</h3>
<p><a name="BM_(Kinds%5C%2FDeployment%2FUpdates)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FProbes)_TOPIC%2F">Kinds/Pod/Probes</a></li>
</ul>
</div>
<p>A <a href="#BM_(deployment)%2Fi">deployment</a> can support one of the two update strategies:</p>
<ul>
<li><code>RollingUpdate</code> - updates <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s piecemeal (default).</li>
<li><code>Recreate</code> - updates by first bringing down all old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s then bringing up all the new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</li>
</ul>
<p><code>Recreate</code> is simple but results in down (a period of time where no <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are running). Most enterprise applications have up-time guarantees and as such require <code>RollingUpdate</code>. <code>RollingUpdate</code> has several options that control the flow and timing of how <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s go down and come up, documented in the example below.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">10</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-attr">template:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my_container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
  <span class="hljs-attr">strategy:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span>
    <span class="hljs-attr">rollingUpdate:</span>
      <span class="hljs-comment"># "maxUnavailable" - During an update, this is the number (or percentage) of pods</span>
      <span class="hljs-comment"># that can be unavailable relative to the number of replicas. Since this deployment</span>
      <span class="hljs-comment"># has 10 replicas, the parameter below is instructing that the number of replicas</span>
      <span class="hljs-comment"># can't go below 8 during an update (at most 2 pods may be unavailable).</span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># If between 0 and 1, this is treated as a percentage of pods (e.g. 0.25 means 25</span>
      <span class="hljs-comment"># percent of pods may be unavailable during an update). </span>
      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">2</span>
      <span class="hljs-comment"># "maxSurge" - During an update, this is the number (or percentage) of excess pods</span>
      <span class="hljs-comment"># that can be available relative to the number of replicas. Since this deployment</span>
      <span class="hljs-comment"># has 10 replicas, the parameter below is instructing that the number of replicas</span>
      <span class="hljs-comment"># can't go above 12 during an update (at most 2 pods extra pods may be running).</span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># If between 0 and 1, this is treated as a percentage of pods (e.g. 0.25 means 25</span>
      <span class="hljs-comment"># percent of pods may be unavailable during an update). </span>
      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">2</span>
      <span class="hljs-comment"># "minReadySeconds" - Once all of the readiness probes of a new pod succeed, this</span>
      <span class="hljs-comment"># is the number of seconds to wait before the deployment deems that the pod has</span>
      <span class="hljs-comment"># been successfully brought up. If any readiness probes within the pod fail during</span>
      <span class="hljs-comment"># this wait, the update is blocked.</span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># This is useful to prevent scenarios where pods initially report as ready but</span>
      <span class="hljs-comment"># revert to un-ready soon after receiving traffic.</span>
      <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">10</span>
      <span class="hljs-comment"># "progressDeadlineSeconds" - This is the maximum number of seconds that is allowed</span>
      <span class="hljs-comment"># before progress is made. If this is exceeded, the deployment is considered stalled.</span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># Default value is 600 (10 minutes).</span>
      <span class="hljs-attr">progressDeadlineSeconds:</span> <span class="hljs-number">300</span>
</code></pre>
<p>It's common for <a href="#BM_(deployment)%2Fi">deployment</a>s to fail or get stuck for several reasons:</p>
<ul>
<li>Insufficient <a href="#BM_(node)%2Fi">node</a> resources.</li>
<li>Problems pulling <a href="#BM_(image)%2Fi">image</a>s.</li>
<li>Probe failures (startup probes / <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s).</li>
<li>etc..</li>
</ul>
<a name="H_Rollbacks"></a><h3>Rollbacks</h3>
<p><a name="BM_(Kinds%5C%2FDeployment%2FRollbacks)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(deployment)%2Fi">deployment</a> retains update history in case it needs to rollback. The mechanism used for this is <a href="#BM_(replica%20set)%2Fi">replica set</a>s: For each update, a <a href="#BM_(deployment)%2Fi">deployment</a> launches a new <a href="#BM_(replica%20set)%2Fi">replica set</a>. The <a href="#BM_(replica%20set)%2Fi">replica set</a> for the old version ramps down the number of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s while the <a href="#BM_(replica%20set)%2Fi">replica set</a> for the new version ramps up the number of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. Once all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s have been transitioned to the new version, the old <a href="#BM_(replica%20set)%2Fi">replica set</a> (now empty of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s) is kept online.</p>
<p>It's good practice to limit the number of revisions kept in a <a href="#BM_(deployment)%2Fi">deployment</a>s update history because it limits the number of <a href="#BM_(replica%20set)%2Fi">replica set</a>s kept alive.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">5</span>  <span class="hljs-comment"># Keep the 5 latest revisions</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-attr">template:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my_container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You can inspect previous versions via <code>kubectl rollout history deployment my-deployment</code>. For each update, it's good practice to set the <code>kubernetes.io/change-cause</code> <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a> a custom message describing what was updated / why it was updated -- this shows up in the history.</p>
<p>You can a rollback via <code>kubectl rollout undo deployments my-deployment --to-revision=12345</code>.</p>
</div>
<a name="H_Stateful%20Set"></a><h2>Stateful Set</h2>
<p><a name="BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FReplica%20Set)_TOPIC%2Fi">Kinds/Replica Set</a></li>
<li><a href="#BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi">Kinds/Deployment</a></li>
<li><a href="#BM_(Kinds%5C%2FVolume)_TOPIC%2Fi">Kinds/Volume</a></li>
<li><a href="#BM_(Kinds%5C%2FService%2FHeadless)_TOPIC%2Fi">Kinds/Service/Headless</a></li>
</ul>
</div>
<p>A <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> is similar to a <a href="#BM_(deployment)%2Fi">deployment</a> but the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s it creates are guaranteed to have a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> and each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is able to have its own dedicated storage volumes. In the <a href="#BM_(context)%2Fi">context</a> of <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s, ...</p>
<ul>
<li><a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> means that if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> goes down, the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> responsible for it will replace it with a new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> has the exact same identification information (same name, IP, etc..). Contrast that to <a href="#BM_(deployment)%2Fi">deployment</a>s, where replacement <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s have completely new identities.</li>
<li>dedicated storage volume means that each <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> can have its own unique <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s. Contrast that to <a href="#BM_(deployment)%2Fi">deployment</a>s, where <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s are shared across all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>"<a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">Stable identity</a>" doesn't imply that a replacement <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will be scheduled on the same <a href="#BM_(node)%2Fi">node</a>. The replacement may end up on another <a href="#BM_(node)%2Fi">node</a>.</p>
</div>
<p>A <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> requires three separate pieces of information:</p>
<ol>
<li>a headless <a href="#BM_(service)%2Fi">service</a>, which acts as a gateway to a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (referred to as a <a href="#BM_(governing%20service)%2Fi">governing service</a>).</li>
<li>a volume claim template, which templates <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s for a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</li>
<li>a <a href="#BM_(pod%20template)%2Fi">pod template</a>, which templates <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s similar to <a href="#BM_(pod%20template)%2Fi">pod template</a> for a <a href="#BM_(deployment)%2Fi">deployment</a>.</li>
</ol>
<p>These three pieces are represented as two separate <a href="#BM_(object)%2Fi">object</a>s: the <a href="#BM_(governing%20service)%2Fi">governing service</a> and the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> itself.</p>
<pre class="hljs"><code><span class="hljs-comment"># Manifest #1: Headless service for the stateful set's pods (governing service).</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span>
  <span class="hljs-comment"># Routes traffic to pods based on the following label selectors, which are the same</span>
  <span class="hljs-comment"># key-value pairs used for pod template labels of the the stateful set further down.</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
<span class="hljs-string">----</span>
<span class="hljs-comment"># Manifest #2: The stateful set itself, which contains both the pod template and the</span>
<span class="hljs-comment"># volume claim template.</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-stateful-set</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Selectors are label selectors used to identify pods, which match the key-value pairs</span>
  <span class="hljs-comment"># used for pod template labels further down.</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">my-service</span>  <span class="hljs-comment"># Name of headless service for stateful set (governing service).</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>              <span class="hljs-comment"># Number of replicas for the stateful set.</span>
  <span class="hljs-comment"># Persistent volume claims will be created based on the following template.</span>
  <span class="hljs-attr">volumeClaimTemplates:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">data</span>
      <span class="hljs-attr">spec:</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">requests:</span>
             <span class="hljs-attr">storage:</span> <span class="hljs-string">1Mi</span>
        <span class="hljs-attr">accessModes:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-comment"># Pod's will be created based on the following template. Note that the volume mount</span>
  <span class="hljs-comment"># references the persistent volume claim template described above.</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
          <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">volumeMounts:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span>
              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/data</span>
  <span class="hljs-comment"># Similar to deployments, stateful sets also support updating / rollback mechanisms exist,</span>
  <span class="hljs-comment"># but not exactly the same ones.</span>
  <span class="hljs-attr">strategy:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span>
    <span class="hljs-attr">rollingUpdate:</span>
      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span>
   <span class="hljs-comment"># Once all of the readiness probes of a new pod succeed, this is the number of seconds to</span>
   <span class="hljs-comment"># wait before the stateful set deems the pod to be available. No readiness probes within</span>
   <span class="hljs-comment"># the pod can fail during this wait.</span>
  <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">10</span>
</code></pre>
<p>The example above creates a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> that manages three <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas and a <a href="#BM_(governing%20service)%2Fi">governing service</a> for those <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. The <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s created by the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> are numbered starting from 0: <code>my-stateful-set-0</code>, <code>my-stateful-set-1</code>, and <code>my-stateful-set-2</code>. In addition, each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> gets its own <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> mounted at <code>/data</code> containing a modest amount of storage space. That <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> will have the format <code>data-my-stateful-set-N</code> (where <code>N</code> is the ordinal suffix)</p>
<p><img src="svgbob_bd64f79422fd8f89b72a9af707d8592e912528bf.svg" alt="Kroki diagram output"></p>
<p>The ordinal suffixes of a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are part of their <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a>. If a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> were to die, the volume for that <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> will be re-bound to its replacement. <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">Stateful set</a>s take great care to ensure that no more than one <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will ever be running with the same <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> so as to prevent race conditions (e.g. conflicts regarding IP / host, multiple <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s using the same volume, etc..). In many cases, that means a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> won't be replaced until the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> is absolutely sure that it has died.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set%2FScaling)_TOPIC%2Fi">Kinds/Stateful Set/Scaling</a> (Scaling via ordinal suffixes and race condition prevention)</li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set%2FUpdates)_TOPIC%2Fi">Kinds/Stateful Set/Updates</a> (Race condition prevention on <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> updates)</li>
</ul>
</div>
<a name="H_Scaling"></a><h3>Scaling</h3>
<p><a name="BM_(Kinds%5C%2FStateful%20Set%2FScaling)_TOPIC%2Fi"></a><strong></strong></p>
<p>Because of <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> guarantees and the fact that each <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> can have its own distinct volumes, <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s have different scaling behavior than <a href="#BM_(deployment)%2Fi">deployment</a>s. A <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> scales <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s based on the ordinal suffix of its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> names. When the number of replicas is ...</p>
<ul>
<li>decreased, the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> brings down the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s with the highest ordinal suffixes first (decrementing).</li>
<li>increased, the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> brings up new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s with the next unused ordinal suffixes (incrementing).</li>
</ul>
<p>For example, given the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> <code>my-stateful-set</code> with 3 replicas (those replicas being <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s <code>my-stateful-set-0</code>, <code>my-stateful-set-1</code>, and <code>my-stateful-set-2</code>), ...</p>
<ul>
<li>decrementing the replica count to 1 is guaranteed to shut down <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s <code>my-stateful-set-2</code> and <code>my-stateful-set-1</code> (in that order).</li>
<li>incrementing the replica count to 5 is guaranteed to spin up <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s <code>my-stateful-set-4</code> and <code>my-stateful-set-5</code> (in that order).</li>
</ul>
<p>The scaling behavior makes the stable identities of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s being removed / added known beforehand. In contrast, a <a href="#BM_(deployment)%2Fi">deployment</a>'s scaling behavior makes no guarantees as to which replicas get removed / added and in what order.</p>
<p><img src="svgbob_3decf7dfd2ad397dce8e82a693efd05ae34717bc.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">Stateful set</a>s scale one <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> at a time to avoid race conditions that are sometimes present in distributed applications (e.g. which database server is the primary vs which database server is the replica). When scaling down, the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s for a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> won't be removed along with the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. This is to avoid permanently deleting data in the event of an accidental scale down. Likewise, when scaling up, if a volume for that <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> is already present, that volume gets attached instead of creating a new volume.</p>
<p>For example, given the same 3 replica <code>my-stateful-set</code> example above, changing the number of replicas to 1 will leave the volumes for <code>my-stateful-set-1</code> and <code>my-stateful-set-2</code> lingering undeleted.</p>
<p><img src="svgbob_6eb8bad03ac873d281ca218985de0884fc409eba.svg" alt="Kroki diagram output"></p>
<p>Changing the number of replicas back to 3 will then recreate <code>my-stateful-set-1</code> and <code>my-stateful-set-2</code>, but those new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s will be assigned the lingering undeleted volumes from before rather than being assigned new volumes (all previous data will be present).</p>
<p><img src="svgbob_b49af1cb0b5e903b14e888efcb5c3626750bba7b.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> will not proceed with scaling until all preceding <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (ordinal suffix) are in a healthy running state. The reason for this is that, if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is unhealthy and the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> gets scaled down, it's effectively lost two members at once. This goes against the "only one <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can go down at a time" <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> scaling behavior.</p>
<p>For example, given the same 3 replica <code>my-stateful-set</code> example above, scaling down to 1 replica will first shut down <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <code>my-stateful-set-2</code> and then <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <code>my-stateful-set-1</code>. If <code>my-stateful-set-2</code> shuts down but then <code>my-stateful-set-0</code> enters into an unhealthy state, <code>my-stateful-set-1</code> won't shut down until <code>my-stateful-set-0</code> recovers. Likewise, if <code>my-stateful-set-0</code> enters into an an unknown state (e.g. the <a href="#BM_(node)%2Fi">node</a> running it temporarily lost communication with the <a href="#BM_(control%20plane)%2Fi">control plane</a>), <code>my-stateful-set-1</code> won't shut down until <code>my-stateful-set-0</code> is known and healthy.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The scaling guarantees described here can be relaxed through <code>spec.podManagementPolicy</code>. By default, this value is set to <code>OrderedReady</code>, which enables the behavior described in this section. If it were instead set to <code>Parallel</code>, the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s scaling will launch / terminate <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s in parallel and won't wait for preceding <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to be healthy.</p>
</div>
<a name="H1_Updates"></a><h3>Updates</h3>
<p><a name="BM_(Kinds%5C%2FStateful%20Set%2FUpdates)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FDeployment%2FUpdates)_TOPIC%2Fi">Kinds/Deployment/Updates</a></li>
<li><a href="#BM_(Kinds%5C%2FVolume%2FStorage%20Classes)_TOPIC%2Fi">Kinds/Volume/Storage Classes</a></li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set%2FScaling)_TOPIC%2Fi">Kinds/Stateful Set/Scaling</a></li>
</ul>
</div>
<p>There are two templates in a stable set: a <a href="#BM_(pod%20template)%2Fi">pod template</a> and a volume claim template.</p>
<p>A <a href="#BM_(pod%20template)%2Fi">pod template</a> has two different update strategies:</p>
<ul>
<li><code>RollingUpdate</code> - updates <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s piecemeal (default).</li>
<li><code>OnDelete</code> - user must manually bring down each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> will replace it with updated version.</li>
</ul>
<p><code>OnDelete</code> is simple but requires user intervention to shutdown <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. <code>RollingUpdate</code> is similar to the <code>RollingUpdate</code> strategy for <a href="#BM_(deployment)%2Fi">deployment</a>s, but it supports less parameters and its behavior is slightly different. Specifically, rolling updates for <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s support two parameters.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-ss</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">my-service</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">10</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
  <span class="hljs-comment"># Rolling update strategy.</span>
  <span class="hljs-attr">strategy:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span>
    <span class="hljs-attr">rollingUpdate:</span>
      <span class="hljs-comment"># "maxUnavailable" - During an update, this is the number (or percentage) of pods</span>
      <span class="hljs-comment"># that can be unavailable relative to the number of replicas. Since this deployment</span>
      <span class="hljs-comment"># has 10 replicas, the parameter below is instructing that the number of replicas</span>
      <span class="hljs-comment"># can't go below 8 during an update (at most 2 pods may be unavailable).</span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># If between 0 and 1, this is treated as a percentage of pods (e.g. 0.25 means 25</span>
      <span class="hljs-comment"># percent of pods may be unavailable during an update). </span>
      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span>
      <span class="hljs-comment"># "partition" - Only pods with suffix ordinals that are &gt;= to this number will</span>
      <span class="hljs-comment"># receive updates. All other pods will remain un-updated. For this stateful set,</span>
      <span class="hljs-comment"># that means only "my-ss-5", "my-ss-6", "my-ss-7", "my-ss-8", "my-ss-9", and</span>
      <span class="hljs-comment"># "my-ss-10" get updated. </span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># This is a useful feature for gradual / phased roll outs.</span>
      <span class="hljs-attr">partition:</span> <span class="hljs-number">5</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(deployment)%2Fi">Deployment</a>s also supported the rolling update parameter <code>minReadySeconds</code>. There's a similar feature for <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s but it goes under the path <code>spec.minReadySeconds</code> (it isn't specific to rolling updates).</p>
</div>
<p>Rolling updates performed with a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> management policy of <code>OrderedReady</code> (the default) may get into a broken state which requires manual intervention to roll back. If an update results in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> entering into an unhealthy state, the rolling update will pause. Reverting the <a href="#BM_(pod%20template)%2Fi">pod template</a> won't work because it goes against the "only one <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can go down at a time" behavior of <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set%2FScaling)_TOPIC%2Fi">Kinds/Stateful Set/Scaling</a> (Discussion of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> management policy and only one <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can go down at a time" behavior)</li>
</ul>
</div>
<p>A volume claim template cannot be updated. The system will reject an updated <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> if its volume claim template differs from the original. As such, users have devised various manual strategies for modifying volumes in a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>:</p>
<ul>
<li>
<p>Expanding the volumes for a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s is documented <a href="https://serverfault.com/a/989665">here</a>. The idea is to manually edit each <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a> then re-create the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> without deleting any of its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
<pre class="hljs"><code>kubectl edit pvc &lt;name&gt; <span class="hljs-comment"># for each PVC in the StatefulSet, to increase its capacity.</span>
kubectl delete sts --cascade=orphan &lt;name&gt; <span class="hljs-comment"># to delete the StatefulSet and leave its pods.</span>
kubectl apply -f &lt;name&gt; <span class="hljs-comment"># to recreate the StatefulSet.</span>
kubectl rollout restart sts &lt;name&gt; <span class="hljs-comment"># to restart the pods, one at a time. During restart, the pod's PVC will be resized.</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For this to work, I think the volume type / storage class needs to support expanding volumes (<code>allowVolumeExpansion</code> is <code>true</code>)?</p>
</div>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What about shrinking a volume? I imagine what you need to do is, starting with the last ordinal to the first (current <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> denoted N), ...</p>
<ol>
<li>delete <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> without deleting its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (<code>kubectl delete sts --cascade=orphan &lt;name&gt;</code>).</li>
<li>delete <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N.</li>
<li>create a temporary volume with the new desired size.</li>
<li>create a temporary <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with both the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N's volume and the temporary volume attached.</li>
<li>use the temporary <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to copy <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N's volume to the temporary volume.</li>
<li>delete the temporary <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li>delete <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N's volume.</li>
<li>re-create <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N's volume with the new desired size (same name).</li>
<li>create a temporary <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> with both the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N's volume and the temporary volume attached.</li>
<li>use the temporary <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to copy the temporary volume to <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> N's volume.</li>
<li>re-create the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> (<code>kubectl apply -f &lt;name&gt;</code>).</li>
<li>trigger the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> to restart <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s one at a time (<code>kubectl rollout restart sts &lt;name&gt;</code>).</li>
</ol>
<p>The last step should restart the deleted <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, and that deleted <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will attach the updated volume.</p>
<p>These same steps may work for expanding volumes when <code>allowVolumeExpansion</code> isn't set to <code>true</code>.</p>
</div>
<a name="H_Peer%20Discovery"></a><h3>Peer Discovery</h3>
<p><a name="BM_(Kinds%5C%2FStateful%20Set%2FPeer%20Discovery)_TOPIC%2Fi"></a><strong></strong></p>
<p>A <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_(governing%20service)%2Fi">governing service</a> allows for its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to discover each other (peer discovery). For each <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> in a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>, that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will have a sub-domain within that <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_(governing%20service)%2Fi">governing service</a>. For example, a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> with the name <code>my-ss</code> in the <a href="#BM_(namespace)%2Fi">namespace</a> <code>apple</code> within the cluster will expose its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s as ...</p>
<ul>
<li><code>my-ss-0.my-ss.apple.svc.cluster.local</code></li>
<li><code>my-ss-1.my-ss.apple.svc.cluster.local</code></li>
<li><code>my-ss-2.my-ss.apple.svc.cluster.local</code></li>
<li>...</li>
</ul>
<p>... , where each sub-domain points to one of the stable identities.</p>
<p>A <a href="#BM_(governing%20service)%2Fi">governing service</a> allows for enumerating all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s within its <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> via DNS <a href="#BM_(service)%2Fi">service</a> records (SRV). In the example above, performing an SRV lookup on <code>my-ss.apple.svc.cluster.local</code> will list out the sub-domains and IPs for all <code>my-ss</code> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you have access to <code>dig</code>, you can do <code>dig SRV my-ss.apple.svc.cluster.local</code> and it'll list out all available sub-domains and their IPs for you.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If polling for the IP of a peer that hasn't come up yet, DNS negative caching might cause a small delay to discovering the IP when that peer actually comes up.</p>
</div>
<a name="H_Job"></a><h2>Job</h2>
<p><a name="BM_(Kinds%5C%2FJob)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod)_TOPIC%2Fi">Kinds/Pod</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FRestart%20Policy)_TOPIC%2F">Kinds/Pod/Restart Policy</a></li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi">Kinds/Stateful Set</a></li>
</ul>
</div>
<p>A <a href="#BM_(job)%2Fi">job</a> launches one or more <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to perform one-off tasks. Once those one-off tasks complete, the <a href="#BM_(job)%2Fi">job</a> is effectively over. Typical <a href="#BM_(job)%2Fi">job</a> use-cases include ...</p>
<ul>
<li>database migration</li>
<li>database compaction</li>
<li>log file removal</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-job</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">5</span>  <span class="hljs-comment"># Num of pods that can run at the same time (default is 1).</span>
  <span class="hljs-attr">completions:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Num of pods that must successfully finish for job to end (default is 1).</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">4</span> <span class="hljs-comment"># Max num of retries of a failed pod before failing job (default is 6).</span>
  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">99</span> <span class="hljs-comment"># Max secs before job forcibly fails, killing all pods.</span>
  <span class="hljs-comment"># Completion mode, when set to "Indexed", provides an ordinal suffix / stable identity to</span>
  <span class="hljs-comment"># each launched pod, similar to how a stateful set provides its pods with a stable identity.</span>
  <span class="hljs-comment"># This is useful in cases where the pods of a job need to communicate with each other (e.g.</span>
  <span class="hljs-comment"># distributed work-queue processing), but a service will likely also need to be provided.</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># In most cases, this should be set to "NonIndexed" (default value).</span>
  <span class="hljs-attr">completionMode:</span> <span class="hljs-string">NonIndexed</span>
  <span class="hljs-comment"># Pod template describing job's pods.</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-comment"># Restart policy of the launched pods. For jobs, this must be set to either</span>
      <span class="hljs-comment"># "OnFailure" or "Never".</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
</code></pre>
<p>The example <a href="#BM_(job)%2Fi">job</a> attempts to runs 10 <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to successful completion, keeping up to 5 concurrently running at any one time. If a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> fails, the <a href="#BM_(job)%2Fi">job</a> will retry it up to 4 times before failing the <a href="#BM_(job)%2Fi">job</a> entirely. Similarly, the <a href="#BM_(job)%2Fi">job</a> itself runs no more than 99 seconds before failing entirely.</p>
<p>Common gotchas with <a href="#BM_(job)%2Fi">job</a>s:</p>
<ul>
<li>
<p><em>Lingering finished <a href="#BM_(job)%2Fi">job</a>s</em>: By default, neither a <a href="#BM_(job)%2Fi">job</a> nor its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are cleaned up after the <a href="#BM_(job)%2Fi">job</a> ends (regardless of success or failure). This can end up cluttering the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> servers.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">Kind</a>s/<a href="#BM_(job)%2Fi">Job</a>/Cleanup (<a href="#BM_(job)%2Fi">Job</a> cleanup strategies)</li>
</ul>
</div>
</li>
<li>
<p><em>No communication between <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s</em>: By default, a <a href="#BM_(job)%2Fi">job</a> will automatically pick <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(label)%2Fi">label</a>s and set its <a href="#BM_(label%20selector)%2Fi">label selector</a>s so as not to conflict with other <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s in the system. Without consistent <a href="#BM_(label)%2Fi">label</a>s, the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s of a <a href="#BM_(job)%2Fi">job</a> can't communicate with each other.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">Kind</a>s/<a href="#BM_(job)%2Fi">Job</a>/User-defined <a href="#BM_(label)%2Fi">Label</a>s (<a href="#BM_(job)%2Fi">Job</a> cleanup strategies)</li>
</ul>
</div>
</li>
<li>
<p><em>Unexpected concurrency</em>: Even if <code>spec.concurrency</code> and <code>spec.completions</code> are both set to 1, there are cases where a <a href="#BM_(job)%2Fi">job</a> may launch more than once. As such, a <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s should be tolerant of concurrency.</p>
</li>
<li>
<p><em><code>activeDeadlineSeconds</code> confusion</em>: There's an <code>activeDeadlineSeconds</code> that can go in the <a href="#BM_(pod%20template)%2Fi">pod template</a> as well which is different from the <a href="#BM_(job)%2Fi">job</a>'s <code>activeDeadlineSeconds</code>. Don't confuse the two.</p>
</li>
</ul>
<a name="H_Cleanup"></a><h3>Cleanup</h3>
<p><a name="BM_(Kinds%5C%2FJob%2FCleanup)_TOPIC%2Fi"></a><strong></strong></p>
<p>One common problem with <a href="#BM_(job)%2Fi">job</a>s is resource cleanup. With the exception of failed <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s that have been retried (<code>spec.backoffLimit</code>), a completed <a href="#BM_(job)%2Fi">job</a> won't delete its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s by default. Those <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are kept around in a non-running state so that their logs can be examined if needed. Likewise, the <a href="#BM_(job)%2Fi">job</a> itself isn't deleted on completion either.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This became a problem for me when using Amazon EKS with Amazon Fargate to run the <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. The Fargate <a href="#BM_(node)%2Fi">node</a>s were never removed from the cluster because the <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s were never deleted?</p>
</div>
<p>The problem with letting <a href="#BM_(job)%2Fi">job</a>s and <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s linger around in the system is that it causes clutter, putting pressure on the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> servers. Typically, it's up to the user to delete a <a href="#BM_(job)%2Fi">job</a> (deleting a <a href="#BM_(job)%2Fi">job</a> will also deletes any lingering <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s). However, there are other mechanisms that can automate the deletion of <a href="#BM_(job)%2Fi">job</a>s:</p>
<ul>
<li>
<p>There's a higher-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> called <a href="#BM_(cron%20job)%2Fi">cron job</a> that has cleanup policies for ended <a href="#BM_(job)%2Fi">job</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FCron%20Job)_TOPIC%2Fi">Kinds/Cron Job</a> ("<a href="#BM_(job)%2Fi">Job</a> history limit" fields)</li>
</ul>
</div>
</li>
<li>
<p>There's a time-to-live mechanism that can be used to automatically deletes <a href="#BM_(job)%2Fi">job</a>s that have ended (regardless of success or failure) after some duration.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-job</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># The number of seconds have the job has ended before the job is eligible to be</span>
  <span class="hljs-comment"># deleted. If this is 0, the job will be deleted immediately after ending.</span>
  <span class="hljs-attr">ttlSecondsAfterFinished:</span> <span class="hljs-number">100</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
   <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span>
</code></pre>
</li>
</ul>
<a name="H_User-defined%20Labels"></a><h3>User-defined Labels</h3>
<p><code>(bm} /(Kinds\/Job\/User-defined Labels</code></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set%2FPeer%20Discovery)_TOPIC%2Fi">Kinds/Stateful Set/Peer Discovery</a></li>
</ul>
</div>
<p>By default, a <a href="#BM_(job)%2Fi">job</a> automatically picks out a unique <a href="#BM_(label)%2Fi">label</a> to identify its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s (such that it definitively knows which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s in the system belong to it). However, it's possible to give custom <a href="#BM_(label)%2Fi">label</a>s to a <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s / give custom <a href="#BM_(label%20selector)%2Fi">label selector</a>s to a <a href="#BM_(job)%2Fi">job</a>. This is useful is cases where a <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s need to communicate with each other: A headless <a href="#BM_(service)%2Fi">service</a> can target a <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s based on its <a href="#BM_(label)%2Fi">label</a>s, which is similar to how a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s can communicate with and discover each other (<a href="#BM_(governing%20service)%2Fi">governing service</a>).</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-job</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">5</span>  <span class="hljs-comment"># Num of pods that can run at the same time (default is 1).</span>
  <span class="hljs-attr">completions:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Num of pods that must successfully finish for job to end (default is 1).</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">4</span> <span class="hljs-comment"># Max num of retries of a failed pod before failing job (default is 6).</span>
  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">99</span> <span class="hljs-comment"># Max secs before job forcibly fails, killing all pods.</span>
  <span class="hljs-comment"># Completion mode, when set to "Indexed", provides an ordinal suffix / stable identity to</span>
  <span class="hljs-comment"># each launched pod, similar to how a stateful set provides its pods with a stable identity.</span>
  <span class="hljs-comment"># This is useful in cases where the pods of a job need to communicate with each other (e.g.</span>
  <span class="hljs-comment"># distributed work-queue processing), but a service will likely also need to be provided.</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># In most cases, this should be set to "NonIndexed" (default value).</span>
  <span class="hljs-attr">completionMode:</span> <span class="hljs-string">NonIndexed</span>
  <span class="hljs-comment"># Selectors are label selectors used to identify pods, which match the key-value pairs</span>
  <span class="hljs-comment"># used for pod template labels further down.</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># In most cases, you shouldn't need to specify this (or the labels in the pod template</span>
  <span class="hljs-comment"># below). When not present, the system will automatically pick labels / label selectors</span>
  <span class="hljs-comment"># that won't conflict with other jobs / pods.</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-comment"># Pod template describing job's pods.</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
      <span class="hljs-comment"># Restart policy of the launched pods. For jobs, this must be set to either</span>
      <span class="hljs-comment"># "OnFailure" or "Never".</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
</code></pre>
<a name="H_Cron%20Job"></a><h2>Cron Job</h2>
<p><a name="BM_(Kinds%5C%2FCron%20Job)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FJob)_TOPIC%2Fi">Kinds/Job</a></li>
</ul>
</div>
<p>A <a href="#BM_(cron%20job)%2Fi">cron job</a> launches a <a href="#BM_(job)%2Fi">job</a> periodically on a schedule, defined in <a href="https://en.wikipedia.org/wiki/Cron#Overview">cron format</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cronjob</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">schedule:</span> <span class="hljs-string">"0 * * * *"</span>  <span class="hljs-comment"># Schedule of the job in cron format (launches every hour)</span>
  <span class="hljs-comment"># How much tolerance to have (in seconds) for a scheduled run of a job that's been missed.</span>
  <span class="hljs-comment"># If a scheduled run gets missed for any reason but is identified within this window,</span>
  <span class="hljs-comment"># it'll run anyways. If it's past the window, it'll count as a failed job.</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># This is an optional field. If not set, there is no deadline (infinite tolerance).</span>
  <span class="hljs-attr">startingDeadlineSeconds:</span> <span class="hljs-number">200</span>
  <span class="hljs-comment"># How should a job launch be treated if the previously launched job is still running.</span>
  <span class="hljs-comment"># If this is set to ...</span>
  <span class="hljs-comment">#  * "Allow", it allows the jobs to run concurrently (default value).</span>
  <span class="hljs-comment">#  * "Forbid", it skips the new job launch, meaning concurrently running jobs not allowed.</span>
  <span class="hljs-comment">#  * "Replace", it replaces the previously running job with the new job.</span>
  <span class="hljs-attr">concurrencyPolicy:</span> <span class="hljs-string">Forbid</span>
  <span class="hljs-comment"># How many ended successful/failed jobs should remain in Kubernetes. If set to 0, a job and</span>
  <span class="hljs-comment"># its corresponding pods are removed immediately after ending. If  &gt; 0, the last N jobs and</span>
  <span class="hljs-comment"># their pods will remain in Kubernetes (useful for inspection of logs).</span>
  <span class="hljs-attr">successfulJobsHistoryLimit:</span> <span class="hljs-number">0</span>
  <span class="hljs-attr">failedJobsHistoryLimit:</span> <span class="hljs-number">0</span>
  <span class="hljs-comment"># Job template that describes the job that a cron job launches. This is effectively a job</span>
  <span class="hljs-comment"># definition without "apiVersion", "kind", and "metadata" fields.</span>
  <span class="hljs-attr">jobTemplate:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">template:</span>
        <span class="hljs-attr">spec:</span>
          <span class="hljs-attr">containers:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
              <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There is no stable support for timezones. The timezone used by all <a href="#BM_(cron%20job)%2Fi">cron job</a>s is whatever the timezone of the <a href="#BM_(controller)%2Fi">controller</a> manager is (other parts of the doc say unspecified timezone). There currently is a beta feature that's gated off that lets you specify a timezone by setting <code>spec.timeZone</code> (e.g. setting it to <code>Etc/UTC</code> will use UTC time).</p>
</div>
<p>Common gotchas with <a href="#BM_(cron%20job)%2Fi">cron job</a>s:</p>
<ul>
<li>
<p><em>Unexpected concurrency</em>: There are cases where a <a href="#BM_(cron%20job)%2Fi">cron job</a> may launch more than once. As such, a <a href="#BM_(job)%2Fi">job</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s should be tolerant of concurrency.</p>
</li>
<li>
<p><em>Unexpected misses</em>: There are cases where a <a href="#BM_(cron%20job)%2Fi">cron job</a> may not launch even though it's supposed to.</p>
</li>
</ul>
<a name="H_Daemon%20Set"></a><h2>Daemon Set</h2>
<p><a name="BM_(Kinds%5C%2FDaemon%20Set)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FReplica%20Set)_TOPIC%2Fi">Kinds/Replica Set</a></li>
<li><a href="#BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi">Kinds/Deployment</a></li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi">Kinds/Stateful Set</a></li>
</ul>
</div>
<p>A <a href="#BM_(daemon%20set)%2Fi">daemon set</a> ensures that a set of <a href="#BM_(node)%2Fi">node</a>s each have a copy of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> always up and running. Typical scenarios where a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is used include ...</p>
<ul>
<li><a href="#BM_(node)%2Fi">node</a> log collection (e.g. logstash agent).</li>
<li><a href="#BM_(node)%2Fi">node</a> monitoring (e.g. zabbix agent).</li>
</ul>
<p>The above scenarios are ones which break <a href="#BM_(container)%2Fi">container</a> / <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> isolation. That is, a <a href="#BM_(daemon%20set)%2Fi">daemon set</a> is intended to run <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s that are coupled to <a href="#BM_(node)%2Fi">node</a>s and sometimes those <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s will do things such as mount the <a href="#BM_(node)%2Fi">node</a>'s root filesystem and run commands to either install software or gather information.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-ds</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Selectors are label selectors used to identify pods, which match the key-value pairs</span>
  <span class="hljs-comment"># used for pod template labels further down.</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
  <span class="hljs-comment"># Pod template describing daemon set's pods.</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
      <span class="hljs-comment"># These labels are how this daemon set will determine if the pod is running on a node.</span>
      <span class="hljs-comment"># It will look around for pods with this set of labels.</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-comment"># Put copies of this pod only on nodes that have these labels. There is also a</span>
      <span class="hljs-comment"># "nodeAffinity" field and "tolerations" field, which allow for more elaborate logic</span>
      <span class="hljs-comment"># / soft logic for node selection (too vast to cover here).</span>
      <span class="hljs-comment">#</span>
      <span class="hljs-comment"># If neither "nodeSelector" nor "nodeAffinity" is set, copies of this pod will run on</span>
      <span class="hljs-comment"># all nodes.</span>
      <span class="hljs-attr">nodeSelector:</span>
        <span class="hljs-attr">type:</span> <span class="hljs-string">my-node-type</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
          <span class="hljs-attr">resources:</span>
            <span class="hljs-attr">limits:</span>
              <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span>
              <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span>
          <span class="hljs-attr">volumeMounts:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span>
              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/host_log</span>
              <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">volumes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span>
          <span class="hljs-attr">hostPath:</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span>
</code></pre>
<p>The example above runs a copy of the <a href="#BM_(pod%20template)%2Fi">pod template</a> on each <a href="#BM_(node)%2Fi">node</a> that has the <a href="#BM_(label)%2Fi">label</a> <code>type=my-node-type</code> and mounts the host's <code>/var/log</code> directory to <code>/host_log</code> in the <a href="#BM_(container)%2Fi">container</a>. Most <a href="#BM_(daemon%20set)%2Fi">daemon set</a>s are used for some form of monitoring or manipulation of <a href="#BM_(node)%2Fi">node</a>s, so it's common to have volumes of the type <code>hostPath</code>, which mounts a directory that's directly on the <a href="#BM_(node)%2Fi">node</a> itself.</p>
<p>Unlike <a href="#BM_(deployment)%2Fi">deployment</a>s and <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s, <a href="#BM_(daemon%20set)%2Fi">daemon set</a>s don't have support for rolling updates. On any change to a <a href="#BM_(daemon%20set)%2Fi">daemon set</a>'s <a href="#BM_(pod%20template)%2Fi">pod template</a> on <a href="#BM_(node)%2Fi">node</a> selection criteria, old <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are deleted and updated <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s are brought up in their place.</p>
<a name="H_Service%20Account"></a><h2>Service Account</h2>
<p><a name="BM_(Kinds%5C%2FService%20Account)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FNamespace)_TOPIC%2Fi">Kinds/Namespace</a></li>
<li><a href="#BM_(Kinds%5C%2FSecret)_TOPIC%2F">Kinds/Secret</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FAPI%20Access)_TOPIC%2F">Kinds/Pod/API Access</a></li>
<li><a href="#BM_(Kinds%5C%2FPod%2FImages%2FPrivate%20Container%20Registries)_TOPIC%2F">Kinds/Pod/Images/Private Container Registries</a></li>
</ul>
</div>
<p>A <a href="#BM_(service%20account)%2Fi">service account</a> is a set of credentials that applications within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> use to communicate with the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server. <a href="#BM_(service%20account)%2Fi">Service account</a>s also provide an aggregation point for <a href="#BM_(image)%2Fi">image</a> pull <a href="#BM_(secret)%2Fi">secret</a>s and other security-related features.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service-account</span>
<span class="hljs-comment"># A list of image pull secrets to use with private container registries. When this service</span>
<span class="hljs-comment"># account is applied to a pod, all image pull secrets in the service account get added to</span>
<span class="hljs-comment"># the pod.</span>
<span class="hljs-attr">imagePullSecrets:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-dockerhub-secret</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-aws-ecr-secret</span>
<span class="hljs-comment"># API access credentials will never be mounted to any pod that uses this service account.</span>
<span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span>
</code></pre>
<p>By default, each <a href="#BM_(namespace)%2Fi">namespace</a> comes with its own <a href="#BM_(service%20account)%2Fi">service account</a> which <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s in that <a href="#BM_(namespace)%2Fi">namespace</a> automatically use. The <a href="#BM_(service%20account)%2Fi">service account</a> used by a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can be overridden to another <a href="#BM_(service%20account)%2Fi">service account</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Custom service account to use. This can't be changed once the pod's been creatd.</span>
  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">my-service-account</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-registry.example/tiger/my-container:1.0.1</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(API%20Security)_TOPIC%2Fi">API Security</a> (<a href="#BM_(role%5B-%5Cs%5Dbased%20access%20control)%2Fi">Role-based access control</a> to limit a <a href="#BM_(service%20account)%2Fi">service account</a>'s access to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API)</li>
</ul>
</div>
<a name="H_Horizontal%20Pod%20Autoscaler"></a><h2>Horizontal Pod Autoscaler</h2>
<p><a name="BM_(Kinds%5C%2FHorizontal%20Pod%20Autoscaler)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FReplica%20Set)_TOPIC%2Fi">Kinds/Replica Set</a></li>
<li><a href="#BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi">Kinds/Deployment</a></li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi">Kinds/Stateful Set</a></li>
<li><a href="#BM_(Kinds%5C%2FIngress)_TOPIC%2Fi">Kinds/Ingress</a></li>
</ul>
</div>
<p>A <a href="#BM_(horizontal%20pod%20autoscaler%7Chorizontal%20pod%20autoscaling)%2Fi">horizontal pod autoscaler</a> (<a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a>) periodically measures how much work a set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas are doing so that it can appropriately adjust the number of replicas on that <a href="#BM_(replica%20set)%2Fi">replica set</a>, <a href="#BM_(deployment)%2Fi">deployment</a>, or <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>. If the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas ...</p>
<ul>
<li>aren't doing enough work, the numbers of replicas is decreased.</li>
<li>are doing too much work, the number of replicas is increased.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This feature depends on a "metrics server" that should be running on <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> by default.</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">autoscaling/v2</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">HorizontalPodAutoscaler</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-hpa</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># What kind and name are being targeted for autoscaling? Is it a replica set, deployment,</span>
  <span class="hljs-comment"># stateful set, or something else?</span>
  <span class="hljs-attr">scaleTargetRef:</span>
    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">my-ss</span>
  <span class="hljs-comment"># What are the minimum and maximum replicas that this HPA will scale to? At the time of</span>
  <span class="hljs-comment"># writing, the minimum number of replicas must be 1 or more (it can't be 0).</span>
  <span class="hljs-attr">minReplicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">maxReplicas:</span> <span class="hljs-number">10</span>
  <span class="hljs-comment"># What type of metrics are being collected? In this example, on average across all active</span>
  <span class="hljs-comment"># pod replicas, we want the CPU load to be 50%. If the average is more than 50%, scale</span>
  <span class="hljs-comment"># down the number of replicas. If it's more, scale up the number of replicas.</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># The average utilization is referring to the amount of resource requested by the pod. In</span>
  <span class="hljs-comment"># this example, this is 50% of the CPU resource AS REQUESTED BY THE POD (via the pod's</span>
  <span class="hljs-comment"># spec.containers[].resources.requests for CPU).</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># Instead of doing average percentage, you can also do absolute values by changing</span>
  <span class="hljs-comment"># target.type to AverageValue and replacing target.averageUtilization with</span>
  <span class="hljs-comment"># target.averageValue.</span>
  <span class="hljs-attr">metrics:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Resource</span>
      <span class="hljs-attr">resource:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">cpu</span>
        <span class="hljs-attr">target:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">Utilization</span>
          <span class="hljs-attr">averageUtilization:</span> <span class="hljs-number">50</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FResources)_TOPIC%2F">Kinds/Pod/Resources</a> (Refresher on <a href="#BM_(resource%20request)%2Fi">resource request</a>s)</li>
</ul>
</div>
<p>In the example above, if the average CPU usage of the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> <code>my-ss</code> replicas is</p>
<ul>
<li>less than 50% that of the CPU <a href="#BM_(resource%20request)%2Fi">resource request</a>ed, the replicas will scale down until there are 2 replicas or until the CPU usage reaches 50%.</li>
<li>more than 50% that of the CPU <a href="#BM_(resource%20request)%2Fi">resource request</a>ed, the replicas will scale up until there are 10 replicas or until the CPU usage reaches 50%.</li>
</ul>
<p>The <a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a> will at-most double the the number of replicas on each iteration. Each scaling iteration has an intentional waiting period. Specifically, scaling ...</p>
<ul>
<li>up will only occur if no previous scaling has occurred in the past 3 mins.</li>
<li>down will only occur if no previous scaling has occured in the past 5 mins.</li>
</ul>
<p>The example above tracked a single metric (CPU <a href="#BM_(utilization)%2Fi">utilization</a>), but multiple metrics can be tracked by a single <a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a>. Metrics can be one of three types:</p>
<ul>
<li><code>Resource</code> metrics cover CPU and memory metrics of the replicas.</li>
<li><code>Pods</code> metrics cover other metrics of the replicas (e.g. custom user-defined metrics).</li>
<li><code>Object</code> are metrics related to some other <a href="#BM_(object)%2Fi">object</a> in the same <a href="#BM_(namespace)%2Fi">namespace</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>How do you implement custom user-defined metrics? I would imagine you need to do API calls to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server (or to the metrics server) from the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas.</p>
</div>
<p>If there are multiple metrics being tracked by an <a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a>, as in the example below, that <a href="#BM_%5Cb(HPA)%5Cb%2F">HPA</a> calculates the replica counts for each metric and then chooses the one with the highest.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">autoscaling/v2</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">HorizontalPodAutoscaler</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-hpa</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">scaleTargetRef:</span>
    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">my-ss</span>
  <span class="hljs-attr">minReplicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">maxReplicas:</span> <span class="hljs-number">10</span>
  <span class="hljs-attr">metrics:</span>
    <span class="hljs-comment"># Target an average of 50% CPU utilization across all replicas</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Resource</span>
      <span class="hljs-attr">resource:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">cpu</span>
        <span class="hljs-attr">target:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">Utilization</span>
          <span class="hljs-attr">averageUtilization:</span> <span class="hljs-number">50</span>
    <span class="hljs-comment"># Target an average of 1000 queries-per-second across all replicas.</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Pods</span>
      <span class="hljs-attr">pods:</span>
        <span class="hljs-attr">metric:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">queries-per-second</span>
        <span class="hljs-attr">target:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">AverageValue</span>
          <span class="hljs-attr">averageValue:</span> <span class="hljs-number">1000</span>
    <span class="hljs-comment"># Target an average of 1000 queries-per-second across all replicas.</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Object</span>
      <span class="hljs-attr">object:</span>
        <span class="hljs-attr">metric:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">requests-per-second</span>
        <span class="hljs-attr">describedObject:</span>
          <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1</span>
          <span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">my-ingress</span>
        <span class="hljs-attr">target:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">Value</span>
          <span class="hljs-attr">averageValue:</span> <span class="hljs-number">2000</span>
</code></pre>
<p>Common gotchas with HPAs:</p>
<ul>
<li>
<p><em>Scale to zero</em>: Setting the number of minimum replicas to zero isn't supported. See <a href="https://github.com/kubernetes/kubernetes/issues/69687">here</a>.</p>
</li>
<li>
<p><em>Scaling memory</em>: It's easy to autoscale based on CPU, but be careful with autoscaling based on memory. If the number of replicas scale up, the existing replicas need to somehow "release" memory, which can't really be done without killing the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s and starting them back up again.</p>
</li>
<li>
<p><em>Scaling on non-linear scaling metrics</em>: Be careful with scaling based on metrics that don't linearly scale. For example, if you double the number of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, the value of that metric should cut in half. This may end up becoming an issue when scaling based off of poorly designed custom user-defined metrics.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>In addition to <a href="#BM_(horizontal%20pod%20autoscaler%7Chorizontal%20pod%20autoscaling)%2Fi">horizontal pod autoscaler</a>, there's a <a href="#BM_(vertical%20pod%20autoscaler%7Cvertical%20pod%20autoscaling)%2Fi">vertical pod autoscaler</a> (<a href="#BM_%5Cb(VPA)%5Cb%2F">VPA</a>). A <a href="#BM_%5Cb(VPA)%5Cb%2F">VPA</a> will scale a single <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> based on metrics and its <a href="#BM_(resource%20request)%2Fi">resource request</a>s / <a href="#BM_(resource%20limit)%2Fi">resource limit</a>s.</p>
<p>The <a href="#BM_%5Cb(VPA)%5Cb%2F">VPA</a> <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> doesn't come built-in with <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>. It's provided as an add-on package found <a href="https://github.com/kubernetes/autoscaler">here</a>.</p>
</div>
<a name="H_Cluster%20Autoscaler"></a><h2>Cluster Autoscaler</h2>
<p><a name="BM_(Kinds%5C%2FCluster%20Autoscaler)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod)_TOPIC%2Fi">Kinds/Pod</a></li>
<li><a href="#BM_(Kinds%5C%2FNode)_TOPIC%2Fi">Kinds/Node</a></li>
</ul>
</div>
<p>A <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaler</a> is a component that scales a <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> cluster on a public cloud by adding and removing <a href="#BM_(node)%2Fi">node</a>s as needed. Each public could has its own implementation of a <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaler</a>. In some clouds, the implementation is exposed as a <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> / set of <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s. In other clouds, the implementation is exposed as a web interface or a command-line interface.</p>
<p>In most cases, <a href="#BM_(node)%2Fi">node</a>s and added and removed to predefined groups called <a href="#BM_(node)%2Fi">node</a> pools. Each <a href="#BM_(node)%2Fi">node</a> pool has <a href="#BM_(node)%2Fi">node</a>s of the same type (same resources and features). For example, a specific <a href="#BM_(node)%2Fi">node</a> pool of machines with the same CPU, networking gear, and same amount and type of RAM.</p>
<p>If a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is scheduled to run but none of the <a href="#BM_(node)%2Fi">node</a>s have enough resources to run it, the <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaler</a> will increase the number of <a href="#BM_(node)%2Fi">node</a>s in one of the <a href="#BM_(node)%2Fi">node</a> pools that has the capability to run the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>. Likewise, the <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaler</a> will decrease the number of <a href="#BM_(node)%2Fi">node</a>s if <a href="#BM_(node)%2Fi">node</a>s aren't being utilized enough by actively running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It doesn't seem to be consistent so there isn't much else to put about <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaling</a>. See the <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaler</a> section on <a href="https://github.com/kubernetes/autoscaler">this website</a> and navigate to whatever public cloud you're using.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%20Disruption%20Budget)_TOPIC%2Fi">Kinds/Pod Disruption Budget</a> (Prevent rapid killing of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s on scale down)</li>
</ul>
</div>
<a name="H_Pod%20Disruption%20Budget"></a><h2>Pod Disruption Budget</h2>
<p><a name="BM_(Kinds%5C%2FPod%20Disruption%20Budget)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FCluster%20Autoscaler)_TOPIC%2Fi">Kinds/Cluster Autoscaler</a></li>
<li><a href="#BM_(Kinds%5C%2FReplica%20Set)_TOPIC%2Fi">Kinds/Replica Set</a></li>
<li><a href="#BM_(Kinds%5C%2FDeployment)_TOPIC%2Fi">Kinds/Deployment</a></li>
<li><a href="#BM_(Kinds%5C%2FStateful%20Set)_TOPIC%2Fi">Kinds/Stateful Set</a></li>
</ul>
</div>
<p>A <a href="#BM_(pod%20disruption%20budget)%2Fi">pod disruption budget</a> (<a href="#BM_%5Cb(PDB)%5Cb%2F">PDB</a>) specifies the number of downed <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas that a <a href="#BM_(replica%20set)%2Fi">replica set</a>, <a href="#BM_(deployment)%2Fi">deployment</a>, or <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> can tolerate relative to its expected replica count. In this case, a disrupted <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is one that's brought down via ...</p>
<ul>
<li>voluntary disruptions (e.g. manually removing a <a href="#BM_(node)%2Fi">node</a> from the cluster).</li>
<li>involuntary disruptions (e.g. kernel panic on a <a href="#BM_(node)%2Fi">node</a>).</li>
<li>rolling updates (<a href="#BM_(deployment)%2Fi">deployment</a>s and <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>).</li>
</ul>
<p>Once a <a href="#BM_%5Cb(PDB)%5Cb%2F">PDB</a> has reached its downed <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replica limit, it prevents further downing of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas via voluntary disruptions. It cannot prevent further downing of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> replicas via involuntary disruptions or rolling updates (these downed <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s will still be accounted for within the <a href="#BM_%5Cb(PDB)%5Cb%2F">PDB</a>).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This has something to do with an "Eviction API". Haven't had a chance to read about this yet.</p>
</div>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">policy/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PodDisruptionBudget</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pdb</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># Selector for pod replicas within the stateful set.</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">my-ss-pods</span>
  <span class="hljs-comment"># Max number of pods that can be unavailable at one time.</span>
  <span class="hljs-comment">#</span>
  <span class="hljs-comment"># Instead of "maxUnavailable", this can also be "minAvailable", which is the min number of</span>
  <span class="hljs-comment"># pods must be available at all times.</span>
  <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">3</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(manifest)%2Fi">manifest</a> is using <a href="#BM_(label%20selector)%2Fi">label selector</a>s are being used to identify <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. How does it know what the replica count is for the <a href="#BM_(replica%20set)%2Fi">replica set</a> / <a href="#BM_(deployment)%2Fi">deployment</a> / or <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>? According to the docs:</p>
<blockquote>
<p>The "intended" number of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s is computed from the .spec.replicas of the workload resource that is managing those <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. The <a href="#BM_(control%20plane)%2Fi">control plane</a> discovers the owning workload resource by examining the .metadata.ownerReferences of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">Pod</a>.</p>
</blockquote>
</div>
<a name="H_Custom%20Kinds"></a><h1>Custom Kinds</h1>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<p>TODO: write an example python <a href="#BM_(controller)%2Fi">controller</a> here and talk about how to deploy it + ch 18</p>
<a name="H_API%20Security"></a><h1>API Security</h1>
<p><a name="BM_(API%20Security)_TOPIC%2Fi"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FPod%2FAPI%20Access)_TOPIC%2F">Kinds/Pod/API Access</a></li>
<li><a href="#BM_(Kinds%5C%2FService%20Account)_TOPIC%2Fi">Kinds/Service Account</a></li>
</ul>
</div>
<p>Access control to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API is modeled using accounts and groups, where an account can be associated with many groups and each group grants a certain set of permissions to its users. Two types of accounts are provided:</p>
<ul>
<li>users, which are accounts for human access.</li>
<li><a href="#BM_(service%20account)%2Fi">service account</a>s, which are accounts for programmatic access.</li>
</ul>
<p><img src="svgbob_ec0249d0405268594cd75de6c2486b390fb6c27b.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(service%20account)%2Fi">Service account</a>s are what get used when a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> needs access to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API. <a href="#BM_(container)%2Fi">Container</a>s within that <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> have a volume mounted with certificates and credentials that the applications within can use to authenticate and communicate with the API server.</p>
<p>Each <a href="#BM_(namespace)%2Fi">namespace</a> gets created with a default <a href="#BM_(service%20account)%2Fi">service account</a> (named <code>default</code>). By default, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s created under a <a href="#BM_(namespace)%2Fi">namespace</a> will be assigned the default <a href="#BM_(service%20account)%2Fi">service account</a> for that <a href="#BM_(namespace)%2Fi">namespace</a>. A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can be configured to use a custom <a href="#BM_(service%20account)%2Fi">service account</a> that has more or less access rights than the default <a href="#BM_(service%20account)%2Fi">service account</a>. A <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> can also forgo volume mounting the credentials of a <a href="#BM_(service%20account)%2Fi">service account</a> entirely if the applications within it don't need access to the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API.</p>
<p><img src="svgbob_cd1a5ca68efdcbb4d31b3e68e6cb9aeaef5f6566.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Kinds%5C%2FService%20Account)_TOPIC%2Fi">Kinds/Service Account</a> (Creating <a href="#BM_(service%20account)%2Fi">service account</a>s)</li>
<li><a href="#BM_(API%20Security%5C%2FDisable%20Credentials)_TOPIC%2Fi">API Security/Disable Credentials</a> (Disable volume mounting <a href="#BM_(service%20account)%2Fi">service account</a> credentials)</li>
</ul>
</div>
<p>How access rights are defined depends on how <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> has been set up. By default, <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> is set up to use <a href="#BM_(role%5B-%5Cs%5Dbased%20access%20control)%2Fi">role-based access control</a> (<a href="#BM_(RBAC)%2F">RBAC</a>), which tightly maps to the REST semantics of the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server. <a href="#BM_(RBAC)%2F">RBAC</a> limits what actions can be performed on which <a href="#BM_(object)%2Fi">object</a>s: <a href="#BM_(object)%2Fi">Object</a>s map to REST resources (paths on the REST server) and manipulations of <a href="#BM_(object)%2Fi">object</a>s map to REST actions (verbs such as <code>DELETE</code>, <code>GET</code>, <code>PUT</code>, etc.. on those REST server paths).</p>
<p>The subsections below detail <a href="#BM_(RBAC)%2F">RBAC</a> as well as other API security related topics.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Other types of access control mechanisms exist as well, such as attribute-based access control (ABAC).</p>
</div>
<a name="H_Role-based%20Access%20Control"></a><h2>Role-based Access Control</h2>
<p><a name="BM_(API%20Security%5C%2FRole-based%20Access%20Control)_TOPIC%2Fi"></a><strong></strong></p>
<p><a href="#BM_(RBAC)%2F">RBAC</a> tightly maps to the REST semantics of the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server by limiting what actions can be performed on which <a href="#BM_(object)%2Fi">object</a>s: <a href="#BM_(object)%2Fi">Object</a>s map to REST resources (paths on the REST server) and manipulations of <a href="#BM_(object)%2Fi">object</a>s map to REST actions (verbs such as <code>DELETE</code>, <code>GET</code>, <code>PUT</code>, etc.. on those REST server paths). <a href="#BM_(RBAC)%2F">RBAC</a> is configured using two sets of <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s:</p>
<ul>
<li><code>Role</code> and <code>ClusterRole</code> specify which actions can be performed on which <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s / in which <a href="#BM_(namespace)%2Fi">namespace</a>.</li>
<li><code>RoleBinding</code> and <code>ClusterRoleBinding</code> specify which <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a>s bind to which users, groups, or <a href="#BM_(service%20account)%2Fi">service account</a>s.</li>
</ul>
<p>A <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a> always maps a single <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> to many users, groups, and <a href="#BM_(service%20account)%2Fi">service account</a>s.</p>
<p><img src="svgbob_b8d9436c1457523d139017b64ab3ce5cfa6d21f9.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that a ...</p>
<ul>
<li><a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(object)%2Fi">object</a> / <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> is one that comes under the umbrella of a <a href="#BM_(namespace)%2Fi">namespace</a>: <a href="#BM_(service)%2Fi">Service</a>s, <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, <a href="#BM_(config%20map%7Cconfiguration%20map)%2Fi">config map</a>s, etc..</li>
<li>cluster-level <a href="#BM_(object)%2Fi">object</a> / <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> is one that comes under the umbrella of the entire cluster (it's cluster-wide, not tied to a <a href="#BM_(namespace)%2Fi">namespace</a>): <a href="#BM_(node)%2Fi">Node</a>s, <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>s, etc...</li>
</ul>
</div>
<p><code>ClusterRole</code> and <code>ClusterRoleBinding</code> are cluster-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s while <code>Role</code> and <code>RoleBinding</code> are <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s. <a href="#BM_(RBAC)%2F">RBAC</a> provides provides different permissions based on which <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> variant (<code>ClusterRole</code> vs <code>Role</code>) gets used with which <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a> variant (<code>ClusterRoleBinding</code> vs <code>RoleBinding</code>):</p>
<table>
<thead>
<tr>
<th><a href="#BM_(cluster%20role%7Crole)%2Fi">Role</a></th>
<th>Binding</th>
<th>Permission Granted</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Role</code></td>
<td><code>RoleBinding</code></td>
<td>Allow access to <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s in that <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> / <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a>'s <a href="#BM_(namespace)%2Fi">namespace</a>.</td>
</tr>
<tr>
<td><code>ClusterRole</code></td>
<td><code>ClusterRoleBinding</code></td>
<td>Allows access to <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s in all <a href="#BM_(namespace)%2Fi">namespace</a>s, cluster-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, and arbitrary URL paths on the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server.</td>
</tr>
<tr>
<td><code>ClusterRole</code></td>
<td><code>RoleBinding</code></td>
<td>Allow access to <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s in all <a href="#BM_(namespace)%2Fi">namespace</a>s, cluster-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, and arbitrary URL paths on the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server. But, that access is only permitted from within the <a href="#BM_(namespace)%2Fi">namespace</a> of the <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a>.</td>
</tr>
<tr>
<td><code>Role</code></td>
<td><code>ClusterRoleBinding</code></td>
<td>Invalid. It's allowed but it <em>does nothing</em> (it won't cause an error).</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>Role</code> and <code>RoleBinding</code>: Allow access to <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s in that <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> / <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a>'s <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span>
  <span class="hljs-comment"># Namespace of this role. Permissions are for THIS namespace only. If omitted, the current</span>
  <span class="hljs-comment"># namespace is used.</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ns</span>
<span class="hljs-attr">rules:</span>  <span class="hljs-comment"># List of kinds and actions go here</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">services</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">get</span>, <span class="hljs-string">list</span>]
<span class="hljs-string">----</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role-binding</span>
  <span class="hljs-comment"># Namespace of this role binding. This must be the same as the role being bound (otherwise,</span>
  <span class="hljs-comment"># the role binding won't be able to see the role as its in another namespace?). If omitted,</span>
  <span class="hljs-comment"># the current namespace is used.</span>
  <span class="hljs-attr">namespace:</span>  <span class="hljs-string">my-ns</span>
<span class="hljs-comment"># The role that's being bound.</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span>
<span class="hljs-comment"># The users/groups/service accounts that the role is being bound to.</span>
<span class="hljs-attr">subjects:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
    <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-other-ns</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">system:authenticated</span>
</code></pre>
</li>
<li>
<p><code>ClusterRole</code> and <code>ClusterRoleBinding</code>: Allow access to <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s in all <a href="#BM_(namespace)%2Fi">namespace</a>s, cluster-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, and arbitrary URL paths on the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role</span>
<span class="hljs-attr">rules:</span>  <span class="hljs-comment"># List of kinds and actions go here</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">nodes</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">get</span>, <span class="hljs-string">list</span>]
  <span class="hljs-bullet">-</span> <span class="hljs-attr">nonResourceURLs:</span>  <span class="hljs-comment"># List of server paths to allow go under here.</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">/api</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">/api/*</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">/apis</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">/apis/*</span>
<span class="hljs-string">----</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role-binding</span>
<span class="hljs-comment"># The role that's being bound.</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role</span>
<span class="hljs-comment"># The users/groups/service accounts that the role is being bound to.</span>
<span class="hljs-attr">subjects:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
    <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ns</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">system:authenticated</span>
</code></pre>
</li>
<li>
<p><code>ClusterRole</code> and <code>RoleBinding</code>: Allow access to <a href="#BM_(namespace)%2Fi">namespace</a>-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s in all <a href="#BM_(namespace)%2Fi">namespace</a>s, cluster-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, and arbitrary URL paths on the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server. But, that access is only permitted from within the <a href="#BM_(namespace)%2Fi">namespace</a> of the <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role</span>
<span class="hljs-attr">rules:</span>  <span class="hljs-comment"># List of kinds and actions go here</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">services</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">get</span>, <span class="hljs-string">list</span>]
<span class="hljs-string">----</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role-binding</span>
  <span class="hljs-comment"># Namespace of this role binding. Although the cluster role being bound to this role binding</span>
  <span class="hljs-comment"># allows access to everything (all namespaces and at the cluster-level), access must happen</span>
  <span class="hljs-comment"># from within this namespace.</span>
  <span class="hljs-attr">namespace:</span>  <span class="hljs-string">my-ns</span>
<span class="hljs-comment"># The role that's being bound.</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span>
<span class="hljs-comment"># The users/groups/service accounts that the role is being bound to. If the group is pointing</span>
<span class="hljs-comment"># to a service account, is that service account required to be in the same namespace as this</span>
<span class="hljs-comment"># role binding for access to be allowed? (Unsure at this point)</span>
<span class="hljs-attr">subjects:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
    <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-other-ns</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">system:authenticated</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I'm still confused as to what this actually does. The example above gives permissions to the default <a href="#BM_(service%20account)%2Fi">service account</a> in the <code>my-other-ns</code> <a href="#BM_(namespace)%2Fi">namespace</a>, but the <code>RoleBinding</code> is in the <code>my-ns</code> <a href="#BM_(namespace)%2Fi">namespace</a>. Does that mean the <a href="#BM_(service%20account)%2Fi">service account</a> won't get permissions because it's in another <a href="#BM_(namespace)%2Fi">namespace</a>?</p>
</div>
</li>
<li>
<p><code>Role</code> and <code>ClusterRoleBinding</code>: Invalid. It's allowed but it <em>does nothing</em> (it won't cause an error).</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ns</span>
<span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">services</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">get</span>, <span class="hljs-string">list</span>]
<span class="hljs-string">----</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role-binding</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span>
<span class="hljs-attr">subjects:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
    <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ns</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
</code></pre>
</li>
</ul>
<p><a href="#BM_(cluster%20role%7Crole)%2Fi">Role</a>s / <a href="#BM_(cluster%20role%7Crole)%2Fi">cluster role</a>s define a set of rules, where each rule grants access to a specific part of the API. Each rule requires three pieces of information:</p>
<ul>
<li><code>resources</code>: The <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s to allow (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, <a href="#BM_(service)%2Fi">service</a>s, <a href="#BM_(node)%2Fi">node</a>s, etc.., note these are plurals).</li>
<li><code>verbs</code>: The actions to allow (e.g. <code>GET</code>, <code>DELETE</code>, etc..).</li>
<li><code>apiGroups</code>: The APIs of the <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s, which roughly maps to the <code>apiVersion</code> field used within a <a href="#BM_(manifest)%2Fi">manifest</a> for that <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>. For core APIs such as <a href="#BM_(service)%2Fi">service</a>s and <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, this should be an empty string.</li>
</ul>
<p>In addition, <a href="#BM_(cluster%20role%7Crole)%2Fi">cluster role</a>s take in a set of paths, where each path grants access to a specific path on the API server. This is useful in scenarios where the path being accessed doesn't represent a <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> (meaning it can't be represented with rules as described above -- e.g. querying the health information of the cluster).</p>
<p>All of the fields discussed above can use wildcards via <code>*</code>.</p>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role</span>
<span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">"*"</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">"*"</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"*"</span>]
  <span class="hljs-bullet">-</span> <span class="hljs-attr">nonResourceURLs:</span> [<span class="hljs-string">"/api/*"</span>, <span class="hljs-string">"/apis/*"</span>]
</code></pre>
<p><a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">Role binding</a>s / <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">cluster role binding</a>s associate a set of subjects (users, groups, and / or <a href="#BM_(service%20account)%2Fi">service account</a>s) with a <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> / <a href="#BM_(cluster%20role%7Crole)%2Fi">cluster role</a> with, granting each subject the permissions defined by that <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> / <a href="#BM_(cluster%20role%7Crole)%2Fi">cluster role</a>. Each subject needs to be either a ...</p>
<ul>
<li><a href="#BM_(service%20account)%2Fi">service account</a>, requiring that <a href="#BM_(service%20account)%2Fi">service account</a>'s name and <a href="#BM_(namespace)%2Fi">namespace</a>.</li>
<li>group, requiring that group's name.</li>
<li>user, requiring that user's name.</li>
</ul>
<pre class="hljs"><code><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-cluster-role-binding</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span>
<span class="hljs-attr">subjects:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
    <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ns</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">default</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">system:authenticated</span>  <span class="hljs-comment"># case-sensitive</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">dave</span>  <span class="hljs-comment"># case-sensitive</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I suspect that users and groups are cluster-level resources, hence the lack of <a href="#BM_(namespace)%2Fi">namespace</a>. Haven't been able to verify this.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What exactly is the <code>system:authenticated</code> group in the examples above? According to the book, there are several groups internal to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> that help identify an account:</p>
<ul>
<li><code>system:unauthenticated</code> - Group assigned when authentication failed.</li>
<li><code>system:authenticated</code> - Group assigned when authentication succeeded.</li>
<li><code>system:serviceaccounts</code> - Group assigned to <a href="#BM_(service%20account)%2Fi">service account</a>s.</li>
<li><code>system:serviceaccounts:&lt;NAMESPACE&gt;</code> - Group assigned to <a href="#BM_(service%20account)%2Fi">service account</a>s under a specific <a href="#BM_(namespace)%2Fi">namespace</a>.</li>
</ul>
</div>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> comes with several predefined <a href="#BM_(cluster%20role%7Crole)%2Fi">cluster role</a>s that can be used as needed:</p>
<ul>
<li><code>cluster-admin</code>: Full-access to everything in the cluster.</li>
<li><code>admin</code>: Access to almost everything in the cluster (resource quotas and <a href="#BM_(namespace)%2Fi">namespace</a>s excluded).</li>
<li><code>view</code>: Access to view most <a href="#BM_(object)%2Fi">object</a>s in the cluster (<a href="#BM_(cluster%20role%7Crole)%2Fi">role</a>s and <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a>s excluded).</li>
<li><code>edit</code>: Access to edit most <a href="#BM_(object)%2Fi">object</a>s in the cluster (<a href="#BM_(cluster%20role%7Crole)%2Fi">role</a>s and <a href="#BM_(role%20binding%7Ccluster%20role%20binding)%2Fi">role binding</a>s excluded).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>edit</code> also excludes access to resource quotes and <a href="#BM_(namespace)%2Fi">namespace</a>s? Unsure.</p>
</div>
<a name="H_Disable%20Credentials"></a><h2>Disable Credentials</h2>
<p><a name="BM_(API%20Security%5C%2FDisable%20Credentials)_TOPIC%2Fi"></a><strong></strong></p>
<p>By default, a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> will mount its <a href="#BM_(service%20account)%2Fi">service account</a>'s credentials to <code>/var/run/secrets/kubernetes.io/serviceaccount</code> within its <a href="#BM_(container)%2Fi">container</a>s. Unless access to the API is required, it's good practice to disable the mounting of credentials entirely. This can be done via the <a href="#BM_(service%20account)%2Fi">service account</a> <a href="#BM_(object)%2Fi">object</a> or the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> <a href="#BM_(object)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-comment"># Disable on service account</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service-account</span>
  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Don't mount creds into pods using this service account</span>
<span class="hljs-string">----</span>
<span class="hljs-comment"># Disable on pod</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">my-service-account</span>
  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># Prevent auth details from mounting to containers in pod</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:1.0</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that it's also possible to disable auto-mounting on individual <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. Auto-mounting can't be disabled on individual <a href="#BM_(container)%2Fi">container</a>s, but it is possible to override the <code>/var/run/secrets/kubernetes.io/serviceaccount</code> mount on those <a href="#BM_(container)%2Fi">container</a>s with something like tmpfs (empty directory).</p>
</div>
<a name="H_Kubectl%20Cheatsheet"></a><h1>Kubectl Cheatsheet</h1>
<p><a href="#BM_(kubectl)%2Fi">kubectl</a> commands are typically organized into <a href="#BM_(context)%2Fi">context</a>s, where each <a href="#BM_(context)%2Fi">context</a> is defines <a href="#BM_(context)%2Fi">context</a>ual information about the cluster: cluster location, cluster authentication, and default <a href="#BM_(namespace)%2Fi">namespace</a>. To ...</p>
<ul>
<li>set location, <code>kubectl config set-context {CTX} --cluster={VAL}</code></li>
<li>set user, <code>kubectl config set-context {CTX} --user={VAL}</code></li>
<li>set <a href="#BM_(namespace)%2Fi">namespace</a>, <code>kubectl config set-context {CTX} --namespace={VAL}</code></li>
<li>use a <a href="#BM_(context)%2Fi">context</a>, <code>kubectl config use-context {CTX}</code></li>
</ul>
<p><a href="#BM_(context)%2Fi">Context</a> information is usually stored in <code>$HOME/.kube/config</code>.</p>
<p><a href="#BM_(kubectl)%2Fi">kubectl</a> commands that target an <a href="#BM_(object)%2Fi">object</a> require a <a href="#BM_(namespace)%2Fi">namespace</a>. That <a href="#BM_(namespace)%2Fi">namespace</a> can either be supplied via ...</p>
<ul>
<li><code>--namespace={NS}</code> argument to target a specific <a href="#BM_(namespace)%2Fi">namespace</a>,</li>
<li><code>--all-namespaces</code> argument to target all <a href="#BM_(namespace)%2Fi">namespace</a>s,</li>
</ul>
<p>, ... or through the default <a href="#BM_(namespace)%2Fi">namespace</a> set for the current <a href="#BM_(context)%2Fi">context</a>. If not set explicitly in the <a href="#BM_(context)%2Fi">context</a>, the <a href="#BM_(namespace)%2Fi">namespace</a> will be <code>default</code>.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API is exposed as a RESTful interface, meaning everything is represented as an <a href="#BM_(object)%2Fi">object</a> and accessed / mutated using standard REST verbs (GET, PUT, DELETE, etc..). <a href="#BM_(kubectl)%2Fi">kubectl</a> uses this interface to access the cluster. For example, accessing https://cluster/api/v1/<a href="#BM_(namespace)%2Fi">namespace</a>s/default/<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s/obn_pod is equivalent to running <code>kubectl get pod obj_pod</code>. The difference between the two is that by default <a href="#BM_(kubectl)%2Fi">kubectl</a> formats the output in a human friendly manner, often omitting or shortening certain details. That output can be controlled using flags. Specifically, to ...</p>
<ul>
<li>get more detail, use <code>-o wide</code>.</li>
<li>remove headers such that the output can be more easily piped to other tools like <code>wc</code>, use <code>--no-headers</code>.</li>
<li>get JSON output <code>-o json</code></li>
<li>get YAML output <code>-o yaml</code></li>
<li>get JSON output isolated to a specific field or fields <code>-o jsonpath --template={TEMPLATE}</code>, where the template is a JSONPath expression.</li>
</ul>
<a name="H_CRUD"></a><h2>CRUD</h2>
<p><code>get</code> / <code>describe</code> allows you to get details on a specific <a href="#BM_(object)%2Fi">object</a>s and resources. To get an overview of a ...</p>
<ul>
<li>list of all <a href="#BM_(object)%2Fi">object</a>s of a specific resource type using <code>kubectl get {RES}</code>.</li>
<li>a specific <a href="#BM_(object)%2Fi">object</a> of a specific resource type using <code>kubectl get {RES} {OBJ}</code>.</li>
</ul>
<p><code>describe</code> provides more in-depth information vs <code>get</code>.</p>
<p>Examples of <a href="#BM_(object)%2Fi">object</a> access:</p>
<ul>
<li><code>kubectl get componentstatuses</code> - basic cluster diagnostics</li>
<li><code>kubectl get nodes</code> - list <a href="#BM_(node)%2Fi">node</a>s</li>
<li><code>kubectl get nodes --selector='class=high-mem'</code> - list <a href="#BM_(node)%2Fi">node</a>s that have <a href="#BM_(label)%2Fi">label</a> class set to high-mem (<a href="#BM_(label%20selector)%2Fi">label selector</a>)</li>
<li><code>kubectl get nodes --selector='class=high-mem,!gpu'</code> - list <a href="#BM_(node)%2Fi">node</a>s that have <a href="#BM_(label)%2Fi">label</a> class set to high-mem but <a href="#BM_(label)%2Fi">label</a> gpu unset (<a href="#BM_(label%20selector)%2Fi">label selector</a>)</li>
<li><code>kubectl describe nodes {NAME}</code> - <a href="#BM_(node)%2Fi">node</a> information</li>
<li><code>kubectl get daemonSets --namespace={NAMESPACE} {NAME}</code></li>
<li><code>kubectl get deployments --namespace={NAMESPACE} {NAME}</code></li>
<li><code>kubectl get services --namespace={NAMESPACE} {NAME}</code></li>
</ul>
<p>Add <code>--watch</code> flag to have <a href="#BM_(kubectl)%2Fi">kubectl</a> continually provide updates.</p>
<p><code>apply</code> allows you to create and update <a href="#BM_(object)%2Fi">object</a>s. To create or update using ...</p>
<ul>
<li>a YAML file, <code>kubectl apply -f obj.yaml</code>.</li>
<li>a JSON file, <code>kubectl apply -f obj.json</code>.</li>
<li>STDIN, <code>kubectl apply -f -</code>.</li>
</ul>
<p>It will not allow you to delete <a href="#BM_(object)%2Fi">object</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Is this true? See <code>kubectl apply</code> with prune flag.</p>
</div>
<p><code>edit</code> is shorthand for <code>get</code> and <code>apply</code> in that it'll open the YAML in an editor and allow you to make changes directly.</p>
<ul>
<li><code>kubectl edit deployment {NAME}</code></li>
<li><code>kubectl edit service {NAME}</code></li>
</ul>
<p><code>delete</code> allows you to delete an <a href="#BM_(object)%2Fi">object</a>. To delete using ...</p>
<ul>
<li>a YAML file, <code>kubectl delete -f obj.yaml</code>.</li>
<li>a JSON file, <code>kubectl delete -f obj.json</code>.</li>
<li>STDIN, <code>kubectl apply -f -</code>.</li>
<li>command line, <code>kubectl delete {RES} {OBJ}</code></li>
</ul>
<p>In certain cases, the <a href="#BM_(object)%2Fi">object</a> being deleted has parental links to other <a href="#BM_(object)%2Fi">object</a>s. For example, a <a href="#BM_(replica%20set)%2Fi">replica set</a> is the parent of the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s it creates and watches. If you delete these parent <a href="#BM_(object)%2Fi">object</a>s, by default their children go with it unless the <code>--cascade=false</code> flag is used.</p>
<p><code>label</code> / <code>annotate</code> allows you to <a href="#BM_(label)%2Fi">label</a> / <a href="#BM_(annotation%7Cannotate)%2Fi">annotate</a> an <a href="#BM_(object)%2Fi">object</a>.</p>
<ul>
<li><code>kubectl label pods {POD} mark=55a</code> - set <a href="#BM_(label)%2Fi">label</a> mark to value 55a on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> (no overwrite).</li>
<li><code>kubectl label --overwrite pods {POD} mark=77a</code> - overwrite <a href="#BM_(label)%2Fi">label</a> mark to value 77a on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl label --overwrite pods {POD} mark=77a,end=fff</code> - overwrite <a href="#BM_(label)%2Fi">label</a> mark to value 77a and end to value fff on a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl label pods {POD} mark-</code> - remove <a href="#BM_(label)%2Fi">label</a> mark from a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p>When referencing <a href="#BM_(object)%2Fi">object</a>s, the ...</p>
<ul>
<li><code>--selector</code> flag can be fed in a <a href="#BM_(label%20selector)%2Fi">label selector</a> that filters those <a href="#BM_(object)%2Fi">object</a>s.</li>
<li><code>--all</code> flag can target everything.</li>
</ul>
<a name="H1_Deployment"></a><h2>Deployment</h2>
<p><code>rollout</code> allows you to monitor and control <a href="#BM_(deployment)%2Fi">deployment</a> rollouts.</p>
<ul>
<li><code>kubectl rollout status deployments {DEPLOYMENT}</code> - monitor rollout</li>
<li><code>kubectl rollout pause deployments {DEPLOYMENT}</code> - pause rollout</li>
<li><code>kubectl rollout resume deployments {DEPLOYMENT}</code> - resume rollout</li>
<li><code>kubectl rollout history deployments {DEPLOYMENT}</code> - view rollout history</li>
<li><code>kubectl rollout undo deployments {DEPLOYMENT}</code> - undo rollout (works regardless state -- e.g. if a rollout is currently in progress or not)</li>
<li><code>kubectl rollout undo deployments {DEPLOYMENT} --to-revision={REV}</code> - undo rollout to a previous revision (see rollout history command)</li>
</ul>
<p><code>configmap</code> allows you to create a configuration for applications running in <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
<ul>
<li><code>kubectl create configmap {CONFIGMAP} --from-file=my-config.txt --from-literal=key1=value1 --from-literal=key2=value2</code></li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The option <code>--from-file</code> can also point to a directory, in which case an entry will get created for each file in the directory provided that the filenames don't have any disallowed characters.</p>
</div>
<p><code>secret</code> allows you to create a security related configuration for applications running in <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
<ul>
<li><code>kubectl create secret generic my-tls-cert --from-file=a.crt --from-file=a.key</code></li>
</ul>
<a name="H_Proxy"></a><h2>Proxy</h2>
<p><code>proxy</code> allows you to launch a proxy that lets you talk internally with the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API server.</p>
<ul>
<li><code>kubectl proxy</code></li>
</ul>
<a name="H_Debug"></a><h2>Debug</h2>
<p><code>logs</code> allows you to view outputs of a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubectl logs {POD}</code> - get logs for a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl logs {POD} -c {CONTAINER}</code> - get logs for a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl logs {POD} -c {CONTAINER} -f</code> - tail logs for a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<p><code>exec</code> allows you to run a command on a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubectl exec -it {POD} -- ps uax</code> - execute ps on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl exec -it {POD} -- bash</code> - execute bash on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and interact with it.</li>
<li><code>kubectl exec -it {POD} -c {CONTAINER} -- bash</code> - execute bash on a <a href="#BM_(container)%2Fi">container</a> within <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> and interact with it.</li>
</ul>
<p><code>attach</code> allows you to attach to a <a href="#BM_(container)%2Fi">container</a>'s main running process.</p>
<ul>
<li><code>kubectl attach -it {POD}</code> - attach to main process on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl attach -it {POD} -c {CONTAINER}</code> - attach to main process on a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>attach</code> is similar to <code>logs</code> with the tailing flag but also allows you pipe into stdin.</p>
</div>
<p><code>cp</code> allows you to copy files between your machine and a <a href="#BM_(container)%2Fi">container</a>.</p>
<ul>
<li><code>kubetctl cp {POD}:{POD_PATH} {LOCAL_PATH}</code> - copy from single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to local path.</li>
<li><code>kubetctl cp {LOCAL_PATH} {POD}:{POD_PATH}</code> - copy from local path to a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubetctl cp {POD}:{POD_PATH} {LOCAL_PATH} -c {CONTAINER}</code> - copy from a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to local path.</li>
</ul>
<p><code>port-forward</code> allows you to connect to a open port on a <a href="#BM_(container)%2Fi">container</a> or connect to a <a href="#BM_(service)%2Fi">service</a>.</p>
<ul>
<li><code>kubectl port-forward {POD} 8080:80</code> - forward port 8080 locally to port 80 on a single <a href="#BM_(container)%2Fi">container</a> <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl port-forward {POD} 8080:80 -c {CONTAINER}</code> - forward port 8080 locally to port 80 on a <a href="#BM_(container)%2Fi">container</a> within a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</li>
<li><code>kubectl port-forward services/{SERVICE} 8080:80</code> - forward port 8080 locally to port 80 for some <a href="#BM_(service)%2Fi">service</a>.</li>
</ul>
<p><code>top</code> allows you to see cluster usage.</p>
<ul>
<li><code>kubectl top nodes</code> - view <a href="#BM_(node)%2Fi">node</a> resource usages.</li>
<li><code>kubectl top pods</code> - view <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> resource usages.</li>
</ul>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(%5Cbkind)s%3F%5Cb%2Fi"></a><strong>kind</strong> - A class of <a href="#BM_(object)%2Fi">object</a> within <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>, <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(secret)%2Fi">secret</a>, <a href="#BM_(replica%20set)%2Fi">replica set</a>, <a href="#BM_(deployment)%2Fi">deployment</a>, etc..).</p>
</li>
<li>
<p><a name="BM_(object)%2Fi"></a><strong>object</strong> - An entity orchestrated / managed by <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>, such as a running <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> or <a href="#BM_(service)%2Fi">service</a>.</p>
</li>
<li>
<p><a name="BM_(manifest)%2Fi"></a><strong>manifest</strong> - A <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a> (either YAML or JSON) that describes an <a href="#BM_(object)%2Fi">object</a>. This is effectively a blueprint for an <a href="#BM_(object)%2Fi">object</a>, similar to how an <a href="#BM_(image)%2Fi">image</a> is a blueprint for a <a href="#BM_(container)%2Fi">container</a>.</p>
</li>
<li>
<p><a name="BM_(image)%2Fi"></a><strong>image</strong> - An application packaged as an immutable and isolated filesystem. The filesystem typically contains all library dependencies required for the application to run in an isolated and reproducible manner (e.g. library dependencies are the versions expected by the application).</p>
<p><a href="#BM_(image)%2Fi">Image</a>s also typically include metadata describing its needs and operational standards (e.g. memory requirements for the application).</p>
</li>
<li>
<p><a name="BM_(container)%2Fi"></a><strong>container</strong> - An instance of an <a href="#BM_(image)%2Fi">image</a>. A <a href="#BM_(container)%2Fi">container</a> creates an isolated copy of the <a href="#BM_(image)%2Fi">image</a>'s filesystem, isolates the resources required for that <a href="#BM_(image)%2Fi">image</a>, and launches the entrypoint application for that <a href="#BM_(image)%2Fi">image</a>. That <a href="#BM_(container)%2Fi">container</a> can't see or access anything outside of the <a href="#BM_(container)%2Fi">container</a> unless explicitly allowed to by the user. For example, opening a port 8080 on a <a href="#BM_(container)%2Fi">container</a> won't open port 8080 on the host running it, but the user can explicitly ask that port 8080 in the <a href="#BM_(container)%2Fi">container</a> map to some port on the host.</p>
</li>
<li>
<p><a name="BM_(registry)%2Fi"></a><strong>registry</strong> - A <a href="#BM_(service)%2Fi">service</a> for storing and retrieving <a href="#BM_(image)%2Fi">image</a>s.</p>
</li>
<li>
<p><a name="BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi"></a><strong>multistage image</strong> - A <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a> produced by merging portions of other <a href="#BM_(container)%2Fi">container</a> <a href="#BM_(image)%2Fi">image</a>s together. For example, to build a <a href="#BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi">multistage image</a> that contains Java as well as compiled C++ binaries, ...</p>
<ol>
<li>an <a href="#BM_(image)%2Fi">image</a> containing the JVM has its Java directory pulled out.</li>
<li>an <a href="#BM_(image)%2Fi">image</a> containing the GNU Compiler toolchain compiles some C++ code, then those compiled binaries are pulled out.</li>
</ol>
<p>The end result is that the <a href="#BM_(multistage%20build%7Cmultistage%20image%7Cmultistage%20container%20image)%2Fi">multistage build</a> only contains the relevant portions of its "stages" (previous <a href="#BM_(image)%2Fi">image</a>s), leading to a more focused <a href="#BM_(image)%2Fi">image</a> with smaller size.</p>
</li>
<li>
<p><a name="BM_(Open%20Container%20Initiative%20runtime%7COpen%20Container%20Initiative)%2Fi"></a><strong>open container initiative runtime</strong>  <a name="BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F"></a><strong></strong>- A runtime responsible for only creating and launching <a href="#BM_(container)%2Fi">container</a>s. Examples include runC, rkt, runV, gviso, etc.. Some of these use Linux isolation technology (cgroups and <a href="#BM_(namespace)%2Fi">namespace</a>s) while others use virtualization technology.</p>
</li>
<li>
<p><a name="BM_(container%20runtime%20interface)%2Fi"></a><strong>container runtime interface</strong> <a name="BM_%5Cb(CRI)s%3F%5Cb%2F"></a><strong></strong> - A runtime responsible for the high-level management of <a href="#BM_(container)%2Fi">container</a>s and <a href="#BM_(image)%2Fi">image</a>s: <a href="#BM_(image)%2Fi">image</a> management, <a href="#BM_(image)%2Fi">image</a> distribution, <a href="#BM_(container)%2Fi">container</a> mounts / storage, <a href="#BM_(container)%2Fi">container</a> networking, etc..</p>
<p><a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s are also responsible for running <a href="#BM_(container)%2Fi">container</a>s, but typically do so by delegating to an <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>. Examples of <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s include <a href="#BM_(container)%2Fi">container</a>d, and cri-o.</p>
</li>
<li>
<p><a name="BM_(container%20engine)%2Fi"></a><strong>container engine</strong> - A high-level application / cohesive set of applications used for all the things <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>s and <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s are used for as well as building <a href="#BM_(image)%2Fi">image</a>s, signing <a href="#BM_(image)%2Fi">image</a>s, and several other extra features. <a href="#BM_(container%20engine)%2Fi">Container engine</a>s typically delegate to <a href="#BM_%5Cb(OCI%20runtime%7COCI)s%3F%5Cb%2F">OCI runtime</a>s and <a href="#BM_%5Cb(CRI)s%3F%5Cb%2F">CRI</a>s for most of their functionality.</p>
<p>Examples include Docker Engine and <a href="#BM_(container)%2Fi">Container</a> Tools (podman for running <a href="#BM_(container)%2Fi">container</a>s, buildah for building <a href="#BM_(image)%2Fi">image</a>s, and skopeo for <a href="#BM_(image)%2Fi">image</a> distribution).</p>
</li>
<li>
<p><a name="BM_(Kubernetes)%2Fi"></a><strong>Kubernetes</strong> - A tool for orchestrating multiple <a href="#BM_(container)%2Fi">container</a>s across a set machines. Provides features such as load balancing, <a href="#BM_(service)%2Fi">service</a> naming, <a href="#BM_(service)%2Fi">service</a> discovery, automated <a href="#BM_(service)%2Fi">service</a> scaling, and automated <a href="#BM_(service)%2Fi">service</a> recovery.</p>
</li>
<li>
<p><a name="BM_(node)%2Fi"></a><strong>node</strong> - A host that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> uses to run the <a href="#BM_(container)%2Fi">container</a>s its orchestrating.</p>
</li>
<li>
<p><a name="BM_(master%20node)%2Fi"></a><strong>master node</strong> - A <a href="#BM_(node)%2Fi">node</a> responsible for the managing the cluster (<a href="#BM_(control%20plane)%2Fi">control plane</a>).</p>
</li>
<li>
<p><a name="BM_(worker%20node)%2Fi"></a><strong>worker node</strong> - A <a href="#BM_(node)%2Fi">node</a> responsible for running application <a href="#BM_(container)%2Fi">container</a>s.</p>
</li>
<li>
<p><a name="BM_%5Cb(pod)s%3F%5Cb%2Fi"></a><strong>pod</strong> - A set of <a href="#BM_(container)%2Fi">container</a>s all bundled together as a single unit, where all <a href="#BM_(container)%2Fi">container</a>s in that bundle are intended to run on the same <a href="#BM_(node)%2Fi">node</a>.</p>
</li>
<li>
<p><a name="BM_(pod%20template)%2Fi"></a><strong>pod template</strong> - The blueprint for creating <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
</li>
<li>
<p><a name="BM_(namespace)%2Fi"></a><strong>namespace</strong> - A user-defined category for <a href="#BM_(object)%2Fi">object</a>s in a cluster (e.g. <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s), allowing <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> do things such as apply isolation and access control. By default, the <a href="#BM_(kubectl)%2Fi">kubectl</a> command uses the <a href="#BM_(namespace)%2Fi">namespace</a> <code>default</code> if no <a href="#BM_(namespace)%2Fi">namespace</a> is specified.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book tells you to think of it like it's a folder.</p>
</div>
</li>
<li>
<p><a name="BM_(kube-system)%2Fi"></a><strong>kube-system</strong> - A <a href="#BM_(namespace)%2Fi">namespace</a> for internal cluster components (<a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s) that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs for itself. For example, <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">Kubernetes's DNS</a> <a href="#BM_(service)%2Fi">service</a>, <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">Kubernetes's proxy</a> <a href="#BM_(service)%2Fi">service</a>, etc.. all run under the <a href="#BM_(kube-system)%2Fi">kube-system</a> <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
</li>
<li>
<p><a name="BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi"></a><strong>kube-proxy</strong> - An internal <a href="#BM_(kube-proxy%7CKubernetes%20proxy%7CKubernetes's%20proxy)%2Fi">Kubernetes proxy</a> <a href="#BM_(service)%2Fi">service</a> responsible for routing traffic to the correct <a href="#BM_(service)%2Fi">service</a>s and load balancing between a <a href="#BM_(service)%2Fi">service</a>'s <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s. Runs on every <a href="#BM_(node)%2Fi">node</a> in the cluster.</p>
</li>
<li>
<p><a name="BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi"></a><strong>core-dns</strong> - An internal <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">Kubernetes DNS</a> <a href="#BM_(service)%2Fi">service</a> responsible for naming and discovery of the <a href="#BM_(service)%2Fi">service</a>s running on the cluster. Older versions of <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> call this <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">kube-dns</a> instead of <a href="#BM_(core-dns%7Ckube-dns%7CKubernetes%20DNS%7CKubernetes's%20DNS)%2Fi">core-dns</a>.</p>
</li>
<li>
<p><a name="BM_(kubernetes-dashboard%7CKubernetes%20Dashboard%7CKubernetes%20UI%7CKubernetes%20GUI%7CKubernetes's%20Dashboard%7CKubernetes's%20UI%7CKubernetes's%20GUI)%2Fi"></a><strong>kubernetes-dashboard</strong> - An internal <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(service)%2Fi">service</a> responsible for providing a GUI to interface with and explore the cluster.</p>
</li>
<li>
<p><a name="BM_(kubectl)%2Fi"></a><strong>kubectl</strong> - The standard command-line client for <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>.</p>
</li>
<li>
<p><a name="BM_(context)%2Fi"></a><strong>context</strong> - In reference to <a href="#BM_(kubectl)%2Fi">kubectl</a>, <a href="#BM_(context)%2Fi">context</a> refers to default cluster access settings <a href="#BM_(kubectl)%2Fi">kubectl</a> applies when running some command: cluster location, cluster authentication, and default <a href="#BM_(namespace)%2Fi">namespace</a>.</p>
</li>
<li>
<p><a name="BM_(label)%2Fi"></a><strong>label</strong> - User-defined key-value pairs assigned to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(object)%2Fi">object</a>s to group those <a href="#BM_(object)%2Fi">object</a>s together. <a href="#BM_(label)%2Fi">Label</a>ing <a href="#BM_(object)%2Fi">object</a>s makes it so they can be accessed as a set (e.g. target all <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s with authoring team set to SRE). Unlike <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s, <a href="#BM_(label)%2Fi">label</a>s aren't for assigning metadata to <a href="#BM_(object)%2Fi">object</a>s.</p>
</li>
<li>
<p><a name="BM_(label%20selector)%2Fi"></a><strong>label selector</strong> - An expression language used to find <a href="#BM_(object)%2Fi">object</a>s with <a href="#BM_(label)%2Fi">label</a>s. For example...</p>
<ul>
<li><code>key=value</code></li>
<li><code>key!=value</code></li>
<li><code>key in (value1, value2)</code></li>
</ul>
</li>
<li>
<p><a name="BM_(annotation%7Cannotate)%2Fi"></a><strong>annotation</strong> - User-defined key-value pairs assigned to <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> <a href="#BM_(object)%2Fi">object</a>s that acts as metadata for other tools and libraries. Unlike <a href="#BM_(label)%2Fi">label</a>s, <a href="#BM_(annotation%7Cannotate)%2Fi">annotation</a>s aren't for grouping <a href="#BM_(object)%2Fi">object</a>s together.</p>
</li>
<li>
<p><a name="BM_(declarative%20configuration)%2Fi"></a><strong>declarative configuration</strong> - A form of configuring where the configuration is submitted as a state and the system adjusts itself to match that state.</p>
</li>
<li>
<p><a name="BM_(imperative%20configuration)%2Fi"></a><strong>imperative configuration</strong> - A form of configuring where the configuration is submitted as a set of instructions and the system runs those instructions.</p>
</li>
<li>
<p><a name="BM_(health%20check)%2Fi"></a><strong>health check</strong> - A <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> mechanism that checks the state of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s and performs corrective action if it deems necessary. This includes both ensuring that the main <a href="#BM_(container)%2Fi">container</a> process is running, <a href="#BM_(liveness%20probe)%2Fi">liveness probe</a>s, and <a href="#BM_(readiness%20probe)%2Fi">readiness probe</a>s.</p>
</li>
<li>
<p><a name="BM_(liveness%20probe)%2Fi"></a><strong>liveness probe</strong> - A user-defined task that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs to ensure that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is running correctly. For example, an HTTP server that stalls when for more than 15 seconds before returning a response may be deemed as no longer live.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> restarts a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> if it deems it as no longer alive.</p>
</li>
<li>
<p><a name="BM_(readiness%20probe)%2Fi"></a><strong>readiness probe</strong> - A user-defined task that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> runs to ensure that a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> is in a position to accept requests. For example, an HTTP server that has all of its worker threads busy processing requests may be deemed as not ready.</p>
<p><a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> stops routing requests to a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> if its no longer ready (removed from load balancer).</p>
</li>
<li>
<p><a name="BM_(utilization)%2Fi"></a><strong>utilization</strong> - A metric that tracks the amount of resources in use vs the amount of resources available.</p>
</li>
<li>
<p><a name="BM_(resource%20request)%2Fi"></a><strong>resource request</strong> - The minimum amount of resources required to run an <a href="#BM_(image)%2Fi">image</a> (not a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>).</p>
</li>
<li>
<p><a name="BM_(resource%20limit)%2Fi"></a><strong>resource limit</strong> - The maximum amount of resources that an <a href="#BM_(image)%2Fi">image</a> (not a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>) may take up.</p>
<p>If <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> needs to scale down a resource for a <a href="#BM_(container)%2Fi">container</a> that isn't dynamic (e.g. a running process can have its CPU usage reduced but you can't force a running process to give up memory its holding on to), the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> gets restarted with that resource scaled down.</p>
</li>
<li>
<p><a name="BM_(service)%2Fi"></a><strong>service</strong> - A set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s exposed under a single named network <a href="#BM_(service)%2Fi">service</a>. Requests coming in to the <a href="#BM_(service)%2Fi">service</a> and are load balanced across the set of <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s.</p>
</li>
<li>
<p><a name="BM_(endpoints)%2Fi"></a><strong>endpoints</strong> - A low-level <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that's used to map a <a href="#BM_(service)%2Fi">service</a> to the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s it routes to. In other words, an <a href="#BM_(endpoints)%2Fi">endpoints</a> (note the plural) <a href="#BM_(object)%2Fi">object</a> is an abstraction that references a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(ingress)%2Fi"></a><strong>ingress</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that acts as an HTTP-based frontend that routes and load balances incoming external requests to the correct <a href="#BM_(service)%2Fi">service</a>. This <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> is an interface without an implementation, meaning that <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> doesn't have anything built-in to handle <a href="#BM_(ingress)%2Fi">ingress</a>. Implementations of this interfaces are referred to as <a href="#BM_(ingress)%2Fi">Ingress</a> <a href="#BM_(controller)%2Fi">controller</a>s and are provided by third-parties.</p>
</li>
<li>
<p><a name="BM_(replica%20set)%2Fi"></a><strong>replica set</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that ensures a certain number of copies of some <a href="#BM_(pod%20template)%2Fi">pod template</a> are running at any time.</p>
</li>
<li>
<p><a name="BM_(deployment)%2Fi"></a><strong>deployment</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that has the same functionality as a <a href="#BM_(replica%20set)%2Fi">replica set</a> but also provides functionality for updating <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to a new version and rolling them back to previous versions.</p>
</li>
<li>
<p><a name="BM_(stateful%20set%7Cstable%20identity)%2Fi"></a><strong>stateful set</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that has similar functionality to a <a href="#BM_(deployment)%2Fi">deployment</a> but also allows its <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to retain a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> and dedicated persistent storage.</p>
<ul>
<li><a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">Stable identity</a> means that, if a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> dies, it gets replaced with a new <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> that has the same identity information (same name, same IP, etc..)</li>
<li>Dedicated persistent storage means that each <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stable identity</a> can have <a href="#BM_(persistent%20volume%20claim)%2Fi">persistent volume claim</a>s unique to it (not shared between other <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s within the <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>).</li>
</ul>
</li>
<li>
<p><a name="BM_(reconciliation%20loop)%2Fi"></a><strong>reconciliation loop</strong> - A loop that continually observes state and attempts to reconcile it to some desired state if it deviates. See <a href="#BM_(declarative%20configuration)%2Fi">declarative configuration</a>.</p>
</li>
<li>
<p><a name="BM_(daemon%20set)%2Fi"></a><strong>daemon set</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that ensures a set of <a href="#BM_(node)%2Fi">node</a>s always have an instance of some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> running.</p>
</li>
<li>
<p><a name="BM_(job)%2Fi"></a><strong>job</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that launches as a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> to perform some one-off task.</p>
</li>
<li>
<p><a name="BM_(cron%20job)%2Fi"></a><strong>cron job</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that launches <a href="#BM_(job)%2Fi">job</a>s on a repeating schedule.</p>
</li>
<li>
<p><a name="BM_(config%20map%7Cconfiguration%20map)%2Fi"></a><strong>configuration map</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> for configuring the <a href="#BM_(container)%2Fi">container</a>s running in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(secret)%2Fi"></a><strong>secret</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> for security-related configurations of the <a href="#BM_(container)%2Fi">container</a>s running in a <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>.</p>
</li>
<li>
<p><a name="BM_(millicpu%7Cmillicore)%2Fi"></a><strong>millicpu</strong> - A <a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a> is 0.001 CPU cores (e.g. 1000 <a href="#BM_(millicpu%7Cmillicore)%2Fi">millicpu</a> = 1 core).</p>
</li>
<li>
<p><a name="BM_(persistent%20volume)%2Fi"></a><strong>persistent volume</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that represents non-ephemeral disk space.</p>
</li>
<li>
<p><a name="BM_(persistent%20volume%20claim)%2Fi"></a><strong>persistent volume claim</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that claims a <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a>, essentially acting as a marker that the <a href="#BM_(persistent%20volume)%2Fi">persistent volume</a> is claimed and ready to use by <a href="#BM_(container)%2Fi">container</a>s within the cluster.</p>
</li>
<li>
<p><a name="BM_(governing%20service)%2Fi"></a><strong>governing service</strong> - A headless <a href="#BM_(service)%2Fi">service</a> for a <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> that lets the <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s of that <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a> to discover each other (peer discovery).</p>
</li>
<li>
<p><a name="BM_(control%20plane)%2Fi"></a><strong>control plane</strong> - The distributed software that controls and makes up the functionality of a <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> cluster, including the API server and scheduler used for assigning <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s to <a href="#BM_(worker%20node)%2Fi">worker node</a>s.</p>
</li>
<li>
<p><a name="BM_(controller)%2Fi"></a><strong>controller</strong> - A piece of software running on the <a href="#BM_(control%20plane)%2Fi">control plane</a> that provides some functionality. This includes doing the work of reconciling observed state to desired state (<a href="#BM_(reconciliation%20loop)%2Fi">reconciliation loop</a>) and / or supporting new <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a>s. <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">Kind</a>s such as <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s, <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>s, <a href="#BM_(node)%2Fi">node</a>s, etc.. all have <a href="#BM_(controller)%2Fi">controller</a>s backing them, and custom <a href="#BM_(controller)%2Fi">controller</a>s can be written and deployed by users.</p>
</li>
<li>
<p><a name="BM_(service%20account)%2Fi"></a><strong>service account</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> used for authenticating <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s with the <a href="#BM_(control%20plane)%2Fi">control plane</a>.</p>
</li>
<li>
<p><a name="BM_(role%5B-%5Cs%5Dbased%20access%20control)%2Fi"></a><strong>role-based access control</strong> <a name="BM_(RBAC)%2F"></a><strong></strong> - The default security mechanism in <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a>, which uses <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a>s to limit what users (and <a href="#BM_(service%20account)%2Fi">service account</a>s) can access via the <a href="#BM_(Kubernetes)%2Fi">Kubernetes</a> API.</p>
</li>
<li>
<p><a name="BM_(cluster%20role%7Crole)%2Fi"></a><strong>role</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> specific to <a href="#BM_(RBAC)%2F">RBAC</a> that defines a set of permissions.</p>
</li>
<li>
<p><a name="BM_(role%20binding%7Ccluster%20role%20binding)%2Fi"></a><strong>role binding</strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> specific to <a href="#BM_(RBAC)%2F">RBAC</a> that binds a <a href="#BM_(cluster%20role%7Crole)%2Fi">role</a> to a set of users, groups, and / or <a href="#BM_(service%20account)%2Fi">service account</a>s.</p>
</li>
<li>
<p><a name="BM_(horizontal%20pod%20autoscaler%7Chorizontal%20pod%20autoscaling)%2Fi"></a><strong>horizontal pod autoscaler</strong> <a name="BM_%5Cb(HPA)%5Cb%2F"></a><strong></strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that automatically scales the number of replicas in a <a href="#BM_(deployment)%2Fi">deployment</a>, <a href="#BM_(stateful%20set%7Cstable%20identity)%2Fi">stateful set</a>, or <a href="#BM_(replica%20set)%2Fi">replica set</a> based on how much load existing replicas are under.</p>
</li>
<li>
<p><a name="BM_(vertical%20pod%20autoscaler%7Cvertical%20pod%20autoscaling)%2Fi"></a><strong>vertical pod autoscaler</strong> <a name="BM_%5Cb(VPA)%5Cb%2F"></a><strong></strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that automatically scales the resource requirements for some <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a> based on how much load existing replicas are under.</p>
</li>
<li>
<p><a name="BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi"></a><strong>cluster autoscaler</strong> - A component that automatically scales the number of <a href="#BM_(node)%2Fi">node</a>s in a cluster based on need.</p>
</li>
<li>
<p><a name="BM_(pod%20disruption%20budget)%2Fi"></a><strong>pod disruption budget</strong> <a name="BM_%5Cb(PDB)%5Cb%2F"></a><strong></strong> - A <a href="#BM_(%5Cbkind)s%3F%5Cb%2Fi">kind</a> that defines the minimum number of available <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s / maximum number of unavailable <a href="#BM_%5Cb(pod)s%3F%5Cb%2Fi">pod</a>s can be during a cluster resizing event (e.g. when <a href="#BM_(cluster%20autoscaler%7Ccluster%20autoscaling)%2Fi">cluster autoscaler</a> is scaling up or down <a href="#BM_(node)%2Fi">node</a>s).</p>
</li>
</ul>
<p></p>
<p></p>
<p></p>

        </body></html>