import json
import lzma
import math
import multiprocessing
import re
from itertools import product
from random import sample
from statistics import mean
from sys import stdin
from typing import Optional

from distance_matrix.DistanceMatrix import DistanceMatrix
from graph.UndirectedGraph import Graph
from phylogeny.NeighbourJoiningPhylogeny import neighbour_joining_phylogeny, to_dot


# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
# GLOBAL SEQUENCE ALIGNMENT CODE
def global_alignment_score(
        v: str,
        w: str,
        weight_lookup: dict[tuple[Optional[str], Optional[str]]]
) -> float:
    v_node_count = len(v) + 1
    w_node_count = len(w) + 1
    node_matrix = []
    for v_node_idx in range(v_node_count):
        row = [math.nan] * w_node_count
        node_matrix.append(row)
    node_matrix[0][0] = 0.0           # source node weight
    for v_node_idx, w_node_idx in product(range(v_node_count), range(w_node_count)):
        parents = []
        if v_node_idx > 0 and w_node_idx > 0:
            v_elem = v[v_node_idx - 1]
            w_elem = w[w_node_idx - 1]
            parents.append(
                node_matrix[v_node_idx - 1][w_node_idx - 1] + weight_lookup[v_elem, w_elem]
            )
        if v_node_idx > 0:
            v_elem = v[v_node_idx - 1]
            parents.append(
                node_matrix[v_node_idx - 1][w_node_idx] + weight_lookup[v_elem, None]
            )
        if w_node_idx > 0:
            w_elem = w[w_node_idx - 1]
            parents.append(
                node_matrix[v_node_idx][w_node_idx - 1] + weight_lookup[None, w_elem]
            )
        if parents:  # parents wil be empty if v_node_idx and w_node_idx were both 0
            node_matrix[v_node_idx][w_node_idx] = max(parents)
    return node_matrix[v_node_idx][w_node_idx]


def to_weight_table(lines: list[str]) -> dict[tuple[Optional[str], Optional[str]], float]:
    ret = {}
    header = lines[0].split()
    for data in lines[1:]:
        elems = data.split()
        e1 = None if elems[0] == '*' else elems[0]
        for e2, weight in zip(header, elems[1:]):
            e2 = None if e2 == '*' else e2
            ret[e1, e2] = float(weight)
    return ret


def to_dot(g: Graph[str, None, str, float], scale=0.1) -> str:
    ret = 'graph G {\n'
    ret += ' layout=neato\n'
    ret += ' graph[rankdir=LR]\n'
    ret += ' node[shape=box, fontname="Courier-Bold", fontsize=10]\n'
    ret += ' edge[fontname="Courier-Bold", fontsize=10]\n'
    nodes = sorted(g.get_nodes())
    n_lookup = {n: (re.sub(r"\W+", '', n), n.replace('\n', '\\n')) for n in nodes}
    for n in nodes:
        n_id, n_label = n_lookup[n]
        ret += f'{n_id} [label="{n_label}"]\n'
    for e in sorted(g.get_edges()):
        n1, n2, weight = g.get_edge(e)
        n1_id, _ = n_lookup[n1]
        n2_id, _ = n_lookup[n2]
        ret += f'{n1_id} -- {n2_id} [label="{weight:.2f}", len={weight*scale}]\n'
    ret += '}'
    return ret


def main():
    print("<div style=\"border:1px solid black;\">", end="\n\n")
    print("`{bm-disable-all}`", end="\n\n")
    try:
        # Read matrix
        lines = stdin.readlines()
        jsonpath = lines.pop(0).strip()
        sample_size = int(lines.pop(0).strip())
        edge_len_scale = float(lines.pop(0).strip())
        weight_lines = [l.rstrip() for l in lines]
        weight_lookup = to_weight_table(weight_lines)
        with lzma.open(jsonpath, mode='rt', encoding='utf-8') as f:
            seqs = json.loads(f.read())
        seqs_sample = sample(list(seqs), sample_size)
        print(f'Given a random sample of {sample_size} sequences from {jsonpath} and the following alignment weights...')
        print()
        print('```')
        for l in weight_lines:
            print(l)
        print('```')
        print()
        print(f'The tree generated by neighbour joining phylogeny is (distances measured using global alignment, edge lengths scaled to {edge_len_scale}) ...')
        print()
        relatedness = {}
        with multiprocessing.Pool(4) as p:
            for s1 in seqs_sample:
                tests = [(s1, s2) for s2 in seqs_sample if (s1, s2) not in relatedness]
                jobs = [(seqs[s1], seqs[s2], weight_lookup) for s1, s2 in tests]
                weights = p.starmap(global_alignment_score, jobs)
                for (test_s1, test_s2), weight in zip(tests, weights):
                    relatedness[test_s1, test_s2] = weight
                    relatedness[test_s2, test_s1] = weight
        # convert final alignment weights to distances -- There are some assumptions being made here, specifically that
        # that for sequences X and Y, max(alignment_score(X,X), alignment_score(Y,Y)) is the best possible alignment
        # score you can have. Depending on the weight matrix for alignment, this may not be true, but it's probably an
        # okay assumption to max.
        #
        #   best_possible_alignment_score = max(alignment_score(X,X), alignment_score(Y,Y))
        #
        # The distance is measured by subtracting alignment_score(X,Y) from this best alignment score
        #
        #  distance = best_possible_alignment_score - alignment_score(X,Y)
        distances = {}
        for s1, s2 in product(seqs_sample, repeat=2):
            if s1 == s2:
                distances[s1, s2] = 0
                continue
            peak = max(relatedness[s1, s1], relatedness[s2, s2])
            distances[s1, s2] = peak - relatedness[s1, s2]
        dist_mat = DistanceMatrix(distances)
        _next_edge_id = 0
        def gen_edge_id():
            nonlocal _next_edge_id
            _next_edge_id += 1
            return f'E{_next_edge_id}'
        _next_node_id = 0
        def gen_node_id():
            nonlocal _next_node_id
            _next_node_id += 1
            return f'N{_next_node_id}'
        tree = neighbour_joining_phylogeny(dist_mat, gen_node_id, gen_edge_id)
        print()
        print('```{dot}')
        print(f'{to_dot(tree, scale=edge_len_scale)}')
        print('```')
        print()
    finally:
        print("</div>", end="\n\n")
        print("`{bm-enable-all}`", end="\n\n")


if __name__ == '__main__':
    main()