<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <link href="katex/katex.min.css" rel="stylesheet"><title>Bioinformatics
</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><div class="toc">
<ul>
<li><a href="#H_Introduction">Introduction</a></li>
<li><a href="#H_Algorithms">Algorithms</a></li>
<ul>
<li><a href="#H_K-mer">K-mer</a></li>
<ul>
<li><a href="#H_Reverse%20Complement">Reverse Complement</a></li>
<li><a href="#H_Hamming%20Distance">Hamming Distance</a></li>
<li><a href="#H_Hamming%20Distance%20Neighbourhood">Hamming Distance Neighbourhood</a></li>
<li><a href="#H_Find%20Locations">Find Locations</a></li>
<li><a href="#H_Find%20Clumps">Find Clumps</a></li>
<li><a href="#H_Find%20Repeating">Find Repeating</a></li>
<li><a href="#H_Find%20Repeating%20in%20Window">Find Repeating in Window</a></li>
<li><a href="#H_Probability%20of%20Appearance">Probability of Appearance</a></li>
<ul>
<li><a href="#H_Bruteforce%20Algorithm">Bruteforce Algorithm</a></li>
<li><a href="#H_Selection%20Estimate%20Algorithm">Selection Estimate Algorithm</a></li>
</ul>
</ul>
<li><a href="#H_GC%20Skew">GC Skew</a></li>
<li><a href="#H_Motif">Motif</a></li>
<ul>
<li><a href="#H_Consensus%20String">Consensus String</a></li>
<li><a href="#H_Motif%20Matrix%20Count">Motif Matrix Count</a></li>
<li><a href="#H_Motif%20Matrix%20Profile">Motif Matrix Profile</a></li>
<li><a href="#H_Motif%20Matrix%20Score">Motif Matrix Score</a></li>
<ul>
<li><a href="#H_Popularity%20Algorithm">Popularity Algorithm</a></li>
<li><a href="#H_Entropy%20Algorithm">Entropy Algorithm</a></li>
<li><a href="#H_Relative%20Entropy%20Algorithm">Relative Entropy Algorithm</a></li>
</ul>
<li><a href="#H_Motif%20Logo">Motif Logo</a></li>
<li><a href="#H_K-mer%20Match%20Probability">K-mer Match Probability</a></li>
<li><a href="#H_Find%20Motif%20Matrix">Find Motif Matrix</a></li>
<ul>
<li><a href="#H1_Bruteforce%20Algorithm">Bruteforce Algorithm</a></li>
<li><a href="#H_Median%20String%20Algorithm">Median String Algorithm</a></li>
<li><a href="#H_Greedy%20Algorithm">Greedy Algorithm</a></li>
<li><a href="#H_Randomized%20Algorithm">Randomized Algorithm</a></li>
<li><a href="#H_Gibbs%20Sampling%20Algorithm">Gibbs Sampling Algorithm</a></li>
</ul>
<li><a href="#H_Motif%20Matrix%20Hybrid%20Alphabet">Motif Matrix Hybrid Alphabet</a></li>
</ul>
<li><a href="#H_DNA%20Sequencing">DNA Sequencing</a></li>
<ul>
<li><a href="#H_Stitch%20Reads">Stitch Reads</a></li>
<li><a href="#H_Stitch%20Read-Pairs">Stitch Read-Pairs</a></li>
<li><a href="#H_Break%20Reads">Break Reads</a></li>
<li><a href="#H_Break%20Read-Pairs">Break Read-Pairs</a></li>
<li><a href="#H_Probability%20of%20Fragment%20Occurrence">Probability of Fragment Occurrence</a></li>
<li><a href="#H_Overlap%20Graph">Overlap Graph</a></li>
<li><a href="#H_De%20Bruijn%20Graph">De Bruijn Graph</a></li>
<li><a href="#H_Find%20Bubbles">Find Bubbles</a></li>
<li><a href="#H_Find%20Contigs">Find Contigs</a></li>
</ul>
<li><a href="#H_Peptide%20Sequencing">Peptide Sequencing</a></li>
<ul>
<li><a href="#H_Codon%20Encode">Codon Encode</a></li>
<li><a href="#H_Codon%20Decode">Codon Decode</a></li>
<li><a href="#H_Experimental%20Spectrum">Experimental Spectrum</a></li>
<li><a href="#H_Theoretical%20Spectrum">Theoretical Spectrum</a></li>
<ul>
<li><a href="#H2_Bruteforce%20Algorithm">Bruteforce Algorithm</a></li>
<li><a href="#H_Prefix%20Sum%20Algorithm">Prefix Sum Algorithm</a></li>
</ul>
<li><a href="#H_Spectrum%20Convolution">Spectrum Convolution</a></li>
<li><a href="#H_Spectrum%20Score">Spectrum Score</a></li>
<li><a href="#H_Spectrum%20Sequence">Spectrum Sequence</a></li>
<ul>
<li><a href="#H3_Bruteforce%20Algorithm">Bruteforce Algorithm</a></li>
<li><a href="#H_Branch-and-bound%20Algorithm">Branch-and-bound Algorithm</a></li>
<li><a href="#H_Leaderboard%20Algorithm">Leaderboard Algorithm</a></li>
</ul>
</ul>
</ul>
<li><a href="#H_Stories">Stories</a></li>
<ul>
<li><a href="#H_Bacterial%20Genome%20Replication">Bacterial Genome Replication</a></li>
<ul>
<li><a href="#H_Find%20Ori%20and%20Ter">Find Ori and Ter</a></li>
<li><a href="#H_Find%20the%20DnaA%20Box">Find the DnaA Box</a></li>
</ul>
<li><a href="#H_Transcription%20Factors">Transcription Factors</a></li>
<ul>
<li><a href="#H_Find%20Regulatory%20Motif">Find Regulatory Motif</a></li>
</ul>
</ul>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_Introduction"></a><h1>Introduction</h1>
<p>Bioinformatics is the science of transforming and processing biological data to gain new insights, particularly omics data: genomics, proteomics, metabolomics, etc.. Bioinformatics is mostly a mix of biology, computer science, and statistics / data science.</p>
<a name="H_Algorithms"></a><h1>Algorithms</h1>
<a name="H_K-mer"></a><h2>K-mer</h2>
<p><a name="BM_(Algorithms%5C%2FK-mer)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is a sub<a href="#BM_(sequence)%2Fi">sequence</a> of length k within some larger biological <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. DNA or <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain). For example, in the DNA <a href="#BM_(sequence)%2Fi">sequence</a> GAAATC, the following <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
<p>Common scenarios involving <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s:</p>
<ul>
<li>Search for an exact <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>.</li>
<li>Search for an approximate <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> (fuzzy search).</li>
<li>Find <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s of interest in a <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</li>
</ul>
<a name="H_Reverse%20Complement"></a><h3>Reverse Complement</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FReverse%20Complement)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, calculate its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>.</p>
<p><strong>WHY</strong>: Depending on the type of biological <a href="#BM_(sequence)%2Fi">sequence</a>, a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may have one or more alternatives. For DNA <a href="#BM_(sequence)%2Fi">sequence</a>s specifically, a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> of interest may have an alternate form. Since the DNA molecule comes as 2 strands, where ...</p>
<ul>
<li>each strand's direction is opposite of the other,</li>
<li>each strand position has a nucleotide that complements the nucleotide at that same position on the other stand:
<ul>
<li>A ⟷ T</li>
<li>C ⟷ G</li>
</ul>
</li>
</ul>
<p><img src="svgbob_c44b72fd8e03cfe92b63a0a3b83bfe37c5551666.svg" alt="Kroki diagram output"></p>
<p>, ... the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may be just as valid as the original <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>. For example, if an enzyme is known to bind to a specific DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, it's possible that it might also bind to the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_complement</span>(<span class="hljs-params">strand: str</span>):</span>
    ret = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(strand)):
        base = strand[i]
        <span class="hljs-keyword">if</span> base == <span class="hljs-string">'A'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'a'</span>:
            base = <span class="hljs-string">'T'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'T'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'t'</span>:
            base = <span class="hljs-string">'A'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'C'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'c'</span>:
            base = <span class="hljs-string">'G'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'G'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'g'</span>:
            base = <span class="hljs-string">'C'</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Unexpected base: '</span> + base)

        ret += base
    <span class="hljs-keyword">return</span> ret[::<span class="hljs-number">-1</span>]
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Original: TAATCCG</p>
<p>Reverse Complement: CGGATTA</p>
</div>
<p></p>
<a name="H_Hamming%20Distance"></a><h3>Hamming Distance</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given 2 <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, the hamming distance is the number of positional mismatches between them.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that enzyme can also bind to other <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns that are slight variations of the original. For example, that enzyme may be able to bind to both AAACTG and AAAGTG.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hamming_distance</span>(<span class="hljs-params">kmer1: str, kmer2: str</span>) -&gt; int:</span>
    mismatch = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> ch1, ch2 <span class="hljs-keyword">in</span> zip(kmer1, kmer2):
        <span class="hljs-keyword">if</span> ch1 != ch2:
            mismatch += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> mismatch
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Kmer1: ACTTTGTT</p>
<p>Kmer2: AGTTTCTT</p>
<p>Hamming Distance: 2</p>
</div>
<p></p>
<a name="H_Hamming%20Distance%20Neighbourhood"></a><h3>Hamming Distance Neighbourhood</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance%20Neighbourhood)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F">Algorithms/K-mer/Hamming Distance</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a source <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> and a minimum hamming distance, find all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s such within the hamming distance of the source <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>. In other words, find all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s such that <code>hamming_distance(source_kmer, kmer) &lt;= min_distance</code>.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that enzyme can also bind to other <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns that are slight variations of the original. This algorithm finds all such variations.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_all_dna_kmers_within_hamming_distance</span>(<span class="hljs-params">kmer: str, hamming_dist: int</span>) -&gt; set[str]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurse</span>(<span class="hljs-params">kmer: str, hamming_dist: int, output: set[str]</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> hamming_dist == <span class="hljs-number">0</span>:
            output.add(kmer)
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(kmer)):
            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">'ACTG'</span>:
                neighbouring_kmer = kmer[:i] + ch + kmer[i + <span class="hljs-number">1</span>:]
                recurse(neighbouring_kmer, hamming_dist - <span class="hljs-number">1</span>, output)

    output = set()
    recurse(kmer, hamming_dist, output)

    <span class="hljs-keyword">return</span> output
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Kmers within hamming distance 1 of AAAA: {'AAGA', 'AAAG', 'ACAA', 'AACA', 'AATA', 'AAAC', 'TAAA', 'AAAT', 'AGAA', 'AAAA', 'CAAA', 'ATAA', 'GAAA'}</p>
</div>
<p></p>
<a name="H_Find%20Locations"></a><h3>Find Locations</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Locations)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F">Algorithms/K-mer/Hamming Distance</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FReverse%20Complement)_TOPIC%2F">Algorithms/K-mer/Reverse Complement</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, find where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> occurs in some larger <a href="#BM_(sequence)%2Fi">sequence</a>. The search may potentially include the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s variants (e.g. <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>).</p>
<p><strong>WHY</strong>: Imagine that you know of a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern that serves some function in an organism. If you see that same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern appearing in some other related organism, it could be a sign that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern serves a similar function. For example, the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern could be used by 2 related types of bacteria as a <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>.</p>
<p>The enzyme that operates on that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may also operate on its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> as well as slight variations on that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>. For example, if an enzyme binds to AAAAAAAAA, it may also bind to its...</p>
<ul>
<li><a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>: TTTTTTTTT</li>
<li>approximate variants: AAAAAAAAA, AAATAAAAA, AAAAAGAAA, ...</li>
<li>approximate variants of its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>s: TTTTTTTTT, TTTTTTATT, TTCTTTTTT, ...</li>
</ul>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Options</span>(<span class="hljs-params">NamedTuple</span>):</span>
    hamming_distance: int = <span class="hljs-number">0</span>
    reverse_complement: bool = <span class="hljs-literal">False</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_locations</span>(<span class="hljs-params">sequence: str, kmer: str, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; List[int]:</span>
    <span class="hljs-comment"># Construct test kmers</span>
    test_kmers = set()
    test_kmers.add(kmer)
    [test_kmers.add(alt_kmer) <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)]
    <span class="hljs-keyword">if</span> options.reverse_complement:
        rc_kmer = reverse_complement(kmer)
        [test_kmers.add(alt_rc_kmer) <span class="hljs-keyword">for</span> alt_rc_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(rc_kmer, options.hamming_distance)]

    <span class="hljs-comment"># Slide over the sequence's kmers and check for matches against test kmers</span>
    k = len(kmer)
    idxes = []
    <span class="hljs-keyword">for</span> seq_kmer, i <span class="hljs-keyword">in</span> slide_window(sequence, k):
        <span class="hljs-keyword">if</span> seq_kmer <span class="hljs-keyword">in</span> test_kmers:
            idxes.append(i)
    <span class="hljs-keyword">return</span> idxes
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Found AAAA in AAAAGAACCTAATCTTAAAGGAGATGATGATTCTAA at index [0, 1, 2, 3, 12, 15, 16, 30]</p>
</div>
<p></p>
<a name="H_Find%20Clumps"></a><h3>Find Clumps</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Clumps)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Locations)_TOPIC%2F">Algorithms/K-mer/Find Locations</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, find where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> clusters in some larger <a href="#BM_(sequence)%2Fi">sequence</a>. The search may potentially include the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s variants (e.g. <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to, where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> is a special <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>. Finding the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> clustered in a small region is a good indicator that you've found the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_clusters</span>(<span class="hljs-params">sequence: str, kmer: str, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; List[int]:</span>
    cluster_locs = []

    locs = find_kmer_locations(sequence, kmer, options)
    start_i = <span class="hljs-number">0</span>
    occurrence_count = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> end_i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(locs)):
        <span class="hljs-keyword">if</span> locs[end_i] - locs[start_i] &lt; cluster_window_size:  <span class="hljs-comment"># within a cluster window?</span>
            occurrence_count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> occurrence_count &gt;= min_occurrence_in_cluster:  <span class="hljs-comment"># did the last cluster meet the min ocurr requirement?</span>
                cluster_locs.append(locs[start_i])
            start_i = end_i
            occurrence_count = <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> cluster_locs
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Found clusters of GGG (at least 3 occurrences in window of 13) in GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT at index [19, 37]</p>
</div>
<p></p>
<a name="H_Find%20Repeating"></a><h3>Find Repeating</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FReverse%20Complement)_TOPIC%2F">Algorithms/K-mer/Reverse Complement</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance%20Neighbourhood)_TOPIC%2F">Algorithms/K-mer/Hamming Distance Neighbourhood</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(sequence)%2Fi">sequence</a>, find clusters of unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s within that <a href="#BM_(sequence)%2Fi">sequence</a>. In other words, for each unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that exists in the <a href="#BM_(sequence)%2Fi">sequence</a>, see if it clusters in the <a href="#BM_(sequence)%2Fi">sequence</a>. The search may potentially include variants of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> variants (e.g. <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>s of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to, where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> is a special <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>. Given that you don't know the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> but you do know the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>, you can scan through the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> for repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">from</span> Utils <span class="hljs-keyword">import</span> slide_window


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_kmers</span>(<span class="hljs-params">data: str, k: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Counter[str]:</span>
    counter = Counter()
    <span class="hljs-keyword">for</span> kmer, i <span class="hljs-keyword">in</span> slide_window(data, k):
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
            counter[neighbouring_kmer] += <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
            <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
                counter[neighbouring_kmer] += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> counter


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_repeating_kmers</span>(<span class="hljs-params">data: str, k: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Set[str]:</span>
    counts = count_kmers(data, k, options)

    _, top_count = counts.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]

    top_kmers = set()
    <span class="hljs-keyword">for</span> kmer, count <span class="hljs-keyword">in</span> counts.items():
        <span class="hljs-keyword">if</span> count == top_count:
            top_kmers.add((kmer, count))
    <span class="hljs-keyword">return</span> top_kmers
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Top 5-mer frequencies for GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT:</p>
<ul>
<li>AAGGG = 6 occurrences</li>
<li>CCCTT = 6 occurrences</li>
<li>TTTAA = 6 occurrences</li>
<li>TTAAA = 6 occurrences</li>
<li>TGATC = 6 occurrences</li>
<li>GATCA = 6 occurrences</li>
</ul>
</div>
<p></p>
<a name="H_Find%20Repeating%20in%20Window"></a><h3>Find Repeating in Window</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating%20in%20Window)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating)_TOPIC%2F">Algorithms/K-mer/Find Repeating</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(sequence)%2Fi">sequence</a>, find regions within that <a href="#BM_(sequence)%2Fi">sequence</a> that contain clusters of unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s. In other words, ...</p>
<ul>
<li>slide a window over the cluster.</li>
<li>for each unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that exists in the window, see if it clusters in the <a href="#BM_(sequence)%2Fi">sequence</a>.</li>
</ul>
<p>The search may potentially include variants of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> variants (e.g. <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>s of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to, where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> is a special <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>. Given that you don't know the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> but you do know the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>, you can scan through the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> for repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan_for_repeating_kmers_in_clusters</span>(<span class="hljs-params">sequence: str, k: int, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Set[KmerCluster]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neighborhood</span>(<span class="hljs-params">kmer: str</span>) -&gt; Set[str]:</span>
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
        <span class="hljs-keyword">return</span> neighbourhood

    kmer_counter = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_kmer</span>(<span class="hljs-params">kmer: str, loc: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> kmer <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kmer_counter:
            kmer_counter[kmer] = set()
        kmer_counter[kmer].add(window_idx + kmer_idx)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_kmer</span>(<span class="hljs-params">kmer: str, loc: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        kmer_counter[kmer].remove(window_idx - <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> len(kmer_counter[kmer]) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">del</span> kmer_counter[kmer]

    clustered_kmers = set()

    old_first_kmer = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> window, window_idx <span class="hljs-keyword">in</span> slide_window(sequence, cluster_window_size):
        first_kmer = window[<span class="hljs-number">0</span>:k]
        last_kmer = window[-k:]

        <span class="hljs-comment"># If first iteration, add all kmers</span>
        <span class="hljs-keyword">if</span> window_idx == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> kmer, kmer_idx <span class="hljs-keyword">in</span> slide_window(window, k):
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(kmer):
                    add_kmer(alt_kmer, window_idx + kmer_idx)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Add kmer that was walked in to</span>
            <span class="hljs-keyword">for</span> new_last_kmer <span class="hljs-keyword">in</span> neighborhood(last_kmer):
                add_kmer(new_last_kmer, window_idx + cluster_window_size - k)
            <span class="hljs-comment"># Remove kmer that was walked out of</span>
            <span class="hljs-keyword">if</span> old_first_kmer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(old_first_kmer):
                    remove_kmer(alt_kmer, window_idx - <span class="hljs-number">1</span>)

        old_first_kmer = first_kmer

        <span class="hljs-comment"># Find clusters within window -- tuple is k-mer, start_idx, occurrence_count</span>
        [clustered_kmers.add(KmerCluster(k, min(v), len(v))) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kmer_counter.items() <span class="hljs-keyword">if</span> len(v) &gt;= min_occurrence_in_cluster]

    <span class="hljs-keyword">return</span> clustered_kmers
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Found clusters of k=9 (at least 6 occurrences in window of 20) in TTTTTTTTTTTTTCCCTTTTTTTTTCCCTTTTTTTTTTTTT at...</p>
<ul>
<li>KmerCluster(kmer='TAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='CAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='AGAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=0, occurrence_count=7)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=1, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAGA', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=7)</li>
<li>KmerCluster(kmer='AAAAAAAAC', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAT', start_index=27, occurrence_count=6)</li>
</ul>
</div>
<p></p>
<a name="H_Probability%20of%20Appearance"></a><h3>Probability of Appearance</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FProbability%20of%20Appearance)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Locations)_TOPIC%2F">Algorithms/K-mer/Find Locations</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given ...</p>
<ul>
<li>the length of a <a href="#BM_(sequence)%2Fi">sequence</a> (n)</li>
<li>a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a></li>
<li>a count (c)</li>
</ul>
<p>... find the probability of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> appearing at least c times within an arbitrary <a href="#BM_(sequence)%2Fi">sequence</a> of length n. For example, the probability that the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA appears at least 2 times in a <a href="#BM_(sequence)%2Fi">sequence</a> of length 4:</p>
<ul>
<li>AAAA - yes</li>
<li>AAAT - yes</li>
<li>AAAC - yes</li>
<li>AAAG - yes</li>
<li>AATA - no</li>
<li>AATT - no</li>
<li>AATC - no</li>
<li>AATG - no</li>
<li>...</li>
<li>TAAA - yes</li>
<li>...</li>
<li>CAAA - yes</li>
<li>...</li>
<li>GAAA - yes</li>
<li>...</li>
<li>GGGA - no</li>
<li>GGGT - no</li>
<li>GGGC - no</li>
<li>GGGG - no</li>
</ul>
<p>The probability is 7/256.</p>
<p>This isn't trivial to accurately compute because the occurrences of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> within a <a href="#BM_(sequence)%2Fi">sequence</a> may overlap. For example, the number of times AA appears in AAAA is 3 while in CAAA it's 2.</p>
<p><strong>WHY</strong>: When a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is found within a <a href="#BM_(sequence)%2Fi">sequence</a>, knowing the probability of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> being found within an arbitrary <a href="#BM_(sequence)%2Fi">sequence</a> of the same length hints at the significance of the find. For example, if some <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">10-mer</a> has a 0.2 chance of appearing in an arbitrary <a href="#BM_(sequence)%2Fi">sequence</a> of length 50, that's too high of a chance to consider it a significant find -- 0.2 means 1 in 5 chance that the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">10-mer</a> just randomly happens to appear.</p>
<a name="H_Bruteforce%20Algorithm"></a><h4>Bruteforce Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm tries every possible combination of <a href="#BM_(sequence)%2Fi">sequence</a> to find the probability. It falls over once the length of the <a href="#BM_(sequence)%2Fi">sequence</a> extends into the double digits. It's intended to help conceptualize what's going on.</p>
<pre class="hljs"><code><span class="hljs-comment"># Of the X sequence combinations tried, Y had the k-mer. The probability is Y/X.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bruteforce_probability</span>(<span class="hljs-params">searchspace_len: int, searchspace_symbol_count: int, search_for: List[int], min_occurrence: int</span>) -&gt; (int, int):</span>
    found = <span class="hljs-number">0</span>
    found_max = searchspace_symbol_count ** searchspace_len

    str_to_search = [<span class="hljs-number">0</span>] * searchspace_len

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_instances</span>():</span>
        ret = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, searchspace_len - len(search_for) + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> str_to_search[i:i + len(search_for)] == search_for:
                ret += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> ret

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk</span>(<span class="hljs-params">idx: int</span>):</span>
        <span class="hljs-keyword">nonlocal</span> found

        <span class="hljs-keyword">if</span> idx == searchspace_len:
            count = count_instances()
            <span class="hljs-keyword">if</span> count &gt;= min_occurrence:
                found += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, searchspace_symbol_count):
                walk(idx + <span class="hljs-number">1</span>)
                str_to_search[idx] += <span class="hljs-number">1</span>
            str_to_search[idx] = <span class="hljs-number">0</span>

    walk(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">return</span> found, found_max
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Brute-forcing probability of ACTG in arbitrary sequence of length 8</p>
<p>Probability: 0.0195159912109375 (1279/65536)</p>
</div>
<p></p>
<a name="H_Selection%20Estimate%20Algorithm"></a><h4>Selection Estimate Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The explanation in the comments below are a bastardization of "1.13 Detour: Probabilities of Patterns in a String" in the Pevzner book...</p>
</div>
<p>This algorithm tries estimating the probability by ignoring the fact that the occurrences of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> in a <a href="#BM_(sequence)%2Fi">sequence</a> may overlap. For example, searching for the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA in the <a href="#BM_(sequence)%2Fi">sequence</a> AAAT yields 2 instances of AA:</p>
<ul>
<li>[AA]AT</li>
<li>A[AA]T</li>
</ul>
<p>If you go ahead and ignore overlaps, you can think of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s occurring in a string as insertions. For example, imagine a <a href="#BM_(sequence)%2Fi">sequence</a> of length 7 and the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA. If you were to inject 2 instances of AA into the <a href="#BM_(sequence)%2Fi">sequence</a> to get it to reach length 7, how would that look?</p>
<p>2 instances of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> is 4 characters has a length of 5. To get the <a href="#BM_(sequence)%2Fi">sequence</a> to end up with a length of 7 after the insertions, the <a href="#BM_(sequence)%2Fi">sequence</a> needs to start with a length of 3:</p>
<pre><code>SSS
</code></pre>
<p>Given that you're changing reality to say that the instances WON'T overlap in the <a href="#BM_(sequence)%2Fi">sequence</a>, you can treat each instance of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA as a single entity being inserted. The number of ways that these 2 instances can be inserted into the <a href="#BM_(sequence)%2Fi">sequence</a> is 10:</p>
<pre><code>I = insertion of AA, S = arbitrary sequence character

IISSS  ISISS  ISSIS  ISSSI
SIISS  SISIS  SISSI
SSIIS  SSISI
SSSII
</code></pre>
<p>Another way to think of the above insertions is that they aren't insertions. Rather, you have 5 items in total and you're selecting 2 of them. How many ways can you select 2 of those 5 items? 10.</p>
<p>The number of ways to insert can be counted via the "binomial coefficient": <code>bc(m, k) = m!/(k!(m-k)!)</code>, where m is the total number of items (5 in the example above) and k is the number of selections (2 in the example above). For the example above:</p>
<pre><code>bc(5, 2) = 5!/(2!(5-2)!) = 10
</code></pre>
<p>Since the SSS can be any arbitrary nucleotide <a href="#BM_(sequence)%2Fi">sequence</a> of 3, count the number of different representations that are possible for SSS: <code>4^3 = 4*4*4 = 64</code> (4^3, 4 because a nucleotide can be one of ACTG, 3 because the length is 3). In each of these representations, the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA can be inserted in 10 different ways:</p>
<pre><code>64*10 = 640
</code></pre>
<p>Since the total length of the <a href="#BM_(sequence)%2Fi">sequence</a> is 7, count the number of different representations that are possible:</p>
<pre><code>4^7 = 4*4*4*4*4*4*4 = 16384
</code></pre>
<p>The estimated probability is 640/16384. For...</p>
<ul>
<li>non-overlapping <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, the estimation will actually be relatively accurate.</li>
<li>overlapping <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, the estimation won't be as accurate.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Maybe try training a deep learning model to see if it can provide better estimates?</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_probability</span>(<span class="hljs-params">searchspace_len: int, searchspace_symbol_count: int, search_for: List[int], min_occurrence: int</span>) -&gt; float:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>):</span>
        <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> num
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> num * factorial(num - <span class="hljs-number">1</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bc</span>(<span class="hljs-params">m, k</span>):</span>
        <span class="hljs-keyword">return</span> factorial(m) / (factorial(k) * factorial(m - k))

    k = len(search_for)
    n = (searchspace_len - min_occurrence * k)
    <span class="hljs-keyword">return</span> bc(n + min_occurrence, min_occurrence) * (searchspace_symbol_count ** n) / searchspace_symbol_count ** searchspace_len
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Estimating probability of ACTG in arbitrary sequence of length 8</p>
<p>Probability: 0.01953125</p>
</div>
<p></p>
<a name="H_GC%20Skew"></a><h2>GC Skew</h2>
<p><a name="BM_(Algorithms%5C%2FGC%20Skew)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(sequence)%2Fi">sequence</a>, create a counter and walk over the <a href="#BM_(sequence)%2Fi">sequence</a>. Whenever a ...</p>
<ul>
<li>G is encountered, increment the counter.</li>
<li>C is encountered, decrement the counter.</li>
</ul>
<p><strong>WHY</strong>: Given the DNA <a href="#BM_(sequence)%2Fi">sequence</a> of an organism, some segments may have lower count of Gs vs Cs.</p>
<p>During replication, some segments of DNA stay single-stranded for a much longer time than other segments. <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a>. Specifically, in <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, C has a greater tendency to mutate to T. When that <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a> re-binds to a neighbouring strand, the positions of any nucleotides that mutated from C to T will change on the neighbouring strand from G to A.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>s of ...</p>
<ul>
<li>C is G</li>
<li>A is T</li>
</ul>
<p>It mutated from C to T. Since its now T, its complement is A.</p>
</div>
<p>Plotting the skew shows roughly which segments of DNA stayed single-stranded for a longer period of time. That information hints at special / useful locations in the organism's DNA <a href="#BM_(sequence)%2Fi">sequence</a> (<a href="#BM_(replication%20origin)%2Fi">replication origin</a> / <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a>).</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gc_skew</span>(<span class="hljs-params">seq: str</span>):</span>
    counter = <span class="hljs-number">0</span>
    skew = [counter]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(seq)):
        <span class="hljs-keyword">if</span> seq[i] == <span class="hljs-string">'G'</span>:
            counter += <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">elif</span> seq[i] == <span class="hljs-string">'C'</span>:
            counter -= <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">else</span>:
            skew.append(counter)
    <span class="hljs-keyword">return</span> skew
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, -1, -1,...</p>
<p><img src="skew_babf857bad6dd935f0d1ddbbb8b5005f.png" alt="GC Skew Plot"></p>
</div>
<p></p>
<a name="H_Motif"></a><h2>Motif</h2>
<p><a name="BM_(Algorithms%5C%2FMotif)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p>A <a href="#BM_(motif)%2Fi">motif</a> is a pattern that matches many different <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, where those matched <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s have some shared biological significance. The pattern matches a fixed k where each position may have alternate forms. The simplest way to think of a <a href="#BM_(motif)%2Fi">motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]C</code> may match to ATTGC, ATTCC, TTTGC, and TTTCC.</p>
<p>A common scenario involving <a href="#BM_(motif)%2Fi">motif</a>s is to search through a set of DNA <a href="#BM_(sequence)%2Fi">sequence</a>s for an unknown <a href="#BM_(motif)%2Fi">motif</a>: Given a set of <a href="#BM_(sequence)%2Fi">sequence</a>s, it's suspected that each <a href="#BM_(sequence)%2Fi">sequence</a> contains a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches some <a href="#BM_(motif)%2Fi">motif</a>. But, that <a href="#BM_(motif)%2Fi">motif</a> isn't known beforehand. Both the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s and the <a href="#BM_(motif)%2Fi">motif</a> they match need to be found.</p>
<p>For example, each of the following <a href="#BM_(sequence)%2Fi">sequence</a>s contains a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches some <a href="#BM_(motif)%2Fi">motif</a>:</p>
<table>
<thead>
<tr>
<th><a href="#BM_(sequence)%2Fi">Sequence</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATTGTTACCATAACCTTATTGCTAG</td>
</tr>
<tr>
<td>ATTCCTTTAGGACCACCCCAAACCC</td>
</tr>
<tr>
<td>CCCCAGGAGGGAACCTTTGCACACA</td>
</tr>
<tr>
<td>TATATATTTCCCACCCCAAGGGGGG</td>
</tr>
</tbody>
</table>
<p>That <a href="#BM_(motif)%2Fi">motif</a> is the one described above (<code>[AT]TT[GC]C</code>):</p>
<table>
<thead>
<tr>
<th><a href="#BM_(sequence)%2Fi">Sequence</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATTGTTACCATAACCTT<strong>ATTGC</strong>TAG</td>
</tr>
<tr>
<td><strong>ATTCC</strong>TTTAGGACCACCCCAAACCC</td>
</tr>
<tr>
<td>CCCCAGGAGGGAACC<strong>TTTGC</strong>ACACA</td>
</tr>
<tr>
<td>TATATA<strong>TTTCC</strong>CACCCCAAGGGGGG</td>
</tr>
</tbody>
</table>
<p>A <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is a matrix of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s where each <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> matches a <a href="#BM_(motif)%2Fi">motif</a>. In the example <a href="#BM_(sequence)%2Fi">sequence</a>s above, the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> would be:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>A <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches a <a href="#BM_(motif)%2Fi">motif</a> may be referred to as a <a href="#BM_(motif%20member)%2Fi">motif member</a>.</p>
<a name="H_Consensus%20String"></a><h3>Consensus String</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FConsensus%20String)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, generate a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> where each position is the nucleotide most abundant at that column of the matrix.</p>
<p><strong>WHY</strong>: Given a set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are suspected to be part of a <a href="#BM_(motif)%2Fi">motif</a> (<a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>), the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> generated by selecting the most abundant column at each index is the "ideal" <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> for the <a href="#BM_(motif)%2Fi">motif</a>. It's a concise way of describing the <a href="#BM_(motif)%2Fi">motif</a>, especially if the columns in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> are highly conserved.</p>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It may be more appropriate to use a <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> when representing <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a> because alternate nucleotides could be represented as a single letter. The Pevzner book doesn't mention this specifically but multiple online sources discuss it.</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_consensus_string</span>(<span class="hljs-params">kmers: List[str]</span>) -&gt; str:</span>
    count = len(kmers[<span class="hljs-number">0</span>]);
    out = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, count):
        c = Counter()
        <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> kmers:
            c[kmer[i]] += <span class="hljs-number">1</span>
        ch = c.most_common(<span class="hljs-number">1</span>)
        out += ch[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    <span class="hljs-keyword">return</span> out
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Consensus is TTTCC in <br><br> ATTGC<br>ATTCC<br>TTTGC<br>TTTCC<br>TTTCA</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Count"></a><h3>Motif Matrix Count</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Count)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, count how many of each nucleotide are in each column.</p>
<p><strong>WHY</strong>: Having a count of the number of nucleotides in each column is a basic statistic that gets used further down the line for tasks such as scoring a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">motif_matrix_count</span>(<span class="hljs-params">motif_matrix: List[str], elements=<span class="hljs-string">'ACGT'</span></span>) -&gt; Dict[str, List[int]]:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    ret = {}
    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> elements:
        ret[ch] = [<span class="hljs-number">0</span>] * cols
    
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cols):
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, rows):
            item = motif_matrix[r][c]
            ret[item][c] += <span class="hljs-number">1</span>
            
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Counting nucleotides at each column of the motif matrix...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>Result...</p>
<p>('A', [2, 0, 0, 0, 0])<br>('C', [0, 0, 0, 0, 3])<br>('G', [0, 0, 0, 4, 1])<br>('T', [2, 4, 4, 0, 0])</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Profile"></a><h3>Motif Matrix Profile</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Count)_TOPIC%2F">Algorithms/Motif/Motif Matrix Count</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, for each column calculate how often A, C, G, and T occur as percentages.</p>
<p><strong>WHY</strong>: The percentages for each column represent a probability distribution for that column. For example, in column 1 of...</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
</tr>
</tbody>
</table>
<ul>
<li>A appears 25% of the time.</li>
<li>C appears 25% of the time.</li>
<li>T appears 50% of the time.</li>
<li>G appears 0% of the time.</li>
</ul>
<p>These probability distributions can be used further down the line for tasks such as determining the probability that some arbitrary <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> conforms to the same <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">motif_matrix_profile</span>(<span class="hljs-params">motif_matrix_counts: Dict[str, List[int]]</span>) -&gt; Dict[str, List[float]]:</span>
    ret = {}
    <span class="hljs-keyword">for</span> elem, counts <span class="hljs-keyword">in</span> motif_matrix_counts.items():
        ret[elem] = [<span class="hljs-number">0.0</span>] * len(counts)

    cols = len(counts)  <span class="hljs-comment"># all elems should have the same len, so just grab the last one that was walked over</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cols):
        total = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> motif_matrix_counts.keys():
            total += motif_matrix_counts[elem][i]
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> motif_matrix_counts.keys():
            ret[elem][i] = motif_matrix_counts[elem][i] / total

    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Profiling nucleotides at each column of the motif matrix...</p>
<p>ATTCG<br>CTTCG<br>TTTCG<br>TTTTG</p>
<p>Result...</p>
<p>('A', [0.25, 0.0, 0.0, 0.0, 0.0])<br>('C', [0.25, 0.0, 0.0, 0.75, 0.0])<br>('G', [0.0, 0.0, 0.0, 0.0, 1.0])<br>('T', [0.5, 1.0, 1.0, 0.25, 0.0])</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Score"></a><h3>Motif Matrix Score</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, assign it a score based on how similar the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that make up the matrix are to each other. Specifically, how conserved the nucleotides at each column are.</p>
<p><strong>WHY</strong>: Given a set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are suspected to be part of a <a href="#BM_(motif)%2Fi">motif</a> (<a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>), the more similar those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are to each other the more likely it is that those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>. This seems to be the case for many enzymes that bind to DNA based on a <a href="#BM_(motif)%2Fi">motif</a> (e.g. <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s).</p>
<a name="H_Popularity%20Algorithm"></a><h4>Popularity Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> by summing up the number of unpopular items in a column. For example, imagine a column has 7 Ts, 2 Cs, and 1A. The Ts are the most popular (7 items), meaning that the 3 items (2 Cs and 1 A) are unpopular -- the score for the column is 3.</p>
<p>Sum up each of the column scores to the get the final score for the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. A lower score is better.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motif</span>(<span class="hljs-params">motif_matrix: List[str]</span>) -&gt; int:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counter_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cols):
        counter = Counter()
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, rows):
            counter[motif_matrix[r][c]] += <span class="hljs-number">1</span>
        counter_per_col.append(counter)

    <span class="hljs-comment"># sum counts for each column AFTER removing the top-most count -- that is, consider the top-most count as the</span>
    <span class="hljs-comment"># most popular char, so you're summing the counts of all the UNPOPULAR chars</span>
    unpopular_sums = []
    <span class="hljs-keyword">for</span> counter <span class="hljs-keyword">in</span> counter_per_col:
        most_popular_item = counter.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        <span class="hljs-keyword">del</span> counter[most_popular_item]
        unpopular_sum = sum(counter.values())
        unpopular_sums.append(unpopular_sum)

    <span class="hljs-keyword">return</span> sum(unpopular_sums)
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>3</p>
</div>
<p></p>
<a name="H_Entropy%20Algorithm"></a><h4>Entropy Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score%2FEntropy%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F">Algorithms/Motif/Motif Matrix Profile</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> by calculating the <a href="#BM_(entropy)%2Fi">entropy</a> of each column in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. <a href="#BM_(entropy)%2Fi">Entropy</a> is defined as the level of uncertainty for some variable. The more uncertain the nucleotides are in the column of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the higher (worse) the score. For example, given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> with 10 rows, a column with ...</p>
<ul>
<li>10 A nucleotides has low <a href="#BM_(entropy)%2Fi">entropy</a> because it's highly conserved,</li>
<li>6 A and 4 T nucleotides has a higher <a href="#BM_(entropy)%2Fi">entropy</a> because it's less highly conserved.</li>
</ul>
<p>Sum the output for each column to get the final score for the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. A lower score is better.</p>
<pre class="hljs"><code><span class="hljs-comment"># According to the book, method of scoring a motif matrix as defined in ScoreMotif.py isn't the method used in the</span>
<span class="hljs-comment"># real-world. The method used in the real-world is this method, where...</span>
<span class="hljs-comment"># 1. each column has its probability distribution calculated (prob of A vs prob C vs prob of T vs prob of G)</span>
<span class="hljs-comment"># 2. the entropy of each of those prob dist are calculated</span>
<span class="hljs-comment"># 3. those entropies are summed up to get the ENTROPY OF THE MOTIF MATRIX</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_entropy</span>(<span class="hljs-params">values: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:
        ret += value * (log(value, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    ret = -ret
    <span class="hljs-keyword">return</span> ret

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motify_entropy</span>(<span class="hljs-params">motif_matrix: List[str]</span>) -&gt; float:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counts = motif_matrix_count(motif_matrix)
    profile = motif_matrix_profile(counts)

    <span class="hljs-comment"># prob dist to entropy</span>
    entropy_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        entropy = calculate_entropy([profile[<span class="hljs-string">'A'</span>][c], profile[<span class="hljs-string">'C'</span>][c], profile[<span class="hljs-string">'G'</span>][c], profile[<span class="hljs-string">'T'</span>][c]])
        entropy_per_col.append(entropy)

    <span class="hljs-comment"># sum up entropies to get entropy of motif</span>
    <span class="hljs-keyword">return</span> sum(entropy_per_col)
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>1.811278124459133</p>
</div>
<p></p>
<a name="H_Relative%20Entropy%20Algorithm"></a><h4>Relative Entropy Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score%2FEntropy%20Algorithm)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score/Entropy Algorithm</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> by calculating the <a href="#BM_(entropy)%2Fi">entropy</a> of each column relative to the overall nucleotide distribution of the <a href="#BM_(sequence)%2Fi">sequence</a>s from which each <a href="#BM_(motif%20member)%2Fi">motif member</a> came from. This is important when finding <a href="#BM_(motif%20member)%2Fi">motif member</a>s across a set of <a href="#BM_(sequence)%2Fi">sequence</a>s. For example, the following <a href="#BM_(sequence)%2Fi">sequence</a>s have a nucleotide distribution highly skewed towards C...</p>
<table>
<thead>
<tr>
<th><a href="#BM_(sequence)%2Fi">Sequence</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>CCCCCCCCCCCCCCCCCATTGCCCC</td>
</tr>
<tr>
<td>ATTCCCCCCCCCCCCCCCCCCCCCC</td>
</tr>
<tr>
<td>CCCCCCCCCCCCCCCTTTGCCCCCC</td>
</tr>
<tr>
<td>CCCCCCTTTCTCCCCCCCCCCCCCC</td>
</tr>
</tbody>
</table>
<p>Given the <a href="#BM_(sequence)%2Fi">sequence</a>s in the example above, of all <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> possible for k=5, basic <a href="#BM_(entropy)%2Fi">entropy</a> scoring will always lead to a matrix filled with Cs:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>Even though the above <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> scores perfect, it's likely junk. <a href="#BM_%5Cb(member)_MOTIF%2Fi">Member</a>s containing all Cs score better because the <a href="#BM_(sequence)%2Fi">sequence</a>s they come from are biased (saturated with Cs), not because they share some higher biological significance.</p>
<p>To reduce bias, the nucleotide distributions from which the <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s came from need to be factored in to the <a href="#BM_(entropy)%2Fi">entropy</a> calculation: relative <a href="#BM_(entropy)%2Fi">entropy</a>.</p>
<pre class="hljs"><code><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> This is different from the traditional version of entropy -- it doesn't negate the sum before returning it.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_entropy</span>(<span class="hljs-params">probabilities_for_nuc: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> probabilities_for_nuc:
        ret += value * (log(value, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_cross_entropy</span>(<span class="hljs-params">probabilities_for_nuc: List[float], total_frequencies_for_nucs: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> prob, total_freq <span class="hljs-keyword">in</span> zip(probabilities_for_nuc, total_frequencies_for_nucs):
        ret += prob * (log(total_freq, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> total_freq &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motif_relative_entropy</span>(<span class="hljs-params">motif_matrix: List[str], source_strs: List[str]</span>) -&gt; float:</span>
    <span class="hljs-comment"># calculate frequency of nucleotide across all source strings</span>
    nuc_counter = Counter()
    nuc_total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> source_str <span class="hljs-keyword">in</span> source_strs:
        <span class="hljs-keyword">for</span> nuc <span class="hljs-keyword">in</span> source_str:
            nuc_counter[nuc] += <span class="hljs-number">1</span>
        nuc_total += len(source_str)
    nuc_freqs = dict([(k, v / nuc_total) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> nuc_counter.items()])

    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counts = motif_matrix_count(motif_matrix)
    profile = motif_matrix_profile(counts)
    relative_entropy_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        <span class="hljs-comment"># get entropy of column in motif</span>
        entropy = calculate_entropy(
            [
                profile[<span class="hljs-string">'A'</span>][c],
                profile[<span class="hljs-string">'C'</span>][c],
                profile[<span class="hljs-string">'G'</span>][c],
                profile[<span class="hljs-string">'T'</span>][c]
            ]
        )
        <span class="hljs-comment"># get cross entropy of column in motif (mixes in global nucleotide frequencies)</span>
        cross_entropy = calculate_cross_entropy(
            [
                profile[<span class="hljs-string">'A'</span>][c],
                profile[<span class="hljs-string">'C'</span>][c],
                profile[<span class="hljs-string">'G'</span>][c],
                profile[<span class="hljs-string">'T'</span>][c]
            ],
            [
                nuc_freqs[<span class="hljs-string">'A'</span>],
                nuc_freqs[<span class="hljs-string">'C'</span>],
                nuc_freqs[<span class="hljs-string">'G'</span>],
                nuc_freqs[<span class="hljs-string">'T'</span>]
            ]
        )
        relative_entropy = entropy - cross_entropy
        <span class="hljs-comment"># Right now relative_entropy is calculated by subtracting cross_entropy from (a negated) entropy. But, according</span>
        <span class="hljs-comment"># to the Pevzner book, the calculation of relative_entropy can be simplified to just...</span>
        <span class="hljs-comment"># def calculate_relative_entropy(probabilities_for_nuc: List[float], total_frequencies_for_nucs: List[float]) -&gt; float:</span>
        <span class="hljs-comment">#     ret = 0.0</span>
        <span class="hljs-comment">#     for prob, total_freq in zip(probabilities_for_nuc, total_frequency_for_nucs):</span>
        <span class="hljs-comment">#         ret += value * (log(value / total_freq, 2.0) if value &gt; 0.0 else 0.0)</span>
        <span class="hljs-comment">#     return ret</span>
        relative_entropy_per_col.append(relative_entropy)

    <span class="hljs-comment"># sum up entropies to get entropy of motif</span>
    ret = sum(relative_entropy_per_col)

    <span class="hljs-comment"># All of the other score_motif algorithms try to MINIMIZE score. In the case of relative entropy (this algorithm),</span>
    <span class="hljs-comment"># the greater the score is the better of a match it is. As such, negate this score so the existing algorithms can</span>
    <span class="hljs-comment"># still try to minimize.</span>
    <span class="hljs-keyword">return</span> -ret
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>In the outputs below, the score in the second output should be less than (better) the score in the first output.</p>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>CCCCC<br>CCCCC<br>CCCCC<br>CCCCC</p>
<p>... which was pulled from ...</p>
<p>CCCCCCCCCCCCCCCCCATTGCCCC<br>ATTCCCCCCCCCCCCCCCCCCCCCC<br>CCCCCCCCCCCCCCCTTTGCCCCCC<br>CCCCCCTTTCTCCCCCCCCCCCCCC</p>
<p>-1.172326268185115</p>
</div>
<p></p>
<div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>ATTCC<br>CTTTG<br>TTTCT</p>
<p>... which was pulled from ...</p>
<p>CCCCCCCCCCCCCCCCCATTGCCCC<br>ATTCCCCCCCCCCCCCCCCCCCCCC<br>CCCCCCCCCCCCCCCTTTGCCCCCC<br>CCCCCCTTTCTCCCCCCCCCCCCCC</p>
<p>-10.194105327448927</p>
</div>
<p></p>
<a name="H_Motif%20Logo"></a><h3>Motif Logo</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Logo)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score%2FEntropy%20Algorithm)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score/Entropy Algorithm</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, generate a graphical representation showing how conserved the <a href="#BM_(motif)%2Fi">motif</a> is. Each position has its possible nucleotides stacked on top of each other, where the height of each nucleotide is based on how conserved it is. The more conserved a position is, the taller that column will be. This type of graphical representation is called a <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">sequence logo</a>.</p>
<p><strong>WHY</strong>: A <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">sequence logo</a> helps more quickly convey the characteristics of the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> it's for.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>For this particular <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">logo</a> implementation, a lower <a href="#BM_(entropy)%2Fi">entropy</a> results in a taller overall column.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_entropy</span>(<span class="hljs-params">values: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:
        ret += value * (log(value, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    ret = -ret
    <span class="hljs-keyword">return</span> ret

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_logo</span>(<span class="hljs-params">motif_matrix_profile: Dict[str, List[float]]</span>) -&gt; Logo:</span>
    columns = list(motif_matrix_profile.keys())
    data = [motif_matrix_profile[k] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> motif_matrix_profile.keys()]
    data = list(zip(*data))  <span class="hljs-comment"># trick to transpose data</span>

    entropies = list(map(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span> - calculate_entropy(x), data))

    data_scaledby_entropies = [[p * e <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> d] <span class="hljs-keyword">for</span> d, e <span class="hljs-keyword">in</span> zip(data, entropies)]

    df = pd.DataFrame(
        columns=columns,
        data=data_scaledby_entropies
    )
    logo = lm.Logo(df)
    logo.ax.set_ylabel(<span class="hljs-string">'information (bits)'</span>)
    logo.ax.set_xlim([<span class="hljs-number">-1</span>, len(df)])
    <span class="hljs-keyword">return</span> logo
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Generating logo for the following motif matrix...</p>
<p>TCGGGGGTTTTT<br>CCGGTGACTTAC<br>ACGGGGATTTTC<br>TTGGGGACTTTT<br>AAGGGGACTTCC<br>TTGGGGACTTCC<br>TCGGGGATTCAT<br>TCGGGGATTCCT<br>TAGGGGAACTAC<br>TCGGGTATAACC</p>
<p>Result...</p>
<p><img src="motif_logo_01b7e8763a84973751af52163d52f5bd.svg" alt="Motif Logo"></p>
</div>
<p></p>
<a name="H_K-mer%20Match%20Probability"></a><h3>K-mer Match Probability</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Count)_TOPIC%2F">Algorithms/Motif/Motif Matrix Count</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F">Algorithms/Motif/Motif Matrix Profile</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, calculate the probability of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> being a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> of that <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p><strong>WHY</strong>: Being able to determine if a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is potentially a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> of a <a href="#BM_(motif)%2Fi">motif</a> can help speed up experiments. For example, imagine that you suspect 21 different <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> of being regulated by the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. You isolate the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a> for 6 of those <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> and use their <a href="#BM_(sequence)%2Fi">sequence</a>s as the underlying <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s for a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. That <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> doesn't represent the <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(motif)%2Fi">motif</a> exactly, but it's close enough that you can use it to scan through the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in the remaining 15 <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> and calculate the probability of them being <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p>If a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> exists such that it conforms to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> with a high probability, it likely is a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> of the <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Imagine the following <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>Calculating the counts for that <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>T</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>G</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Calculating the profile from those counts results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>T</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>G</td>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Using this profile, the probability that a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> conforms to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is calculated by mapping the nucleotide at each position of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> to the corresponding nucleotide in the corresponding position of the profile and multiplying them together. For example, the probability that the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>...</p>
<ul>
<li>ATGCAC conforms to the example profile above is calculated as 1*1*0.5*1*1*1 = 0.5</li>
<li>TTGCAC conforms to the example profile above is calculated as 0*1*0.5*1*1*1 = 0</li>
</ul>
<p>Of the these two <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, ...</p>
<ul>
<li>all positions in the first (ATGCAC) have been seen before in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>all but one position in the second (TTGCAC) have been seen before in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> (index 0).</li>
</ul>
<p>Both of these <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s should have a reasonable probability of being <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a>. However, notice how the second <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> ends up with a 0 probability. The reason has to do with the underlying concept behind <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a>: the entire point of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is to use the known <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of a <a href="#BM_(motif)%2Fi">motif</a> to find other potential <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of that same <a href="#BM_(motif)%2Fi">motif</a>. The second <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> contains a T at index 0, but none of the known <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a> have a T at that index. As such, its probability gets reduced to 0 even though the rest of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> conforms.</p>
<p><a href="#BM_(Cromwell's%20rule)%2Fi">Cromwell's rule</a> says that when a probability is based off past events, a hard 0 or 1 values shouldn't be used. As such, a quick workaround to the 0% probability problem described above is to artificially inflate the counts that lead to the profile such that no count is 0 (<a href="#BM_(pseudocount)%2Fi">pseudocount</a>s). For example, for the same <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, incrementing the counts by 1 results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>T</td>
<td>1</td>
<td>5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>G</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Calculating the profile from those inflated counts results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.625</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
<td>0.625</td>
<td>0.125</td>
</tr>
<tr>
<td>C</td>
<td>0.125</td>
<td>0.125</td>
<td>0.375</td>
<td>0.625</td>
<td>0.125</td>
<td>0.625</td>
</tr>
<tr>
<td>T</td>
<td>0.125</td>
<td>0.625</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
</tr>
<tr>
<td>G</td>
<td>0.125</td>
<td>0.125</td>
<td>0.375</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
</tr>
</tbody>
</table>
<p>Using this new profile, the probability that the previous <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s conform are:</p>
<ul>
<li>ATGCAC is calculated as 0.625*0.625*0.325*0.625*0.625*0.625 = 0.031</li>
<li>TTGCAC is calculated as 0.125*0.625*0.325*0.625*0.625*0.625 = 0.0062</li>
</ul>
<p>Although the probabilities seem low, it's all relative. The probability calculated for the first <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> (ATGCAC) is the highest probability possible -- each position in the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> maps to the highest probability nucleotide of the corresponding position of the profile.</p>
<pre class="hljs"><code><span class="hljs-comment"># Run this on the counts before generating the profile to avoid the 0 probability problem.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_psuedocounts_to_count_matrix</span>(<span class="hljs-params">counts: Dict[str, List[int]], extra_count: int = <span class="hljs-number">1</span></span>):</span>
    <span class="hljs-keyword">for</span> elem, elem_counts <span class="hljs-keyword">in</span> counts.items():
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(elem_counts)):
            elem_counts[i] += extra_count


<span class="hljs-comment"># Recall that a profile matrix is a matrix of probabilities. Each row represents a single element (e.g. nucleotide) and</span>
<span class="hljs-comment"># each column represents the probability distribution for that position.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># So for example, imagine the following probability distribution...</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment">#     1   2   3   4</span>
<span class="hljs-comment"># A: 0.2 0.2 0.0 0.0</span>
<span class="hljs-comment"># C: 0.1 0.6 0.0 0.0</span>
<span class="hljs-comment"># G: 0.1 0.0 1.0 1.0</span>
<span class="hljs-comment"># T: 0.7 0.2 0.0 0.0</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># At position 2, the probability that the element will be C is 0.6 while the probability that it'll be T is 0.2. Note</span>
<span class="hljs-comment"># how each column sums to 1.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">determine_probability_of_match_using_profile_matrix</span>(<span class="hljs-params">profile: Dict[str, List[float]], kmer: str</span>):</span>
    prob = <span class="hljs-number">1.0</span>
    <span class="hljs-keyword">for</span> idx, elem <span class="hljs-keyword">in</span> enumerate(kmer):
        prob = prob * profile[elem][idx]
    <span class="hljs-keyword">return</span> prob


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_most_probable_kmer_using_profile_matrix</span>(<span class="hljs-params">profile: Dict[str, List[float]], dna: str</span>):</span>
    k = len(list(profile.values())[<span class="hljs-number">0</span>])

    most_probable: Tuple[str, float] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># [kmer, probability]</span>
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        prob = determine_probability_of_match_using_profile_matrix(profile, kmer)
        <span class="hljs-keyword">if</span> most_probable <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> prob &gt; most_probable[<span class="hljs-number">1</span>]:
            most_probable = (kmer, prob)

    <span class="hljs-keyword">return</span> most_probable
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Motif matrix...</p>
<p>ATGCAC<br>ATGCAC<br>ATCCAC</p>
<p>Probability that TTGCAC matches the motif 0.0...</p>
</div>
<p></p>
<a name="H_Find%20Motif%20Matrix"></a><h3>Find Motif Matrix</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of <a href="#BM_(sequence)%2Fi">sequence</a>s, find <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in those <a href="#BM_(sequence)%2Fi">sequence</a>s that may be <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p><strong>WHY</strong>: A <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> is an enzyme that either increases or decreases a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> rate. It does so by binding to a specific part of the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a> called the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a>. That <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a> consists of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches the <a href="#BM_(motif)%2Fi">motif</a> expected by that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, called a <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<p>A single <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> may operate on many different <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>. Often times a scientist will identify a set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> that are suspected to be regulated by a single <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, but that scientist won't know ...</p>
<ul>
<li>what the <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> is (the pattern expected by the enzyme).</li>
<li>where the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a>s are (which <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s the enzyme is targeting).</li>
<li>how long the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a>s are (which k the enzyme is targeting).</li>
</ul>
<p>The <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> expected by a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> typically expects <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that have the same length and are similar to each other (short hamming distance). As such, potential <a href="#BM_(motif)%2Fi">motif</a> candidates can be derived by finding <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s across the set of <a href="#BM_(sequence)%2Fi">sequence</a>s that are similar to each other.</p>
<a name="H1_Bruteforce%20Algorithm"></a><h4>Bruteforce Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance%20Neighbourhood)_TOPIC%2F">Algorithms/K-mer/Hamming Distance Neighbourhood</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scans over all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in a set of DNA <a href="#BM_(sequence)%2Fi">sequence</a>s, enumerates the hamming distance neighbourhood of each <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, and uses the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s from the hamming distance neighbourhood to build out possible <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a>. Of all the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> built, it selects the one with the lowest score.</p>
<p>Neither k nor the mismatches allowed by the <a href="#BM_(motif)%2Fi">motif</a> is known. As such, the algorithm may need to be repeated multiple times with different value combinations.</p>
<p>Even for trivial inputs, this algorithm falls over very quickly. It's intended to help conceptualize the problem of <a href="#BM_(motif)%2Fi">motif</a> finding.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enumerate_hamming_distance_neighbourhood_for_all_kmer</span>(<span class="hljs-params">
        dna: str,             <span class="hljs-comment"># dna strings to search in for motif</span>
        k: int,               <span class="hljs-comment"># k-mer length</span>
        max_mismatches: int   <span class="hljs-comment"># max num of mismatches for motif (hamming dist)</span>
</span>) -&gt; Set[str]:</span>
    kmers_to_check = set()
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        neighbouring_kmers = find_all_dna_kmers_within_hamming_distance(kmer, max_mismatches)
        kmers_to_check |= neighbouring_kmers

    <span class="hljs-keyword">return</span> kmers_to_check


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exhaustive_motif_search</span>(<span class="hljs-params">dnas: List[str], k: int, max_mismatches: int</span>):</span>
    kmers_for_dnas = [enumerate_hamming_distance_neighbourhood_for_all_kmer(dna, k, max_mismatches) <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_next_matrix</span>(<span class="hljs-params">out_matrix: List[str]</span>):</span>
        idx = len(out_matrix)
        <span class="hljs-keyword">if</span> len(kmers_for_dnas) == idx:
            <span class="hljs-keyword">yield</span> out_matrix[:]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> kmers_for_dnas[idx]:
                out_matrix.append(kmer)
                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> build_next_matrix(out_matrix)
                out_matrix.pop()

    best_motif_matrix = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> next_motif_matrix <span class="hljs-keyword">in</span> build_next_matrix([]):
        <span class="hljs-keyword">if</span> best_motif_matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score_motif(next_motif_matrix) &lt; score_motif(best_motif_matrix):
            best_motif_matrix = next_motif_matrix

    <span class="hljs-keyword">return</span> best_motif_matrix
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=5 and a max of 1 mismatches in the following...</p>
<p>ATAAAGGGATA<br>ACAGAAATGAT<br>TGAAATAACCT</p>
<p>Found the motif matrix...</p>
<p>ATAAT<br>ATAAT<br>ATAAT</p>
</div>
<p></p>
<a name="H_Median%20String%20Algorithm"></a><h4>Median String Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FConsensus%20String)_TOPIC%2F">Algorithms/Motif/Consensus String</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F">Algorithms/K-mer/Hamming Distance</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm takes advantage of the fact that the same score can be derived by scoring a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> either row-by-row or column-by-column. For example, the score for the following <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is 3...</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td><strong>T</strong></td>
<td>C</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>Score</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>For each column, the number of unpopular nucleotides is counted. Then, those counts are summed to get the score: 0 + 0 + 2 + 0 + 1 + 0 = 3.</p>
<p>That exact same score scan be calculated by working through the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> row-by-row...</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td><strong>T</strong></td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3</td>
</tr>
</tbody>
</table>
<p>For each row, the number of unpopular nucleotides is counted. Then, those counts are summed to get the score: 1 + 1 + 1 + 0 = 3.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td><strong>T</strong></td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>Score</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Notice how each row's score is equivalent to the hamming distance between the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> at that row and the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>'s <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>. Specifically, the <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a> for the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is ATCCAC. For each row, ...</p>
<ul>
<li>hamming_distance(ATGCAC, ATCCAC) = 1</li>
<li>hamming_distance(ATGCAC, ATCCAC) = 1</li>
<li>hamming_distance(ATCCTC, ATCCAC) = 1</li>
<li>hamming_distance(ATCCAC, ATCCAC) = 0</li>
</ul>
<p>Given these facts, this algorithm constructs a set of <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>s by enumerating through all possible <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s for some k. Then, for each <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>, it scans over each <a href="#BM_(sequence)%2Fi">sequence</a> to find the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that minimizes the hamming distance for that <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>. These <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are used as the <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>Of all the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> built, the one with the lowest score is selected.</p>
<p>Since the k for the <a href="#BM_(motif)%2Fi">motif</a> is unknown, this algorithm may need to be repeated multiple times with different k values. This algorithm also doesn't scale very well. For k=10, 1048576 different <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>s are possible.</p>
<pre class="hljs"><code><span class="hljs-comment"># The name is slightly confusing. What this actually does...</span>
<span class="hljs-comment">#   For each dna string:</span>
<span class="hljs-comment">#     Find the k-mer with the min hamming distance between the k-mers that make up the DNA string and pattern</span>
<span class="hljs-comment">#   Sum up the min hamming distances of the found k-mers (equivalent to the motif matrix score)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance_between_pattern_and_strings</span>(<span class="hljs-params">pattern: str, dnas: List[str]</span>) -&gt; int:</span>
    min_hds = []

    k = len(pattern)
    <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas:
        min_hd = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> dna_kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
            hd = hamming_distance(pattern, dna_kmer)
            <span class="hljs-keyword">if</span> min_hd <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> hd &lt; min_hd:
                min_hd = hd
        min_hds.append(min_hd)
    <span class="hljs-keyword">return</span> sum(min_hds)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">median_string</span>(<span class="hljs-params">k: int, dnas: List[str]</span>):</span>
    last_best: Tuple[str, int] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># last found consensus string and its score</span>
    <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> enumerate_patterns(k):
        score = distance_between_pattern_and_strings(kmer, dnas)  <span class="hljs-comment"># find score of best motif matrix where consensus str is kmer</span>
        <span class="hljs-keyword">if</span> last_best <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score &lt; last_best[<span class="hljs-number">1</span>]:
            last_best = kmer, score
    <span class="hljs-keyword">return</span> last_best
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Found the consensus string GAC with a score of 2</p>
</div>
<p></p>
<a name="H_Greedy%20Algorithm"></a><h4>Greedy Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm begins by constructing a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> where the only <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> is a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> picked from the first <a href="#BM_(sequence)%2Fi">sequence</a>. From there, it goes through the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in the ...</p>
<ol>
<li>second <a href="#BM_(sequence)%2Fi">sequence</a> to find the one that has the highest match probability to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and adds it as a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>third <a href="#BM_(sequence)%2Fi">sequence</a> to find the one that has the highest match probability to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and adds it as a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>fourth <a href="#BM_(sequence)%2Fi">sequence</a> to find the one that has the highest match probability to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and adds it as a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>...</li>
</ol>
<p>This process repeats once for every <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> in the first <a href="#BM_(sequence)%2Fi">sequence</a>. Each repetition produces a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Of all the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> built, the one with the lowest score is selected.</p>
<p>This is a <a href="#BM_(greedy%20algorithm)%2Fi">greedy algorithm</a>. It builds out potential <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> by selecting the locally optimal <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from each <a href="#BM_(sequence)%2Fi">sequence</a>. While this may not lead to the globally optimal <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, it's fast and has a higher than normal likelihood of picking out the correct <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greedy_motif_search_with_psuedocounts</span>(<span class="hljs-params">k: int, dnas: List[str]</span>):</span>
    best_motif_matrix = [dna[<span class="hljs-number">0</span>:k] <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]

    <span class="hljs-keyword">for</span> motif, _ <span class="hljs-keyword">in</span> slide_window(dnas[<span class="hljs-number">0</span>], k):
        motif_matrix = [motif]
        counts = motif_matrix_count(motif_matrix)
        apply_psuedocounts_to_count_matrix(counts)
        profile = motif_matrix_profile(counts)

        <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas[<span class="hljs-number">1</span>:]:
            next_motif, _ = find_most_probable_kmer_using_profile_matrix(profile, dna)
            <span class="hljs-comment"># push in closest kmer as a motif member and recompute profile for the next iteration</span>
            motif_matrix.append(next_motif)
            counts = motif_matrix_count(motif_matrix)
            apply_psuedocounts_to_count_matrix(counts)
            profile = motif_matrix_profile(counts)

        <span class="hljs-keyword">if</span> score_motif(motif_matrix) &lt; score_motif(best_motif_matrix):
            best_motif_matrix = motif_matrix

    <span class="hljs-keyword">return</span> best_motif_matrix
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Found the motif matrix...</p>
<p>GAC<br>GAC<br>GTC<br>GAG<br>GAC</p>
</div>
<p></p>
<a name="H_Randomized%20Algorithm"></a><h4>Randomized Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix%2FRandomized%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F">Algorithms/Motif/Motif Matrix Profile</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm selects a random <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from each <a href="#BM_(sequence)%2Fi">sequence</a> to form an initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Then, for each <a href="#BM_(sequence)%2Fi">sequence</a>, it finds the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that has the highest probability of matching that <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s form the <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of a new <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. If the new <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> scores better than the existing <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the existing <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> gets replaced with the new <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and the process repeats. Otherwise, the existing <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is selected.</p>
<p>In theory, this algorithm works because all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in a <a href="#BM_(sequence)%2Fi">sequence</a> other than the <a href="#BM_(motif%20member)%2Fi">motif member</a> are considered to be random noise. As such, if no <a href="#BM_(motif%20member)%2Fi">motif member</a>s were selected when creating the initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the profile of that initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> would be more or less uniform:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
<tr>
<td>C</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
<tr>
<td>T</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
<tr>
<td>G</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
</tbody>
</table>
<p>Such a profile wouldn't allow for converging to a vastly better scoring <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>However, if at least one <a href="#BM_(motif%20member)%2Fi">motif member</a> were selected when creating the initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the profile of that initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> would skew towards the <a href="#BM_(motif)%2Fi">motif</a>:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td><strong>0.333</strong></td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td><strong>0.333</strong></td>
<td>0.233</td>
</tr>
<tr>
<td>C</td>
<td>0.233</td>
<td>0.233</td>
<td><strong>0.333</strong></td>
<td><strong>0.333</strong></td>
<td>0.233</td>
<td><strong>0.333</strong></td>
</tr>
<tr>
<td>T</td>
<td>0.233</td>
<td><strong>0.333</strong></td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
</tr>
<tr>
<td>G</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
</tr>
</tbody>
</table>
<p>Such a profile would lead to a better scoring <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> where that better scoring <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> contains the other <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p>In practice, this algorithm may trip up on real-world data. Real-world <a href="#BM_(sequence)%2Fi">sequence</a>s don't actually contain random noise. The hope is that the only <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are highly similar to each other in the <a href="#BM_(sequence)%2Fi">sequence</a>s are <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a>. It's possible that the <a href="#BM_(sequence)%2Fi">sequence</a>s contain other sets of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are similar to each other but vastly different than the <a href="#BM_(motif%20member)%2Fi">motif member</a>s. In such cases, even if a <a href="#BM_(motif%20member)%2Fi">motif member</a> were to be selected when creating the initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the algorithm may converge to a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> that isn't for the <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p>This is a <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">monte carlo algorithm</a>. It uses randomness to deliver an approximate solution. While this may not lead to the globally optimal <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, it's fast and as such can be run multiple times. The run with the best <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> will likely be a good enough solution (it captures most of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s, or parts of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s if k was too small, or etc..).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomized_motif_search_with_psuedocounts</span>(<span class="hljs-params">k: int, dnas: List[str]</span>) -&gt; List[str]:</span>
        motif_matrix = []
        <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas:
            start = randrange(len(dna) - k + <span class="hljs-number">1</span>)
            kmer = dna[start:start + k]
            motif_matrix.append(kmer)

        best_motif_matrix = motif_matrix

        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            counts = motif_matrix_count(motif_matrix)
            apply_psuedocounts_to_count_matrix(counts)
            profile = motif_matrix_profile(counts)

            motif_matrix = [find_most_probable_kmer_using_profile_matrix(profile, dna)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]
            <span class="hljs-keyword">if</span> score_motif(motif_matrix) &lt; score_motif(best_motif_matrix):
                best_motif_matrix = motif_matrix
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> best_motif_matrix
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Running 1000 iterations...</p>
<p>Best found the motif matrix...</p>
<p>GAC<br>GAC<br>GTC<br>GAG<br>GAC</p>
</div>
<p></p>
<a name="H_Gibbs%20Sampling%20Algorithm"></a><h4>Gibbs Sampling Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix%2FRandomized%20Algorithm)_TOPIC%2F">Algorithms/Motif/Find Motif Matrix/Randomized Algorithm</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The Pevzner book mentions there's more to Gibbs Sampling than what it discussed. I looked up the topic but couldn't make much sense of it.</p>
</div>
<p>This algorithm selects a random <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from each <a href="#BM_(sequence)%2Fi">sequence</a> to form an initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Then, one of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s from the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is randomly chosen and replaced with another <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from the same <a href="#BM_(sequence)%2Fi">sequence</a> that the removed <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> came from. The replacement is selected by using a weighted random number algorithm, where how likely a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is to be chosen as a replacement has to do with how probable of a match it is to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>This process of replacement is repeated for some user-defined number of cycles, at which point the algorithm has hopefully homed in on the desired <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>This is a <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">monte carlo algorithm</a>. It uses randomness to deliver an approximate solution. While this may not lead to the globally optimal <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, it's fast and as such can be run multiple times. The run with the best <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> will likely be a good enough solution (it captures most of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s, or parts of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s if k was too small, or etc..).</p>
<p>The idea behind this algorithm is similar to the idea behind the <a href="#BM_(randomized%20algorithm)%2Fi">randomized algorithm</a> for <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> finding, except that this algorithm is more conservative in how it converges on a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and the weighted random selection allows it to potentially break out if stuck in a local optima.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gibbs_rand</span>(<span class="hljs-params">prob_dist: List[float]</span>) -&gt; int:</span>
    <span class="hljs-comment"># normalize prob_dist -- just incase sum(prob_dist) != 1.0</span>
    prob_dist_sum = sum(prob_dist)
    prob_dist = [p / prob_dist_sum <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> prob_dist]

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        selection = randrange(<span class="hljs-number">0</span>, len(prob_dist))
        <span class="hljs-keyword">if</span> random() &lt; prob_dist[selection]:
            <span class="hljs-keyword">return</span> selection


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">determine_probabilities_of_all_kmers_in_dna</span>(<span class="hljs-params">profile_matrix: Dict[str, List[float]], dna: str, k: int</span>) -&gt; List[int]:</span>
    ret = []
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        prob = determine_probability_of_match_using_profile_matrix(profile_matrix, kmer)
        ret.append(prob)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gibbs_sampler_motif_search_with_psuedocounts</span>(<span class="hljs-params">k: int, dnas: List[str], cycles: int</span>) -&gt; List[str]:</span>
    motif_matrix = []
    <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas:
        start = randrange(len(dna) - k + <span class="hljs-number">1</span>)
        kmer = dna[start:start + k]
        motif_matrix.append(kmer)

    best_motif_matrix = motif_matrix[:]  <span class="hljs-comment"># create a copy, otherwise you'll be modifying both motif and best_motif</span>

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cycles):
        i = randrange(len(dnas))  <span class="hljs-comment"># pick a dna</span>
        <span class="hljs-keyword">del</span> motif_matrix[i]  <span class="hljs-comment"># remove the kmer for that dna from the motif str</span>

        counts = motif_matrix_count(motif_matrix)
        apply_psuedocounts_to_count_matrix(counts)
        profile = motif_matrix_profile(counts)

        new_motif_kmer_probs = determine_probabilities_of_all_kmers_in_dna(profile, dnas[i], k)
        new_motif_kmer_idx = gibbs_rand(new_motif_kmer_probs)
        new_motif_kmer = dnas[i][new_motif_kmer_idx:new_motif_kmer_idx+k]
        motif_matrix.insert(i, new_motif_kmer)

        <span class="hljs-keyword">if</span> score_motif(motif_matrix) &lt; score_motif(best_motif_matrix):
            best_motif_matrix = motif_matrix[:]  <span class="hljs-comment"># create a copy, otherwise you'll be modifying both motif and best_motif</span>

    <span class="hljs-keyword">return</span> best_motif_matrix
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Running 1000 iterations...</p>
<p>Best found the motif matrix...</p>
<p>GAC<br>GAC<br>GTC<br>CAC<br>GAC</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Hybrid%20Alphabet"></a><h3>Motif Matrix Hybrid Alphabet</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Hybrid%20Alphabet)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FConsensus%20String)_TOPIC%2F">Algorithms/Motif/Consensus String</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix)_TOPIC%2F">Algorithms/Motif/Find Motif Matrix</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: When creating finding a <a href="#BM_(motif)%2Fi">motif</a>, it may be beneficial to use a <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> rather than the standard nucleotides (A, C, T, and G). For example, the following <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> marks certain combinations of nucleotides as a single letter:</p>
<ul>
<li>A = A</li>
<li>C = C</li>
<li>T = T</li>
<li>G = G</li>
<li>W = A or T</li>
<li>S = G or C</li>
<li>K = G or T</li>
<li>Y = C or T</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The alphabet above was pulled from the Pevzner book section 2.16: Complications in <a href="#BM_(motif)%2Fi">Motif</a> Finding. It's a subset of the <a href="#BM_(IUPAC%20nucleotide%20code)%2Fi">IUPAC nucleotide code</a>s alphabet. The author didn't mention if the alphabet was explicitly chosen for <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> finding. If it was, it may have been derived from running probabilities over already discovered <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>s: e.g. for the <a href="#BM_(motif)%2Fi">motif</a>s already discovered, if a position has 2 possible nucleotides then G/C (S), G/T (K), C/T (Y), and A/T (W) are likely but other combinations aren't.</p>
</div>
<p><strong>WHY</strong>: <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">Hybrid alphabet</a>s may make it easier for <a href="#BM_(motif)%2Fi">motif</a> finding algorithms to converge on a <a href="#BM_(motif)%2Fi">motif</a>. For example, when scoring a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, treat the position as a single letter if the distinct nucleotides at that position map to one of the combinations in the <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a>.</p>
<p><a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">Hybrid alphabet</a>s may make more sense for representing a <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>. Rather than picking out the most popular nucleotide, the <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> can be used to describe alternating nucleotides at each position.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code>PEVZNER_2_16_ALPHABET = dict()
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'A'</span>, <span class="hljs-string">'T'</span>})] = <span class="hljs-string">'W'</span>
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'G'</span>, <span class="hljs-string">'C'</span>})] = <span class="hljs-string">'S'</span>
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>})] = <span class="hljs-string">'K'</span>
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'C'</span>, <span class="hljs-string">'T'</span>})] = <span class="hljs-string">'Y'</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_hybrid_alphabet_motif_matrix</span>(<span class="hljs-params">motif_matrix: List[str], hybrid_alphabet: Dict[FrozenSet[str], str]</span>) -&gt; List[str]:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    motif_matrix = motif_matrix[:]  <span class="hljs-comment"># make a copy</span>
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        distinct_nucs_at_c = frozenset([motif_matrix[r][c] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows)])
        <span class="hljs-keyword">if</span> distinct_nucs_at_c <span class="hljs-keyword">in</span> hybrid_alphabet:
            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
                motif_member = motif_matrix[r]
                motif_member = motif_member[:c] + hybrid_alphabet[distinct_nucs_at_c] + motif_member[c+<span class="hljs-number">1</span>:]
                motif_matrix[r] = motif_member

    <span class="hljs-keyword">return</span> motif_matrix
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Converted...</p>
<p>CATCCG<br>CTTCCT<br>CATCTT</p>
<p>to...</p>
<p>CWTCYK<br>CWTCYK<br>CWTCYK</p>
<p>using...</p>
<p>{frozenset({'A', 'T'}): 'W', frozenset({'G', 'C'}): 'S', frozenset({'G', 'T'}): 'K', frozenset({'T', 'C'}): 'Y'}</p>
</div>
<p></p>
<a name="H_DNA%20Sequencing"></a><h2>DNA Sequencing</h2>
<p><a name="BM_(Algorithms%5C%2FDNA%20Sequencing)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p>DNA <a href="#BM_(sequencer)%2Fi">sequencer</a>s work by taking many copies of an organism's <a href="#BM_(genome)%2Fi">genome</a>, breaking up those copies into fragments, then scanning in those fragments. <a href="#BM_(sequencer)%2Fi">Sequencer</a>s typically scan fragments in 1 of 2 ways:</p>
<ul>
<li>
<p><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s - small DNA fragments of equal size (represented as <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</p>
<p><img src="svgbob_0466ab6a6dc49c17c2bac89fed628823f1b8d580.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s - small DNA fragments of equal size where the bases in the middle part of the fragment aren't known (represented as <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a>s).</p>
<p><img src="svgbob_246ba3d13372ae267d9a596e030d11d7550b036b.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<p><a href="#BM_(assembly%7Cassemble)%2Fi">Assembly</a> is the process of reconstructing an organism's <a href="#BM_(genome)%2Fi">genome</a> from the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s returned by a <a href="#BM_(sequencer)%2Fi">sequencer</a>. Since the <a href="#BM_(sequencer)%2Fi">sequencer</a> breaks up many copies of the same <a href="#BM_(genome)%2Fi">genome</a> and each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s start position is random, the original <a href="#BM_(genome)%2Fi">genome</a> can be reconstructed by finding overlaps between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s and stitching them back together.</p>
<p><img src="svgbob_c14e6c546e8e4369db69bd39a7c6e934e7ddefe7.svg" alt="Kroki diagram output"></p>
<p>A typical problem with <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> is that the number of errors in a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> increase as the number of scanned bases increases. As such, <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s are preferred over <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s: by only scanning in the head and tail of a long <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>, the scan won't contain as many errors as a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> of the same length but will still contain extra information which helps with <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a> (length of unknown nucleotides in between the prefix and suffix).</p>
<p><a href="#BM_(assembly%7Cassemble)%2Fi">Assembly</a> has many practical complications that prevent full <a href="#BM_(genome)%2Fi">genome</a> reconstruction from <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s:</p>
<ul>
<li>
<p>Which strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double stranded DNA</a> that a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> / <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> comes from isn't known, which means the overlaps you find may not be accurate.</p>
<p><img src="svgbob_9a1e8981d7c6da721c87d87057f266ca1aeee3d2.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>The <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s may not cover the entire <a href="#BM_(genome)%2Fi">genome</a>, which prevents full reconstruction.</p>
<p><img src="svgbob_b6294ec3ffaf661c338522ed9985ae78672bd1a0.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>The <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s may have errors (e.g. wrong nucleotides scanned in), which may prevent finding overlaps.</p>
<p><img src="svgbob_51205be80cb357bdfa476acb058e6136e81a0051.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>The <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for repetitive parts of the <a href="#BM_(genome)%2Fi">genome</a> (e.g. <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>s) likely can't be accurately <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a>d.</p>
<p><img src="svgbob_b6caa3257c0c8b7d997763ca20474e872861ae48.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<a name="H_Stitch%20Reads"></a><h3>Stitch Reads</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a list of overlapping <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s where ...</p>
<ul>
<li>all <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s are of the same k,</li>
<li>all overlap regions are of the same length,</li>
<li>and each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> in the list overlaps with the next <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> in the list</li>
</ul>
<p>... , stitch them together. For example, in the <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> list [GAAA, AAAT, AATC] each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> overlaps the subsequent <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> by an offset of 1: GAAATC.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>G</td>
<td>A</td>
<td>A</td>
<td>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>R2</td>
<td></td>
<td>A</td>
<td>A</td>
<td>A</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>R3</td>
<td></td>
<td></td>
<td>A</td>
<td>A</td>
<td>T</td>
<td>C</td>
</tr>
<tr>
<td>Stitched</td>
<td>G</td>
<td>A</td>
<td>A</td>
<td>A</td>
<td>T</td>
<td>C</td>
</tr>
</tbody>
</table>
<p><strong>WHY</strong>: Since the <a href="#BM_(sequencer)%2Fi">sequencer</a> breaks up many copies of the same DNA and each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>'s start position is random, larger parts of the original DNA can be reconstructed by finding overlaps between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s and stitching them back together.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append_overlap</span>(<span class="hljs-params">self: Read, other: Read, skip: int = <span class="hljs-number">1</span></span>) -&gt; Read:</span>
    offset = len(self.data) - len(other.data)
    data_head = self.data[:offset]
    data = self.data[offset:]

    prefix = data[:skip]
    overlap1 = data[skip:]
    overlap2 = other.data[:-skip]
    suffix = other.data[-skip:]
    ret = data_head + prefix
    <span class="hljs-keyword">for</span> ch1, ch2 <span class="hljs-keyword">in</span> zip(overlap1, overlap2):
        ret += ch1 <span class="hljs-keyword">if</span> ch1 == ch2 <span class="hljs-keyword">else</span> <span class="hljs-string">'?'</span>  <span class="hljs-comment"># for failure, use IUPAC nucleotide codes instead of question mark?</span>
    ret += suffix
    <span class="hljs-keyword">return</span> Read(ret, source=(<span class="hljs-string">'overlap'</span>, [self, other]))

<span class="hljs-meta">@staticmethod</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stitch</span>(<span class="hljs-params">items: List[Read], skip: int = <span class="hljs-number">1</span></span>) -&gt; str:</span>
    <span class="hljs-keyword">assert</span> len(items) &gt; <span class="hljs-number">0</span>
    ret = items[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> other <span class="hljs-keyword">in</span> items[<span class="hljs-number">1</span>:]:
        ret = ret.append_overlap(other, skip)
    <span class="hljs-keyword">return</span> ret.data
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Stitched [GAAA, AAAT, AATC] to GAAATC</p>
</div>
<p></p>
<a name="H_Stitch%20Read-Pairs"></a><h3>Stitch Read-Pairs</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a list of overlapping <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s where ...</p>
<ul>
<li>all <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s are of the same k and d,</li>
<li>all overlap regions are of the same length,</li>
<li>and each <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> in the list overlaps with the next <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> in the list</li>
</ul>
<p>... , stitch them together. For example, in the <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> list [ATG---CCG, TGT---CGT, GTT---GTT, TTA---TTC] each <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> overlaps the subsequent <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> by an offset of 1: ATGTTACCGTTC.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>R2</td>
<td></td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>G</td>
<td>T</td>
<td></td>
<td></td>
</tr>
<tr>
<td>R3</td>
<td></td>
<td></td>
<td>G</td>
<td>T</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>G</td>
<td>T</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>R4</td>
<td></td>
<td></td>
<td></td>
<td>T</td>
<td>T</td>
<td>A</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>T</td>
<td>T</td>
<td>C</td>
</tr>
<tr>
<td>Stitched</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>T</td>
<td>A</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td>T</td>
<td>T</td>
<td>C</td>
</tr>
</tbody>
</table>
<p><strong>WHY</strong>: Since the <a href="#BM_(sequencer)%2Fi">sequencer</a> breaks up many copies of the same DNA and each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>'s start position is random, larger parts of the original DNA can be reconstructed by finding overlaps between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s and stitching them back together.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Overlapping <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s are stitched by taking the first <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> and iterating through the remaining <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s where ...</p>
<ul>
<li>the suffix from each remaining <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s head k is appended to the first <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s head k.</li>
<li>the suffix from each remaining <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s tail k is appended to the first <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s tail k.</li>
</ul>
<p>For example, to stitch [ATG---CCG, TGT---CGT], ...</p>
<ol>
<li>stitch the heads as if they were <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s: [ATG, TGT] results in ATGT,</li>
<li>stitch the tails as if they were <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s: [CCG, CGT] results in CCGT.</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>R2</td>
<td></td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>G</td>
<td>T</td>
</tr>
<tr>
<td>Stitched</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td>T</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append_overlap</span>(<span class="hljs-params">self: ReadPair, other: ReadPair, skip: int = <span class="hljs-number">1</span></span>) -&gt; ReadPair:</span>
    self_head = Read(self.data.head)
    other_head = Read(other.data.head)
    new_head = self_head.append_overlap(other_head)
    new_head = new_head.data

    self_tail = Read(self.data.tail)
    other_tail = Read(other.data.tail)
    new_tail = self_tail.append_overlap(other_tail)
    new_tail = new_tail.data

    <span class="hljs-comment"># WARNING: new_d may go negative -- In the event of a negative d, it means that rather than there being a gap</span>
    <span class="hljs-comment"># in between the head and tail, there's an OVERLAP in between the head and tail. To get rid of the overlap, you</span>
    <span class="hljs-comment"># need to remove either the last d chars from head or first d chars from tail.</span>
    new_d = self.d - skip
    kdmer = Kdmer(new_head, new_tail, new_d)

    <span class="hljs-keyword">return</span> ReadPair(kdmer, source=(<span class="hljs-string">'overlap'</span>, [self, other]))

<span class="hljs-meta">@staticmethod</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stitch</span>(<span class="hljs-params">items: List[ReadPair], skip: int = <span class="hljs-number">1</span></span>) -&gt; str:</span>
    <span class="hljs-keyword">assert</span> len(items) &gt; <span class="hljs-number">0</span>
    ret = items[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> other <span class="hljs-keyword">in</span> items[<span class="hljs-number">1</span>:]:
        ret = ret.append_overlap(other, skip)
    <span class="hljs-keyword">assert</span> ret.d &lt;= <span class="hljs-number">0</span>, <span class="hljs-string">"Gap still exists -- not enough to stitch"</span>
    overlap_count = -ret.d
    <span class="hljs-keyword">return</span> ret.data.head + ret.data.tail[overlap_count:]
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Stitched [ATG---CCG, TGT---CGT, GTT---GTT, TTA---TTC] to ATGTTACCGTTC</p>
</div>
<p></p>
<a name="H_Break%20Reads"></a><h3>Break Reads</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a set of <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s that arbitrarily overlap, each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> can be broken into many smaller <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s that overlap better. For example, given 4 <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">10-mer</a>s that arbitrarily overlap, you can break them into better overlapping <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">5-mer</a>s...</p>
<p><img src="svgbob_d9e103b16312cfe660d19df9305a9361ac1241ac.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">Breaking reads</a> may cause more ambiguity in overlaps. At the same time, <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a> makes it easier to find overlaps by bringing the overlaps closer together and provides (artificially) increased <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-comment"># This is read breaking -- why not just call it break? because break is a reserved keyword.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shatter</span>(<span class="hljs-params">self: Read, k: int</span>) -&gt; List[Read]:</span>
    ret = []
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(self.data, k):
        r = Read(kmer, source=(<span class="hljs-string">'shatter'</span>, [self]))
        ret.append(r)
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Broke ACTAAGAACC to [ACTAA, CTAAG, TAAGA, AAGAA, AGAAC, GAACC]</p>
</div>
<p></p>
<a name="H_Break%20Read-Pairs"></a><h3>Break Read-Pairs</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s that arbitrarily overlap, each <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> can be broken into many <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s with a smaller k that overlap better. For example, given 4 <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(4,2)-mer</a>s that arbitrarily overlap, you can break them into better overlapping <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(2,4)-mer</a>s...</p>
<p><img src="svgbob_eb8f1251b4e293a9662ade2c0a4452a7c7884f2f.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">Breaking read-pairs</a> may cause more ambiguity in overlaps. At the same time, <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a> makes it easier to find overlaps by bringing the overlaps closer together and provides (artificially) increased <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-comment"># This is read breaking -- why not just call it break? because break is a reserved keyword.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shatter</span>(<span class="hljs-params">self: ReadPair, k: int</span>) -&gt; List[ReadPair]:</span>
    ret = []
    d = (self.k - k) + self.d
    <span class="hljs-keyword">for</span> window_head, window_tail <span class="hljs-keyword">in</span> zip(slide_window(self.data.head, k), slide_window(self.data.tail, k)):
        kmer_head, _ = window_head
        kmer_tail, _ = window_tail
        kdmer = Kdmer(kmer_head, kmer_tail, d)
        rp = ReadPair(kdmer, source=(<span class="hljs-string">'shatter'</span>, [self]))
        ret.append(rp)
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Broke ACTA--AACC to [AC----AA, CT----AC, TA----CC]</p>
</div>
<p></p>
<a name="H_Probability%20of%20Fragment%20Occurrence"></a><h3>Probability of Fragment Occurrence</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FProbability%20of%20Fragment%20Occurrence)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Stitch Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Break Read-Pairs</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: <a href="#BM_(sequencer)%2Fi">Sequencer</a>s work by taking many copies of an organism's <a href="#BM_(genome)%2Fi">genome</a>, randomly breaking up those <a href="#BM_(genome)%2Fi">genome</a>s into smaller pieces, and randomly scanning in those pieces (<a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s). As such, it isn't immediately obvious how many times each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> actually appears in the <a href="#BM_(genome)%2Fi">genome</a>.</p>
<p>Imagine that you're <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> an organism's <a href="#BM_(genome)%2Fi">genome</a>. Given that ...</p>
<ul>
<li>there's good <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> of the <a href="#BM_(genome)%2Fi">genome</a> (e.g. ~30x as many <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s as the length of the <a href="#BM_(genome)%2Fi">genome</a>),</li>
<li>the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s scanned in are chosen at random (unbiased),</li>
<li>the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s scanned in start at random offsets in the <a href="#BM_(genome)%2Fi">genome</a> (unbiased),</li>
<li>and the majority of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are for non-repeating parts of the <a href="#BM_(genome)%2Fi">genome</a>.</li>
</ul>
<p>... you can use probabilities to hint at how many times a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> appears in the <a href="#BM_(genome)%2Fi">genome</a>.</p>
<p><strong>WHY</strong>:</p>
<p>Determining how many times a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> appears in a <a href="#BM_(genome)%2Fi">genome</a> helps with <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>. Specifically, ...</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for repeat regions of the <a href="#BM_(genome)%2Fi">genome</a> can be accounted for during <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s containing <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s may be detectable and filtered out prior to <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</li>
</ul>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For simplicity's sake, the <a href="#BM_(genome)%2Fi">genome</a> is single-stranded (not <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a> / no <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>ing stand).</p>
</div>
<p>Imagine a <a href="#BM_(genome)%2Fi">genome</a> of ATGGATGC. A <a href="#BM_(sequencer)%2Fi">sequencer</a> runs over that single strand and generates <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">3-mer</a> <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s with roughly 30x <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>. The resulting <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are ...</p>
<table>
<thead>
<tr>
<th><a href="#BM_%5Cb(read)_SEQ%2Fi">Read</a></th>
<th># of Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATG</td>
<td>61</td>
</tr>
<tr>
<td>TGG</td>
<td>30</td>
</tr>
<tr>
<td>GAT</td>
<td>31</td>
</tr>
<tr>
<td>TGC</td>
<td>29</td>
</tr>
<tr>
<td>TGT</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Since the <a href="#BM_(genome)%2Fi">genome</a> is known to have less than 50% repeats, the dominate number of copies likely maps to 1 instance of that <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> appearing in the <a href="#BM_(genome)%2Fi">genome</a>. Since the dominate number is ~30, divide the number of copies for each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> by ~30 to find out roughly how many times each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> appears in the <a href="#BM_(genome)%2Fi">genome</a> ...</p>
<table>
<thead>
<tr>
<th><a href="#BM_%5Cb(read)_SEQ%2Fi">Read</a></th>
<th># of Copies</th>
<th># of Appearances in <a href="#BM_(genome)%2Fi">Genome</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>ATG</td>
<td>61</td>
<td>2</td>
</tr>
<tr>
<td>TGG</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>GAT</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>TGC</td>
<td>29</td>
<td>1</td>
</tr>
<tr>
<td>TGT</td>
<td>1</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>Note the last <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> (TGT) has 0.03 appearances, meaning it's a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> that it either</p>
<ul>
<li>contains a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>,</li>
<li>or it has poor <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> (likely because it's at the head / tail of the <a href="#BM_(genome)%2Fi">genome</a> so it got scanned in less than other <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s).</li>
</ul>
<p>In this case, it's an error because it doesn't appear in the original <a href="#BM_(genome)%2Fi">genome</a>: TGT is not in ATGGATGC.</p>
<pre class="hljs"><code><span class="hljs-comment"># If less than 50% of the reads are from repeats, this attempts to count and normalize such that it can hint at which</span>
<span class="hljs-comment"># reads may contain errors (= ~0) and which reads are for repeat regions (&gt; 1.0).</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_fragment_occurrence_probabilities</span>(<span class="hljs-params">fragments: List[T]</span>) -&gt; Dict[T, float]:</span>
    counter = Counter(fragments)
    max_digit_count = max([len(str(count)) <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> counter.values()])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(max_digit_count):
        rounded_counter = Counter(dict([(k, round(count, -i)) <span class="hljs-keyword">for</span> k, count <span class="hljs-keyword">in</span> counter.items()]))
        <span class="hljs-keyword">for</span> k, orig_count <span class="hljs-keyword">in</span> counter.items():
            <span class="hljs-keyword">if</span> rounded_counter[k] == <span class="hljs-number">0</span>:
                rounded_counter[k] = orig_count
        most_occurring_count, times_counted = Counter(rounded_counter.values()).most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">if</span> times_counted &gt;= len(rounded_counter) * <span class="hljs-number">0.5</span>:
            <span class="hljs-keyword">return</span> dict([(key, value / most_occurring_count) <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> rounded_counter.items()])
    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f'Failed to find a common count: <span class="hljs-subst">{counter}</span>'</span>)
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Sequenced fragments:</p>
<ul>
<li>ATG was scanned in 61 times.</li>
<li>TGG was scanned in 30 times.</li>
<li>GAT was scanned in 31 times.</li>
<li>TGC was scanned in 29 times.</li>
<li>TGT was scanned in 1 times.</li>
</ul>
<p>Probability of occurrence in genome:</p>
<ul>
<li>ATG probably has 2.0 appearances in the genome.</li>
<li>TGG probably has 1.0 appearances in the genome.</li>
<li>GAT probably has 1.0 appearances in the genome.</li>
<li>TGC probably has 1.0 appearances in the genome.</li>
<li>TGT probably has 0.03333333333333333 appearances in the genome.</li>
</ul>
</div>
<p></p>
<a name="H_Overlap%20Graph"></a><h3>Overlap Graph</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Stitch Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Break Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FProbability%20of%20Fragment%20Occurrence)_TOPIC%2F">Algorithms/Assembly/Probability of Fragment Occurrence</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single strand of DNA, create a directed graph where ...</p>
<ol>
<li>
<p>each node is a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</p>
<p><img src="svgbob_ba61508d2d4f3dfef58ce5783f8e22f49ddec891.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>each edge is between overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s (nodes), where the ...</p>
<ul>
<li>source node has the overlap in its suffix .</li>
<li>destination node has the overlap in its prefix.</li>
</ul>
<p><img src="svgbob_62843d070e55883049a5a0f4881f1ec17928f780.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p>This is called an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>.</p>
<p><strong>WHY</strong>: An <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> shows the different ways that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s can be stitched together. A path in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> that touches each node exactly once is one possibility for the original <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single stranded DNA</a> that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from. For example...</p>
<ul>
<li>[TTA, TAG, AGT, GTT, TTA, TAC, ACT, CTT] ⟶ TTAGTTACTT</li>
<li>[TTA, TAC, ACT, CTT, TTA, TAG, AGT, GTT] ⟶ TTACTTAGTT</li>
<li>[ACT, CTT, TTA, TAG, AGT, GTT, TTA, TAC] ⟶ ACTTAGTTAC</li>
<li>[CTT, TTA, TAG, AGT, GTT, TTA, TAC, ACT] ⟶ CTTAGTTACT</li>
<li>...</li>
</ul>
<p>These paths are referred to as <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Notice that the example graph is circular. If the organism <a href="#BM_(genome)%2Fi">genome</a> itself were also circular (e.g. bacterial <a href="#BM_(genome)%2Fi">genome</a>), the <a href="#BM_(genome)%2Fi">genome</a> guesses above are all actually the same because circular <a href="#BM_(genome)%2Fi">genome</a>s don't have a beginning / end.</p>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p><a href="#BM_(sequencer)%2Fi">Sequencer</a>s produce <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s, but <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s by themselves typically aren't enough for most experiments / algorithms. In theory, stitching overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single-strand of DNA should reveal that single-strand of DNA. In practice, real-world complications make revealing that single-strand of DNA nearly impossible:</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s are for both strands (strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a> a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s from isn't known).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be missing (<a href="#BM_(sequencer)%2Fi">sequencer</a> didn't capture it).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have inconsistent <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> (<a href="#BM_(sequencer)%2Fi">sequencer</a> captured it too many/few times).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be repeated (regions of the <a href="#BM_(genome)%2Fi">genome</a> may repeat).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have errors (<a href="#BM_(sequencer)%2Fi">sequencer</a> produced <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be stitch-able in more than one way (multiple <a href="#BM_(genome)%2Fi">genome</a> reconstruction guesses).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may take a long time to stitch (computationally intensive).</li>
</ul>
<p>Never the less, in an ideal world where most of these problems don't exist, an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> is a good way to guess the single-strand of DNA that a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from. An <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> assumes that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s it's operating on ...</p>
<ul>
<li>are from a single-strand of DNA,</li>
<li>have correct occurrence counts (no missing or extra),</li>
<li>and contain no errors.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Although the complications discussed above make it impossible to get the original <a href="#BM_(genome)%2Fi">genome</a> in its entirety, it's still possible to pull out large parts of the original <a href="#BM_(genome)%2Fi">genome</a>. This is discussed in <a href="#BM_(Algorithms%5C%2FAssembly%2FFind%20Contigs)_TOPIC%2F">Algorithms/Assembly/Find Contigs</a>.</p>
</div>
<p>To construct an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, create an edge between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s that have an overlap.</p>
<p>For each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>, add that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s ...</p>
<ul>
<li>prefix to a hash table.</li>
<li>suffix to a hash table.</li>
</ul>
<p>Then, join the hash tables together to find overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_overlap_graph</span>(<span class="hljs-params">items: List[T], skip: int = <span class="hljs-number">1</span></span>) -&gt; Graph[T]:</span>
    ret = Graph()

    prefixes = dict()
    suffixes = dict()
    <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(items):
        prefix = item.prefix(skip)
        prefixes.setdefault(prefix, set()).add(i)
        suffix = item.suffix(skip)
        suffixes.setdefault(suffix, set()).add(i)

    <span class="hljs-keyword">for</span> key, indexes <span class="hljs-keyword">in</span> suffixes.items():
        other_indexes = prefixes.get(key)
        <span class="hljs-keyword">if</span> other_indexes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indexes:
            item = items[i]
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> other_indexes:
                <span class="hljs-keyword">if</span> i == j:
                    <span class="hljs-keyword">continue</span>
                other_item = items[j]
                ret.insert_edge(item, other_item)
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTA', 'TTA', 'TAG', 'AGT', 'GTT', 'TAC', 'ACT', 'CTT'], the overlap graph is...</p>
<p><img src="dot_8ca9fb7886e86704dc01b1bffd1d6dd1.svg" alt="Dot diagram"></p>
</div>
<p></p>
<p>A path that touches each node of an graph exactly once is a <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a>. Each  The <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> is a guess as to the original single strand of DNA that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for the graph came from.</p>
<p>The code shown below recursively walks all paths. Of all the paths it walks over, the ones that walk every node of the graph exactly once are selected.</p>
<p>This algorithm will likely fall over on non-trivial <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>s. Even finding one <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> is computationally intensive.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exhaustively_walk_until_all_nodes_touched_exactly_one</span>(<span class="hljs-params">
        graph: Graph[T],
        from_node: T,
        current_path: List[T]
</span>) -&gt; List[List[T]]:</span>
    current_path.append(from_node)

    <span class="hljs-keyword">if</span> len(current_path) == len(graph):
        found_paths = [current_path.copy()]
    <span class="hljs-keyword">else</span>:
        found_paths = []
        <span class="hljs-keyword">for</span> to_node <span class="hljs-keyword">in</span> graph.get_outputs(from_node):
            <span class="hljs-keyword">if</span> to_node <span class="hljs-keyword">in</span> set(current_path):
                <span class="hljs-keyword">continue</span>
            found_paths += exhaustively_walk_until_all_nodes_touched_exactly_one(graph, to_node, current_path)

    current_path.pop()
    <span class="hljs-keyword">return</span> found_paths


<span class="hljs-comment"># walk each node exactly once</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_hamiltonian_paths</span>(<span class="hljs-params">graph: Graph[T], from_node: T</span>) -&gt; List[List[T]]:</span>
    <span class="hljs-keyword">return</span> exhaustively_walk_until_all_nodes_touched_exactly_one(graph, from_node, [])
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTA', 'TTA', 'TAG', 'AGT', 'GTT', 'TAC', 'ACT', 'CTT'], the overlap graph is...</p>
<p><img src="dot_8ca9fb7886e86704dc01b1bffd1d6dd1.svg" alt="Dot diagram"></p>
<p>... and the Hamiltonian paths are ...</p>
<ul>
<li>TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA</li>
<li>TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT</li>
<li>AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG</li>
<li>TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA</li>
<li>TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA</li>
<li>CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT</li>
<li>TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT</li>
<li>TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT</li>
<li>AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG</li>
<li>ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC</li>
<li>GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT</li>
<li>CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT</li>
<li>ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC</li>
<li>GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT</li>
<li>TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA</li>
<li>TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT</li>
</ul>
</div>
<p></p>
<a name="H_De%20Bruijn%20Graph"></a><h3>De Bruijn Graph</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FDe%20Bruijn%20Graph)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Stitch Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Break Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FProbability%20of%20Fragment%20Occurrence)_TOPIC%2F">Algorithms/Assembly/Probability of Fragment Occurrence</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F">Algorithms/Assembly/Overlap Graph</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single strand of DNA, create a directed graph where ...</p>
<ol>
<li>
<p>each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> is represented as an edge connecting 2 nodes, where the ...</p>
<ul>
<li>source node is the prefix of the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</li>
<li>destination node is the suffix of the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</li>
</ul>
<p><img src="svgbob_843b8aaedb289d3d3ad5aef2fcd9bf5a504ad5af.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>duplicate nodes are merged into a single node.</p>
<p><img src="svgbob_7dea4cc54e9eac3d3a657922085849157a9cf869.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p>This graph is called a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>: a <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> and <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> graph where the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are represented as edges.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The example graph above is <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>. But, depending on the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s used, the graph may not be totally <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>. A technique for dealing with this is detailed below. For now, just assume that the graph will be <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>.</p>
</div>
<p><strong>WHY</strong>:  Similar to an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> shows the different ways that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s can be stitched together. However, unlike an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are represented as edges rather than nodes. Where in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> you need to find paths that touch every node exactly once (<a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a>), in a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> you need to find paths that walk over every edge exactly once (<a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>).</p>
<p>A path in a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> that walks over each edge exactly once is one possibility for the original <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single stranded DNA</a> that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from: it starts and ends at the same node (a cycle), and walks over every edge in the graph.</p>
<p>In contrast to finding a <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, it's much faster to find an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> in a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>.</p>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s were originally invented to solve the <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> string problem, which is effectively the same concept as <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<p><a href="#BM_(sequencer)%2Fi">Sequencer</a>s produce <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s, but <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s by themselves typically aren't enough for most experiments / algorithms. In theory, stitching overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single-strand of DNA should reveal that single-strand of DNA. In practice, real-world complications make revealing that single-strand of DNA nearly impossible:</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s are for both strands (strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a> a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s from isn't known).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be missing (<a href="#BM_(sequencer)%2Fi">sequencer</a> didn't capture it).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have inconsistent <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> (<a href="#BM_(sequencer)%2Fi">sequencer</a> captured it too many/few times).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be repeated (regions of the <a href="#BM_(genome)%2Fi">genome</a> may repeat).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have errors (<a href="#BM_(sequencer)%2Fi">sequencer</a> produced <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be stitch-able in more than one way (multiple <a href="#BM_(genome)%2Fi">genome</a> reconstruction guesses).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may take a long time to stitch (computationally intensive).</li>
</ul>
<p>Never the less, in an ideal world where most of these problems don't exist, a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> is a good way to guess the single-strand of DNA that a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from. A <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> assumes that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s it's operating on ...</p>
<ul>
<li>are from a single-strand of DNA,</li>
<li>have correct occurrence counts (no missing or extra),</li>
<li>and contain no errors.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Although the complications discussed above make it impossible to get the original <a href="#BM_(genome)%2Fi">genome</a> in its entirety, it's still possible to pull out large parts of the original <a href="#BM_(genome)%2Fi">genome</a>. This is discussed in <a href="#BM_(Algorithms%5C%2FAssembly%2FFind%20Contigs)_TOPIC%2F">Algorithms/Assembly/Find Contigs</a>.</p>
</div>
<p>To construct a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>, add an edge for each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>, creating missing nodes as required.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_debruijn_graph</span>(<span class="hljs-params">reads: List[T], skip: int = <span class="hljs-number">1</span></span>) -&gt; Graph[T]:</span>
    graph = Graph()
    <span class="hljs-keyword">for</span> read <span class="hljs-keyword">in</span> reads:
        from_node = read.prefix(skip)
        to_node = read.suffix(skip)
        graph.insert_edge(from_node, to_node)
    <span class="hljs-keyword">return</span> graph
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTAG', 'TAGT', 'AGTT', 'GTTA', 'TTAC', 'TACT', 'ACTT', 'CTTA'], the de Bruijn graph is...</p>
<p><img src="dot_fc6c4f4bf004838f81f7a6343b7d2e19.svg" alt="Dot diagram"></p>
</div>
<p></p>
<p>Note how the graph above is both <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> and <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>. In most cases, non-circular <a href="#BM_(genome)%2Fi">genome</a>s won't generate a <a href="#BM_(balanced%20graph)%2Fi">balanced graph</a> like the one above. Instead, a non-circular <a href="#BM_(genome)%2Fi">genome</a> will very likely generate a graph that's nearly <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>: Nearly <a href="#BM_(balanced%20graph)%2Fi">balanced graph</a>s are graphs that are would be <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> if not for a few un<a href="#BM_(balanced%20node)%2Fi">balanced node</a>s (usually root and tail nodes). They can artificially be made to become <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> by finding im<a href="#BM_(balanced%20node)%2Fi">balanced node</a>s and creating artificial edges between them until they become <a href="#BM_(balanced%20node)%2Fi">balanced node</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Circular <a href="#BM_(genome)%2Fi">genome</a>s are <a href="#BM_(genome)%2Fi">genome</a>s that wrap around (e.g. bacterial <a href="#BM_(genome)%2Fi">genome</a>s). They don't have a beginning / end.</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_unbalanced_nodes</span>(<span class="hljs-params">graph: Graph[T]</span>) -&gt; List[Tuple[T, int, int]]:</span>
    unbalanced_nodes = []
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        in_degree = graph.get_in_degree(node)
        out_degree = graph.get_out_degree(node)
        <span class="hljs-keyword">if</span> in_degree != out_degree:
            unbalanced_nodes.append((node, in_degree, out_degree))
    <span class="hljs-keyword">return</span> unbalanced_nodes


<span class="hljs-comment"># creates a balanced graph from a nearly balanced graph -- nearly balanced means the graph has an equal number of</span>
<span class="hljs-comment"># missing outputs and missing inputs.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">balance_graph</span>(<span class="hljs-params">graph: Graph[T]</span>) -&gt; Tuple[Graph[T], Set[T], Set[T]]:</span>
    unbalanced_nodes = find_unbalanced_nodes(graph)
    nodes_with_missing_ins = filter(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>] &lt; x[<span class="hljs-number">2</span>], unbalanced_nodes)
    nodes_with_missing_outs = filter(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>] &gt; x[<span class="hljs-number">2</span>], unbalanced_nodes)

    graph = graph.copy()

    <span class="hljs-comment"># create 1 copy per missing input / per missing output</span>
    n_per_need_in = [_n <span class="hljs-keyword">for</span> n, in_degree, out_degree <span class="hljs-keyword">in</span> nodes_with_missing_ins <span class="hljs-keyword">for</span> _n <span class="hljs-keyword">in</span> [n] * (out_degree - in_degree)]
    n_per_need_out = [_n <span class="hljs-keyword">for</span> n, in_degree, out_degree <span class="hljs-keyword">in</span> nodes_with_missing_outs <span class="hljs-keyword">for</span> _n <span class="hljs-keyword">in</span> [n] * (in_degree - out_degree)]
    <span class="hljs-keyword">assert</span> len(n_per_need_in) == len(n_per_need_out)  <span class="hljs-comment"># need an equal count of missing ins and missing outs to balance</span>

    <span class="hljs-comment"># balance</span>
    <span class="hljs-keyword">for</span> n_need_in, n_need_out <span class="hljs-keyword">in</span> zip(n_per_need_in, n_per_need_out):
        graph.insert_edge(n_need_out, n_need_in)

    <span class="hljs-keyword">return</span> graph, set(n_per_need_in), set(n_per_need_out)  <span class="hljs-comment"># return graph with cycle, orig root nodes, orig tail nodes</span>
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTAC', 'TACC', 'ACCC', 'CCCT'], the artificially balanced de Bruijn graph is...</p>
<p><img src="dot_060b6d958ad63bcbb55a116f699b26f5.svg" alt="Dot diagram"></p>
<p>... with original head nodes at {TTA} and tail nodes at {CCT}.</p>
</div>
<p></p>
<p>Given a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> (<a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> and <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>), you can find a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> by randomly walking unexplored edges in the graph. Pick a starting node and randomly walk edges until you end up back at that same node, ignoring all edges that were previously walked over. Of the nodes that were walked over, pick one that still has unexplored edges and repeat the process: Walk edges from that node until you end up back at that same node, ignoring edges all edges that were previously walked over (including those in the past iteration). Continue this until you run out of unexplored edges.</p>
<pre class="hljs"><code><span class="hljs-comment"># (6, 8), (8, 7), (7, 9), (9, 6)  ----&gt;  68796</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edge_list_to_node_list</span>(<span class="hljs-params">edges: List[Tuple[T, T]]</span>) -&gt; List[T]:</span>
    ret = [edges[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]
    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> edges:
        ret.append(e[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomly_walk_and_remove_edges_until_cycle</span>(<span class="hljs-params">graph: Graph[T], node: T</span>) -&gt; List[T]:</span>
    end_node = node
    edge_list = []
    from_node = node
    <span class="hljs-keyword">while</span> len(graph) &gt; <span class="hljs-number">0</span>:
        to_nodes = graph.get_outputs(from_node)
        to_node = next(to_nodes, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">assert</span> to_node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># eularian graphs are strongly connected, meaning we should never hit dead-end nodes</span>

        graph.delete_edge(from_node, to_node, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>)

        edge = (from_node, to_node)
        edge_list.append(edge)
        from_node = to_node
        <span class="hljs-keyword">if</span> from_node == end_node:
            <span class="hljs-keyword">return</span> edge_list_to_node_list(edge_list)

    <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># eularian graphs are strongly connected and balanced, meaning we should never run out of nodes</span>


<span class="hljs-comment"># graph must be strongly connected</span>
<span class="hljs-comment"># graph must be balanced</span>
<span class="hljs-comment"># if the 2 conditions above are met, the graph will be eularian (a eulerian cycle exists)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_eulerian_cycle</span>(<span class="hljs-params">graph: Graph[T], start_node: T</span>) -&gt; List[T]:</span>
    graph = graph.copy()

    node_cycle = randomly_walk_and_remove_edges_until_cycle(graph, start_node)
    node_cycle_ptr = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> len(graph) &gt; <span class="hljs-number">0</span>:
        new_node_cycle = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> local_ptr, node <span class="hljs-keyword">in</span> enumerate(node_cycle[node_cycle_ptr:]):
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:
                <span class="hljs-keyword">continue</span>
            node_cycle_ptr += local_ptr
            inject_node_cycle = randomly_walk_and_remove_edges_until_cycle(graph, node)
            new_node_cycle = node_cycle[:]
            new_node_cycle[node_cycle_ptr:node_cycle_ptr+<span class="hljs-number">1</span>] = inject_node_cycle
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">assert</span> new_node_cycle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
        node_cycle = new_node_cycle

    <span class="hljs-keyword">return</span> node_cycle
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTA', 'TAT', 'ATT', 'TTC', 'TCT', 'CTT'], the de Bruijn graph is...</p>
<p><img src="dot_3a93e1cbe061465a28efa39eadb1f973.svg" alt="Dot diagram"></p>
<p>... and a Eulerian cycle is ...</p>
<p>TT -&gt; TC -&gt; CT -&gt; TT -&gt; TA -&gt; AT -&gt; TT</p>
</div>
<p></p>
<p>Note that the graph above is naturally <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> (no artificial edges have been added in to make it <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>). If the graph you're finding a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> on has been artificially <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>, simply start the search for a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> from one of the original head node. The artificial edge will show up at the end of the <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>, and as such can be dropped from the path.</p>
<p><img src="svgbob_cdf5dbb7db5be8e11adb7461507ac8e7ae647e3a.svg" alt="Kroki diagram output"></p>
<p>This algorithm picks one <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> in a graph. Most graph have multiple <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s, likely too many to enumerate all of them.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See the section on <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> strings to see a real-world application of <a href="#BM_(Eulerian%20graph)%2Fi">Eulerian graph</a>s. For something like k=20, good luck trying to enumerate all <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s.</p>
</div>
<a name="H_Find%20Bubbles"></a><h3>Find Bubbles</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FFind%20Bubbles)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F">Algorithms/Assembly/Overlap Graph</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FDe%20Bruijn%20Graph)_TOPIC%2F">Algorithms/Assembly/De Bruijn Graph</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s that have been broken to k (<a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a> / <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>), any ...</p>
<ul>
<li>forked prefixes,</li>
<li>forked suffixes,</li>
<li>or bubbles</li>
</ul>
<p>... of length ...</p>
<ul>
<li>k in the <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>,</li>
<li>or k-1 in the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a></li>
</ul>
<p>... may have been from a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>.</p>
<p><img src="svgbob_986faa465630c014228747bd8c1b6750b9c7d5a7.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: When <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s returned by a <a href="#BM_(sequencer)%2Fi">sequencer</a> get broken (<a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a> / <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>), any <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s containing <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s may show up in the graph as one of 3 structures: forked prefix, forked suffix, or bubble. As such, it may be possible to detect these structures and flatten them (by removing bad branches) to get a cleaner graph.</p>
<p>For example, imagine the <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> ATTGG. <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">Read breaking</a> it into <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s results in: [AT, TT, TG, GG].</p>
<p><img src="svgbob_14d21a2810cefc8cfab333aadbe576260b565d48.svg" alt="Kroki diagram output"></p>
<p>Now, imagine that the <a href="#BM_(sequencer)%2Fi">sequencer</a> captures that same part of the <a href="#BM_(genome)%2Fi">genome</a> again, but this time the <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> contains a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>. Depending on where the incorrect nucleotide is, one of the 3 structures will get introduced into the graph:</p>
<ul>
<li>
<p>ATTGG vs A<strong>C</strong>TGG (within first 2 elements)</p>
<p><img src="svgbob_0c0a09e604164ee4ffcdc4f3fcfa420c2035cdd5.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>ATTGG vs ATT<strong>C</strong>G (within last 2 elements)</p>
<p><img src="svgbob_8749bd635048fbfa4bd483e9c5425e73ff41a8d1.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>ATTGG vs AT<strong>C</strong>GG (sandwiched after first 2 elements and before last 2 elements)</p>
<p><img src="svgbob_3cc83e04b59a481951a59a2edd92cab8b200b193.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<p>Note that just because these structures exist doesn't mean that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s they represent definitively have <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s. These structures could have been caused by other problems / may not be problems at all:</p>
<ul>
<li>Bubbles may be caused by repetitive regions of DNA: <a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s from different parts of the <a href="#BM_(genome)%2Fi">genome</a> that are the same except for a few positions will show up as bubbles.</li>
<li>Bubbles / forks may be caused when <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a>: When both strands of DNA get tangled into the same graph, it's possible that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s from different strands form bubbles or forks.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The Pevzner book says that bubble removal is a common feature in modern <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a>rs. My assumption is that, before pulling out <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s (described later on), basic probabilities are used to try and suss out if a branch in a bubble / prefix fork / suffix fork is bad and remove it if it is. This (hopefully) results in longer <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s.</p>
</div>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_head_convergences</span>(<span class="hljs-params">graph: Graph[T], branch_len: int</span>) -&gt; List[Tuple[Optional[T], List[T], Optional[T]]]:</span>
    root_nodes = filter(<span class="hljs-keyword">lambda</span> n: graph.get_in_degree(n) == <span class="hljs-number">0</span>, graph.get_nodes())

    ret = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> root_nodes:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_outputs(n):
            path_from_child = walk_outs_until_converge(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            diverging_node = <span class="hljs-literal">None</span>
            branch_path = [n] + path_from_child[:<span class="hljs-number">-1</span>]
            converging_node = path_from_child[<span class="hljs-number">-1</span>]
            path = (diverging_node, branch_path, converging_node)
            <span class="hljs-keyword">if</span> len(branch_path) &lt;= branch_len:
                ret.append(path)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_tail_divergences</span>(<span class="hljs-params">graph: Graph[T], branch_len: int</span>) -&gt; List[Tuple[Optional[T], List[T], Optional[T]]]:</span>
    tail_nodes = filter(<span class="hljs-keyword">lambda</span> n: graph.get_out_degree(n) == <span class="hljs-number">0</span>, graph.get_nodes())

    ret = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> tail_nodes:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_inputs(n):
            path_from_child = walk_ins_until_diverge(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            diverging_node = path_from_child[<span class="hljs-number">0</span>]
            branch_path = path_from_child[<span class="hljs-number">1</span>:] + [n]
            converging_node = <span class="hljs-literal">None</span>
            path = (diverging_node, branch_path, converging_node)
            <span class="hljs-keyword">if</span> len(branch_path) &lt;= branch_len:
                ret.append(path)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_bubbles</span>(<span class="hljs-params">graph: Graph[T], branch_len: int</span>) -&gt; List[Tuple[Optional[T], List[T], Optional[T]]]:</span>
    branching_nodes = filter(<span class="hljs-keyword">lambda</span> n: graph.get_out_degree(n) &gt; <span class="hljs-number">1</span>, graph.get_nodes())

    ret = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> branching_nodes:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_outputs(n):
            path_from_child = walk_outs_until_converge(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            diverging_node = n
            branch_path = path_from_child[:<span class="hljs-number">-1</span>]
            converging_node = path_from_child[<span class="hljs-number">-1</span>]
            path = (diverging_node, branch_path, converging_node)
            <span class="hljs-keyword">if</span> len(branch_path) &lt;= branch_len:
                ret.append(path)
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Fragments from sequencer:</p>
<ul>
<li>ATAGGAC scanned in 1.</li>
<li>ATTGGAC scanned in 55.</li>
<li>TTGGACA scanned in 30.</li>
<li>TGGACAA scanned in 30.</li>
<li>GGACAAT scanned in 30.</li>
<li>GACAATC scanned in 30.</li>
<li>ACAATCT scanned in 30.</li>
<li>ACAGTCT scanned in 1.</li>
<li>CAATCTC scanned in 30.</li>
<li>AATCTCG scanned in 30.</li>
<li>ATCTCGG scanned in 30.</li>
<li>TCTCGGG scanned in 30.</li>
<li>CTCGGGC scanned in 55.</li>
<li>CTCGTGC scanned in 1.</li>
</ul>
<p>Fragments after being broken to k=4:</p>
<ul>
<li>ATAG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>TAGG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>AGGA broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>GGAC broken out 146 times, so it probably appears in the genome 1.0 times.</li>
<li>ATTG broken out 55 times, so it probably appears in the genome 1.0 times.</li>
<li>TTGG broken out 85 times, so it probably appears in the genome 1.0 times.</li>
<li>TGGA broken out 115 times, so it probably appears in the genome 1.0 times.</li>
<li>GACA broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>ACAA broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>CAAT broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>AATC broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>ATCT broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>ACAG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>CAGT broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>AGTC broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>GTCT broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>TCTC broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>CTCG broken out 146 times, so it probably appears in the genome 1.0 times.</li>
<li>TCGG broken out 115 times, so it probably appears in the genome 1.0 times.</li>
<li>CGGG broken out 85 times, so it probably appears in the genome 1.0 times.</li>
<li>GGGC broken out 55 times, so it probably appears in the genome 1.0 times.</li>
<li>TCGT broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>CGTG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>GTGC broken out 1 times, so it probably appears in the genome 0.01 times.</li>
</ul>
<p>De Bruijn graph:</p>
<p><img src="dot_58d24202dc65f3967dedac820f12af62.svg" alt="Dot diagram"></p>
<p>Problem paths:</p>
<ul>
<li>Src: ACA, Dst: TCT, Branch: CAA-&gt;AAT-&gt;ATC</li>
<li>Src: ACA, Dst: TCT, Branch: CAG-&gt;AGT-&gt;GTC</li>
<li>Src: None, Dst: GGA, Branch: ATA-&gt;TAG-&gt;AGG</li>
<li>Src: None, Dst: GGA, Branch: ATT-&gt;TTG-&gt;TGG</li>
<li>Src: TCG, Dst: None, Branch: CGG-&gt;GGG-&gt;GGC</li>
<li>Src: TCG, Dst: None, Branch: CGT-&gt;GTG-&gt;TGC</li>
</ul>
</div>
<p></p>
<a name="H_Find%20Contigs"></a><h3>Find Contigs</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FFind%20Contigs)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F">Algorithms/Assembly/Overlap Graph</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FDe%20Bruijn%20Graph)_TOPIC%2F">Algorithms/Assembly/De Bruijn Graph</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FFind%20Bubbles)_TOPIC%2F">Algorithms/Assembly/Find Bubbles</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> or <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>, find the longest possible stretches of non-branching nodes. Each stretch will be a path that's either  ...</p>
<ul>
<li>
<p>a line: each node has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1.</p>
<p><img src="svgbob_8f50e668ad56e2eeff3c39e6aa89792f6f9444f9.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>a cycle: each node has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1 and it loops.</p>
<p><img src="svgbob_9a5c6dc10a8a016d6f43d4c9bdd6243d0ee5b332.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>a line sandwiched between branching nodes: nodes in between have an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1 but either...</p>
<ul>
<li>starts at a node where <a href="#BM_(indegree)%2Fi">indegree</a> != 1 but <a href="#BM_(outdegree)%2Fi">outdegree</a> == 1 (incoming branch),</li>
<li>or ends at a node where <a href="#BM_(indegree)%2Fi">indegree</a> == 1 but <a href="#BM_(outdegree)%2Fi">outdegree</a> != 1 (outgoing branch),</li>
<li>or both.</li>
</ul>
<p><img src="svgbob_057bcd0e831c50ca2384b8da9ea9cd1f46186b4a.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<p>Each found path is called a <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>: a contiguous piece of the graph. For example, ...</p>
<p><img src="svgbob_f186de7e9649b7a39a09b48a6c55ea97a221dce1.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: An <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> / <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> represents all the possible ways a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s may be stitched together to infer the full <a href="#BM_(genome)%2Fi">genome</a>. However, real-world complications make it impractical to guess the full <a href="#BM_(genome)%2Fi">genome</a>:</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s are for both strands (strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a> a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s from isn't known).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be missing (<a href="#BM_(sequencer)%2Fi">sequencer</a> didn't capture it).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have inconsistent <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> (<a href="#BM_(sequencer)%2Fi">sequencer</a> captured it too many/few times).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be repeated (regions of the <a href="#BM_(genome)%2Fi">genome</a> may repeat).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have errors (<a href="#BM_(sequencer)%2Fi">sequencer</a> produced <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be stitch-able in more than one way (multiple <a href="#BM_(genome)%2Fi">genome</a> reconstruction guesses).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may take a long time to stitch (computationally intensive).</li>
</ul>
<p>These complications result in graphs that are too tangled, <a href="#BM_(disconnected)%2Fi">disconnected</a>, etc... As such, the best someone can do is to pull out the <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s in the graph: unambiguous stretches of DNA.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_until_non_1_to_1</span>(<span class="hljs-params">graph: Graph[T], node: T</span>) -&gt; Optional[List[T]]:</span>
    ret = [node]
    ret_quick_lookup = {node}
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        out_degree = graph.get_out_degree(node)
        in_degree = graph.get_in_degree(node)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(in_degree == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> out_degree == <span class="hljs-number">1</span>):
            <span class="hljs-keyword">return</span> ret

        children = graph.get_outputs(node)
        child = next(children)
        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">in</span> ret_quick_lookup:
            <span class="hljs-keyword">return</span> ret

        node = child
        ret.append(node)
        ret_quick_lookup.add(node)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_until_loop</span>(<span class="hljs-params">graph: Graph[T], node: T</span>) -&gt; Optional[List[T]]:</span>
    ret = [node]
    ret_quick_lookup = {node}
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        out_degree = graph.get_out_degree(node)
        <span class="hljs-keyword">if</span> out_degree &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> out_degree == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        children = graph.get_outputs(node)
        child = next(children)
        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">in</span> ret_quick_lookup:
            <span class="hljs-keyword">return</span> ret

        node = child
        ret.append(node)
        ret_quick_lookup.add(node)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_maximal_non_branching_paths</span>(<span class="hljs-params">graph: Graph[T]</span>) -&gt; List[List[T]]:</span>
    paths = []

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        out_degree = graph.get_out_degree(node)
        in_degree = graph.get_in_degree(node)
        <span class="hljs-keyword">if</span> (in_degree == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> out_degree == <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> out_degree == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_outputs(node):
            path_from_child = walk_until_non_1_to_1(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            path = [node] + path_from_child
            paths.append(path)

    skip_nodes = set()
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> skip_nodes:
            <span class="hljs-keyword">continue</span>
        out_degree = graph.get_out_degree(node)
        in_degree = graph.get_in_degree(node)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (in_degree == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> out_degree == <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> out_degree == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">continue</span>
        path = walk_until_loop(graph, node)
        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">continue</span>
        path = path + [node]
        paths.append(path)
        skip_nodes |= set(path)

    <span class="hljs-keyword">return</span> paths
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TGG', 'GGT', 'GGT', 'GTG', 'CAC', 'ACC', 'CCA'], the de Bruijn graph is...</p>
<p><img src="dot_c3d570f99942f291a0b7bb8aa20edc6d.svg" alt="Dot diagram"></p>
<p>The following contigs were found...</p>
<p>GG-&gt;GT</p>
<p>GG-&gt;GT</p>
<p>GT-&gt;TG-&gt;GG</p>
<p>CA-&gt;AC-&gt;CC-&gt;CA</p>
</div>
<p></p>
<a name="H_Peptide%20Sequencing"></a><h2>Peptide Sequencing</h2>
<p><a name="BM_(Algorithms%5C%2FPeptide%20Sequencing)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p>A <a href="#BM_(peptide)%2Fi">peptide</a> is a miniature protein consisting of a chain of <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s anywhere between 2 to 100 <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s in length. <a href="#BM_(peptide)%2Fi">Peptide</a>s are created through two mechanisms:</p>
<ol>
<li>ribosomal <a href="#BM_(peptide)%2Fi">peptide</a>s: DNA gets <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to mRNA (<a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a>), which in turn gets <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translated</a> by the ribosome into a <a href="#BM_(peptide)%2Fi">peptide</a> (<a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>).</li>
<li><a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a>s: proteins called <a href="#BM_%5Cb(NRP)%5Cb%2Fi">NRP</a> synthetase construct <a href="#BM_(peptide)%2Fi">peptide</a>s.</li>
</ol>
<p>For ribosomal <a href="#BM_(peptide)%2Fi">peptide</a>s, each <a href="#BM_(amino%20acid)%2Fi">amino acid</a> is <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>d as a DNA <a href="#BM_(sequence)%2Fi">sequence</a> of length 3. This 3 length DNA <a href="#BM_(sequence)%2Fi">sequence</a> is referred to as a <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>. By knowing which <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s map to which <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s, the ...</p>
<ul>
<li><a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> can be determined by mapping from DNA to <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s (you know the <a href="#BM_(peptide)%2Fi">peptide</a> just by looking at the DNA).</li>
<li><a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> can be searched for in DNA by finding <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s (you can see if the <a href="#BM_(peptide)%2Fi">peptide</a> is <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>d in a <a href="#BM_(genome)%2Fi">genome</a>).</li>
</ul>
<p>For <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a>s, a sample of the <a href="#BM_(peptide)%2Fi">peptide</a> needs to be isolated and passed through a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>. A <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> is a device that shatters and bins molecules by their mass-to-charge ratio: Given a sample of molecules, the device randomly shatters each molecule in the sample (forming ions), then bins each ion by its mass-to-charge ratio (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>m</mi><mi>z</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{m}{z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>).</p>
<p>The output of a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> is a plot called a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a>. The plot's ...</p>
<ul>
<li>x-axis is the mass-to-charge ratio.</li>
<li>y-axis is the intensity of that mass-to-charge ratio (how much more / less did that mass-to-charge appear compared to the others).</li>
</ul>
<p><img src="svgbob_2b5ef43ae7572c2c6bf63687c53860a71830d160.svg" alt="Kroki diagram output"></p>
<p>For example, given a sample containing multiple instances of the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY, the <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> will take each instance of NQY and randomly break the bonds between its <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s:</p>
<p><img src="svgbob_33c109cffe376e25dfa6ba85b256a1bb307dcd76.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>How does it know to break the bonds holding <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s together and not bonds within the <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s themselves? My guess is that the bonds coupling one <a href="#BM_(amino%20acid)%2Fi">amino acid</a> to another are much weaker than the bonds holding an individual <a href="#BM_(amino%20acid)%2Fi">amino acid</a> together -- it's more likely that the weaker bonds will be broken.</p>
</div>
<p>Each <a href="#BM_(subpeptide)%2Fi">subpeptide</a> then will have its mass-to-charge ratio measured, which in turn gets converted to a set of potential masses by performing basic math. With these potential masses, it's possible to infer the <a href="#BM_(sequence)%2Fi">sequence</a> of the <a href="#BM_(peptide)%2Fi">peptide</a>.</p>
<p>Special consideration needs to be given to the real-world practical problems with <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometry</a>. Specifically, the <a href="#BM_(spectrum)_MS%2Fi">spectrum</a> given back by a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> will very likely ...</p>
<ul>
<li>miss mass-to-charge ratios for some fragments of the intended molecule (missing entries).</li>
<li>include mass-to-charge ratios for fragments of unintended molecules (faulty entries).</li>
<li>have noisy mass-to-charge ratios.</li>
</ul>
<p>The following table contains a list of common <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s with their masses and <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a> mappings:</p>
<table>
<thead>
<tr>
<th>1 Letter Code</th>
<th>3 Letter Code</th>
<th><a href="#BM_(amino%20acid)%2Fi">Amino Acid</a></th>
<th><a href="#BM_(codon%7Cgenetic%20code)%2Fi">Codon</a>s</th>
<th>Monoisotopic Mass (<a href="#BM_(dalton)%2Fi">dalton</a>s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Ala</td>
<td>Alanine</td>
<td>GCA, GCC, GCG, GCU</td>
<td>71.04</td>
</tr>
<tr>
<td>C</td>
<td>Cys</td>
<td>Cysteine</td>
<td>UGC, UGU</td>
<td>103.01</td>
</tr>
<tr>
<td>D</td>
<td>Asp</td>
<td>Aspartic acid</td>
<td>GAC, GAU</td>
<td>115.03</td>
</tr>
<tr>
<td>E</td>
<td>Glu</td>
<td>Glutamic acid</td>
<td>GAA, GAG</td>
<td>129.04</td>
</tr>
<tr>
<td>F</td>
<td>Phe</td>
<td>Phenylalanine</td>
<td>UUC, UUU</td>
<td>147.07</td>
</tr>
<tr>
<td>G</td>
<td>Gly</td>
<td>Glycine</td>
<td>GGA, GGC, GGG, GGU</td>
<td>57.02</td>
</tr>
<tr>
<td>H</td>
<td>His</td>
<td>Histidine</td>
<td>CAC, CAU</td>
<td>137.06</td>
</tr>
<tr>
<td>I</td>
<td>Ile</td>
<td>Isoleucine</td>
<td>AUA, AUC, AUU</td>
<td>113.08</td>
</tr>
<tr>
<td>K</td>
<td>Lys</td>
<td>Lysine</td>
<td>AAA, AAG</td>
<td>128.09</td>
</tr>
<tr>
<td>L</td>
<td>Leu</td>
<td>Leucine</td>
<td>CUA, CUC, CUG, CUU, UUA, UUG</td>
<td>113.08</td>
</tr>
<tr>
<td>M</td>
<td>Met</td>
<td>Methionine</td>
<td>AUG</td>
<td>131.04</td>
</tr>
<tr>
<td>N</td>
<td>Asn</td>
<td>Asparagine</td>
<td>AAC, AAU</td>
<td>114.04</td>
</tr>
<tr>
<td>P</td>
<td>Pro</td>
<td>Proline</td>
<td>CCA, CCC, CCG, CCU</td>
<td>97.05</td>
</tr>
<tr>
<td>Q</td>
<td>Gln</td>
<td>Glutamine</td>
<td>CAA, CAG</td>
<td>128.06</td>
</tr>
<tr>
<td>R</td>
<td>Arg</td>
<td>Arginine</td>
<td>AGA, AGG, CGA, CGC, CGG, CGU</td>
<td>156.1</td>
</tr>
<tr>
<td>S</td>
<td>Ser</td>
<td>Serine</td>
<td>AGC, AGU, UCA, UCC, UCG, UCU</td>
<td>87.03</td>
</tr>
<tr>
<td>T</td>
<td>Thr</td>
<td>Threonine</td>
<td>ACA, ACC, ACG, ACU</td>
<td>101.05</td>
</tr>
<tr>
<td>V</td>
<td>Val</td>
<td>Valine</td>
<td>GUA, GUC, GUG, GUU</td>
<td>99.07</td>
</tr>
<tr>
<td>W</td>
<td>Trp</td>
<td>Tryptophan</td>
<td>UGG</td>
<td>186.08</td>
</tr>
<tr>
<td>Y</td>
<td>Tyr</td>
<td>Tyrosine</td>
<td>UAC, UAU</td>
<td>163.06</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td><strong>STOP</strong></td>
<td>UAA, UAG, UGA</td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The stop marker tells the ribosome to stop translating / the protein is complete. The <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s are listed as <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s (RNA). For nucleotides (DNA), swap U with T.</p>
</div>
<a name="H_Codon%20Encode"></a><h3>Codon Encode</h3>
<p><strong>WHAT</strong>: Given a DNA <a href="#BM_(sequence)%2Fi">sequence</a>, map each <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a> to the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> it represents. In total, there are 6 different ways that a DNA <a href="#BM_(sequence)%2Fi">sequence</a> could be <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translated</a>:</p>
<ol>
<li>Since the length of a <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a> is 3, the <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encoding</a> of the <a href="#BM_(peptide)%2Fi">peptide</a> could start from offset 0, 1, or 2 (referred to as <a href="#BM_(reading%20frame)%2Fi">reading frame</a>s).</li>
<li>Since DNA is double stranded, either the DNA <a href="#BM_(sequence)%2Fi">sequence</a> or its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> could represent the <a href="#BM_(peptide)%2Fi">peptide</a>.</li>
</ol>
<p><strong>WHY</strong>: The composition of a <a href="#BM_(peptide)%2Fi">peptide</a> can be determined from the DNA <a href="#BM_(sequence)%2Fi">sequence</a> that <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>s it.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code>_codon_to_amino_acid = {<span class="hljs-string">'AAA'</span>: <span class="hljs-string">'K'</span>, <span class="hljs-string">'AAC'</span>: <span class="hljs-string">'N'</span>, <span class="hljs-string">'AAG'</span>: <span class="hljs-string">'K'</span>, <span class="hljs-string">'AAU'</span>: <span class="hljs-string">'N'</span>, <span class="hljs-string">'ACA'</span>: <span class="hljs-string">'T'</span>, <span class="hljs-string">'ACC'</span>: <span class="hljs-string">'T'</span>, <span class="hljs-string">'ACG'</span>: <span class="hljs-string">'T'</span>, <span class="hljs-string">'ACU'</span>: <span class="hljs-string">'T'</span>,
                        <span class="hljs-string">'AGA'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'AGC'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'AGG'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'AGU'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'AUA'</span>: <span class="hljs-string">'I'</span>, <span class="hljs-string">'AUC'</span>: <span class="hljs-string">'I'</span>, <span class="hljs-string">'AUG'</span>: <span class="hljs-string">'M'</span>, <span class="hljs-string">'AUU'</span>: <span class="hljs-string">'I'</span>,
                        <span class="hljs-string">'CAA'</span>: <span class="hljs-string">'Q'</span>, <span class="hljs-string">'CAC'</span>: <span class="hljs-string">'H'</span>, <span class="hljs-string">'CAG'</span>: <span class="hljs-string">'Q'</span>, <span class="hljs-string">'CAU'</span>: <span class="hljs-string">'H'</span>, <span class="hljs-string">'CCA'</span>: <span class="hljs-string">'P'</span>, <span class="hljs-string">'CCC'</span>: <span class="hljs-string">'P'</span>, <span class="hljs-string">'CCG'</span>: <span class="hljs-string">'P'</span>, <span class="hljs-string">'CCU'</span>: <span class="hljs-string">'P'</span>,
                        <span class="hljs-string">'CGA'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CGC'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CGG'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CGU'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CUA'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'CUC'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'CUG'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'CUU'</span>: <span class="hljs-string">'L'</span>,
                        <span class="hljs-string">'GAA'</span>: <span class="hljs-string">'E'</span>, <span class="hljs-string">'GAC'</span>: <span class="hljs-string">'D'</span>, <span class="hljs-string">'GAG'</span>: <span class="hljs-string">'E'</span>, <span class="hljs-string">'GAU'</span>: <span class="hljs-string">'D'</span>, <span class="hljs-string">'GCA'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'GCC'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'GCG'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'GCU'</span>: <span class="hljs-string">'A'</span>,
                        <span class="hljs-string">'GGA'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GGC'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GGG'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GGU'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GUA'</span>: <span class="hljs-string">'V'</span>, <span class="hljs-string">'GUC'</span>: <span class="hljs-string">'V'</span>, <span class="hljs-string">'GUG'</span>: <span class="hljs-string">'V'</span>, <span class="hljs-string">'GUU'</span>: <span class="hljs-string">'V'</span>,
                        <span class="hljs-string">'UAA'</span>: <span class="hljs-string">'*'</span>, <span class="hljs-string">'UAC'</span>: <span class="hljs-string">'Y'</span>, <span class="hljs-string">'UAG'</span>: <span class="hljs-string">'*'</span>, <span class="hljs-string">'UAU'</span>: <span class="hljs-string">'Y'</span>, <span class="hljs-string">'UCA'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'UCC'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'UCG'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'UCU'</span>: <span class="hljs-string">'S'</span>,
                        <span class="hljs-string">'UGA'</span>: <span class="hljs-string">'*'</span>, <span class="hljs-string">'UGC'</span>: <span class="hljs-string">'C'</span>, <span class="hljs-string">'UGG'</span>: <span class="hljs-string">'W'</span>, <span class="hljs-string">'UGU'</span>: <span class="hljs-string">'C'</span>, <span class="hljs-string">'UUA'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'UUC'</span>: <span class="hljs-string">'F'</span>, <span class="hljs-string">'UUG'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'UUU'</span>: <span class="hljs-string">'F'</span>}

_amino_acid_to_codons = dict()
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> _codon_to_amino_acid.items():
    _amino_acid_to_codons.setdefault(v, []).append(k)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">codon_to_amino_acid</span>(<span class="hljs-params">rna: str</span>) -&gt; Optional[str]:</span>
    <span class="hljs-keyword">return</span> _codon_to_amino_acid.get(rna)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">amino_acid_to_codons</span>(<span class="hljs-params">codon: str</span>) -&gt; Optional[List[str]]:</span>
    <span class="hljs-keyword">return</span> _amino_acid_to_codons.get(codon)
</code></pre>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_peptide</span>(<span class="hljs-params">dna: str</span>) -&gt; str:</span>
    rna = dna_to_rna(dna)
    protein_seq = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> codon <span class="hljs-keyword">in</span> split_to_size(rna, <span class="hljs-number">3</span>):
        codon_str = <span class="hljs-string">''</span>.join(codon)
        protein_seq += codon_to_amino_acid(codon_str)
    <span class="hljs-keyword">return</span> protein_seq


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_peptides_all_readingframes</span>(<span class="hljs-params">dna: str</span>) -&gt; List[str]:</span>
    ret = []
    <span class="hljs-keyword">for</span> dna_ <span class="hljs-keyword">in</span> (dna, dna_reverse_complement(dna)):
        <span class="hljs-keyword">for</span> rf_start <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):
            rf_end = len(dna_) - ((len(dna_) - rf_start) % <span class="hljs-number">3</span>)
            peptide = encode_peptide(dna_[rf_start:rf_end])
            ret.append(peptide)
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given AAAAGAACCTAATCTTAAAGGAGATGATGATTCTAA, the possible peptide encodings are...</p>
<ul>
<li>KRT*S*RR**F*</li>
<li>KEPNLKGDDDS</li>
<li>KNLILKEMMIL</li>
<li>LESSSPLRLGSF</li>
<li>*NHHLL*D*VL</li>
<li>RIIISFKIRFF</li>
</ul>
</div>
<p></p>
<a name="H_Codon%20Decode"></a><h3>Codon Decode</h3>
<p><strong>WHAT</strong>: Given a <a href="#BM_(peptide)%2Fi">peptide</a>, map each <a href="#BM_(amino%20acid)%2Fi">amino acid</a> to the DNA <a href="#BM_(sequence)%2Fi">sequence</a>s it represents. Since each <a href="#BM_(amino%20acid)%2Fi">amino acid</a> can map to multiple <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s, there may be multiple DNA <a href="#BM_(sequence)%2Fi">sequence</a>s for a single <a href="#BM_(peptide)%2Fi">peptide</a>.</p>
<p><strong>WHY</strong>: The DNA <a href="#BM_(sequence)%2Fi">sequence</a>s that <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a> a <a href="#BM_(peptide)%2Fi">peptide</a> can be determined from the <a href="#BM_(peptide)%2Fi">peptide</a> itself.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code>_codon_to_amino_acid = {<span class="hljs-string">'AAA'</span>: <span class="hljs-string">'K'</span>, <span class="hljs-string">'AAC'</span>: <span class="hljs-string">'N'</span>, <span class="hljs-string">'AAG'</span>: <span class="hljs-string">'K'</span>, <span class="hljs-string">'AAU'</span>: <span class="hljs-string">'N'</span>, <span class="hljs-string">'ACA'</span>: <span class="hljs-string">'T'</span>, <span class="hljs-string">'ACC'</span>: <span class="hljs-string">'T'</span>, <span class="hljs-string">'ACG'</span>: <span class="hljs-string">'T'</span>, <span class="hljs-string">'ACU'</span>: <span class="hljs-string">'T'</span>,
                        <span class="hljs-string">'AGA'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'AGC'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'AGG'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'AGU'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'AUA'</span>: <span class="hljs-string">'I'</span>, <span class="hljs-string">'AUC'</span>: <span class="hljs-string">'I'</span>, <span class="hljs-string">'AUG'</span>: <span class="hljs-string">'M'</span>, <span class="hljs-string">'AUU'</span>: <span class="hljs-string">'I'</span>,
                        <span class="hljs-string">'CAA'</span>: <span class="hljs-string">'Q'</span>, <span class="hljs-string">'CAC'</span>: <span class="hljs-string">'H'</span>, <span class="hljs-string">'CAG'</span>: <span class="hljs-string">'Q'</span>, <span class="hljs-string">'CAU'</span>: <span class="hljs-string">'H'</span>, <span class="hljs-string">'CCA'</span>: <span class="hljs-string">'P'</span>, <span class="hljs-string">'CCC'</span>: <span class="hljs-string">'P'</span>, <span class="hljs-string">'CCG'</span>: <span class="hljs-string">'P'</span>, <span class="hljs-string">'CCU'</span>: <span class="hljs-string">'P'</span>,
                        <span class="hljs-string">'CGA'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CGC'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CGG'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CGU'</span>: <span class="hljs-string">'R'</span>, <span class="hljs-string">'CUA'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'CUC'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'CUG'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'CUU'</span>: <span class="hljs-string">'L'</span>,
                        <span class="hljs-string">'GAA'</span>: <span class="hljs-string">'E'</span>, <span class="hljs-string">'GAC'</span>: <span class="hljs-string">'D'</span>, <span class="hljs-string">'GAG'</span>: <span class="hljs-string">'E'</span>, <span class="hljs-string">'GAU'</span>: <span class="hljs-string">'D'</span>, <span class="hljs-string">'GCA'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'GCC'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'GCG'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'GCU'</span>: <span class="hljs-string">'A'</span>,
                        <span class="hljs-string">'GGA'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GGC'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GGG'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GGU'</span>: <span class="hljs-string">'G'</span>, <span class="hljs-string">'GUA'</span>: <span class="hljs-string">'V'</span>, <span class="hljs-string">'GUC'</span>: <span class="hljs-string">'V'</span>, <span class="hljs-string">'GUG'</span>: <span class="hljs-string">'V'</span>, <span class="hljs-string">'GUU'</span>: <span class="hljs-string">'V'</span>,
                        <span class="hljs-string">'UAA'</span>: <span class="hljs-string">'*'</span>, <span class="hljs-string">'UAC'</span>: <span class="hljs-string">'Y'</span>, <span class="hljs-string">'UAG'</span>: <span class="hljs-string">'*'</span>, <span class="hljs-string">'UAU'</span>: <span class="hljs-string">'Y'</span>, <span class="hljs-string">'UCA'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'UCC'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'UCG'</span>: <span class="hljs-string">'S'</span>, <span class="hljs-string">'UCU'</span>: <span class="hljs-string">'S'</span>,
                        <span class="hljs-string">'UGA'</span>: <span class="hljs-string">'*'</span>, <span class="hljs-string">'UGC'</span>: <span class="hljs-string">'C'</span>, <span class="hljs-string">'UGG'</span>: <span class="hljs-string">'W'</span>, <span class="hljs-string">'UGU'</span>: <span class="hljs-string">'C'</span>, <span class="hljs-string">'UUA'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'UUC'</span>: <span class="hljs-string">'F'</span>, <span class="hljs-string">'UUG'</span>: <span class="hljs-string">'L'</span>, <span class="hljs-string">'UUU'</span>: <span class="hljs-string">'F'</span>}

_amino_acid_to_codons = dict()
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> _codon_to_amino_acid.items():
    _amino_acid_to_codons.setdefault(v, []).append(k)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">codon_to_amino_acid</span>(<span class="hljs-params">rna: str</span>) -&gt; Optional[str]:</span>
    <span class="hljs-keyword">return</span> _codon_to_amino_acid.get(rna)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">amino_acid_to_codons</span>(<span class="hljs-params">codon: str</span>) -&gt; Optional[List[str]]:</span>
    <span class="hljs-keyword">return</span> _amino_acid_to_codons.get(codon)
</code></pre>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_peptide</span>(<span class="hljs-params">peptide: str</span>) -&gt; List[str]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">subpeptide: str, dna: str, ret: List[str]</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> len(subpeptide) == <span class="hljs-number">0</span>:
            ret.append(dna)
            <span class="hljs-keyword">return</span>
        aa = subpeptide[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> codon <span class="hljs-keyword">in</span> amino_acid_to_codons(aa):
            dfs(subpeptide[<span class="hljs-number">1</span>:], dna + rna_to_dna(codon), ret)
    dnas = []
    dfs(peptide, <span class="hljs-string">''</span>, dnas)
    <span class="hljs-keyword">return</span> dnas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_peptide_count</span>(<span class="hljs-params">peptide: str</span>) -&gt; int:</span>
    count = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> peptide:
        vals = amino_acid_to_codons(ch)
        count *= len(vals)
    <span class="hljs-keyword">return</span> count
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given NQY, the possible DNA encodings are...</p>
<ul>
<li>AACCAATAC</li>
<li>AACCAATAT</li>
<li>AACCAGTAC</li>
<li>AACCAGTAT</li>
<li>AATCAATAC</li>
<li>AATCAATAT</li>
<li>AATCAGTAC</li>
<li>AATCAGTAT</li>
</ul>
</div>
<p></p>
<a name="H_Experimental%20Spectrum"></a><h3>Experimental Spectrum</h3>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FExperimental%20Spectrum)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a> for a <a href="#BM_(peptide)%2Fi">peptide</a>, derive a set of potential masses from the mass-to-charge ratios. These potential masses are referred to as an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<p><strong>WHY</strong>: A <a href="#BM_(peptide)%2Fi">peptide</a>'s <a href="#BM_(sequence)%2Fi">sequence</a> can be inferred from a list of its potential <a href="#BM_(subpeptide)%2Fi">subpeptide</a> masses.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Prior to deriving masses from a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a>, filter out low intensity mass-to-charge ratios. The remaining mass-to-charge ratios are converted to potential masses using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>m</mi><mi>z</mi></mfrac><mo>⋅</mo><mi>z</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\frac{m}{z} \cdot z = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>.</p>
<p>For example, consider a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> that has a tendency to produce +1 and +2 ions. This <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> produces the following mass-to-charge ratios: [100, 150, 250]. Each mass-to-charge ratio from this <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> will be converted to two possible masses:</p>
<ul>
<li>100 ⟶ [100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 200<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</li>
<li>150 ⟶ [150<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 300<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</li>
<li>250 ⟶ [250<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 500<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</li>
</ul>
<p>It's impossible to know which mass is correct, so all masses are included in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>:</p>
<p>[100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 150<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 200<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 250<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 300<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 500<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>].</p>
<pre class="hljs"><code><span class="hljs-comment"># Its expected that low intensity mass_charge_ratios have already been filtered out prior to invoking this func.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">experimental_spectrum</span>(<span class="hljs-params">mass_charge_ratios: List[float], charge_tendencies: Set[float]</span>) -&gt; List[float]:</span>
    ret = [<span class="hljs-number">0.0</span>]  <span class="hljs-comment"># implied -- subpeptide of length 0</span>
    <span class="hljs-keyword">for</span> mcr <span class="hljs-keyword">in</span> mass_charge_ratios:
        <span class="hljs-keyword">for</span> charge <span class="hljs-keyword">in</span> charge_tendencies:
            ret.append(mcr * charge)
    ret.sort()
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The experimental spectrum for the mass-to-charge ratios...</p>
<p>[100.0, 150.0, 250.0]</p>
<p>... and charge tendencies...</p>
<p>{1.0, 2.0}</p>
<p>... is...</p>
<p>[0.0, 100.0, 150.0, 200.0, 250.0, 300.0, 500.0]</p>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The following section isn't from the Pevzner book or any online resources. I came up with it in an effort to solve the final assignment for Chapter 4 (the chapter on <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a> <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>). As such, it might not be entirely correct / there may be better ways to do this.</p>
</div>
<p>Just as a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a> is noisy, the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> derived from a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a> is also noisy. For example, consider a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> that produces up to ±0.5 noise per mass-to-charge ratio and has a tendency to produce +1 and +2 charges. A real mass of 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> measured by this <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> will end up in the <a href="#BM_(spectrum)_MS%2Fi">spectrum</a> as a mass-to-charge ratio of either...</p>
<ul>
<li>for +1 charge, anywhere between 99.5 to 100.5 (calculated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>100</mn><mn>1</mn></mfrac><mo>−</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{100}{1} - 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>100</mn><mn>1</mn></mfrac><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{100}{1} + 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span>).</li>
<li>for +2 charge, anywhere between 49.5 to 50.5 (calculated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>100</mn><mn>2</mn></mfrac><mo>−</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{100}{2} - 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>100</mn><mn>2</mn></mfrac><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{100}{2} + 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span>).</li>
</ul>
<p>Converting these mass-to-charge ratio ranges to mass ranges...</p>
<ul>
<li>for +1 charge, anywhere between 99.5<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 100.5<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> (calculated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>99.5</mn><mo>⋅</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">99.5 \cdot 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100.5</mn><mo>⋅</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">100.5 \cdot 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>).</li>
<li>for +2 charge, anywhere between 99<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 101<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> (calculated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>49.5</mn><mo>⋅</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">49.5 \cdot 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">9</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50.5</mn><mo>⋅</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">50.5 \cdot 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>).</li>
</ul>
<p>Note how the +2 charge conversion produces the widest range: 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> ± 1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. Any real mass measured by this <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> will end up in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> with up to ±1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> noise. For example, a real mass of ...</p>
<ul>
<li>99<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> will show up in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> anywhere between 98<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> and 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</li>
<li>100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> will show up in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> anywhere between 99<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 101<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</li>
<li>101<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> will show up in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> anywhere between 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 102<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</li>
</ul>
<p><img src="svgbob_d6d8a41fe65a2e957bcaeb54e9dc6794ee0de080.svg" alt="Kroki diagram output"></p>
<p>Similarly, any mass in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> could have come from a real mass within ±1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> of it. For example, an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass of 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> could have come from a real mass of anywhere between 99<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 101<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>: At a real mass of ...</p>
<ul>
<li>99<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, the corresponding <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass range's maximum is 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> (98<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>).</li>
<li>100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, the corresponding <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass range's middle is 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> (99<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 101<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>).</li>
<li>101<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, the corresponding <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass range's minimum is 100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>: (100<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 102<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>).</li>
</ul>
<p><img src="svgbob_3b5e914f5add7debee6f9ce052bf324c6d6dcf4f.svg" alt="Kroki diagram output"></p>
<p>As such, the maximum amount of noise for a real mass that made its way into the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is the same as the tolerance required for mapping an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass back to the real mass it came from. This tolerance can also be considered noise: the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass is offset from the real mass that it came from.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">experimental_spectrum_noise</span>(<span class="hljs-params">max_mass_charge_ratio_noise: float, charge_tendencies: Set[float]</span>) -&gt; float:</span>
    <span class="hljs-keyword">return</span> max_mass_charge_ratio_noise * abs(max(charge_tendencies))
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given a max mass-to-charge ratio noise of ±0.5 and charge tendencies {1.0, 2.0}, the maximum noise per experimental spectrum mass is ±1.0</p>
</div>
<p></p>
<a name="H_Theoretical%20Spectrum"></a><h3>Theoretical Spectrum</h3>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FExperimental%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Experimental Spectrum</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: A <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is an algorithmically generated list of all <a href="#BM_(subpeptide)%2Fi">subpeptide</a> masses for a known <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> (including 0 and the full <a href="#BM_(peptide)%2Fi">peptide</a>'s mass).</p>
<p>For example, <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY has the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>...</p>
<pre class="hljs"><code>theo_spec = [
  <span class="hljs-number">0</span>,    <span class="hljs-comment"># &lt;empty&gt;</span>
  <span class="hljs-number">114</span>,  <span class="hljs-comment"># N</span>
  <span class="hljs-number">128</span>,  <span class="hljs-comment"># Q</span>
  <span class="hljs-number">163</span>,  <span class="hljs-comment"># Y</span>
  <span class="hljs-number">242</span>,  <span class="hljs-comment"># NQ</span>
  <span class="hljs-number">291</span>,  <span class="hljs-comment"># QY</span>
  <span class="hljs-number">405</span>   <span class="hljs-comment"># NQY</span>
]
</code></pre>
<p>... while <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> produced by feeding NQY to a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> may look something like...</p>
<pre class="hljs"><code>exp_spec = [
  <span class="hljs-number">0.0</span>,    <span class="hljs-comment"># &lt;empty&gt; (implied)</span>
  <span class="hljs-number">113.9</span>,  <span class="hljs-comment"># N</span>
  <span class="hljs-number">115.1</span>,  <span class="hljs-comment"># N</span>
          <span class="hljs-comment"># Q missing</span>
  <span class="hljs-number">136.2</span>,  <span class="hljs-comment"># faulty</span>
  <span class="hljs-number">162.9</span>,  <span class="hljs-comment"># Y</span>
  <span class="hljs-number">242.0</span>,  <span class="hljs-comment"># NQ</span>
          <span class="hljs-comment"># QY missing</span>
  <span class="hljs-number">311.1</span>,  <span class="hljs-comment"># faulty</span>
  <span class="hljs-number">346.0</span>,  <span class="hljs-comment"># faulty</span>
  <span class="hljs-number">405.2</span>   <span class="hljs-comment"># NQY</span>
]
</code></pre>
<p>The <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is what the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> would be in a perfect world...</p>
<ul>
<li>only a single possible mass for each mass-to-charge ratio.</li>
<li>no missing masses.</li>
<li>no faulty masses.</li>
<li>no noise.</li>
</ul>
<p><strong>WHY</strong>: The closer a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is to an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, the more likely it is that the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> used to generate that <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is related to the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> that produced that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. This is the basis for how <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a>s are <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a>: an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is produced by a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>, then that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is compared against a set of <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>s.</p>
<a name="H2_Bruteforce%20Algorithm"></a><h4>Bruteforce Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum%2FBruteforce%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<p><strong>ALGORITHM</strong>:</p>
<p>The following algorithm generates a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> in the most obvious way: iterate over each <a href="#BM_(subpeptide)%2Fi">subpeptide</a> and calculate its mass.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">theoretical_spectrum</span>(<span class="hljs-params">
        peptide: List[AA],
        peptide_type: PeptideType,
        mass_table: Dict[AA, float]
</span>) -&gt; List[int]:</span>
    <span class="hljs-comment"># add subpeptide of length 0's mass</span>
    ret = [<span class="hljs-number">0.0</span>]
    <span class="hljs-comment"># add subpeptide of length 1 to k-1's mass</span>
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(peptide)):
        <span class="hljs-keyword">for</span> subpeptide, _ <span class="hljs-keyword">in</span> slide_window(peptide, k, cyclic=peptide_type == PeptideType.CYCLIC):
            ret.append(sum([mass_table[ch] <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> subpeptide]))
    <span class="hljs-comment"># add subpeptide of length k's mass</span>
    ret.append(sum([mass_table[aa] <span class="hljs-keyword">for</span> aa <span class="hljs-keyword">in</span> peptide]))
    <span class="hljs-comment"># sort and return</span>
    ret.sort()
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The theoretical spectrum for the linear peptide NQY is [0.0, 114.0, 128.0, 163.0, 242.0, 291.0, 405.0]</p>
</div>
<p></p>
<a name="H_Prefix%20Sum%20Algorithm"></a><h4>Prefix Sum Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum%2FPrefix%20Sum%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum%2FBruteforce%20Algorithm)_TOPIC%2F">Algorithms/Mass Spectrometry/Theoretical Spectrum/Bruteforce Algorithm</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>The algorithm starts by calculating the prefix sum of the mass at each position of the <a href="#BM_(peptide)%2Fi">peptide</a>. The prefix sum is calculated by summing all <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses up until that position. For example, the <a href="#BM_(peptide)%2Fi">peptide</a> GASP has the following masses at the following positions...</p>
<table>
<thead>
<tr>
<th>G</th>
<th>A</th>
<th>S</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td>57</td>
<td>71</td>
<td>87</td>
<td>97</td>
</tr>
</tbody>
</table>
<p>As such, the prefix sum at each position is...</p>
<table>
<thead>
<tr>
<th></th>
<th>G</th>
<th>A</th>
<th>S</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mass</td>
<td>57</td>
<td>71</td>
<td>87</td>
<td>97</td>
</tr>
<tr>
<td>Prefix sum of mass</td>
<td>57=57</td>
<td>57+71=128</td>
<td>57+71+87=215</td>
<td>57+71+87+97=312</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code>prefixsum_masses[<span class="hljs-number">0</span>] = mass[<span class="hljs-string">''</span>]     = <span class="hljs-number">0</span>             = <span class="hljs-number">0</span>   <span class="hljs-comment"># Artificially added</span>
prefixsum_masses[<span class="hljs-number">1</span>] = mass[<span class="hljs-string">'G'</span>]    = <span class="hljs-number">0</span>+<span class="hljs-number">57</span>          = <span class="hljs-number">57</span>
prefixsum_masses[<span class="hljs-number">2</span>] = mass[<span class="hljs-string">'GA'</span>]   = <span class="hljs-number">0</span>+<span class="hljs-number">57</span>+<span class="hljs-number">71</span>       = <span class="hljs-number">128</span>
prefixsum_masses[<span class="hljs-number">3</span>] = mass[<span class="hljs-string">'GAS'</span>]  = <span class="hljs-number">0</span>+<span class="hljs-number">57</span>+<span class="hljs-number">71</span>+<span class="hljs-number">87</span>    = <span class="hljs-number">215</span>
prefixsum_masses[<span class="hljs-number">4</span>] = mass[<span class="hljs-string">'GASP'</span>] = <span class="hljs-number">0</span>+<span class="hljs-number">57</span>+<span class="hljs-number">71</span>+<span class="hljs-number">87</span>+<span class="hljs-number">97</span> = <span class="hljs-number">312</span>
</code></pre>
<p>The mass for each <a href="#BM_(subpeptide)%2Fi">subpeptide</a> can be derived from just these prefix sums. For example, ...</p>
<pre class="hljs"><code>mass[<span class="hljs-string">'GASP'</span>] = mass[<span class="hljs-string">'GASP'</span>] - mass[<span class="hljs-string">''</span>]    = prefixsum_masses[<span class="hljs-number">4</span>] - prefixsum_masses[<span class="hljs-number">0</span>]
mass[<span class="hljs-string">'ASP'</span>]  = mass[<span class="hljs-string">'GASP'</span>] - mass[<span class="hljs-string">'G'</span>]   = prefixsum_masses[<span class="hljs-number">4</span>] - prefixsum_masses[<span class="hljs-number">1</span>]
mass[<span class="hljs-string">'AS'</span>]   = mass[<span class="hljs-string">'GAS'</span>]  - mass[<span class="hljs-string">'G'</span>]   = prefixsum_masses[<span class="hljs-number">3</span>] - prefixsum_masses[<span class="hljs-number">1</span>]
mass[<span class="hljs-string">'A'</span>]    = mass[<span class="hljs-string">'GA'</span>]   - mass[<span class="hljs-string">'G'</span>]   = prefixsum_masses[<span class="hljs-number">2</span>] - prefixsum_masses[<span class="hljs-number">1</span>]
mass[<span class="hljs-string">'S'</span>]    = mass[<span class="hljs-string">'GAS'</span>]  - mass[<span class="hljs-string">'GA'</span>]  = prefixsum_masses[<span class="hljs-number">3</span>] - prefixsum_masses[<span class="hljs-number">2</span>]
mass[<span class="hljs-string">'P'</span>]    = mass[<span class="hljs-string">'GASP'</span>] - mass[<span class="hljs-string">'GAS'</span>] = prefixsum_masses[<span class="hljs-number">4</span>] - prefixsum_masses[<span class="hljs-number">3</span>]
<span class="hljs-comment"># etc...</span>
</code></pre>
<p>If the <a href="#BM_(peptide)%2Fi">peptide</a> is a <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a>, some <a href="#BM_(subpeptide)%2Fi">subpeptide</a>s will wrap around. For example, PG is a valid <a href="#BM_(subpeptide)%2Fi">subpeptide</a> if GASP is a <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a>:</p>
<p><img src="svgbob_d514f964b7cded0cda5a87cba46c1b551682073d.svg" alt="Kroki diagram output"></p>
<p>The prefix sum can be used to calculate these wrapping <a href="#BM_(subpeptide)%2Fi">subpeptide</a>s as well. For example...</p>
<pre class="hljs"><code>mass[<span class="hljs-string">'PG'</span>] = mass[<span class="hljs-string">'GASP'</span>] - mass[<span class="hljs-string">'AS'</span>]
           = mass[<span class="hljs-string">'GASP'</span>] - (mass[<span class="hljs-string">'GAS'</span>] - mass[<span class="hljs-string">'G'</span>])    <span class="hljs-comment"># SUBSTITUTE IN mass['AS'] CALC FROM ABOVE</span>
           = prefixsum_masses[<span class="hljs-number">4</span>] - (prefixsum_masses[<span class="hljs-number">3</span>] - prefixsum_masses[<span class="hljs-number">1</span>])
</code></pre>
<p>This algorithm is faster than the bruteforce algorithm, but most use-cases won't notice a performance improvement unless either the...</p>
<ul>
<li><a href="#BM_(peptide)%2Fi">peptide</a> is very long (likely won't happen since <a href="#BM_(peptide)%2Fi">peptide</a>s by definition aren't larger than 50 to 100 <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s)</li>
<li>algorithm runs often.</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">theoretical_spectrum</span>(<span class="hljs-params">
        peptide: List[AA],
        peptide_type: PeptideType,
        mass_table: Dict[AA, float]
</span>) -&gt; List[float]:</span>
    prefixsum_masses = list(accumulate([mass_table[aa] <span class="hljs-keyword">for</span> aa <span class="hljs-keyword">in</span> peptide], initial=<span class="hljs-number">0.0</span>))
    ret = [<span class="hljs-number">0.0</span>]
    <span class="hljs-keyword">for</span> end_idx <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(prefixsum_masses)):
        <span class="hljs-keyword">for</span> start_idx <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, end_idx):
            min_mass = prefixsum_masses[start_idx]
            max_mass = prefixsum_masses[end_idx]
            ret.append(max_mass - min_mass)
            <span class="hljs-keyword">if</span> peptide_type == PeptideType.CYCLIC <span class="hljs-keyword">and</span> start_idx &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> end_idx &lt; len(peptide):
                ret.append(prefixsum_masses[<span class="hljs-number">-1</span>] - (prefixsum_masses[end_idx] - prefixsum_masses[start_idx]))
    ret.sort()
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The theoretical spectrum for the linear peptide NQY is [0.0, 114.0, 128.0, 163.0, 242.0, 291.0, 405.0]</p>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The algorithm above is serial, but it can be made parallel to get even more speed:</p>
<ol>
<li>Parallelized prefix sum (e.g. Hillis-Steele / Blelloch).</li>
<li>Parallelized iteration instead of nested for-loops.</li>
<li>Parallelized sorting (e.g. Parallel merge sort / Parallel brick sort / Bitonic sort).</li>
</ol>
</div>
<a name="H_Spectrum%20Convolution"></a><h3>Spectrum Convolution</h3>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Convolution)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FExperimental%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Experimental Spectrum</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Theoretical Spectrum</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, subtract its masses from each other. The differences are a set of potential <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses for the <a href="#BM_(peptide)%2Fi">peptide</a> that generated that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<p>For example, the following <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is for the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY:</p>
<p>[0.0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 113.9<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 115.1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 136.2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 162.9<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 242.0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 311.1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 346.0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 405.2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</p>
<p>Performing 242.0 - 113.9 results in 128.1, which is very close to the mass for <a href="#BM_(amino%20acid)%2Fi">amino acid</a> Q. The mass for Q was derived even though no <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses are near Q's mass:</p>
<ul>
<li>Mass of N is 114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 2 <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses are near: [113.9, 115.1]</li>
<li>Mass of Q is 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 0 <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses are near: []</li>
<li>Mass of Y is 163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 1 <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass is near: [162.9]</li>
</ul>
<p><strong>WHY</strong>: The closer a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is to an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, the more likely it is that the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> used to generate that <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is related to the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> that produced that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. However, before being able to build a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>, a list of potential <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s need to be inferred from the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. This operation infers a list of potential <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses, which can be mapped to <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s themselves (e.g. 114 maps to N).</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Consider an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> with masses that don't contain any noise. That is, the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> may have faulty masses and may be missing masses, but any correct masses it does have are exact / noise-free. To derive a list of potential <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses for this <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>:</p>
<ol>
<li>Subtract <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses from each other (each mass gets subtracted from every mass).</li>
<li>Filter differences to those between 57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> and 200<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> (generally accepted range for the mass of an <a href="#BM_(amino%20acid)%2Fi">amino acid</a>).</li>
<li>Filter differences to that don't occur at least n times (n is user-defined).</li>
</ol>
<p>The result is a list of potential <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses for the <a href="#BM_(peptide)%2Fi">peptide</a> that produced that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. For example, consider the following <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> for the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY:</p>
<p>[0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 136<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 242<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 311<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 346<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 405<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</p>
<p>The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses...</p>
<ul>
<li>[163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 291<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>] are missing.</li>
<li>[136<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 311<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 346<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>] are faulty.</li>
<li>[114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 242<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 405<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>] are correct and free of noise.</li>
</ul>
<p>Subtract the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>114</th>
<th>136</th>
<th>163</th>
<th>242</th>
<th>311</th>
<th>346</th>
<th>405</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>-114</td>
<td>-136</td>
<td>-163</td>
<td>-242</td>
<td>-311</td>
<td>-346</td>
<td>-405</td>
</tr>
<tr>
<td>114</td>
<td>114</td>
<td>0</td>
<td>-22</td>
<td>-49</td>
<td>-128</td>
<td>-197</td>
<td>-231</td>
<td>-291</td>
</tr>
<tr>
<td>136</td>
<td>136</td>
<td>22</td>
<td>0</td>
<td>-27</td>
<td>-106</td>
<td>-175</td>
<td>-210</td>
<td>-269</td>
</tr>
<tr>
<td>163</td>
<td>163</td>
<td>49</td>
<td>27</td>
<td>0</td>
<td>-79</td>
<td>-148</td>
<td>-183</td>
<td>-242</td>
</tr>
<tr>
<td>242</td>
<td>242</td>
<td>128</td>
<td>106</td>
<td>79</td>
<td>0</td>
<td>-69</td>
<td>-104</td>
<td>-163</td>
</tr>
<tr>
<td>311</td>
<td>311</td>
<td>197</td>
<td>175</td>
<td>148</td>
<td>69</td>
<td>0</td>
<td>-35</td>
<td>-94</td>
</tr>
<tr>
<td>346</td>
<td>346</td>
<td>232</td>
<td>210</td>
<td>183</td>
<td>104</td>
<td>35</td>
<td>0</td>
<td>-59</td>
</tr>
<tr>
<td>405</td>
<td>405</td>
<td>291</td>
<td>269</td>
<td>242</td>
<td>163</td>
<td>94</td>
<td>59</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Then, remove differences that aren't between 57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> and 200<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>114</th>
<th>136</th>
<th>163</th>
<th>242</th>
<th>311</th>
<th>346</th>
<th>405</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>114</td>
<td>114</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>136</td>
<td>136</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>163</td>
<td>163</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>242</td>
<td></td>
<td>128</td>
<td>106</td>
<td>79</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>311</td>
<td></td>
<td>197</td>
<td>175</td>
<td>148</td>
<td>69</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>346</td>
<td></td>
<td></td>
<td></td>
<td>183</td>
<td>104</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>163</td>
<td>94</td>
<td>59</td>
<td></td>
</tr>
</tbody>
</table>
<p>Then, filter out any differences occurring less than than n times. In this case, it makes sense to set n to 1 because almost all of the differences occur only once.</p>
<p>The final result is a list of potential <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses for the <a href="#BM_(peptide)%2Fi">peptide</a> that produced the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>:</p>
<p>[59<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 69<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 79<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 94<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 104<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 106<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 136<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 148<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 175<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 183<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 197<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</p>
<p>Note that the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is for the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY. The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> contained the masses for N (114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>) and Y (163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>), but not Q (128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>). This operation was able to pull out the mass for Q: 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> is in the final list of differences.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spectrum_convolution</span>(<span class="hljs-params">experimental_spectrum: List[float], min_mass=<span class="hljs-number">57.0</span>, max_mass=<span class="hljs-number">200.0</span></span>) -&gt; List[float]:</span>
    <span class="hljs-comment"># it's expected that experimental_spectrum is sorted smallest to largest</span>
    diffs = []
    <span class="hljs-keyword">for</span> row_idx, row_mass <span class="hljs-keyword">in</span> enumerate(experimental_spectrum):
        <span class="hljs-keyword">for</span> col_idx, col_mass <span class="hljs-keyword">in</span> enumerate(experimental_spectrum):
            mass_diff = row_mass - col_mass
            <span class="hljs-keyword">if</span> min_mass &lt;= mass_diff &lt;= max_mass:
                diffs.append(mass_diff)
    diffs.sort()
    <span class="hljs-keyword">return</span> diffs
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The spectrum convolution for [0.0, 114.0, 136.0, 163.0, 242.0, 311.0, 346.0, 405.0] is ...</p>
<ul>
<li>2x163.0</li>
<li>1x59.0</li>
<li>1x69.0</li>
<li>1x79.0</li>
<li>1x94.0</li>
<li>1x104.0</li>
<li>1x106.0</li>
<li>1x114.0</li>
<li>1x128.0</li>
<li>1x136.0</li>
<li>1x148.0</li>
<li>1x175.0</li>
<li>1x183.0</li>
<li>1x197.0</li>
</ul>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The following section isn't from the Pevzner book or any online resources. I came up with it in an effort to solve the final assignment for Chapter 4 (the chapter on <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a> <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>). As such, it might not be entirely correct / there may be better ways to do this.</p>
</div>
<p>The algorithm described above is for <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s that have exact masses (no noise). However, real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s will have noisy masses. Since a real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> has noisy masses, the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses derived from it will also be noisy. For example, consider an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> that has ±1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> noise per mass. A real mass of...</p>
<ul>
<li>242<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> will show up in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> anywhere between 241<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 243<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</li>
<li>114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> will show up in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> anywhere between 113<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 115<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</li>
</ul>
<p>Subtract the opposite extremes from these two ranges: 243<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> - 113<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> = 130<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. That's 2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> away from the real mass difference: 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. As such, the maximum noise per <a href="#BM_(amino%20acid)%2Fi">amino acid</a> mass is 2 times the maximum noise for the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> that it was derived from: ±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> for this example.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spectrum_convolution_noise</span>(<span class="hljs-params">exp_spec_mass_noise: float</span>) -&gt; float:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span> * exp_spec_mass_noise
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given a max experimental spectrum mass noise of ±1.0, the maximum noise per amino acid derived from an experimental spectrum is ±2.0</p>
</div>
<p></p>
<p>Extending the algorithm to handle noisy <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses requires one extra step: group together differences that are within some tolerance of each other, where this tolerance is the maximum <a href="#BM_(amino%20acid)%2Fi">amino acid</a> mass noise calculation described above. For example, consider the following <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> for <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY that has up to ±1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> noise per mass:</p>
<p>[0.0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 113.9<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 115.1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 136.2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 162.9<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 242.0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 311.1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 346.0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 405.2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]</p>
<p>Just as before, subtract the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses and differences that aren't between 57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> and 200<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>:</p>
<table>
<thead>
<tr>
<th></th>
<th>0.0</th>
<th>113.9</th>
<th>115.1</th>
<th>136.2</th>
<th>162.9</th>
<th>242.0</th>
<th>311.1</th>
<th>346.0</th>
<th>405.2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>113.9</td>
<td>113.9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>115.1</td>
<td>115.1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>136.2</td>
<td>136.2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>162.9</td>
<td>162.9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>242.0</td>
<td></td>
<td>128.1</td>
<td>126.9</td>
<td>105.8</td>
<td>79.1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>311.1</td>
<td></td>
<td>197.2</td>
<td>196.0</td>
<td>174.9</td>
<td>142.9</td>
<td>69.1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>346.0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>183.1</td>
<td>104.0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>405.2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>163.0</td>
<td>94.1</td>
<td>59.2</td>
<td></td>
</tr>
</tbody>
</table>
<p>Then, group differences that are within ±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> of each other (2 times the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>'s maximum mass noise):</p>
<ul>
<li>[104.0, 105.8]</li>
<li>[113.9, 115.1]</li>
<li>[128.1, 126.9]</li>
<li>[162.9, 163.0]</li>
<li>[196.0, 197.2]</li>
<li>[59.2]</li>
<li>[69.1]</li>
<li>[79.1]</li>
<li>[94.1]</li>
<li>[136.2]</li>
<li>[142.9]</li>
<li>[174.9]</li>
</ul>
<p>Then, filter out any groups that have less than n occurrences. In this case, filtering to n=2 occurrences reveals that all <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses are captured for NQY:</p>
<ul>
<li>[104.0, 105.8] (junk)</li>
<li>[113.9, 115.1] (mass of N is 114)</li>
<li>[128.1, 126.9] (mass of Q is 128)</li>
<li>[162.9, 163.0] (mass of Y is 163)</li>
<li>[196.0, 197.2] (junk)</li>
</ul>
<p>Note that the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is for the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY. The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> contained the masses near N (113.Da and 115.1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>) and Y (162.9<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>), but not Q. This operation was able to pull out masses near Q: [128.1, 126.9] is in the final list of differences.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group_masses_by_tolerance</span>(<span class="hljs-params">masses: List[float], tolerance: float</span>) -&gt; typing.Counter[float]:</span>
    masses = sorted(masses)
    length = len(masses)
    ret = Counter()
    <span class="hljs-keyword">for</span> i, m1 <span class="hljs-keyword">in</span> enumerate(masses):
        <span class="hljs-keyword">if</span> m1 <span class="hljs-keyword">in</span> ret:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-comment"># search backwards</span>
        left_limit = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):
            m2 = masses[j]
            <span class="hljs-keyword">if</span> abs(m2 - m1) &gt; tolerance:
                <span class="hljs-keyword">break</span>
            left_limit = j
        <span class="hljs-comment"># search forwards</span>
        right_limit = length - <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, length):
            m2 = masses[j]
            <span class="hljs-keyword">if</span> abs(m2 - m1) &gt; tolerance:
                <span class="hljs-keyword">break</span>
            right_limit = j
        count = right_limit - left_limit + <span class="hljs-number">1</span>
        ret[m1] = count
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spectrum_convolution</span>(<span class="hljs-params">
        exp_spec: List[float],  <span class="hljs-comment"># must be sorted smallest to largest</span>
        tolerance: float,
        min_mass: float = <span class="hljs-number">57.0</span>,
        max_mass: float = <span class="hljs-number">200.0</span>,
        round_digits: int = <span class="hljs-number">-1</span>,  <span class="hljs-comment"># if set, rounds to this many digits past decimal point</span>
        implied_zero: bool = False  <span class="hljs-comment"># if set, run as if 0.0 were added to exp_spec</span>
</span>) -&gt; typing.Counter[float]:</span>
    min_mass -= tolerance
    max_mass += tolerance
    diffs = []
    <span class="hljs-keyword">for</span> row_idx, row_mass <span class="hljs-keyword">in</span> enumerate(exp_spec):
        <span class="hljs-keyword">for</span> col_idx, col_mass <span class="hljs-keyword">in</span> enumerate(exp_spec):
            mass_diff = row_mass - col_mass
            <span class="hljs-keyword">if</span> round_digits != <span class="hljs-number">-1</span>:
                mass_diff = round(mass_diff, round_digits)
            <span class="hljs-keyword">if</span> min_mass &lt;= mass_diff &lt;= max_mass:
                diffs.append(mass_diff)
    <span class="hljs-keyword">if</span> implied_zero:
        <span class="hljs-keyword">for</span> mass <span class="hljs-keyword">in</span> exp_spec:
            <span class="hljs-keyword">if</span> min_mass &lt;= mass &lt;= max_mass:
                diffs.append(mass)
            <span class="hljs-keyword">if</span> mass &gt; max_mass:
                <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> group_masses_by_tolerance(diffs, tolerance)
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The spectrum convolution for [113.9, 115.1, 136.2, 162.9, 242.0, 311.1, 346.0, 405.2] is ...</p>
<ul>
<li>2x104.0</li>
<li>2x105.8</li>
<li>2x113.9</li>
<li>2x115.1</li>
<li>2x126.9</li>
<li>2x128.1</li>
<li>2x162.9</li>
<li>2x163.2</li>
<li>2x196.0</li>
<li>2x197.2</li>
<li>1x59.2</li>
<li>1x69.1</li>
<li>1x79.1</li>
<li>1x94.1</li>
<li>1x136.2</li>
<li>1x148.2</li>
<li>1x174.9</li>
<li>1x183.1</li>
</ul>
</div>
<p></p>
<a name="H_Spectrum%20Score"></a><h3>Spectrum Score</h3>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Score)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FExperimental%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Experimental Spectrum</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Theoretical Spectrum</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Convolution)_TOPIC%2F">Algorithms/Mass Spectrometry/Spectrum Convolution</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> and a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>, score them against each other by counting how many masses match between them.</p>
<p><strong>WHY</strong>: The more matching masses between a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> and an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, the more likely it is that the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> used to generate that <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is related to the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> that produced that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. This is the basis for how <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a>s are <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a>: an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is produced by a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>, then that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is compared against a set of <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>s.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Consider an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> with masses that don't contain any noise. That is, the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> may have faulty masses and may be missing masses, but any correct masses it does have are exact / noise-free. Scoring this <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> against a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is simple: count the number of matching masses.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_spectrums</span>(<span class="hljs-params">
        s1: List[float],  <span class="hljs-comment"># must be sorted ascending</span>
        s2: List[float]   <span class="hljs-comment"># must be sorted ascending</span>
</span>) -&gt; int:</span>
    idx_s1 = <span class="hljs-number">0</span>
    idx_s2 = <span class="hljs-number">0</span>
    score = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> idx_s1 &lt; len(s1) <span class="hljs-keyword">and</span> idx_s2 &lt; len(s2):
        s1_mass = s1[idx_s1]
        s2_mass = s2[idx_s2]
        <span class="hljs-keyword">if</span> s1_mass &lt; s2_mass:
            idx_s1 += <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> s1_mass &gt; s2_mass:
            idx_s2 += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            idx_s1 += <span class="hljs-number">1</span>
            idx_s2 += <span class="hljs-number">1</span>
            score += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> score
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The spectrum score for...</p>
<p>[0.0, 57.0, 71.0, 128.0, 199.0, 256.0]</p>
<p>... vs ...</p>
<p>[0.0, 57.0, 71.0, 128.0, 128.0, 199.0, 256.0]</p>
<p>... is 6</p>
</div>
<p></p>
<p>Note that a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> may have multiple masses with the same value but an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> won't. For example, the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> for GAK is ...</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>G</th>
<th>A</th>
<th>K</th>
<th>GA</th>
<th>AK</th>
<th>GAK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mass</td>
<td>0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>57D a</td>
<td>71<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>199<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>256<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
</tr>
</tbody>
</table>
<p>K and GA both have a mass of 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. Since, <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s don't distinguish between where masses come from, an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> for this <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> will only have 1 entry for 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The following section isn't from the Pevzner book or any online resources. I came up with it in an effort to solve the final assignment for Chapter 4 (the chapter on <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a> <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>). As such, it might not be entirely correct / there may be better ways to do this.</p>
</div>
<p>The algorithm described above is for <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s that have exact masses (no noise). However, real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s have noisy masses. That noise needs to be accounted for when identifying matches.</p>
<p>Recall that each <a href="#BM_(amino%20acid)%2Fi">amino acid</a> mass captured by a <a href="#BM_(spectrum%20convolution)%2Fi">spectrum convolution</a> has up to some amount of noise. This is what defines the tolerance for a matching mass between the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> and the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>. Specifically, the maximum amount of noise for a captured <a href="#BM_(amino%20acid)%2Fi">amino acid</a> mass is multiplied by the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> count of the <a href="#BM_(subpeptide)%2Fi">subpeptide</a> to determine the tolerance.</p>
<p>For example, imagine a case where it's determined that the noise tolerance for each captured <a href="#BM_(amino%20acid)%2Fi">amino acid</a> mass is ±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. Given the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> for <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY, the tolerances would be as follows:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>N</th>
<th>Q</th>
<th>Y</th>
<th>NQ</th>
<th>QY</th>
<th>NQY</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mass</td>
<td>0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>163<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>242<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>291<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>405<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
</tr>
<tr>
<td>Tolerance</td>
<td>0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>±4<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>±4<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>±6<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">theoretical_spectrum_tolerances</span>(<span class="hljs-params">
        peptide_len: int,
        peptide_type: PeptideType,
        amino_acid_mass_tolerance: float
</span>) -&gt; List[float]:</span>
    ret = [<span class="hljs-number">0.0</span>]
    <span class="hljs-keyword">if</span> peptide_type == PeptideType.LINEAR:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(peptide_len):
            tolerance = (i + <span class="hljs-number">1</span>) * amino_acid_mass_tolerance
            ret += [tolerance] * (peptide_len - i)
    <span class="hljs-keyword">elif</span> peptide_type == PeptideType.CYCLIC:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(peptide_len - <span class="hljs-number">1</span>):
            tolerance = (i + <span class="hljs-number">1</span>) * amino_acid_mass_tolerance
            ret += [tolerance] * peptide_len
        <span class="hljs-keyword">if</span> peptide_len != <span class="hljs-number">0</span>:
            ret.append(peptide_len * amino_acid_mass_tolerance)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> ValueError()
    <span class="hljs-keyword">return</span> ret
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The theoretical spectrum for linear peptide NQY with amino acid mass tolerance of 2.0...</p>
<p>[0.0, 2.0, 2.0, 2.0, 4.0, 4.0, 6.0]</p>
</div>
<p></p>
<p>Given a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> with tolerances, each <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> mass is checked to see if it fits within a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> mass tolerance. If it fits, it's considered a match. The score includes both the number of matches and how closely each match was to the ideal <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> mass.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan_left</span>(<span class="hljs-params">
        exp_spec: List[float],
        exp_spec_lo_idx: int,
        exp_spec_start_idx: int,
        theo_mid_mass: float,
        theo_min_mass: float
</span>) -&gt; Optional[int]:</span>
    found_dist = <span class="hljs-literal">None</span>
    found_idx = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> range(exp_spec_start_idx, exp_spec_lo_idx - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>):
        exp_mass = exp_spec[idx]
        <span class="hljs-keyword">if</span> exp_mass &lt; theo_min_mass:
            <span class="hljs-keyword">break</span>
        dist_to_theo_mid_mass = abs(exp_mass - theo_mid_mass)
        <span class="hljs-keyword">if</span> found_dist <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> dist_to_theo_mid_mass &lt; found_dist:
            found_idx = idx
            found_dist = dist_to_theo_mid_mass
    <span class="hljs-keyword">return</span> found_idx


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan_right</span>(<span class="hljs-params">
        exp_spec: List[float],
        exp_spec_hi_idx: int,
        exp_spec_start_idx: int,
        theo_mid_mass: float,
        theo_max_mass: float
</span>) -&gt; Optional[int]:</span>
    found_dist = <span class="hljs-literal">None</span>
    found_idx = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> range(exp_spec_start_idx, exp_spec_hi_idx):
        exp_mass = exp_spec[idx]
        <span class="hljs-keyword">if</span> exp_mass &gt; theo_max_mass:
            <span class="hljs-keyword">break</span>
        dist_to_theo_mid_mass = abs(exp_mass - theo_mid_mass)
        <span class="hljs-keyword">if</span> found_dist <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> dist_to_theo_mid_mass &lt; found_dist:
            found_idx = idx
            found_dist = dist_to_theo_mid_mass
    <span class="hljs-keyword">return</span> found_idx


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_closest_within_tolerance</span>(<span class="hljs-params">
        exp_spec: List[float],
        exp_spec_lo_idx: int,
        exp_spec_hi_idx: int,
        theo_exact_mass: float,
        theo_min_mass: float,
        theo_max_mass: float
</span>) -&gt; Optional[int]:</span>
    <span class="hljs-comment"># Binary search exp_spec for the where theo_mid_mass would be inserted (left-most index chosen if already there).</span>
    start_idx = bisect_left(exp_spec, theo_exact_mass, lo=exp_spec_lo_idx, hi=exp_spec_hi_idx)
    <span class="hljs-keyword">if</span> start_idx == exp_spec_hi_idx:
        start_idx -= <span class="hljs-number">1</span>
    <span class="hljs-comment"># From start_idx - 1, walk left to find the closest possible value to theo_mid_mass</span>
    left_idx = scan_left(exp_spec, exp_spec_lo_idx, start_idx - <span class="hljs-number">1</span>, theo_exact_mass, theo_min_mass)
    <span class="hljs-comment"># From start_idx, walk right to find the closest possible value to theo_mid_mass</span>
    right_idx = scan_right(exp_spec, exp_spec_hi_idx, start_idx, theo_exact_mass, theo_max_mass)
    <span class="hljs-keyword">if</span> left_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> right_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># If nothing found, return None</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> left_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># If found something while walking left but not while walking right, return left</span>
        <span class="hljs-keyword">return</span> right_idx
    <span class="hljs-keyword">if</span> right_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># If found something while walking right but not while walking left, return right</span>
        <span class="hljs-keyword">return</span> left_idx
    <span class="hljs-comment"># Otherwise, compare left and right to see which is close to theo_mid_mass and return that</span>
    left_exp_mass = exp_spec[left_idx]
    left_dist_to_theo_mid_mass = abs(left_exp_mass - theo_exact_mass)
    right_exp_mass = exp_spec[left_idx]
    right_dist_to_theo_mid_mass = abs(right_exp_mass - theo_exact_mass)
    <span class="hljs-keyword">if</span> left_dist_to_theo_mid_mass &lt; right_dist_to_theo_mid_mass:
        <span class="hljs-keyword">return</span> left_idx
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> right_idx


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_spectrums</span>(<span class="hljs-params">
        exp_spec: List[float],  <span class="hljs-comment"># must be sorted asc</span>
        theo_spec_with_tolerances: List[Tuple[float, float, float]]  <span class="hljs-comment"># must be sorted asc, items are (expected,min,max)</span>
</span>) -&gt; Tuple[int, float, float]:</span>
    dist_score = <span class="hljs-number">0.0</span>
    within_score = <span class="hljs-number">0</span>
    exp_spec_lo_idx = <span class="hljs-number">0</span>
    exp_spec_hi_idx = len(exp_spec)
    <span class="hljs-keyword">for</span> theo_mass <span class="hljs-keyword">in</span> theo_spec_with_tolerances:
        <span class="hljs-comment"># Find closest exp_spec mass for theo_mass</span>
        theo_exact_mass, theo_min_mass, theo_max_mass = theo_mass
        exp_idx = find_closest_within_tolerance(
            exp_spec,
            exp_spec_lo_idx,
            exp_spec_hi_idx,
            theo_exact_mass,
            theo_min_mass,
            theo_max_mass
        )
        <span class="hljs-keyword">if</span> exp_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-comment"># Calculate how far the found mass is from the ideal mass (theo_exact_mass) -- a perfect match will add 1.0 to</span>
        <span class="hljs-comment"># score, the farther out it is away the less gets added to score (min added will be 0.5).</span>
        exp_mass = exp_spec[exp_idx]
        dist = abs(exp_mass - theo_exact_mass)
        max_dist = theo_max_mass - theo_min_mass
        <span class="hljs-keyword">if</span> max_dist &gt; <span class="hljs-number">0.0</span>:
            closeness = <span class="hljs-number">1.0</span> - (dist / max_dist)
        <span class="hljs-keyword">else</span>:
            closeness = <span class="hljs-number">1.0</span>
        dist_score += closeness
        <span class="hljs-comment"># Increment within_score for each match. The above block increases dist_score as the found mass gets closer to</span>
        <span class="hljs-comment"># theo_exact_mass. There may be a case where a peptide with 6 of 10 AAs matches exactly (6 * 1.0) while another</span>
        <span class="hljs-comment"># peptide with 10 of 10 AAs matching very loosely (10 * 0.5) -- the first peptide will incorrectly win out if</span>
        <span class="hljs-comment"># only dist_score were used.</span>
        within_score += <span class="hljs-number">1</span>
        <span class="hljs-comment"># Move up the lower bound for what to consider in exp_spec such that it it's after the exp_spec mass found</span>
        <span class="hljs-comment"># in this cycle. That is, the next cycle won't consider anything lower than the mass that was found here. This</span>
        <span class="hljs-comment"># is done because theo_spec may contain multiple copies of the same mass, but a real experimental spectrum won't</span>
        <span class="hljs-comment"># do that (e.g. a peptide containing 57 twice will have two entries for 57 in its theoretical spectrum, but a</span>
        <span class="hljs-comment"># real experimental spectrum for that same peptide will only contain 57 -- anything with mass of 57 will be</span>
        <span class="hljs-comment"># collected into the same bin).</span>
        exp_spec_lo_idx = exp_idx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> exp_spec_lo_idx == exp_spec_hi_idx:
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> within_score, dist_score, <span class="hljs-number">0.0</span> <span class="hljs-keyword">if</span> within_score == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> dist_score / within_score
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The spectrum score for...</p>
<p>[0.0, 56.1, 71.9, 126.8, 200.6, 250.9]</p>
<p>... vs ...</p>
<p>[0.0, 57.0, 71.0, 128.0, 128.0, 199.0, 256.0]</p>
<p>... with 2.0 amino acid tolerance is...</p>
<p>(6, 4.624999999999999, 0.7708333333333331)</p>
</div>
<p></p>
<a name="H_Spectrum%20Sequence"></a><h3>Spectrum Sequence</h3>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FExperimental%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Experimental Spectrum</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FTheoretical%20Spectrum)_TOPIC%2F">Algorithms/Mass Spectrometry/Theoretical Spectrum</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Convolution)_TOPIC%2F">Algorithms/Mass Spectrometry/Spectrum Convolution</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Score)_TOPIC%2F">Algorithms/Mass Spectrometry/Spectrum Score</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> and a set of <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses, generate <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>s and score them against the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> in an effort to infer the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> of the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<p><strong>WHY</strong>: The more matching masses between a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> and an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, the more likely it is that the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> used to generate that <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> is related to the <a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> that produced that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<a name="H3_Bruteforce%20Algorithm"></a><h4>Bruteforce Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence%2FBruteforce%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<p><strong>ALGORITHM</strong>:</p>
<p>Imagine if <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s were perfect just like <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>s: no missing masses, no faulty masses, no noise, and preserved repeat masses. To bruteforce the <a href="#BM_(peptide)%2Fi">peptide</a> that produced such an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, generate candidate <a href="#BM_(peptide)%2Fi">peptide</a>s by branching out <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s at each position and compare each candidate <a href="#BM_(peptide)%2Fi">peptide</a>'s <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> to the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. If the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> matches the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, it's reasonable to assume that <a href="#BM_(peptide)%2Fi">peptide</a> is the same as the <a href="#BM_(peptide)%2Fi">peptide</a> that generated the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<p>The algorithm stops branching out once the mass of the candidate <a href="#BM_(peptide)%2Fi">peptide</a> exceeds the final mass in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. For a perfect <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, the final mass is always the mass of the <a href="#BM_(peptide)%2Fi">peptide</a> that produced it. For example, for the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> GAK ...</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>G</th>
<th>A</th>
<th>K</th>
<th>GA</th>
<th>AK</th>
<th>GAK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mass</td>
<td>0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>71<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>199<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>256<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence_peptide</span>(<span class="hljs-params">
        exp_spec: List[float],  <span class="hljs-comment"># must be sorted asc</span>
        peptide_type: PeptideType,
        aa_mass_table: Dict[AA, float]
</span>) -&gt; List[List[AA]]:</span>
    peptide_mass = exp_spec[<span class="hljs-number">-1</span>]
    candidate_peptides = [[]]
    final_peptides = []
    <span class="hljs-keyword">while</span> len(candidate_peptides) &gt; <span class="hljs-number">0</span>:
        new_candidate_peptides = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> candidate_peptides:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> aa_mass_table.keys():
                new_p = p[:] + [m]
                new_p_mass = sum([aa_mass_table[aa] <span class="hljs-keyword">for</span> aa <span class="hljs-keyword">in</span> new_p])
                <span class="hljs-keyword">if</span> new_p_mass == peptide_mass <span class="hljs-keyword">and</span> theoretical_spectrum(new_p, peptide_type, aa_mass_table) == exp_spec:
                    final_peptides.append(new_p)
                <span class="hljs-keyword">elif</span> new_p_mass &lt; peptide_mass:
                    new_candidate_peptides.append(new_p)
        candidate_peptides = new_candidate_peptides
    <span class="hljs-keyword">return</span> final_peptides
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The linear peptides matching the experimental spectrum [0.0, 57.0, 71.0, 128.0, 128.0, 199.0, 256.0] are...</p>
<ul>
<li>GAK</li>
<li>GAQ</li>
<li>KAG</li>
<li>QAG</li>
</ul>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The following section isn't from the Pevzner book or any online resources. I came up with it in an effort to solve the final assignment for Chapter 4 (the chapter on <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a> <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>). As such, it might not be entirely correct / there may be better ways to do this.</p>
</div>
<p>Even though real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s aren't perfect, the high-level algorithm remains the same: Create candidate <a href="#BM_(peptide)%2Fi">peptide</a>s by branching out <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s and capture the best scoring ones until the mass goes too high. However, various low-level aspects of the algorithm need to be modified to handle the problems with real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s.</p>
<p>For starters, since there are no preset <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s to build candidate <a href="#BM_(peptide)%2Fi">peptide</a>s with, <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses are captured using <a href="#BM_(spectrum%20convolution)%2Fi">spectrum convolution</a> and used directly. For example, instead of representing a <a href="#BM_(peptide)%2Fi">peptide</a> as GAK, it's represented as 57-71-128.</p>
<table>
<thead>
<tr>
<th>G</th>
<th>A</th>
<th>K</th>
</tr>
</thead>
<tbody>
<tr>
<td>57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>71<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
<td>128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a></td>
</tr>
</tbody>
</table>
<p>Next, the last mass in a real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> isn't guaranteed to be the mass of the <a href="#BM_(peptide)%2Fi">peptide</a> that produced it. Since real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s have faulty masses and may be missing masses, it's possible that either the <a href="#BM_(peptide)%2Fi">peptide</a>'s mass wasn't captured at all or was captured but at an index that isn't the last element.</p>
<p>If the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>'s <a href="#BM_(peptide)%2Fi">peptide</a> mass was captured and found, it'll have noise. For example, imagine an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> for the <a href="#BM_(peptide)%2Fi">peptide</a> 57-57 with ±1<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> noise. The exact mass of the <a href="#BM_(peptide)%2Fi">peptide</a> 57-57 is 114<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, but if that mass gets placed into the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> it will show up as anywhere between 113<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 115<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>.</p>
<p>Given that same <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, running a <a href="#BM_(spectrum%20convolution)%2Fi">spectrum convolution</a> to derive the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses ends up giving back <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses with ±2<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> noise. For example, the mass 57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> may be derived as anywhere between 55<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> to 59<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. Assuming that you're building the <a href="#BM_(peptide)%2Fi">peptide</a> 57-57 with the low end of that range (55<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>), its mass will be 55<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> + 55<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> = 110<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>. Compared against the high end of the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>'s <a href="#BM_(peptide)%2Fi">peptide</a> mass (115<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>), it's 5<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> away.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">experimental_spectrum_peptide_mass_noise</span>(<span class="hljs-params">exp_spec_mass_noise: float, peptide_len: int</span>) -&gt; float:</span>
    aa_mass_noise = spectrum_convolution_noise(exp_spec_mass_noise)
    <span class="hljs-keyword">return</span> aa_mass_noise * peptide_len + exp_spec_mass_noise
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>Given an experimental spectrum mass noise of ±1.0 and expected peptide length of 2, the maximum noise for an experimental spectrum's peptide mass is ±5.0</p>
</div>
<p></p>
<p>Finally, given that real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s contain faulty masses and may be missing masses, more often than not the <a href="#BM_(peptide)%2Fi">peptide</a>s that score the best aren't the best candidates. <a href="#BM_(theoretical%20spectrum)%2Fi">Theoretical spectrum</a> masses that are ...</p>
<ul>
<li>incorrect but match faulty <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses</li>
<li>correct but are missing in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a></li>
</ul>
<p>... may push poor <a href="#BM_(peptide)%2Fi">peptide</a> candidates forward. As such, it makes sense to keep a backlog of the last m scoring <a href="#BM_(peptide)%2Fi">peptide</a>s. Any of these backlog <a href="#BM_(peptide)%2Fi">peptide</a>s may be the correct <a href="#BM_(peptide)%2Fi">peptide</a> for the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SequenceTester</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">
            self,
            exp_spec: List[float],           <span class="hljs-comment"># must be sorted asc</span>
            aa_mass_table: Dict[AA, float],  <span class="hljs-comment"># amino acid mass table</span>
            aa_mass_tolerance: float,        <span class="hljs-comment"># amino acid mass tolerance</span>
            peptide_min_mass: float,         <span class="hljs-comment"># min mass that the peptide could be</span>
            peptide_max_mass: float,         <span class="hljs-comment"># max mass that the peptide could be</span>
            peptide_type: PeptideType,       <span class="hljs-comment"># linear or cyclic</span>
            score_backlog: int = <span class="hljs-number">0</span>           <span class="hljs-comment"># keep this many previous scores</span>
    </span>):</span>
        self.exp_spec = exp_spec
        self.aa_mass_table = aa_mass_table
        self.aa_mass_tolerance = aa_mass_tolerance
        self.peptide_min_mass = peptide_min_mass
        self.peptide_max_mass = peptide_max_mass
        self.peptide_type = peptide_type
        self.score_backlog = score_backlog
        self.leader_peptides_top_score = <span class="hljs-number">0</span>
        self.leader_peptides = {<span class="hljs-number">0</span>: []}

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_theroetical_spectrum_with_tolerances</span>(<span class="hljs-params">
            peptide: List[AA],
            peptide_type: PeptideType,
            aa_mass_table: Dict[AA, float],
            aa_mass_tolerance: float
    </span>) -&gt; List[Tuple[float, float, float]]:</span>
        theo_spec_raw = theoretical_spectrum(peptide, peptide_type, aa_mass_table)
        theo_spec_tols = theoretical_spectrum_tolerances(len(peptide), peptide_type, aa_mass_tolerance)
        theo_spec = [(m, m - t, m + t) <span class="hljs-keyword">for</span> m, t <span class="hljs-keyword">in</span> zip(theo_spec_raw, theo_spec_tols)]
        <span class="hljs-keyword">return</span> theo_spec

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">
            self,
            peptide: List[AA],
            theo_spec: Optional[List[Tuple[float, float, float]]] = None
    </span>) -&gt; TestResult:</span>
        <span class="hljs-keyword">if</span> theo_spec <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            theo_spec = SequenceTester.generate_theroetical_spectrum_with_tolerances(
                peptide,
                self.peptide_type,
                self.aa_mass_table,
                self.aa_mass_tolerance
            )
        <span class="hljs-comment"># Don't add if mass out of range</span>
        _, tp_min_mass, tp_max_mass = theo_spec[<span class="hljs-number">-1</span>]  <span class="hljs-comment"># last element of theo spec is the mass of the theo spec peptide</span>
        <span class="hljs-keyword">if</span> tp_min_mass &lt; self.peptide_min_mass:
            <span class="hljs-keyword">return</span> TestResult.MASS_TOO_SMALL
        <span class="hljs-keyword">elif</span> tp_max_mass &gt; self.peptide_max_mass:
            <span class="hljs-keyword">return</span> TestResult.MASS_TOO_LARGE
        <span class="hljs-comment"># Don't add if the score is lower than the previous n best scores</span>
        peptide_score = score_spectrums(self.exp_spec, theo_spec)[<span class="hljs-number">0</span>]
        min_acceptable_score = self.leader_peptides_top_score - self.score_backlog
        <span class="hljs-keyword">if</span> peptide_score &lt; min_acceptable_score:
            <span class="hljs-keyword">return</span> TestResult.SCORE_TOO_LOW
        <span class="hljs-comment"># Add, but also remove any previous test peptides that are no longer within the acceptable score threshold</span>
        leaders = self.leader_peptides.setdefault(peptide_score, [])
        leaders.append(peptide)
        <span class="hljs-keyword">if</span> peptide_score &gt; self.leader_peptides_top_score:
            self.leader_peptides_top_score = peptide_score
            <span class="hljs-keyword">if</span> len(self.leader_peptides) &gt;= self.score_backlog:
                smallest_leader_score = min(self.leader_peptides.keys())
                self.leader_peptides.pop(smallest_leader_score)
        <span class="hljs-keyword">return</span> TestResult.ADDED
</code></pre>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence_peptide</span>(<span class="hljs-params">
        exp_spec: List[float],                               <span class="hljs-comment"># must be sorted asc</span>
        aa_mass_table: Dict[AA, float],                      <span class="hljs-comment"># amino acid mass table</span>
        aa_mass_tolerance: float,                            <span class="hljs-comment"># amino acid mass tolerance</span>
        peptide_mass_candidates: List[Tuple[float, float]],  <span class="hljs-comment"># mass range candidates for mass of peptide</span>
        peptide_type: PeptideType,                           <span class="hljs-comment"># linear or cyclic</span>
        score_backlog: int                                   <span class="hljs-comment"># backlog of top scores</span>
</span>) -&gt; SequenceTesterSet:</span>
    tester_set = SequenceTesterSet(
        exp_spec,
        aa_mass_table,
        aa_mass_tolerance,
        peptide_mass_candidates,
        peptide_type,
        score_backlog
    )
    candidates = [[]]
    <span class="hljs-keyword">while</span> len(candidates) &gt; <span class="hljs-number">0</span>:
        new_candidate_peptides = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> candidates:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> aa_mass_table.keys():
                new_p = p[:]
                new_p.append(m)
                res = set(tester_set.test(new_p))
                <span class="hljs-keyword">if</span> res != {TestResult.MASS_TOO_LARGE}:
                    new_candidate_peptides.append(new_p)
        candidates = new_candidate_peptides
    <span class="hljs-keyword">return</span> tester_set
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> in the example below is for the <a href="#BM_(peptide)%2Fi">peptide</a> 114-128-163, which has the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> [0, 114, 128, 163, 242, 291, 405].</p>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Given the ...</p>
<ul>
<li>experimental spectrum: [0.0, 112.5, 127.1, 242.9, 290.0, 404.0]</li>
<li>experimental spectrum mass noise: ±1.0</li>
<li>assumed peptide type: linear</li>
<li>assumed peptide length: 3</li>
<li>assumed peptide mass: any of the last 1 experimental spectrum masses</li>
<li>score backlog: 0</li>
</ul>
<p>Captured mino acid masses are (rounded to 1): [112.5, 114.0, 115.8, 127.1, 130.4, 161.1, 162.9, 177.5]</p>
<p>For peptides between 397.0 and 411.0...</p>
<ul>
<li>Score 6: 114.0-127.1-162.9</li>
<li>Score 6: 162.9-127.1-114.0</li>
</ul>
</div>
<p></p>
<a name="H_Branch-and-bound%20Algorithm"></a><h4>Branch-and-bound Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence%2FBranch-and-bound%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence%2FBruteforce%20Algorithm)_TOPIC%2F">Algorithms/Mass Spectrometry/Spectrum Sequence/Bruteforce Algorithm</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm extends the bruteforce algorithm into a more efficient <a href="#BM_(branch-and-bound%20algorithm%7Cbranch%20and%20bound%20algorithm)%2Fi">branch-and-bound algorithm</a> by adding one extra step: After each branch, any candidates <a href="#BM_(peptide)%2Fi">peptide</a>s deemed to be untenable are discarded. In this case, untenable means that there's no chance / little chance of the <a href="#BM_(peptide)%2Fi">peptide</a> branching out to a correct solution.</p>
<p>Imagine if <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s were perfect just like <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>s: no missing masses, no faulty masses, no noise, and preserved repeat masses. For such an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, an untenable candidate <a href="#BM_(peptide)%2Fi">peptide</a> has a <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> with at least one mass that don't exist in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. For example, the <a href="#BM_(peptide)%2Fi">peptide</a> 57-71-128 has the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> [0<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 57<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 71<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 128<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 199<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>, 256<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a>]. If 71<a href="#BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi">Da</a> were missing from the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>, that <a href="#BM_(peptide)%2Fi">peptide</a> would be untenable (won't move forward).</p>
<p>When testing if a candidate <a href="#BM_(peptide)%2Fi">peptide</a> should move forward, the candidate <a href="#BM_(peptide)%2Fi">peptide</a> be treated as a <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> even if the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is for a <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a>. For example, testing the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> for <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a> NQYQ against the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> for candidate <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a> NQY...</p>
<table>
<thead>
<tr>
<th><a href="#BM_(peptide)%2Fi">Peptide</a></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
</tr>
</thead>
<tbody>
<tr>
<td>NQYQ</td>
<td>0</td>
<td>114</td>
<td>128</td>
<td>128</td>
<td>163</td>
<td>242</td>
<td>242</td>
<td></td>
<td>291</td>
<td>291</td>
<td>370</td>
<td>405</td>
<td>405</td>
<td>419</td>
<td>533</td>
</tr>
<tr>
<td>NQY</td>
<td>0</td>
<td>114</td>
<td>128</td>
<td></td>
<td>163</td>
<td>242</td>
<td></td>
<td>277</td>
<td>291</td>
<td></td>
<td></td>
<td>405</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> contains 277, but the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> doesn't. That means NQY won't branch out any further even though it should. As such, even if the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is for a <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a>, treat candidate <a href="#BM_(peptide)%2Fi">peptide</a>s as if they're linear segments of a <a href="#BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi">cyclic peptide</a> (essentially the same as <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a>s). If the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> for candidate <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY were used...</p>
<table>
<thead>
<tr>
<th><a href="#BM_(peptide)%2Fi">Peptide</a></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
</tr>
</thead>
<tbody>
<tr>
<td>NQYQ</td>
<td>0</td>
<td>114</td>
<td>128</td>
<td>128</td>
<td>163</td>
<td>242</td>
<td>242</td>
<td>291</td>
<td>291</td>
<td>370</td>
<td>405</td>
<td>405</td>
<td>419</td>
<td>533</td>
</tr>
<tr>
<td>NQY</td>
<td>0</td>
<td>114</td>
<td>128</td>
<td></td>
<td>163</td>
<td>242</td>
<td></td>
<td>291</td>
<td></td>
<td></td>
<td>405</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>All <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> masses are in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. As such, the candidate NQY would move forward.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence_peptide</span>(<span class="hljs-params">
        exp_spec: List[float],  <span class="hljs-comment"># must be sorted asc</span>
        peptide_type: PeptideType,
        aa_mass_table: Dict[AA, float]
</span>) -&gt; List[List[AA]]:</span>
    peptide_mass = exp_spec[<span class="hljs-number">-1</span>]
    candidate_peptides = [[]]
    final_peptides = []
    <span class="hljs-keyword">while</span> len(candidate_peptides) &gt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># Branch candidates</span>
        new_candidate_peptides = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> candidate_peptides:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> aa_mass_table:
                new_p = p[:] + [m]
                new_candidate_peptides.append(new_p)
        candidate_peptides = new_candidate_peptides
        <span class="hljs-comment"># Test candidates to see if they match exp_spec or if they should keep being branched</span>
        removal_idxes = set()
        <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(candidate_peptides):
            p_mass = sum([aa_mass_table[aa] <span class="hljs-keyword">for</span> aa <span class="hljs-keyword">in</span> p])
            <span class="hljs-keyword">if</span> p_mass == peptide_mass:
                theo_spec = theoretical_spectrum(p, peptide_type, aa_mass_table)
                <span class="hljs-keyword">if</span> theo_spec == exp_spec:
                    final_peptides.append(p)
                removal_idxes.add(i)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># Why get the theo spec of the linear version even if the peptide is cyclic? Think about what's</span>
                <span class="hljs-comment"># happening here. If the exp spec is for cyclic peptide NQYQ, and you're checking to see if the</span>
                <span class="hljs-comment"># candidate NQY should continue to be branched out...</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Exp spec  cyclic NQYQ: [0, 114, 128, 128, 163, 242, 242,      291, 291, 370, 405, 405, 419, 533]</span>
                <span class="hljs-comment"># Theo spec cyclic NQY:  [0, 114, 128,      163, 242,      277, 291,           405]</span>
                <span class="hljs-comment">#                                                           ^</span>
                <span class="hljs-comment">#                                                           |</span>
                <span class="hljs-comment">#                                                        mass(YN)</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Since NQY is being treated as a cyclic peptide, it has the subpeptide YN (mass of 277). However, the</span>
                <span class="hljs-comment"># cyclic peptide NQYQ doesn't have the subpeptide YN. That means NQY won't be branched out any further</span>
                <span class="hljs-comment"># even though it should. As such, even if the exp spec is for a cyclic peptide, treat the candidates as</span>
                <span class="hljs-comment"># linear segments of that cyclic peptide (essentially linear peptides).</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Exp spec  cyclic NQYQ: [0, 114, 128, 128, 163, 242, 242, 291, 291, 370, 405, 405, 419, 533]</span>
                <span class="hljs-comment"># Theo spec linear NQY:  [0, 114, 128,      163, 242,      291,           405]</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Given the specs above, the exp spec contains all masses in the theo spec.</span>
                theo_spec = theoretical_spectrum(p, PeptideType.LINEAR, aa_mass_table)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> contains_all_sorted(theo_spec, exp_spec):
                    removal_idxes.add(i)
        candidate_peptides = [p <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(candidate_peptides) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> removal_idxes]
    <span class="hljs-keyword">return</span> final_peptides
</code></pre>
<div style="border:1px solid black;">
<p></p>
<p>The cyclic peptides matching the experimental spectrum [0.0, 114.0, 128.0, 128.0, 163.0, 242.0, 242.0, 291.0, 291.0, 370.0, 405.0, 405.0, 419.0, 533.0] are...</p>
<ul>
<li>NKYK</li>
<li>NKYQ</li>
<li>NQYK</li>
<li>NQYQ</li>
<li>KNKY</li>
<li>KNQY</li>
<li>KYKN</li>
<li>KYQN</li>
<li>QNKY</li>
<li>QNQY</li>
<li>QYKN</li>
<li>QYQN</li>
<li>YKNK</li>
<li>YKNQ</li>
<li>YQNK</li>
<li>YQNQ</li>
</ul>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The following section isn't from the Pevzner book or any online resources. I came up with it in an effort to solve the final assignment for Chapter 4 (the chapter on <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a> <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>). As such, it might not be entirely correct / there may be better ways to do this.</p>
</div>
<p>The bounding step described above won't work for real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s. For example, a real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> may ...</p>
<ul>
<li>have a faulty mass that allows candidate <a href="#BM_(peptide)%2Fi">peptide</a>s that should be untenable.</li>
<li>be missing a mass that drops candidate <a href="#BM_(peptide)%2Fi">peptide</a>s that should be good.</li>
<li>have noise that causes good candidate <a href="#BM_(peptide)%2Fi">peptide</a> to be dropped / untenable candidate <a href="#BM_(peptide)%2Fi">peptide</a> through.</li>
</ul>
<p>A possible bounding step for real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s is to mark a candidate <a href="#BM_(peptide)%2Fi">peptide</a> as untenable if it has a certain number or percentage of mismatches. This is a heuristic, meaning that it won't always lead to the correct <a href="#BM_(peptide)%2Fi">peptide</a>. In contrast, the algorithm described above for perfect <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s always leads to the correct <a href="#BM_(peptide)%2Fi">peptide</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence_peptide</span>(<span class="hljs-params">
        exp_spec: List[float],                               <span class="hljs-comment"># must be sorted asc</span>
        aa_mass_table: Dict[AA, float],                      <span class="hljs-comment"># amino acid mass table</span>
        aa_mass_tolerance: float,                            <span class="hljs-comment"># amino acid mass tolerance</span>
        peptide_mass_candidates: List[Tuple[float, float]],  <span class="hljs-comment"># mass range candidates for mass of peptide</span>
        peptide_type: PeptideType,                           <span class="hljs-comment"># linear or cyclic</span>
        score_backlog: int,                                  <span class="hljs-comment"># backlog of top scores</span>
        candidate_threshold: float                           <span class="hljs-comment"># if &lt; 1 then min % match, else min count match</span>
</span>) -&gt; SequenceTesterSet:</span>
    tester_set = SequenceTesterSet(
        exp_spec,
        aa_mass_table,
        aa_mass_tolerance,
        peptide_mass_candidates,
        peptide_type,
        score_backlog
    )
    candidate_peptides = [[]]
    <span class="hljs-keyword">while</span> len(candidate_peptides) &gt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># Branch candidates</span>
        new_candidate_peptides = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> candidate_peptides:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> aa_mass_table:
                new_p = p[:] + [m]
                new_candidate_peptides.append(new_p)
        candidate_peptides = new_candidate_peptides
        <span class="hljs-comment"># Test candidates to see if they match exp_spec or if they should keep being branched</span>
        removal_idxes = set()
        <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(candidate_peptides):
            res = set(tester_set.test(p))
            <span class="hljs-keyword">if</span> {TestResult.MASS_TOO_LARGE} == res:
                removal_idxes.add(i)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># Why get the theo spec of the linear version even if the peptide is cyclic? Think about what's</span>
                <span class="hljs-comment"># happening here. If the exp spec is for cyclic peptide NQYQ, and you're checking to see if the</span>
                <span class="hljs-comment"># candidate NQY should continue to be branched out...</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Exp spec  cyclic NQYQ: [0, 114, 128, 128, 163, 242, 242,      291, 291, 370, 405, 405, 419, 533]</span>
                <span class="hljs-comment"># Theo spec cyclic NQY:  [0, 114, 128,      163, 242,      277, 291,           405]</span>
                <span class="hljs-comment">#                                                           ^</span>
                <span class="hljs-comment">#                                                           |</span>
                <span class="hljs-comment">#                                                        mass(YN)</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Since NQY is being treated as a cyclic peptide, it has the subpeptide YN (mass of 277). However, the</span>
                <span class="hljs-comment"># cyclic peptide NQYQ doesn't have the subpeptide YN. That means NQY won't be branched out any further</span>
                <span class="hljs-comment"># even though it should. As such, even if the exp spec is for a cyclic peptide, treat the candidates as</span>
                <span class="hljs-comment"># linear segments of that cyclic peptide (essentially linear peptides).</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Exp spec  cyclic NQYQ: [0, 114, 128, 128, 163, 242, 242, 291, 291, 370, 405, 405, 419, 533]</span>
                <span class="hljs-comment"># Theo spec linear NQY:  [0, 114, 128,      163, 242,      291,           405]</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># Given the specs above, the exp spec contains all masses in the theo spec.</span>
                theo_spec = SequenceTester.generate_theroetical_spectrum_with_tolerances(
                    p,
                    PeptideType.LINEAR,
                    aa_mass_table,
                    aa_mass_tolerance
                )
                score = score_spectrums(exp_spec, theo_spec)
                <span class="hljs-keyword">if</span> (candidate_threshold &lt; <span class="hljs-number">1.0</span> <span class="hljs-keyword">and</span> score[<span class="hljs-number">0</span>] / len(theo_spec) &lt; candidate_threshold)\
                        <span class="hljs-keyword">or</span> score[<span class="hljs-number">0</span>] &lt; candidate_threshold:
                    removal_idxes.add(i)
        candidate_peptides = [p <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(candidate_peptides) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> removal_idxes]
    <span class="hljs-keyword">return</span> tester_set
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> in the example below is for the <a href="#BM_(peptide)%2Fi">peptide</a> 114-128-163, which has the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> [0, 114, 128, 163, 242, 291, 405].</p>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Given the ...</p>
<ul>
<li>experimental spectrum: [0.0, 112.5, 127.1, 242.9, 290.0, 404.0]</li>
<li>experimental spectrum mass noise: ±1.0</li>
<li>assumed peptide type: linear</li>
<li>assumed peptide length: 3</li>
<li>assumed peptide mass: any of the last 1 experimental spectrum masses</li>
<li>score backlog: 0</li>
<li>candidate threshold: 75.0% mass matches per iteration</li>
</ul>
<p>Captured mino acid masses are (rounded to 1): [112.5, 114.0, 115.8, 127.1, 130.4, 161.1, 162.9, 177.5]</p>
<p>For peptides between 397.0 and 411.0...</p>
<ul>
<li>Score 6: 114.0-127.1-162.9</li>
</ul>
</div>
<p></p>
<a name="H_Leaderboard%20Algorithm"></a><h4>Leaderboard Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<p><a name="BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence%2FLeaderboard%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence%2FBruteforce%20Algorithm)_TOPIC%2F">Algorithms/Mass Spectrometry/Spectrum Sequence/Bruteforce Algorithm</a></li>
<li><a href="#BM_(Algorithms%5C%2FMass%20Spectrometry%2FSpectrum%20Sequence%2FBranch-and-bound%20Algorithm)_TOPIC%2F">Algorithms/Mass Spectrometry/Spectrum Sequence/Branch-and-bound Algorithm</a></li>
</ul>
</div>
<p>This algorithm is similar to the <a href="#BM_(branch-and-bound%20algorithm%7Cbranch%20and%20bound%20algorithm)%2Fi">branch-and-bound algorithm</a>, but the bounding step is slightly different: At each branch, rather than removing untenable candidate <a href="#BM_(peptide)%2Fi">peptide</a>s, it only moves forward the best n scoring candidate <a href="#BM_(peptide)%2Fi">peptide</a>s. These best scoring <a href="#BM_(peptide)%2Fi">peptide</a>s are referred to as the leaderboard.</p>
<p>For a perfect <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> (no missing masses, no faulty masses, no noise, and preserved repeat masses), this algorithm isn't much different than the <a href="#BM_(branch-and-bound%20algorithm%7Cbranch%20and%20bound%20algorithm)%2Fi">branch-and-bound algorithm</a>. However, imagine if the perfect <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> wasn't exactly perfect in that it could have faulty masses and could be missing masses. In such a case, the <a href="#BM_(branch-and-bound%20algorithm%7Cbranch%20and%20bound%20algorithm)%2Fi">branch-and-bound algorithm</a> would always fail while this algorithm could still converge to the correct <a href="#BM_(peptide)%2Fi">peptide</a> -- it's a heuristic, meaning that it isn't guaranteed to lead to the correct <a href="#BM_(peptide)%2Fi">peptide</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence_peptide</span>(<span class="hljs-params">
        exp_spec: List[float],  <span class="hljs-comment"># must be sorted</span>
        peptide_type: PeptideType,
        peptide_mass: Optional[float],
        aa_mass_table: Dict[AA, float],
        leaderboard_size: int
</span>) -&gt; List[List[AA]]:</span>
    <span class="hljs-comment"># Exp_spec could be missing masses / have faulty masses, but even so assume the last mass in exp_spec is the peptide</span>
    <span class="hljs-comment"># mass if the user didn't supply one. This may not be correct -- it's a best guess.</span>
    <span class="hljs-keyword">if</span> peptide_mass <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        peptide_mass = exp_spec[<span class="hljs-number">-1</span>]
    leaderboard = [[]]
    final_peptides = [next(iter(leaderboard))]
    final_score = score_spectrums(
        theoretical_spectrum(final_peptides[<span class="hljs-number">0</span>], peptide_type, aa_mass_table),
        exp_spec
    )
    <span class="hljs-keyword">while</span> len(leaderboard) &gt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># Branch leaderboard</span>
        expanded_leaderboard = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> leaderboard:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> aa_mass_table:
                new_p = p[:] + [m]
                expanded_leaderboard.append(new_p)
        <span class="hljs-comment"># Pull out any expanded_leaderboard peptides with mass &gt;= peptide_mass</span>
        removal_idxes = set()
        <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(expanded_leaderboard):
            p_mass = sum([aa_mass_table[aa] <span class="hljs-keyword">for</span> aa <span class="hljs-keyword">in</span> p])
            <span class="hljs-keyword">if</span> p_mass == peptide_mass:
                <span class="hljs-comment"># The peptide's mass is equal to the expected mass. Check if the score against the current top score. If</span>
                <span class="hljs-comment"># it's ...</span>
                <span class="hljs-comment">#  * a higher score, reset the final peptides to it.</span>
                <span class="hljs-comment">#  * the same score, add it to the final peptides.</span>
                theo_spec = theoretical_spectrum(p, peptide_type, aa_mass_table)
                score = score_spectrums(theo_spec, exp_spec)
                <span class="hljs-keyword">if</span> score &gt; final_score:
                    final_peptides = [p]
                    final_score = score_spectrums(
                        theoretical_spectrum(final_peptides[<span class="hljs-number">0</span>], peptide_type, aa_mass_table),
                        exp_spec
                    )
                <span class="hljs-keyword">elif</span> score == final_score:
                    final_peptides.append(p)
                <span class="hljs-comment"># p should be removed at this point (the line below should be uncommented). Not removing it means that</span>
                <span class="hljs-comment"># it may end up in the leaderboard for the next cycle. If it that happens, it'll get branched out into</span>
                <span class="hljs-comment"># new candidate peptides where each new candidate has an amino acids append. The problem is that it</span>
                <span class="hljs-comment"># doesn't make sense to create these new candidates because p's mass already matches the peptide mass.</span>
                <span class="hljs-comment"># Once p goes into the next cycle and branches out, those branched out candidates will have masses that</span>
                <span class="hljs-comment"># EXCEED the peptide mass, meaning they'll all get removed anyway. This would be fine, except that by</span>
                <span class="hljs-comment"># moving p into the leaderboard for the next cycle you're potentially preventing other viable candidates</span>
                <span class="hljs-comment"># from making it in.</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># So why isn't it being removed (why was the line removal commented out)? The questions on Stepik expect</span>
                <span class="hljs-comment"># no removal at this point. Uncommenting it will cause more peptides than are expected to show up for</span>
                <span class="hljs-comment"># some questions, meaning the answer will be rejected by Stepik.</span>
                <span class="hljs-comment">#</span>
                <span class="hljs-comment"># removal_idxes.add(i)</span>
            <span class="hljs-keyword">elif</span> p_mass &gt; peptide_mass:
                <span class="hljs-comment"># The peptide's mass exceeds the expected mass, meaning that there's no chance that this peptide can be</span>
                <span class="hljs-comment"># a match for exp_spec. Discard it.</span>
                removal_idxes.add(i)
        expanded_leaderboard = [p <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(expanded_leaderboard) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> removal_idxes]
        <span class="hljs-comment"># Set leaderboard to the top n scoring peptides from expanded_leaderboard, but include peptides past n as long</span>
        <span class="hljs-comment"># as those peptides have a score equal to the nth peptide. The reason for this is that because they score the</span>
        <span class="hljs-comment"># same, there's just as much of a chance that they'll end up as the winner as it is that the nth peptide will.</span>
            <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> Why get the theo spec of the linear version even if the peptide is cyclic? For similar reasons as to</span>
            <span class="hljs-comment"># why it's done in the branch-and-bound variant: If we treat candidate peptides as cyclic, their theo spec</span>
            <span class="hljs-comment"># will include masses for wrapping subpeptides of the candidate peptide. These wrapping subpeptide masses</span>
            <span class="hljs-comment"># may end up inadvertently matching masses in the experimental spectrum, meaning that the candidate may get</span>
            <span class="hljs-comment"># a better score than it should, potentially pushing it forward over other candidates that would ultimately</span>
            <span class="hljs-comment"># branch out  to a more optimal final solution. As such, even if the exp  spec is  for a cyclic peptide,</span>
            <span class="hljs-comment"># treat the candidates as linear segments of that cyclic peptide (essentially linear  peptides).</span>
        theo_specs = [theoretical_spectrum(p, PeptideType.LINEAR, aa_mass_table) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> expanded_leaderboard]
        scores = [score_spectrums(theo_spec, exp_spec) <span class="hljs-keyword">for</span> theo_spec <span class="hljs-keyword">in</span> theo_specs]
        scores_paired = sorted(zip(expanded_leaderboard, scores), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)
        leaderboard_trim_to_size = len(expanded_leaderboard)
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(leaderboard_size + <span class="hljs-number">1</span>, len(scores_paired)):
            <span class="hljs-keyword">if</span> scores_paired[leaderboard_size][<span class="hljs-number">1</span>] &gt; scores_paired[j][<span class="hljs-number">1</span>]:
                leaderboard_trim_to_size = j - <span class="hljs-number">1</span>
                <span class="hljs-keyword">break</span>
        leaderboard = [p <span class="hljs-keyword">for</span> p, _ <span class="hljs-keyword">in</span> scores_paired[:leaderboard_trim_to_size]]
    <span class="hljs-keyword">return</span> final_peptides
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> in the example below is for the <a href="#BM_(peptide)%2Fi">peptide</a> NQYQ, which has the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> [0, 114, 128, 128, 163, 242, 242, 291, 291, 370, 405, 405, 419, 533].</p>
</div>
<div style="border:1px solid black;">
<p></p>
<p>The cyclic peptides matching the experimental spectrum [0.0, 114.0, 163.0, 242.0, 291.0, 370.0, 405.0, 419.0, 480.0, 533.0] are with leaderboard size of 10...</p>
<ul>
<li>NKYK</li>
<li>NKYQ</li>
<li>NQYK</li>
<li>NQYQ</li>
<li>YKNK</li>
<li>YKNQ</li>
<li>YQNK</li>
<li>YQNQ</li>
<li>NYKK</li>
<li>NYKQ</li>
<li>NYQK</li>
<li>NYQQ</li>
<li>YNKK</li>
<li>YNKQ</li>
<li>YNQK</li>
<li>YNQQ</li>
<li>KNYK</li>
<li>KNYQ</li>
<li>KYNK</li>
<li>KYNQ</li>
<li>QNYK</li>
<li>QNYQ</li>
</ul>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The following section isn't from the Pevzner book or any online resources. I came up with it in an effort to solve the final assignment for Chapter 4 (the chapter on <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a> <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>). As such, it might not be entirely correct / there may be better ways to do this.</p>
</div>
<p>For real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>s, the algorithm is very similar to the real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> version of the <a href="#BM_(branch-and-bound%20algorithm%7Cbranch%20and%20bound%20algorithm)%2Fi">branch-and-bound algorithm</a>. The only major difference is that the bounding heuristic is swapped out from removing candidates that don't meet a mass match threshold to using a leaderboard to decide which candidates move forward.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence_peptide</span>(<span class="hljs-params">
        exp_spec: List[float],                               <span class="hljs-comment"># must be sorted asc</span>
        aa_mass_table: Dict[AA, float],                      <span class="hljs-comment"># amino acid mass table</span>
        aa_mass_tolerance: float,                            <span class="hljs-comment"># amino acid mass tolerance</span>
        peptide_mass_candidates: List[Tuple[float, float]],  <span class="hljs-comment"># mass range candidates for mass of peptide</span>
        peptide_type: PeptideType,                           <span class="hljs-comment"># linear or cyclic</span>
        score_backlog: int,                                  <span class="hljs-comment"># backlog of top scores</span>
        leaderboard_size: int,
        leaderboard_initial: List[List[AA]] = None           <span class="hljs-comment"># bootstrap candidate peptides for leaderboard</span>
</span>) -&gt; SequenceTesterSet:</span>
    tester_set = SequenceTesterSet(
        exp_spec,
        aa_mass_table,
        aa_mass_tolerance,
        peptide_mass_candidates,
        peptide_type,
        score_backlog
    )
    <span class="hljs-keyword">if</span> leaderboard_initial <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        leaderboard = [[]]
    <span class="hljs-keyword">else</span>:
        leaderboard = leaderboard_initial[:]
    <span class="hljs-keyword">while</span> len(leaderboard) &gt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># Branch candidates</span>
        expanded_leaderboard = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> leaderboard:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> aa_mass_table:
                new_p = p[:] + [m]
                expanded_leaderboard.append(new_p)
        <span class="hljs-comment"># Test candidates to see if they match exp_spec or if they should keep being branched</span>
        removal_idxes = set()
        <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(expanded_leaderboard):
            res = set(tester_set.test(p))
            <span class="hljs-keyword">if</span> {TestResult.MASS_TOO_LARGE} == res:
                removal_idxes.add(i)
        expanded_leaderboard = [p <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> enumerate(expanded_leaderboard) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> removal_idxes]
        <span class="hljs-comment"># Set leaderboard to the top n scoring peptides from expanded_leaderboard, but include peptides past n as long</span>
        <span class="hljs-comment"># as those peptides have a score equal to the nth peptide. The reason for this is that because they score the</span>
        <span class="hljs-comment"># same, there's just as much of a chance that they'll end up as the winner as it is that the nth peptide will.</span>
            <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> Why get the theo spec of the linear version even if the peptide is cyclic? For similar reasons as to</span>
            <span class="hljs-comment"># why it's done in the branch-and-bound variant: If we treat candidate peptides as cyclic, their theo spec</span>
            <span class="hljs-comment"># will include masses for wrapping subpeptides of the candidate peptide. These wrapping subpeptide masses</span>
            <span class="hljs-comment"># may end up inadvertently matching masses in the experimental spectrum, meaning that the candidate may get</span>
            <span class="hljs-comment"># a better score than it should, potentially pushing it forward over other candidates that would ultimately</span>
            <span class="hljs-comment"># branch out  to a more optimal final solution. As such, even if the exp  spec is  for a cyclic peptide,</span>
            <span class="hljs-comment"># treat the candidates as linear segments of that cyclic peptide (essentially linear  peptides).</span>
        theo_specs = [
            SequenceTester.generate_theroetical_spectrum_with_tolerances(
                p,
                peptide_type,
                aa_mass_table,
                aa_mass_tolerance
            )
            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> expanded_leaderboard
        ]
        scores = [score_spectrums(exp_spec, theo_spec) <span class="hljs-keyword">for</span> theo_spec <span class="hljs-keyword">in</span> theo_specs]
        scores_paired = sorted(zip(expanded_leaderboard, scores), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)
        leaderboard_tail_idx = min(leaderboard_size, len(scores_paired)) - <span class="hljs-number">1</span>
        leaderboard_tail_score = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> leaderboard_tail_idx == <span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> scores_paired[leaderboard_tail_idx][<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(leaderboard_tail_idx + <span class="hljs-number">1</span>, len(scores_paired)):
            <span class="hljs-keyword">if</span> scores_paired[j][<span class="hljs-number">1</span>] &lt; leaderboard_tail_score:
                leaderboard_tail_idx = j - <span class="hljs-number">1</span>
                <span class="hljs-keyword">break</span>
        leaderboard = [p <span class="hljs-keyword">for</span> p, _ <span class="hljs-keyword">in</span> scores_paired[:leaderboard_tail_idx + <span class="hljs-number">1</span>]]
    <span class="hljs-keyword">return</span> tester_set
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> in the example below is for the <a href="#BM_(peptide)%2Fi">peptide</a> 114-128-163, which has the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> [0, 114, 128, 163, 242, 291, 405].</p>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Given the ...</p>
<ul>
<li>experimental spectrum: [0.0, 112.5, 127.1, 242.9, 290.0, 404.0]</li>
<li>experimental spectrum mass noise: ±1.0</li>
<li>assumed peptide type: linear</li>
<li>assumed peptide length: 3</li>
<li>assumed peptide mass: any of the last 1 experimental spectrum masses</li>
<li>score backlog: 0</li>
<li>leaderboard size: 100</li>
</ul>
<p>Captured mino acid masses are (rounded to 1): [112.5, 114.0, 115.8, 127.1, 130.4, 161.1, 162.9, 177.5]</p>
<p>For peptides between 397.0 and 411.0...</p>
<ul>
<li>Score 6: 114.0-127.1-162.9</li>
<li>Score 6: 162.9-127.1-114.0</li>
</ul>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This was the version of the algorithm used to solve chapter 4's final assignment (<a href="#BM_(sequence)%2Fi">sequence</a> a real <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> for some unknown variant of Tyrocidine). Note how the parameters into <a href="#BM_(sequence)%2Fi">sequence</a>_<a href="#BM_(peptide)%2Fi">peptide</a> take an initial leaderboard. This initial leaderboard was primed with <a href="#BM_(subpeptide)%2Fi">subpeptide</a> <a href="#BM_(sequence)%2Fi">sequence</a>s from other Tyrocidine variants discusses in chapter 4. The problem wasn't solvable without these <a href="#BM_(subpeptide)%2Fi">subpeptide</a> <a href="#BM_(sequence)%2Fi">sequence</a>s. More information on this can be found in the Python file for the final assignment.</p>
<p>Before coming up with the above solution, I came up with another heuristic that I tried: Use basic genetic algorithms / evolutionary algorithms as the heuristic to move forward <a href="#BM_(peptide)%2Fi">peptide</a>s. This performed even worse than leaderboard: If the mutation rate is too low, the candidates converge to a local optima and can't break out. If the mutation rate is too high, the candidates never converge to a solution. As such, it was removed from the code.</p>
</div>
<a name="H_Stories"></a><h1>Stories</h1>
<a name="H_Bacterial%20Genome%20Replication"></a><h2>Bacterial Genome Replication</h2>
<p>Bacteria are known to have a single chromosome of circular / looping DNA. On that DNA, the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> (<a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>) is the region in which DNA replication starts, while the <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a> (<a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>) is where it ends. The <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> and usually placed on opposite ends of each other.</p>
<p><img src="svgbob_308a4af4e5d6864abeb06f6652581aec0ff50fb1.svg" alt="Kroki diagram output"></p>
<p>The replication process begins by a <a href="#BM_(replication%20fork)%2Fi">replication fork</a> opening at the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>. As replication happens, that fork widens until the point it reaches <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>...</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
<p>For each forked <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s attach on and synthesize a new <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> strand so that it turns back into <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a>....</p>
<p><img src="svgbob_971abfeff166ada9787cd484db9bfbe43120973a.svg" alt="Kroki diagram output"></p>
<p>The process of synthesizing a <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> strand is different based on the section of DNA that <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> is operating on. For each <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, if the direction of that DNA strand is traveling from ...</p>
<ul>
<li><a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> to <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>, it's called a <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>.</li>
<li><a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> to <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>, it's called a <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>.</li>
</ul>
<p><img src="svgbob_ad11e0114c63955ab620cbe9a8dee61a85caa1f9.svg" alt="Kroki diagram output"></p>
<p>Since <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk over DNA in the reverse direction (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>), the 2 <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>s will quickly get walked over in one shot. A <a href="#BM_(primer)%2Fi">primer</a> gets attached to the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>, then a <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> attaches to that <a href="#BM_(primer)%2Fi">primer</a> to begin synthesis of a new strand. Synthesis continues until the <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> is reached...</p>
<p><img src="svgbob_83b0a64a4614fa906388ef166341e3fd293c6dc0.svg" alt="Kroki diagram output"></p>
<p>For the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s, the process is much slower. Since <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk DNA in the reverse direction, the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s get replicated in small segments. That is, as the <a href="#BM_(replication%20fork)%2Fi">replication fork</a> continues to grow, every ~2000 nucleotides a new <a href="#BM_(primer)%2Fi">primer</a> attaches to the end of the fork on the forward strands. A new <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> attaches to each <a href="#BM_(primer)%2Fi">primer</a> and walks in the reverse direction (towards the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>) to synthesize a small segment of DNA. That small segment of DNA is called an <a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>...</p>
<p><img src="svgbob_4c651d9aa100c5b586103bb0d42cc91ff27da474.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BM_(replication%20fork)%2Fi">replication fork</a> will keep widening until the original 2 strands split off. <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> will have made sure that for each separated strand, a newly synthesized <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> is paired to it. The end result is 2 daughter chromosome where each chromosome has gaps...</p>
<p><img src="svgbob_eac405c5709e835b492078d1ea557a7199d8f722.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>s synthesized on the forward strands end up getting sewn together by <a href="#BM_(DNA%20ligase)%2Fi">DNA ligase</a>...</p>
<p><img src="svgbob_5c3304d08cc6bbc226df966d6e1c119636331723.svg" alt="Kroki diagram output"></p>
<p>There are now two complete copies of the DNA.</p>
<a name="H_Find%20Ori%20and%20Ter"></a><h3>Find Ori and Ter</h3>
<p><a name="BM_(Stories%5C%2FBacteria%20Replication%2FFind%20Ori%20and%20Ter)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FGC%20Skew)_TOPIC%2F">Algorithms/GC Skew</a></li>
</ul>
</div>
<p>Since the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> gets its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> synthesized at a much slower rate than the <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>, it stays single stranded for a much longer time. <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a>. Specifically, in <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, C has a greater tendency to mutate to T. This process of mutation is referred to as deanimation.</p>
<p><img src="svgbob_f52124bb3b29a8388ed6a1fc5f597b26a2514f42.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a> spends much less time as a <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>. As such, it experiences much less C to T mutations.</p>
<p><img src="svgbob_7d778227822729bde64ce4a36b5cc9da206869c1.svg" alt="Kroki diagram output"></p>
<p>Ultimately, that means that a single strand will have a different nucleotide distribution between its <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> vs its <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">backward half-strand</a>. If the half-strand being targeted for replication is the ...</p>
<ul>
<li><a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>, some Cs get replaced with Ts. As such, its synthesized <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a> will have less Gs.</li>
<li><a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>, most Cs are kept. As such, its synthesized <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> will keep its Gs.</li>
</ul>
<p>To simplify, the ...</p>
<ul>
<li><a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>: loses Cs, keeps Gs.</li>
<li><a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>: keeps Cs, loses Gs.</li>
</ul>
<p>You can use a GC skew diagram to help pinpoint where the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> might be. The plot will typically form a peak where the <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> is (more G vs C) and form a valley where the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> is (less G vs C). For example, the GC skew diagram for E. coli bacteria shows a distinct peak and distinct valley.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Min position (ori): 4719166</p>
<p>Max position (ter): 2073768</p>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The material talks about how not all bacteria have a single peak and single valley. Some may have multiple. The reasoning for this still hasn't been discovered. It was speculated at one point that some bacteria may have multiple <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> / <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> regions.</p>
</div>
<a name="H_Find%20the%20DnaA%20Box"></a><h3>Find the DnaA Box</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Stories%5C%2FBacteria%20Replication%2FFind%20Ori%20and%20Ter)_TOPIC%2F">Stories/Bacteria Replication/Find Ori and Ter</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating%20in%20Window)_TOPIC%2F">Algorithms/K-mer/Find Repeating in Window</a></li>
<li><a href="#BM_(Algorithms%5C%2FGC%20Skew)_TOPIC%2F">Algorithms/GC Skew</a></li>
</ul>
</div>
<p>Within the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> region, there exists several copies of some <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern. These copies are referred to as <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>es.</p>
<p><img src="svgbob_d3e7c213995dec8a967fa89f40ebae73ed6e53ac.svg" alt="Kroki diagram output"></p>
<p>The DnaA protein binds to a <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> to activate the process of DNA replication. Through experiments, biologists have determined that <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>es are typical <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s. The <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s may not match exactly -- the DnaA protein may bind to ...</p>
<ul>
<li>the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a> itself.</li>
<li>slight variations of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>.</li>
<li>the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>.</li>
<li>slight variations of the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The reason why multiple copies of the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> exist probably has to do with DNA mutation. If one of the copies mutates to a point where the DnaA protein no longer binds to it, it can still bind to the other copies.</p>
</div>
<p>In the example below, the general vicinity of E. coli's <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> is found using GC skew, then that general vicinity is searched for repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s. These repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s are potential <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> candidates.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Ori vicinity (min pos): 4719166</p>
<p>In the ori vicinity, found clusters of k=9 (at least 3 occurrences in window of 500) in ... at...</p>
<ul>
<li>KmerCluster(kmer='CCGCGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGTGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCGGCGGTA', start_index=52, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCGGCGGT', start_index=53, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGAAGATC', start_index=98, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGCGGTTC', start_index=160, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGCT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGGT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGAT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=161, occurrence_count=4)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=162, occurrence_count=4)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=163, occurrence_count=4)</li>
<li>KmerCluster(kmer='CATCAGGCG', start_index=164, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCATCAGGC', start_index=165, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGCGATGG', start_index=199, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTATG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTTCG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCAGTACG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=212, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGG', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGC', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGA', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGTCAGGCG', start_index=215, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCCTG', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCGTT', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCGT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='GCGGATCCT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGCCGGATC', start_index=235, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTAAA', start_index=282, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTTTGATAC', start_index=427, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCTTTTGA', start_index=430, occurrence_count=3)</li>
<li>KmerCluster(kmer='TGGCTGGGG', start_index=460, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCACCATT', start_index=500, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCTTTTTA', start_index=513, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCCTTTTT', start_index=514, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTTT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTAT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGATCCTTT', start_index=516, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCATT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGATCCT', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCCC', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCCGGATCC', start_index=519, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATCCAGA', start_index=522, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCAGGTTTT', start_index=529, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCATTCTCA', start_index=611, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCCAGGTT', start_index=618, occurrence_count=3)</li>
<li>KmerCluster(kmer='ACAGATCTT', start_index=644, occurrence_count=3)</li>
<li>KmerCluster(kmer='AAACAGATC', start_index=646, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCAAATAA', start_index=653, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATTGATC', start_index=730, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTTGTTGAG', start_index=731, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCAAC', start_index=769, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGATCAACC', start_index=836, occurrence_count=3)</li>
</ul>
</div>
<p></p>
<a name="H_Transcription%20Factors"></a><h2>Transcription Factors</h2>
<p>A <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> / <a href="#BM_(regulatory%20protein)%2Fi">regulatory protein</a> is an enzyme that influences the rate of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for some set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>. As the saturation of a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> changes, so does the rate of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for the set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> that it influences.</p>
<p><a href="#BM_(transcription%20factor)%2Fi">Transcription factor</a>s bind to DNA near the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> they influence: a <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a> is located in a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a> and the <a href="#BM_(sequence)%2Fi">sequence</a> at that location is a fuzzy nucleotide <a href="#BM_(sequence)%2Fi">sequence</a> of length 8 to 12 called a <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>. The simplest way to think of a <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]CCCTA</code> may match to ATTGCCCTA, ATTCCCCTA, TTTGCCCTA, and TTTCCCCTA. The regex itself is the <a href="#BM_(motif)%2Fi">motif</a>, while the <a href="#BM_(sequence)%2Fi">sequence</a>s being matched are <a href="#BM_(motif%20member)%2Fi">motif member</a>s.</p>
<p><img src="svgbob_c77523791e9f610ea50acd1a596be075095bcceb.svg" alt="Kroki diagram output"></p>
<p>The production of <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s may be tied to certain internal or external conditions. For example, imagine a flower where the petals...</p>
<ul>
<li>bunch together at night time when sunlight is hidden and temperature is lower.</li>
<li>spread out at day time when sunlight is available and temperature is higher.</li>
</ul>
<p>The external conditions of sunlight and temperature causes the saturation of some <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s to change. Those <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s influence the rate of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> that control the bunching and spreading of the petals.</p>
<p><img src="svgbob_02d5e3f967efc5f1f94cccd5f97a6610035cb8fd.svg" alt="Kroki diagram output"></p>
<a name="H_Find%20Regulatory%20Motif"></a><h3>Find Regulatory Motif</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix)_TOPIC%2F">Algorithms/Motif/Find Motif Matrix</a></li>
</ul>
</div>
<p>Given a organism, it's suspected that some physical change in that organism is linked to a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. However, it isn't known ...</p>
<ul>
<li>which <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> (if any).</li>
<li>what the <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> for that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> is.</li>
</ul>
<p>A special device is used to take snapshots of the organism's mRNA at different points in time: <a href="#BM_(DNA%20microarray)%2Fi">DNA microarray</a> / RNA <a href="#BM_(sequencer)%2Fi">sequencer</a>. Specifically, two snapshots are taken:</p>
<ol>
<li>When the physical change is expressed.</li>
<li>When the physical change isn't expressed.</li>
</ol>
<p>Comparing these snapshots identifies which <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> have noticeably differing rates of <a href="#BM_(gene%20expression)%2Fi">gene expression</a>. If these <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> (or a subset of these <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>) were influenced by the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, their <a href="#BM_(upstream%20region)%2Fi">upstream region</a>s would contain <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<p>Since neither the <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> nor its <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> are known, there is no specific <a href="#BM_(motif)%2Fi">motif</a> to search for in the <a href="#BM_(upstream%20region)%2Fi">upstream region</a>s. But, because <a href="#BM_(motif%20member)%2Fi">motif member</a>s are typically similar to each other, <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> finding algorithms can be used on these <a href="#BM_(upstream%20region)%2Fi">upstream region</a>s to find sets of similar <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s. These similar <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s may all be <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<p><img src="svgbob_bc9f1ba4918b4a4995ec308b823f93eb3da45567.svg" alt="Kroki diagram output"></p>
<p>In the example below, a set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> in baker's yeast (Saccharomyces cerevisiae) are suspected of being influenced by the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. These <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> are searched for a common <a href="#BM_(motif)%2Fi">motif</a>. Assuming one is found, it could be the <a href="#BM_(motif)%2Fi">motif</a> of the suspected <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The example below hard codes k to 18, but you typically don't know what k should be set to beforehand. The Pevzner book doesn't discuss how to work around this problem. A strategy for finding k may be to run the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> finding algorithm multiple times, but with a different k each time. For each <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>, if the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s selected across the runs came from the same general vicinity of the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a>, those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s may either be picking ...</p>
<ul>
<li>the actual <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>.</li>
<li>a part of the actual <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>.</li>
<li>a part of the actual <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> with some junk prepended/appended to it.</li>
</ul>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Organism is baker's yeast. Suspected genes influenced by transcription factor: THI12, YHL017W, SYN8, YCG1, UBX5, and KEI1.</p>
<p>Searching for 18-mer across a set of 6 gene upstream regions...</p>
<p>GAAGAAGATGATGACAAA<br>GAAAAAGAAAAAATAGAA<br>GAAAAAGAAAAAAAAAAA<br>AGAAAAGGAAAAAAAGAA<br>GAATATTAACATATAAAA<br>GAAAAATCAAAAAAATAA</p>
<p>Score is: 21</p>
</div>
<p></p>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi"></a><strong>k-mer</strong> - A sub<a href="#BM_(sequence)%2Fi">sequence</a> of length k within some larger biological <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. DNA or <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain). For example, in the DNA <a href="#BM_(sequence)%2Fi">sequence</a> GAAATC, the following <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi"></a><strong>kd-mer</strong> - A sub<a href="#BM_(sequence)%2Fi">sequence</a> of length 2k + d within some larger biological <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. DNA or <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain) where the first k elements and the last k elements are known but the d elements in between isn't known.</p>
<p>When identifying a <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a> with a specific k and d, the proper syntax is <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(k, d)-mer</a>. For example, <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(1, 2)-mer</a> represents a <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a> with k=1 and d=2. In the DNA <a href="#BM_(sequence)%2Fi">sequence</a> GAAATC, the following <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(1, 2)-mer</a>'s exist: <code>G--A</code>, <code>A--T</code>, <code>A--C</code>.</p>
<p>See <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>.</p>
</li>
<li>
<p><a name="BM_(5')%2Fi"></a><strong>5'</strong> (<a name="BM_(5%20prime)%2Fi"></a><strong>5 prime</strong>) / <a name="BM_(3')%2Fi"></a><strong>3'</strong> (<a name="BM_(3%20prime)%2Fi"></a><strong>3 prime</strong>) - <a href="#BM_(5')%2Fi">5'</a> (<a href="#BM_(5%20prime)%2Fi">5 prime</a>) and <a href="#BM_(3')%2Fi">3'</a> (<a href="#BM_(3%20prime)%2Fi">3 prime</a>) describe the opposite ends of DNA. The chemical structure at each end is what defines if it's <a href="#BM_(5')%2Fi">5'</a> or <a href="#BM_(3')%2Fi">3'</a> -- each end is guaranteed to be different from the other. The forward direction on DNA is defined as <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, while the backwards direction is <a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>.</p>
<p>Two complementing DNA strands will always be attached in opposite directions.</p>
<p><img src="svgbob_a2c87a8f72a4ea21f474350dc6a429e386ae8222.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(DNA%20polymerase)%2Fi"></a><strong>DNA polymerase</strong> - An enzyme that replicates a strand of DNA. That is, <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> walks over a single strand of DNA bases (not the strand of base pairs) and  generates a strand of complements. Before <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can attach itself and start replicating DNA, it requires a <a href="#BM_(primer)%2Fi">primer</a>.</p>
<p><img src="svgbob_ac1f3f5c9441e395290e542abbc9256bed49302f.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> is unidirectional, meaning that it can only walk a DNA strand in one direction: reverse (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>)</p>
</li>
<li>
<p><a name="BM_(primer)%2Fi"></a><strong>primer</strong> - A <a href="#BM_(primer)%2Fi">primer</a> is a short strand of RNA that binds to some larger strand of DNA (single bases, not a strand of base pairs) and allows DNA synthesis to  happen. That is, the <a href="#BM_(primer)%2Fi">primer</a> acts as the entry point for special enzymes <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s. <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s bind to the <a href="#BM_(primer)%2Fi">primer</a> to get access to the strand.</p>
</li>
<li>
<p><a name="BM_(replication%20fork)%2Fi"></a><strong>replication fork</strong> - The process of DNA replication requires that DNA's 2 complementing strands be unwound and split open. The area where the DNA starts to  split is called the <a href="#BM_(replication%20fork)%2Fi">replication fork</a>. In bacteria, the <a href="#BM_(replication%20fork)%2Fi">replication fork</a> starts at the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> and keeps expanding until it reaches the <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a>.  Special enzymes called <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s walk over each unwound strand and create complementing strands.</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(replication%20origin)%2Fi"></a><strong>replication origin</strong> (<a name="BM_%5Cb(ori)%5Cb%2Fi"></a><strong>ori</strong>) - The point in DNA at which replication starts.</p>
</li>
<li>
<p><a name="BM_(replication%20terminus)%2Fi"></a><strong>replication terminus</strong> (<a name="BM_%5Cb(ter)%5Cb%2Fi"></a><strong>ter</strong>) - The point in DNA at which replication ends.</p>
</li>
<li>
<p><a name="BM_(forward%20half-strand)%2Fi"></a><strong>forward half-strand</strong> / <a name="BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi"></a><strong>reverse half-strand</strong> - Bacteria are known to have a single chromosome of circular / looping DNA. In this DNA, the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> (<a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>) is the region of DNA where replication starts, while the <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a> (<a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>) is where replication ends.</p>
<p><img src="svgbob_fb9438945a109c884df7ccc79d1d8051fd358a87.svg" alt="Kroki diagram output"></p>
<p>If you split up the DNA based on <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> being cutting points, you end up with 4 distinct strands. Given that the direction of a strand is <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, if the direction of the strand starts at...</p>
<ul>
<li>
<p><a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and ends at <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>, it's called the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>.</p>
<p><img src="svgbob_d97cf1f12de4bd77dbaf9eca708b0e9120e50b33.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> and ends at <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>, it's called the <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>.</p>
<p><img src="svgbob_0016146d0b3f1f6edf2724e9978d52de7057f5f4.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BM_(forward%20half-strand)%2Fi">Forward half-strand</a> is the same as <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a>.</li>
<li><a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">Reverse half-strand</a> is the same as <a href="#BM_(leading%20half-strand)%2Fi">leading half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BM_(leading%20half-strand)%2Fi"></a><strong>leading half-strand</strong> / <a name="BM_(lagging%20half-strand)%2Fi"></a><strong>lagging half-strand</strong> - Given the 2 strands tha make up a DNA molecule, the strand that goes in the...</p>
<ul>
<li>reverse direction (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>) is called the <a href="#BM_(leading%20half-strand)%2Fi">leading half-strand</a>.</li>
<li>forward direction (<a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>) is called the <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a>.</li>
</ul>
<p>This nomenclature has to do with <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>. Since <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk in the reverse direction (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>), it synthesizes the <a href="#BM_(leading%20half-strand)%2Fi">leading half-strand</a> in one shot. For the <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a> (<a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>), multiple <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s have to used to synthesize DNA, each binding to the lagging strand and walking backwards a small amount to generate a small fragment of DNA (<a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>). the process is much slower for the <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a>, that's why it's called lagging.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BM_(leading%20half-strand)%2Fi">Leading half-strand</a> is the same as <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>.</li>
<li><a href="#BM_(lagging%20half-strand)%2Fi">Lagging half-strand</a> is the same as <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BM_(Okazaki%20fragment)%2Fi"></a><strong>Okazaki fragment</strong> - A small fragment of DNA generated by <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> for <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s. DNA synthesis for the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s can only happen in small pieces. As the fork open ups every ~2000 nucleotides, <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> attaches to the end of the fork on the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> and walks in reverse to generate that small segment (<a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk in the reverse direction).</p>
</li>
<li>
<p><a name="BM_(DNA%20ligase)%2Fi"></a><strong>DNA ligase</strong> - An enzyme that sews together short segments of DNA called <a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>s by binding the phosphate group on the end of one strand with the deoxyribose group on the other strand.</p>
</li>
<li>
<p><a name="BM_(DnaA%20box)%2Fi"></a><strong>DnaA box</strong> - A <a href="#BM_(sequence)%2Fi">sequence</a> in the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> that the DnaA protein (responsible for DNA replication) binds to.</p>
</li>
<li>
<p><a name="BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi"></a><strong>single stranded DNA</strong> - A single strand of DNA, not bound to a strand of its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>s.</p>
<p><img src="svgbob_03d83c0a0dd86c50ead48a0a8bc87eebf4353039.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi"></a><strong>double stranded DNA</strong> - Two strands of DNA bound together, where each strand is the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> of the other.</p>
<p><img src="svgbob_b05df825cb791aaf67d96b4e629e42c02b75f509.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi"></a><strong>gene</strong> - A segment of DNA that contains the instructions for either a protein or functional RNA.</p>
</li>
<li>
<p><a name="BM_(gene%20product)%2Fi"></a><strong>gene product</strong> - The final synthesized material resulting from the instructions that make up a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>. That synthesized material either being a protein or functional RNA.</p>
</li>
<li>
<p><a name="BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi"></a><strong>transcription</strong> - The process of transcribing a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> to RNA. Specifically, the enzyme RNA polymerase copies the segment of DNA that makes up that <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> to a strand of RNA.</p>
<p><img src="svgbob_0fed5f4215fb0a5da3d93da589650b84df3f9c09.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(translation%7Ctranslated%7Ctranslate)%2Fi"></a><strong>translation</strong> - The process of translating mRNA to protein. Specifically, a ribosome takes in the mRNA generated by <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> and outputs the protein that it codes for.</p>
<p><img src="svgbob_aeaffd032a869fcce0f71f969f22f2191880a88c.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(gene%20expression)%2Fi"></a><strong>gene expression</strong> - The process by which a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is synthesized into a <a href="#BM_(gene%20product)%2Fi">gene product</a>. When the <a href="#BM_(gene%20product)%2Fi">gene product</a> is...</p>
<ul>
<li>a protein, the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to mRNA and <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translated</a> to a protein.</li>
<li>functional RNA, the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to a type of RNA that isn't mRNA (only mRNA is <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translated</a> to a protein).</li>
</ul>
<p><img src="svgbob_78b3833e37ddc45358bf3ebf79daba1a9e2604eb.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(regulatory%20gene)%2Fi"></a><strong>regulatory gene</strong> / <a name="BM_(regulatory%20protein)%2Fi"></a><strong>regulatory protein</strong> - The proteins <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>d by these <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> effect <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for certain other <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>. That is, a <a href="#BM_(regulatory%20protein)%2Fi">regulatory protein</a> can cause certain other <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> to be expressed more (promote <a href="#BM_(gene%20expression)%2Fi">gene expression</a>) or less (repress <a href="#BM_(gene%20expression)%2Fi">gene expression</a>).</p>
<p><a href="#BM_(regulatory%20gene)%2Fi">Regulatory gene</a>s are often controlled by external factors (e.g. sunlight, nutrients, temperature, etc..)</p>
</li>
<li>
<p><a name="BM_(feedback%20loop)%2Fi"></a><strong>feedback loop</strong> / <a name="BM_(negative%20feedback%20loop)%2Fi"></a><strong>negative feedback loop</strong> / <a name="BM_(positive%20feedback%20loop)%2Fi"></a><strong>positive feedback loop</strong> - A <a href="#BM_(feedback%20loop)%2Fi">feedback loop</a> is a system where the output (or some part of the output) is fed back into the system to either promote or repress further outputs.</p>
<p><img src="svgbob_3ba8fa4d05a4b9ef40e13dd6d9c7d60ecb9705ad.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BM_(positive%20feedback%20loop)%2Fi">positive feedback loop</a> amplifies the output while a <a href="#BM_(negative%20feedback%20loop)%2Fi">negative feedback loop</a> regulates the output. <a href="#BM_(negative%20feedback%20loop)%2Fi">Negative feedback loop</a>s in particular are important in biology because they allow organisms to maintain homeostasis / equilibrium (keep a consistent internal state). For example, the system that regulates core temperatures in a human is a <a href="#BM_(negative%20feedback%20loop)%2Fi">negative feedback loop</a>. If a human's core temperature gets too...</p>
<ul>
<li>low, they shiver to drive the temperature up.</li>
<li>high, they sweat to drive the temperature down.</li>
</ul>
<p>In the example above, the output is the core temperature. The body monitors its core temperature and employs mechanisms to bring it back to normal if it goes out of range (e.g. sweat, shiver). The outside temperature is influencing the body's core temperature as well as the internal shivering / sweating mechanisms the body employs.</p>
<p><img src="svgbob_894d108e9621a523aaed2c3a3d5d13d20871f1f3.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(circadian%20clock)%2Fi"></a><strong>circadian clock</strong> / <a name="BM_(circadian%20oscillator)%2Fi"></a><strong>circadian oscillator</strong> - A biological clock that synchronizes roughly around the earth's day-night cycle. This internal clock helps many species regulate their physical and behavioural attributes. For example, hunt during the night vs sleep during the day (e.g. nocturnal owls).</p>
</li>
<li>
<p><a name="BM_(upstream%20region)%2Fi"></a><strong>upstream region</strong> - The area just before some interval of DNA. Since the direction of DNA is <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, this area is towards the <a href="#BM_(5')%2Fi">5'</a> end (upper end).</p>
</li>
<li>
<p><a name="BM_(downstream%20region)%2Fi"></a><strong>downstream region</strong> - The area just after some interval of DNA. Since the direction of DNA is <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, this area is towards the <a href="#BM_(3')%2Fi">3'</a> end (lower end).</p>
</li>
<li>
<p><a name="BM_(transcription%20factor)%2Fi"></a><strong>transcription factor</strong> - A <a href="#BM_(regulatory%20protein)%2Fi">regulatory protein</a> that controls the rate of <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> for some <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> that it has influence over (the copying of DNA to mRNA). The protein binds to a specific <a href="#BM_(sequence)%2Fi">sequence</a> in the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a>.</p>
</li>
<li>
<p><a name="BM_(motif)%2Fi"></a><strong>motif</strong> - A pattern that matches against many different <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, where those matched <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s have some shared biological significance. The pattern matches a fixed k where each position may have alternate forms. The simplest way to think of a <a href="#BM_(motif)%2Fi">motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]C</code> may match to ATTGC, ATTCC, TTTGC, and TTTCC.</p>
</li>
<li>
<p><a name="BM_(motif%20member)%2Fi"></a><strong>motif member</strong> <a name="BM_%5Cb(member)_MOTIF%2Fi"></a><strong></strong> - A specific nucleotide <a href="#BM_(sequence)%2Fi">sequence</a> that matches a <a href="#BM_(motif)%2Fi">motif</a>. For example, given a <a href="#BM_(motif)%2Fi">motif</a> represented by the regex <code>[AT]TT[GC]C</code>, the <a href="#BM_(sequence)%2Fi">sequence</a>s ATTGC, ATTCC, TTTGC, and TTTCC would be its <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s.</p>
</li>
<li>
<p><a name="BM_(motif%20matrix%7Cmotif%20matrices)%2Fi"></a><strong>motif matrix</strong> - A set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s stacked on top of each other in a matrix, where the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are either...</p>
<ul>
<li><a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>,</li>
<li>or suspected <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>.</li>
</ul>
<p>For example, the <a href="#BM_(motif)%2Fi">motif</a> <code>[AT]TT[GC]C</code> has the following matrix:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(regulatory%20motif)%2Fi"></a><strong>regulatory motif</strong> - The <a href="#BM_(motif)%2Fi">motif</a> of a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, typically 8 to 12 nucleotides in length.</p>
</li>
<li>
<p><a name="BM_(transcription%20factor%20binding%20site)%2Fi"></a><strong>transcription factor binding site</strong> - The physical binding site for a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. A <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> that's regulated by a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> needs a <a href="#BM_(sequence)%2Fi">sequence</a> located in its <a href="#BM_(upstream%20region)%2Fi">upstream region</a> that the <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> can bind to: a <a href="#BM_(motif%20member)%2Fi">motif member</a> of that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a> is the 600 to 1000 nucleotides preceding the start of the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>.</p>
</div>
</li>
<li>
<p><a name="BM_(cDNA)%2F"></a><strong>cDNA</strong> - A single strand of DNA generated from mRNA. The enzyme reverse transcriptase scans over the mRNA and creates the complementing single DNA strand.</p>
<p><img src="svgbob_97c5d076bf0a1cd98b75bbb88b72fc29c3b1b93d.svg" alt="Kroki diagram output"></p>
<p>The mRNA portion breaks off, leaving the <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>.</p>
<p><img src="svgbob_97e71090d31bdaa40278b0e705aef4e3555be8e3.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(DNA%20microarray)%2Fi"></a><strong>DNA microarray</strong> / <a name="BM_(DNA%20array)%2Fi"></a><strong>DNA array</strong> - A device used to compare <a href="#BM_(gene%20expression)%2Fi">gene expression</a>. This works by measuring 2 mRNA samples against each other: a control sample and an experimental sample. The samples could be from...</p>
<ul>
<li>the same organism but at different times.</li>
<li>diseased and healthy versions of the same organism.</li>
<li>etc..</li>
</ul>
<p>Both mRNA samples are converted to <a href="#BM_(cDNA)%2F">cDNA</a> and are given fluorescent dyes. The control sample gets dyed green while the experimental sample gets dyed red.</p>
<p><img src="svgbob_6ce607591d81d0fd6c7507408e97fb8146e83baf.svg" alt="Kroki diagram output"></p>
<p>A sheet is broken up into multiple regions, where each region has the <a href="#BM_(cDNA)%2F">cDNA</a> for one specific <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> from the control sample printed.</p>
<p><img src="svgbob_421210658cf3b4d0040b4815e879948ebfd7ccc5.svg" alt="Kroki diagram output"></p>
<p>The idea is that once the experimental <a href="#BM_(cDNA)%2F">cDNA</a> is introduced to that region, it should bind to the control <a href="#BM_(cDNA)%2F">cDNA</a> that's been printed to form <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a>. The color emitted in a region should correspond to the amount of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> that region represents. For example, if a region on the sheet is fully yellow, it means that the <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for that <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is roughly equal (red mixed with green is yellow).</p>
</li>
<li>
<p><a name="BM_(greedy%20algorithm)%2Fi"></a><strong>greedy algorithm</strong> - An algorithm that tries to speed things up by taking the locally optimal choice at each step. That is, the algorithm doesn't look more than 1 step ahead.</p>
<p>For example, imagine a chess playing AI that had a strategy of trying to eliminate the other player's most valuable piece at each turn. It would be considered greedy because it only looks 1 move ahead before taking action. Normal chess AIs / players look many moves ahead before taking action. As such, the greedy AI may be fast but it would very likely lose most matches.</p>
</li>
<li>
<p><a name="BM_(Cromwell's%20rule)%2Fi"></a><strong>Cromwell's rule</strong> - When a probability is based off past events, 0.0 and 1.0 shouldn't be used. That is, if you've...</p>
<ul>
<li>never seen an even occur in the past, it doesn't mean that there's a 0.0 probability of it occurring next.</li>
<li>always seen an event occur in the past, it doesn't mean that there's a 1.0 probability of it occurring next.</li>
</ul>
<p>Unless you're dealing with hard logical statements where prior occurrences don't come in to play (e.g. 1+1=2), you should include a small chance that some extremely unlikely event may happen. The example tossed around is "the probability that the sun will not rise tomorrow." Prior recorded observations show that sun has always risen, but that doesn't mean that there's a 1.0 probability of the sun rising tomorrow (e.g. some extremely unlikely cataclysmic event may prevent the sun from rising).</p>
</li>
<li>
<p><a name="BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi"></a><strong>Laplace's rule of succession</strong> - If some independent true/false event occurs n times, and s of those n times were successes, it's natural for people to assume the probability of success is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>s</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{s}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>. However, if the number of successes is 0, the probability would be 0.0. <a href="#BM_(Cromwell's%20rule)%2Fi">Cromwell's rule</a> states that when a probability is based off past events, 0.0 and 1.0 shouldn't be used. As such, a more appropriate / meaningful measure of probability is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+1}{n+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p>
<p>For example, imagine you're sitting on a park bench having lunch. Of the 8 birds you've seen since starting your lunch, all have been pigeons. If you were to calculate the probability that the next bird you'll see a crow, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{0}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> would be flawed because it states that there's no chance that the next bird will be a crow (there obviously is a chance, but it may be a small chance). Instead, applying <a href="#BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi">Laplace's rule</a> allows for the small probability that a crow may be seen next: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>0</mn><mo>+</mo><mn>1</mn></mrow><mrow><mn>8</mn><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{0+1}{8+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p>
<p><a href="#BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi">Laplace's rule of succession</a> is more meaningful when the number of trials (n) is small.</p>
</li>
<li>
<p><a name="BM_(pseudocount)%2Fi"></a><strong>pseudocount</strong> - When a zero is replaced with a small number to prevent unfair scoring. See <a href="#BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi">Laplace's rule of succession</a>.</p>
</li>
<li>
<p><a name="BM_(randomized%20algorithm)%2Fi"></a><strong>randomized algorithm</strong> - An algorithm that uses a source of randomness as part of its logic. <a href="#BM_(randomized%20algorithm)%2Fi">Randomized algorithm</a>s come in two forms: <a href="#BM_(Las%20Vegas%20algorithm)%2Fi">Las Vegas algorithm</a>s and <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">Monte Carlo algorithm</a>s</p>
</li>
<li>
<p><a name="BM_(Las%20Vegas%20algorithm)%2Fi"></a><strong>Las Vegas algorithm</strong> - A <a href="#BM_(randomized%20algorithm)%2Fi">randomized algorithm</a> that delivers a guaranteed exact solution. That is, even though the algorithm makes random decisions it is guaranteed to converge on the exact solution to the problem its trying to solve (not an approximate solution).</p>
<p>An example of a <a href="#BM_(Las%20Vegas%20algorithm)%2Fi">Las Vegas algorithm</a> is randomized quicksort (randomness is applied when choosing the pivot).</p>
</li>
<li>
<p><a name="BM_(Monte%20Carlo%20algorithm)%2Fi"></a><strong>Monte Carlo algorithm</strong> - A <a href="#BM_(randomized%20algorithm)%2Fi">randomized algorithm</a> that delivers an approximate solution. Because these algorithms are quick, they're typically run many times. The approximation considered the best out of all runs is the one that gets chosen as the solution.</p>
<p>An example of a <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">Monte Carlo algorithm</a> is a genetic algorithm to optimize the weights of a deep neural network. That is, a step of the optimization requires running n different neural networks to see which gives the best result, then replacing those n networks with n copies of the best performing network where each copy has randomly tweaked weights. At some point the algorithm will stop producing incrementally better results.</p>
<p>Perform the optimization (the entire thing, not just a single step) thousands of times and pick the best network.</p>
</li>
<li>
<p><a name="BM_(consensus%20string%7Cconsensus%20sequence)%2Fi"></a><strong>consensus string</strong> - The <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> generated by selecting the most abundant column at each index of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 1</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 2</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 3</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 4</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 5</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>consensus</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>The generated <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may also use a <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a>. The <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a> for the same matrix above using <a href="#BM_(IUPAC%20nucleotide%20code)%2Fi">IUPAC nucleotide code</a>s: <code>WTTSS</code>.</p>
</li>
<li>
<p><a name="BM_(entropy)%2Fi"></a><strong>entropy</strong> - The uncertainty associated with a random variable. Given some set of outcomes for a variable, it's calculated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\sum_{i=1}^{n} P(x_i) log P(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>This definition is for information theory. In other contexts (e.g. physics, economics), this term has a different meaning.</p>
</li>
<li>
<p><a name="BM_(genome)%2Fi"></a><strong>genome</strong> - All of the DNA for some organism.</p>
</li>
<li>
<p><a name="BM_(sequence)%2Fi"></a><strong>sequence</strong> - The ordered elements that make up some biological entity. For example, a ...</p>
<ul>
<li>DNA <a href="#BM_(sequence)%2Fi">sequence</a> contains the set of nucleotides and their positions for that DNA strand.</li>
<li><a href="#BM_(peptide)%2Fi">peptide</a> <a href="#BM_(sequence)%2Fi">sequence</a> contains the set of <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s and their positions for that <a href="#BM_(peptide)%2Fi">peptide</a>.</li>
</ul>
</li>
<li>
<p><a name="BM_(sequencing%7Csequenced)%2Fi"></a><strong>sequencing</strong> - The process of determining which nucleotides are assigned to which positions in a strand of DNA or RNA.</p>
<p>The machinery used for DNA <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> is called a <a href="#BM_(sequencer)%2Fi">sequencer</a>. A <a href="#BM_(sequencer)%2Fi">sequencer</a> takes multiple copies of the same DNA, breaks that DNA up into smaller fragments, and scans in those <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s. Each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> is typically the same length but has a unique starting offset. Because the starting offsets are all different, the original larger DNA <a href="#BM_(sequence)%2Fi">sequence</a> can be guessed at by finding <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> with overlapping regions and stitching them together.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 2</td>
<td></td>
<td></td>
<td></td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 3</td>
<td></td>
<td></td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 4</td>
<td></td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 5</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reconstructed</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(sequencer)%2Fi"></a><strong>sequencer</strong> - A machine that performs DNA or RNA <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>.</p>
</li>
<li>
<p><a name="BM_(sequencing%20error)%2Fi"></a><strong>sequencing error</strong> - An error caused by a <a href="#BM_(sequencer)%2Fi">sequencer</a> returning a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> where a nucleotide was misinterpreted at one or more positions (e.g. offset 3 was actually a C but it got scanned in as a G).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This term may also be used in reference to homopolymer errors, known to happen with nanopore technology. From <a href="https://news.ycombinator.com/item?id=25459670">here</a>...</p>
<blockquote>
<p>A homopolymer is when you have stretches of the same nucleotide, and the error is miscounting the number of them. e.g: GAAAC could be called as "GAAC" or "GAAAAC" or even "GAAAAAAAC".</p>
</blockquote>
</div>
</li>
<li>
<p><a name="BM_%5Cb(read)_SEQ%2Fi"></a><strong>read</strong> - A segment of <a href="#BM_(genome)%2Fi">genome</a> scanned in during the process of <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>.</p>
</li>
<li>
<p><a name="BM_(read-pair%7Cread%20pair)%2Fi"></a><strong>read-pair</strong> - A segment of <a href="#BM_(genome)%2Fi">genome</a> scanning in during the process of <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>, where the middle of the segment is unknown. That is, the first k elements and the last k elements are known, but the d elements in between aren't known. The total size of the segment is 2k + d.</p>
<p><a href="#BM_(sequencer)%2Fi">Sequencer</a>s provide <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s as an alternative to longer <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s because the longer a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> is the more errors it contains.</p>
<p>See <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a>.</p>
</li>
<li>
<p><a name="BM_(fragment)_SEQ%2Fi"></a><strong>fragment</strong> - A scanned <a href="#BM_(sequence)%2Fi">sequence</a> returned by a <a href="#BM_(sequencer)%2Fi">sequencer</a>. Represented as either a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> or a <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>.</p>
</li>
<li>
<p><a name="BM_(assembly%7Cassemble)%2Fi"></a><strong>assembly</strong> - The process of stitching together overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s to guess the <a href="#BM_(sequence)%2Fi">sequence</a> of the original larger DNA <a href="#BM_(sequence)%2Fi">sequence</a> that those <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from.</p>
</li>
<li>
<p><a name="BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi"></a><strong>hybrid alphabet</strong> - When representing a <a href="#BM_(sequence)%2Fi">sequence</a> that isn't fully conserved, it may be more appropriate to use an alphabet where each letter can represent more than 1 nucleotide. For example, the <a href="#BM_(IUPAC%20nucleotide%20code)%2Fi">IUPAC nucleotide code</a>s provides the following alphabet:</p>
<ul>
<li>A = A</li>
<li>C = C</li>
<li>T = T</li>
<li>G = G</li>
<li>W = A or T</li>
<li>S = G or C</li>
<li>K = G or T</li>
<li>Y = C or T</li>
<li>...</li>
</ul>
<p>If the <a href="#BM_(sequence)%2Fi">sequence</a> being represented can be either AAAC or AATT, it may be easier to represent a single string of AAWY.</p>
</li>
<li>
<p><a name="BM_(IUPAC%20nucleotide%20code)%2Fi"></a><strong>IUPAC nucleotide code</strong> - A <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> with the following mapping:</p>
<table>
<thead>
<tr>
<th>Letter</th>
<th>Base</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Adenine</td>
</tr>
<tr>
<td>C</td>
<td>Cytosine</td>
</tr>
<tr>
<td>G</td>
<td>Guanine</td>
</tr>
<tr>
<td>T (or U)</td>
<td>Thymine (or Uracil)</td>
</tr>
<tr>
<td>R</td>
<td>A or G</td>
</tr>
<tr>
<td>Y</td>
<td>C or T</td>
</tr>
<tr>
<td>S</td>
<td>G or C</td>
</tr>
<tr>
<td>W</td>
<td>A or T</td>
</tr>
<tr>
<td>K</td>
<td>G or T</td>
</tr>
<tr>
<td>M</td>
<td>A or C</td>
</tr>
<tr>
<td>B</td>
<td>C or G or T</td>
</tr>
<tr>
<td>D</td>
<td>A or G or T</td>
</tr>
<tr>
<td>H</td>
<td>A or C or T</td>
</tr>
<tr>
<td>V</td>
<td>A or C or G</td>
</tr>
<tr>
<td>N</td>
<td>any base</td>
</tr>
<tr>
<td>. or -</td>
<td>gap</td>
</tr>
</tbody>
</table>
<p><a href="https://www.bioinformatics.org/sms/iupac.html">Source</a>.</p>
</li>
<li>
<p><a name="BM_(%5Cblogo%7Csequence%20logo)%2Fi"></a><strong>sequence logo</strong> - A graphical representation of how conserved a <a href="#BM_(sequence)%2Fi">sequence</a>'s positions are. Each position has its possible nucleotides stacked on top of each other, where the height of each nucleotide is based on how conserved it is. The more conserved a position is, the taller that column will be.</p>
<p>Typically applied to DNA or RNA, and May also be applied to other biological <a href="#BM_(sequence)%2Fi">sequence</a> types (e.g. <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s).</p>
<p>The following is an example of a <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">logo</a> generated from a <a href="#BM_(motif)%2Fi">motif</a> <a href="#BM_(sequence)%2Fi">sequence</a>:</p>
<div style="border:1px solid black;">
<p></p>
<p>Generating logo for the following motif matrix...</p>
<p>TCGGGGGTTTTT<br>CCGGTGACTTAC<br>ACGGGGATTTTC<br>TTGGGGACTTTT<br>AAGGGGACTTCC<br>TTGGGGACTTCC<br>TCGGGGATTCAT<br>TCGGGGATTCCT<br>TAGGGGAACTAC<br>TCGGGTATAACC</p>
<p>Result...</p>
<p><img src="motif_logo_01b7e8763a84973751af52163d52f5bd.svg" alt="Motif Logo"></p>
</div>
<p></p>
</li>
<li>
<p><a name="BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi"></a><strong>transposon</strong> - A DNA <a href="#BM_(sequence)%2Fi">sequence</a> that can change its position within a <a href="#BM_(genome)%2Fi">genome</a>, altering the <a href="#BM_(genome)%2Fi">genome</a> size. They come in two flavours:</p>
<ul>
<li>Class I (retro<a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>) - Behaves similarly to copy-and-paste where the <a href="#BM_(sequence)%2Fi">sequence</a> is duplicated. DNA is <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to RNA, followed by that RNA being reverse <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> back to DNA by an enzyme called reverse transcriptase.</li>
<li>Class II (DNA <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>) - Behaves similarly to cut-and-paste where the <a href="#BM_(sequence)%2Fi">sequence</a> is moved. DNA is physically cut out by an enzyme called transposases and placed back in at some other location.</li>
</ul>
<p>Often times, <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>s cause disease. For example, ...</p>
<ul>
<li>insertion of a <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a> into a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> will likely disable that <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>.</li>
<li>after a <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a> leaves a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>, the gap likely won't be repaired correctly.</li>
</ul>
</li>
<li>
<p><a name="BM_(adjacency%20list)%2Fi"></a><strong>adjacency list</strong> - An internal representation of a graph where each node has a list of pointers to other nodes that it can forward to.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
<p>The graph above represented as an <a href="#BM_(adjacency%20list)%2Fi">adjacency list</a> would be...</p>
<table>
<thead>
<tr>
<th>From</th>
<th>To</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
</tr>
<tr>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>D,E</td>
</tr>
<tr>
<td>D</td>
<td>F</td>
</tr>
<tr>
<td>E</td>
<td>D,F</td>
</tr>
<tr>
<td>F</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(adjacency%20matrix)%2Fi"></a><strong>adjacency matrix</strong> - An internal representation of a graph where a matrix defines the number of times that each node forwards to every other node.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
<p>The graph above represented as an <a href="#BM_(adjacency%20matrix)%2Fi">adjacency matrix</a> would be...</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi"></a><strong>Hamiltonian path</strong> - A path in a graph that visits every node exactly once.</p>
<p>The graph below has the <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> ABCEDF.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(Eulerian%20path)%2Fi"></a><strong>Eulerian path</strong> <a name="BM_(Eulerian)_PATH%2Fi"></a><strong></strong> - A path in a graph that visits every edge exactly once.</p>
<p>In the graph below, the <a href="#BM_(Eulerian%20path)%2Fi">Eulerian path</a> is (A,B), (B,C), (C,D), (D,E), (E,C), (C,D), (D,F).</p>
<p><img src="svgbob_87660b191d813d39c396985391b70507c8c1236b.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(Eulerian%20cycle)%2Fi"></a><strong>Eulerian cycle</strong> <a name="BM_(Eulerian)_CYCLE%2Fi"></a><strong></strong> - An <a href="#BM_(Eulerian%20path)%2Fi">Eulerian path</a> that forms a cycle. That is, a path in a graph that is a cycle and visits every edge exactly once.</p>
<p>The graph below has an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> of (A,B), (B,C) (C,D), (D,F), (F,C), (C,A).</p>
<p><img src="svgbob_244dd1930eb16ef58be2261f1ffb9277ad2d793a.svg" alt="Kroki diagram output"></p>
<p>If a graph contains an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>, it's said to be an <a href="#BM_(Eulerian%20graph)%2Fi">Eulerian graph</a>.</p>
</li>
<li>
<p><a name="BM_(Eulerian%20graph)%2Fi"></a><strong>Eulerian graph</strong> <a name="BM_(Eulerian)_GRAPH%2Fi"></a><strong></strong> - For a graph to be <a href="#BM_(Eulerian)_GRAPH%2Fi">Eulerian</a>, it must have am <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>. For a graph to have an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>, it must be both <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> and <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>.</p>
<p><img src="svgbob_d0af75d07c2969afc5f4088d18d3b7a327f26ef2.svg" alt="Kroki diagram output"></p>
<p>Note how in the graph above, ...</p>
<ul>
<li>
<p>every node is reachable from every other node (<a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>),</p>
</li>
<li>
<p>every node has an <a href="#BM_(outdegree)%2Fi">outdegree</a> equal to its <a href="#BM_(indegree)%2Fi">indegree</a> (<a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>).</p>
<table>
<thead>
<tr>
<th>Node</th>
<th><a href="#BM_(indegree)%2Fi">Indegree</a></th>
<th><a href="#BM_(outdegree)%2Fi">Outdegree</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>In contrast, the following graphs are not <a href="#BM_(Eulerian%20graph)%2Fi">Eulerian graph</a>s (no <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s exist):</p>
<ul>
<li>
<p><a href="#BM_(strongly%20connected)%2Fi">Strongly connected</a> but not <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>.</p>
<p><img src="svgbob_efdff1b3ec66000b9acf2ddc84c2d3684d318683.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_(balanced)_GRAPH%2Fi">Balanced</a> but not <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>.</p>
<p><img src="svgbob_48abea7e0377d91bfd845a85b2ee9615e9852bfd.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_(balanced)_GRAPH%2Fi">Balanced</a> but <a href="#BM_(disconnected)%2Fi">disconnected</a> (not <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>).</p>
<p><img src="svgbob_1f6d7503fdb3f3654b3c64f041254352c8d9a43e.svg" alt="Kroki diagram output"></p>
</li>
</ul>
</li>
<li>
<p><a name="BM_(disconnected)%2Fi"></a><strong>disconnected</strong> / <a name="BM_(connected)%2Fi"></a><strong>connected</strong> - A graph is <a href="#BM_(disconnected)%2Fi">disconnected</a> if you can break it out into 2 or more distinct sub-graphs without breaking any paths. In other words, the graph contains at least two nodes which aren't contained in any path.</p>
<p>The graph below is <a href="#BM_(disconnected)%2Fi">disconnected</a> because there is no path that contains E, F, G, or H and A, B, C, or D.</p>
<p><img src="svgbob_754a446a49b8209971f339d76f4fcc492acbb615.svg" alt="Kroki diagram output"></p>
<p>The graph below is <a href="#BM_(connected)%2Fi">connected</a>.</p>
<p><img src="svgbob_028c9291a4412afebe0b605b464987e2c9bf75ef.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(strongly%20connected)%2Fi"></a><strong>strongly connected</strong> - A graph is <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> if every node is reachable from every other node.</p>
<p>The graph below is <strong>not</strong> <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> because neither A nor B is reachable by C, D, E, or F.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
<p>The graph below is <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> because all nodes are reachable from all nodes.</p>
<p><img src="svgbob_244dd1930eb16ef58be2261f1ffb9277ad2d793a.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(indegree)%2Fi"></a><strong>indegree</strong> / <a name="BM_(outdegree)%2Fi"></a><strong>outdegree</strong> - The number of edges leading into / out of a node of a directed graph.</p>
<p>The node below has an <a href="#BM_(indegree)%2Fi">indegree</a> of 3 and an <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1.</p>
<p><img src="svgbob_7159ebaf654fe57b46d2f14a29a73d50e280afe6.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(balanced%20node)%2Fi"></a><strong>balanced node</strong> <a name="BM_(balanced)_NODE%2Fi"></a><strong></strong> - A node of a directed graph that has an equal <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a>. That is, the number of edges coming in is equal to the number of edges going out.</p>
<p>The node below has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1. It is <a href="#BM_(balanced)_NODE%2Fi">balanced</a>.</p>
<p><img src="svgbob_7c49a4fbe8fc85173147545e7a459bca61c84f26.svg" alt="Kroki diagram output"></p>
<p></p>
</li>
<li>
<p><a name="BM_(balanced%20graph)%2Fi"></a><strong>balanced graph</strong> <a name="BM_(balanced)_GRAPH%2Fi"></a><strong></strong> - A directed graph where ever node is <a href="#BM_(balanced)_NODE%2Fi">balanced</a>.</p>
<p>The graph below is <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> because all nodes are <a href="#BM_(balanced)_NODE%2Fi">balanced</a>.</p>
<p><img src="svgbob_244dd1930eb16ef58be2261f1ffb9277ad2d793a.svg" alt="Kroki diagram output"></p>
<table>
<thead>
<tr>
<th>Node</th>
<th><a href="#BM_(indegree)%2Fi">Indegree</a></th>
<th><a href="#BM_(outdegree)%2Fi">Outdegree</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p></p>
</li>
<li>
<p><a name="BM_(overlap%20graph)%2Fi"></a><strong>overlap graph</strong> - A graph representing the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s making up a string. Specifically, the graph is built in 2 steps:</p>
<ol>
<li>
<p>Each node is a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</p>
<p><img src="svgbob_ba61508d2d4f3dfef58ce5783f8e22f49ddec891.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>Each edge is between overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s (nodes), where the ...</p>
<ul>
<li>source node has the overlap in its suffix .</li>
<li>destination node has the overlap in its prefix.</li>
</ul>
<p><img src="svgbob_679d24959920acb04c059d6e53dee545fff77300.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p><a href="#BM_(overlap%20graph)%2Fi">Overlap graph</a>s used for <a href="#BM_(genome)%2Fi">genome</a> <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</p>
</li>
<li>
<p><a name="BM_(de%20Bruijn%20graph)%2Fi"></a><strong>de Bruijn graph</strong> - A special graph representing the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s making up a string. Specifically, the graph is built in 2 steps:</p>
<ol>
<li>
<p>Each <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is represented as an edge connecting 2 nodes. The ...</p>
<ul>
<li>source node represents the first 0 to n-1 elements of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>,</li>
<li>destination node represents last 1 to n elements of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>,</li>
<li>and edge represents the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>.</li>
</ul>
<p>For example, ...</p>
<p><img src="svgbob_8e6112b97be535a52f2be925bb5b56b546699aaa.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>Each node representing the same value is merged together to form the graph.</p>
<p>For example, ...</p>
<p><img src="svgbob_cfa519e3b0b53ea602d7a16720f54ea9c85f3f08.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s are used for <a href="#BM_(genome)%2Fi">genome</a> <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>. It's much faster to <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a> a <a href="#BM_(genome)%2Fi">genome</a> from a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> than it is to from an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>s.</p>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s were originally invented to solve the <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> string problem.</p>
</li>
<li>
<p><a name="BM_(k-universal%7C%5Cd%2B-universal)%2Fi"></a><strong>k-universal</strong> - For some alphabet and k, a string is considered <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> if it contains every <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> for that alphabet exactly once. For example, for an alphabet containing only 0 and 1 (binary) and k=3, a <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">3-universal</a> string would be 0001110100 because it contains every <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">3-mer</a> exactly once:</p>
<ul>
<li>000: <strong>000</strong>1110100</li>
<li>001: 0<strong>001</strong>110100</li>
<li>010: 000111<strong>010</strong>0</li>
<li>011: 00<strong>011</strong>10100</li>
<li>100: 0001110<strong>100</strong></li>
<li>101: 00011<strong>101</strong>00</li>
<li>110: 0001<strong>110</strong>100</li>
<li>111: 000<strong>111</strong>0100</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is effectively <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>. There are a set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s and they're being stitched together to form a larger string. The only difference is that the elements aren't nucleotides.</p>
</div>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s were invented in an effort to construct <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> strings for arbitrary values of k. For example, given the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in the example above (000, 001, ...), a <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> string can be found by constructing a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> from the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s and finding a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> in that graph.</p>
<p><img src="svgbob_f05ffef51444183bdc007d88010e832876608ed7.svg" alt="Kroki diagram output"></p>
<p>There are multiple <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s in the graph, meaning that there are multiple <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">3-universal</a> strings:</p>
<ul>
<li>0001110100</li>
<li>0011101000</li>
<li>1110001011</li>
<li>1100010111</li>
<li>...</li>
</ul>
<p>For larger values of k (e.g. 20), finding <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> strings would be too computationally intensive without <a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s and <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s.</p>
</li>
<li>
<p><a name="BM_(coverage)_SEQ%2Fi"></a><strong>coverage</strong> - Given a substring from some larger <a href="#BM_(sequence)%2Fi">sequence</a> that was reconstructed from a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s, the <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> of that substring is the number of <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s used to construct it. The substring length is typically 1: the <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> for each position of the <a href="#BM_(sequence)%2Fi">sequence</a>.</p>
<p><img src="svgbob_8dd35ba9a6498739b4dd8f3759fd49dec3d1e9c8.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi"></a><strong>read breaking</strong> - The concept of taking multiple <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s and breaking them up into smaller <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s.</p>
<p><img src="svgbob_d9e103b16312cfe660d19df9305a9361ac1241ac.svg" alt="Kroki diagram output"></p>
<p>When <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a>, smaller <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s result in better <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> but also make the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> more tangled. The more tangled the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> is, the harder it is to infer the full <a href="#BM_(sequence)%2Fi">sequence</a>.</p>
<p>In the example above, the average <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>...</p>
<ul>
<li>for the left-hand side (original) is 2.1.</li>
<li>for the right-hand side (broken) is 4.</li>
</ul>
<p>See also: <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What purpose does this actually serve? Mimicking 1 long <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> as n shorter <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s isn't equivalent to actually having <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a> those n shorter <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s. For example, what if the longer <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> being broken up has an error? That error replicates when breaking into n shorter <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s, which gives a false sense of having good <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> and makes it seems as if it wasn't an error.</p>
</div>
</li>
<li>
<p><a name="BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi"></a><strong>read-pair breaking</strong> - The concept of taking multiple <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s and breaking them up into <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s with a smaller k.</p>
<p><img src="svgbob_eb8f1251b4e293a9662ade2c0a4452a7c7884f2f.svg" alt="Kroki diagram output"></p>
<p>When <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>, a smaller k results in better <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> but also make the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> more tangled. The more tangled the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> is, the harder it is to infer the full <a href="#BM_(sequence)%2Fi">sequence</a>.</p>
<p>In the example above, the average <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>...</p>
<ul>
<li>for the left-hand side (original) is 1.6.</li>
<li>for the right-hand side (broken) is 2.5.</li>
</ul>
<p>See also: <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What purpose does this actually serve? Mimicking 1 long <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> as n shorter <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s isn't equivalent to actually having <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a> those n shorter <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s. For example, what if the longer <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> being broken up has an error? That error replicates when breaking into n shorter <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s, which gives a false sense of having good <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> and makes it seems as if it wasn't an error.</p>
</div>
</li>
<li>
<p><a name="BM_(contig)s%3F%5Cb%2Fi"></a><strong>contig</strong> - An unambiguous stretch of DNA derived by searching an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> / <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> for paths that are the longest possible stretches of non-branching nodes (<a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1). Each stretch will be a path that's either  ...</p>
<ul>
<li>
<p>a line: each node has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1.</p>
<p><img src="svgbob_8f50e668ad56e2eeff3c39e6aa89792f6f9444f9.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>a cycle: each node has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1 and it loops.</p>
<p><img src="svgbob_9a5c6dc10a8a016d6f43d4c9bdd6243d0ee5b332.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>a line sandwiched between branching nodes: nodes in between have an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1 but either...</p>
<ul>
<li>starts at a node where <a href="#BM_(indegree)%2Fi">indegree</a> != 1 but <a href="#BM_(outdegree)%2Fi">outdegree</a> == 1 (incoming branch),</li>
<li>or ends at a node where <a href="#BM_(indegree)%2Fi">indegree</a> == 1 but <a href="#BM_(outdegree)%2Fi">outdegree</a> != 1 (outgoing branch),</li>
<li>or both.</li>
</ul>
<p><img src="svgbob_057bcd0e831c50ca2384b8da9ea9cd1f46186b4a.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<p>Real-world complications with DNA <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> make de Bruijn / <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>s too tangled to guess a full <a href="#BM_(genome)%2Fi">genome</a>: both strands of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">double-stranded DNA</a> are <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a> and mixed into the graph, <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s make into the graph, repeats regions of the <a href="#BM_(genome)%2Fi">genome</a> can't be reliably handled by the graph, poor <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>, etc.. As such, biologists / bioinformaticians have no choice but to settle on <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s.</p>
<p><img src="svgbob_db2c0ed38b3144b9db68bc5e39f4b97ce471f510.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(ribonucleotide)%2Fi"></a><strong>ribonucleotide</strong> - Elements that make up RNA, similar to how nucleotides are the elements that make up DNA.</p>
<ul>
<li>A = Adenine (same as nucleotide)</li>
<li>C = Cytosine (same as nucleotide)</li>
<li>G = Guanine (same as nucleotide)</li>
<li>U = Uracil (replace nucleotide Thymine)</li>
</ul>
</li>
<li>
<p><a name="BM_(antibiotic)%2Fi"></a><strong>antibiotic</strong> - A substance (typically an enzyme) for killing, preventing, or inhibiting the grow of bacterial infections.</p>
</li>
<li>
<p><a name="BM_(amino%20acid)%2Fi"></a><strong>amino acid</strong> - The building blocks of <a href="#BM_(peptide)%2Fi">peptide</a>s / proteins, similar to how nucleotides are the building blocks of DNA.</p>
<table>
<thead>
<tr>
<th>1 Letter Code</th>
<th>3 Letter Code</th>
<th><a href="#BM_(amino%20acid)%2Fi">Amino Acid</a></th>
<th>Mass (<a href="#BM_(dalton)%2Fi">dalton</a>s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Ala</td>
<td>Alanine</td>
<td>71.04</td>
</tr>
<tr>
<td>C</td>
<td>Cys</td>
<td>Cysteine</td>
<td>103.01</td>
</tr>
<tr>
<td>D</td>
<td>Asp</td>
<td>Aspartic acid</td>
<td>115.03</td>
</tr>
<tr>
<td>E</td>
<td>Glu</td>
<td>Glutamic acid</td>
<td>129.04</td>
</tr>
<tr>
<td>F</td>
<td>Phe</td>
<td>Phenylalanine</td>
<td>147.07</td>
</tr>
<tr>
<td>G</td>
<td>Gly</td>
<td>Glycine</td>
<td>57.02</td>
</tr>
<tr>
<td>H</td>
<td>His</td>
<td>Histidine</td>
<td>137.06</td>
</tr>
<tr>
<td>I</td>
<td>Ile</td>
<td>Isoleucine</td>
<td>113.08</td>
</tr>
<tr>
<td>K</td>
<td>Lys</td>
<td>Lysine</td>
<td>128.09</td>
</tr>
<tr>
<td>L</td>
<td>Leu</td>
<td>Leucine</td>
<td>113.08</td>
</tr>
<tr>
<td>M</td>
<td>Met</td>
<td>Methionine</td>
<td>131.04</td>
</tr>
<tr>
<td>N</td>
<td>Asn</td>
<td>Asparagine</td>
<td>114.04</td>
</tr>
<tr>
<td>P</td>
<td>Pro</td>
<td>Proline</td>
<td>97.05</td>
</tr>
<tr>
<td>Q</td>
<td>Gln</td>
<td>Glutamine</td>
<td>128.06</td>
</tr>
<tr>
<td>R</td>
<td>Arg</td>
<td>Arginine</td>
<td>156.1</td>
</tr>
<tr>
<td>S</td>
<td>Ser</td>
<td>Serine</td>
<td>87.03</td>
</tr>
<tr>
<td>T</td>
<td>Thr</td>
<td>Threonine</td>
<td>101.05</td>
</tr>
<tr>
<td>V</td>
<td>Val</td>
<td>Valine</td>
<td>99.07</td>
</tr>
<tr>
<td>W</td>
<td>Trp</td>
<td>Tryptophan</td>
<td>186.08</td>
</tr>
<tr>
<td>Y</td>
<td>Tyr</td>
<td>Tyrosine</td>
<td>163.06</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The masses are monoisotopic masses.</p>
</div>
</li>
<li>
<p><a name="BM_(peptide)%2Fi"></a><strong>peptide</strong> - A short <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain of at least size two. <a href="#BM_(peptide)%2Fi">Peptide</a>s are considered miniature proteins, but when something should be called a <a href="#BM_(peptide)%2Fi">peptide</a> vs a protein is loosely defined: the cut-off is anywhere between 50 to 100 <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s.</p>
</li>
<li>
<p><a name="BM_(polypeptide)%2Fi"></a><strong>polypeptide</strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> of at least size 10.</p>
</li>
<li>
<p><a name="BM_(cyclopeptide%7Ccyclic%20peptide)%2Fi"></a><strong>cyclopeptide</strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> that doesn't have a start / end. It loops.</p>
<p><img src="svgbob_0de8076d92d299650e3473fc869328891e1ef452.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(linear%20peptide)%2Fi"></a><strong>linear peptide</strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> that has a start and an end. It doesn't loop.</p>
<p><img src="svgbob_1a5d3942fce4284a9ad77c8e4624b7b21573543d.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(subpeptide)%2Fi"></a><strong>subpeptide</strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> derived taking some contiguous piece of a larger <a href="#BM_(peptide)%2Fi">peptide</a>.</p>
<p>A <a href="#BM_(subpeptide)%2Fi">subpeptide</a> can have a length == 1 where a <a href="#BM_(peptide)%2Fi">peptide</a> must have a length &gt; 1. As such, in the case where the <a href="#BM_(subpeptide)%2Fi">subpeptide</a> has a length ...</p>
<ul>
<li>== 1, it isn't considered a <a href="#BM_(peptide)%2Fi">peptide</a>.</li>
<li>&gt; 1, it is considered a <a href="#BM_(peptide)%2Fi">peptide</a>.</li>
</ul>
</li>
<li>
<p><a name="BM_(central%20dogma%20of%20molecular%20biology)%2Fi"></a><strong>central dogma of molecular biology</strong> - The overall concept of <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> and <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>: Instructions for making a protein are copied from DNA to RNA, then RNA feeds into the ribosome to make that protein (DNA → RNA → Protein).</p>
<p>Most, not all, <a href="#BM_(peptide)%2Fi">peptide</a>s are synthesized as described above. <a href="#BM_(non-ribosomal%20peptide)%2Fi">Non-ribosomal peptide</a>s are synthesized outside of the <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> and <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>.</p>
</li>
<li>
<p><a name="BM_(non-ribosomal%20peptide)%2Fi"></a><strong>non-ribosomal peptide</strong> <a name="BM_%5Cb(NRP)%5Cb%2Fi"></a><strong></strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> that was synthesized by a protein called <a href="#BM_%5Cb(NRP)%5Cb%2Fi">NRP</a> synthetase rather than synthesized by a ribosome. <a href="#BM_%5Cb(NRP)%5Cb%2Fi">NRP</a> synthetase builds <a href="#BM_(peptide)%2Fi">peptide</a>s one <a href="#BM_(amino%20acid)%2Fi">amino acid</a> at a time without relying on <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> or <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>.</p>
<p><a href="#BM_(non-ribosomal%20peptide)%2Fi">Non-ribosomal peptide</a>s may be cyclic. Common use-cases for <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a>s:</p>
<ul>
<li><a href="#BM_(antibiotic)%2Fi">antibiotic</a>s</li>
<li>anti-tumor agents</li>
<li>immunosuppressors</li>
<li>communication between bacteria (quorum sensing)</li>
</ul>
</li>
<li>
<p><a name="BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi"></a><strong>mass spectrometer</strong> - A device that randomly shatters molecules into pieces and measures the mass-to-charge of those pieces. The output of the device is a plot called a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a>.</p>
<p>Note that <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>s have various real-world practical problems. Specifically, they ...</p>
<ul>
<li>may not capture all possible pieces from the intended molecules (missing mass-to-charge ratios).</li>
<li>may capture pieces from unintended molecules (faulty mass-to-charge ratios).</li>
<li>will likely introduce noise into the pieces they capture.</li>
</ul>
</li>
<li>
<p><a name="BM_(spectrum)_MS%2Fi"></a><strong>spectrum</strong> - The output of a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>. The...</p>
<ul>
<li>x-axis is the mass-to-charge ratio.</li>
<li>y-axis is the intensity of that mass-to-charge ratio (how much more / less did that mass-to-charge appear compared to the others).</li>
</ul>
<p><img src="svgbob_2b5ef43ae7572c2c6bf63687c53860a71830d160.svg" alt="Kroki diagram output"></p>
<p>Note that <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>s have various real-world practical problems. Specifically, they ...</p>
<ul>
<li>may not capture all possible pieces from the intended molecules (missing mass-to-charge ratios).</li>
<li>may capture pieces from unintended molecules (faulty mass-to-charge ratios).</li>
<li>will likely introduce noise into the pieces they capture.</li>
</ul>
<p>As such, these plots aren't exact.</p>
</li>
<li>
<p><a name="BM_(experimental%20spectrum)%2Fi"></a><strong>experimental spectrum</strong> - List of potential fragment masses derived from a <a href="#BM_(spectrum)_MS%2Fi">spectrum</a>. That is, the molecules fed into the <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> were randomly fragmented and each fragment had its mass-to-charge ratio measured. From there, each mass-to-charge ratio was converted a set of potential masses.</p>
<p>The masses in an <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> ...</p>
<ul>
<li>may not capture all possible fragments for the intended molecule (missing masses).</li>
<li>may capture fragments from unintended molecules (faulty masses).</li>
<li>will likely contain noise.</li>
</ul>
<p>In the context of <a href="#BM_(peptide)%2Fi">peptide</a>s, the <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> is expected to fragment based on the bonds holding the individual <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s together. For example, given the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY, the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> may include the masses for [N, Q, ?, ?, QY, ?, NQY] (? indicate faulty masses, Y and NQ missing).</p>
</li>
<li>
<p><a name="BM_(theoretical%20spectrum)%2Fi"></a><strong>theoretical spectrum</strong> - List of all of possible fragment masses for a molecule in addition to 0 and the mass of the entire molecule. This is what the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> would be in a perfect world: no missing masses, no faulty masses, no noise, only a single possible mass for each mass-to-charge ratio.</p>
<p>In the context of <a href="#BM_(peptide)%2Fi">peptide</a>s, the <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> is expected to fragment based on the bonds holding the individual <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s together. For example, given the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY, the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> will include the masses for [0, N, Q, Y, NQ, QY, NQY]. It shouldn't include masses for partial <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s. For example, it shouldn't include NQY breaking into 2 pieces by splitting Q, such that one half has N and part of Q, and the other has the remaining part of Q with Y.</p>
</li>
<li>
<p><a name="BM_(spectrum%20convolution)%2Fi"></a><strong>spectrum convolution</strong> - An operation used to derive <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses that probably come from the <a href="#BM_(peptide)%2Fi">peptide</a> used to generate that <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>. That is, it generates a list of <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses that could have been for the <a href="#BM_(peptide)%2Fi">peptide</a> that generated the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>.</p>
<p>The operation derives <a href="#BM_(amino%20acid)%2Fi">amino acid</a> masses by subtracting <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> masses from each other. For example, the following <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> is for the <a href="#BM_(linear%20peptide)%2Fi">linear peptide</a> NQY: [113.9, 115.1, 136.2, 162.9, 242.0, 311.1, 346.0, 405.2]. Performing 242.0 - 113.9 results in 128.1, which is very close to the mass for <a href="#BM_(amino%20acid)%2Fi">amino acid</a> Y.</p>
<p>Note how the mass for Y was derived from the masses in <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> even though it's missing from the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> itself:</p>
<ul>
<li>Mass of N is 114. 2 masses are close to 114 in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>: [113.9, 115.1].</li>
<li>Mass of Q is 163. 1 mass is close to 163 in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>: [162.9].</li>
<li>Mass of Y is 128. 0 masses are close to 128 in the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a>: [].</li>
</ul>
</li>
<li>
<p><a name="BM_(dalton)%2Fi"></a><strong>dalton</strong> <a name="BM_%5Cb%5Cd%2B(%3F%3A%5C.%5Cd%2B)%3F(Da)%5Cb%2Fi"></a><strong></strong> - A unit of measurement used in physics and chemistry. 1 <a href="#BM_(dalton)%2Fi">Dalton</a> is approximately the mass of a single proton / neutron, derived by taking the mass of a carbon-12 atom and dividing it by 12.</p>
</li>
<li>
<p><a name="BM_(codon%7Cgenetic%20code)%2Fi"></a><strong>codon</strong> - A <a href="#BM_(sequence)%2Fi">sequence</a> of 3 <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s that maps to an <a href="#BM_(amino%20acid)%2Fi">amino acid</a> or a stop marker. During <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>, the ribosome <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translate</a>s the RNA to a protein 3 <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s at a time:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The stop marker tells the ribosome to stop translating / the protein is complete.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s are listed as <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s (RNA). For nucleotides (DNA), swap U with T.</p>
</div>
<table>
<thead>
<tr>
<th>1 Letter Code</th>
<th>3 Letter Code</th>
<th><a href="#BM_(amino%20acid)%2Fi">Amino Acid</a></th>
<th><a href="#BM_(codon%7Cgenetic%20code)%2Fi">Codon</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Ala</td>
<td>Alanine</td>
<td>GCA, GCC, GCG, GCU</td>
</tr>
<tr>
<td>C</td>
<td>Cys</td>
<td>Cysteine</td>
<td>UGC, UGU</td>
</tr>
<tr>
<td>D</td>
<td>Asp</td>
<td>Aspartic acid</td>
<td>GAC, GAU</td>
</tr>
<tr>
<td>E</td>
<td>Glu</td>
<td>Glutamic acid</td>
<td>GAA, GAG</td>
</tr>
<tr>
<td>F</td>
<td>Phe</td>
<td>Phenylalanine</td>
<td>UUC, UUU</td>
</tr>
<tr>
<td>G</td>
<td>Gly</td>
<td>Glycine</td>
<td>GGA, GGC, GGG, GGU</td>
</tr>
<tr>
<td>H</td>
<td>His</td>
<td>Histidine</td>
<td>CAC, CAU</td>
</tr>
<tr>
<td>I</td>
<td>Ile</td>
<td>Isoleucine</td>
<td>AUA, AUC, AUU</td>
</tr>
<tr>
<td>K</td>
<td>Lys</td>
<td>Lysine</td>
<td>AAA, AAG</td>
</tr>
<tr>
<td>L</td>
<td>Leu</td>
<td>Leucine</td>
<td>CUA, CUC, CUG, CUU, UUA, UUG</td>
</tr>
<tr>
<td>M</td>
<td>Met</td>
<td>Methionine</td>
<td>AUG</td>
</tr>
<tr>
<td>N</td>
<td>Asn</td>
<td>Asparagine</td>
<td>AAC, AAU</td>
</tr>
<tr>
<td>P</td>
<td>Pro</td>
<td>Proline</td>
<td>CCA, CCC, CCG, CCU</td>
</tr>
<tr>
<td>Q</td>
<td>Gln</td>
<td>Glutamine</td>
<td>CAA, CAG</td>
</tr>
<tr>
<td>R</td>
<td>Arg</td>
<td>Arginine</td>
<td>AGA, AGG, CGA, CGC, CGG, CGU</td>
</tr>
<tr>
<td>S</td>
<td>Ser</td>
<td>Serine</td>
<td>AGC, AGU, UCA, UCC, UCG, UCU</td>
</tr>
<tr>
<td>T</td>
<td>Thr</td>
<td>Threonine</td>
<td>ACA, ACC, ACG, ACU</td>
</tr>
<tr>
<td>V</td>
<td>Val</td>
<td>Valine</td>
<td>GUA, GUC, GUG, GUU</td>
</tr>
<tr>
<td>W</td>
<td>Trp</td>
<td>Tryptophan</td>
<td>UGG</td>
</tr>
<tr>
<td>Y</td>
<td>Tyr</td>
<td>Tyrosine</td>
<td>UAC, UAU</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td><strong>STOP</strong></td>
<td>UAA, UAG, UGA</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(reading%20frame)%2Fi"></a><strong>reading frame</strong> - The different ways of dividing a DNA string into <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s. Specifically, there are 6 different ways that a DNA string can be divided into <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s:</p>
<ul>
<li>You can start dividing at index 0, 1, or 2.</li>
<li>You can divide either the DNA string itself or the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>ing DNA string.</li>
</ul>
<p>For example, given the string ATGTTCCATTAA, the following <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a> division are possible:</p>
<table>
<thead>
<tr>
<th>DNA</th>
<th>Start Index</th>
<th>Discard Prefix</th>
<th><a href="#BM_(codon%7Cgenetic%20code)%2Fi">Codon</a>s</th>
<th>Discard Suffix</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATGTTCCATTAA</td>
<td>0</td>
<td></td>
<td>ATG, TTC, CAT, TAA</td>
<td></td>
</tr>
<tr>
<td>ATGTTCCATTAA</td>
<td>1</td>
<td>A</td>
<td>TGT, TCC, ATT</td>
<td>AA</td>
</tr>
<tr>
<td>ATGTTCCATTAA</td>
<td>2</td>
<td>AT</td>
<td>GTT, CCA, TTA</td>
<td>A</td>
</tr>
<tr>
<td>TTAATGGAACAT</td>
<td>0</td>
<td></td>
<td>TTA, ATG, GAA, CAT</td>
<td></td>
</tr>
<tr>
<td>TTAATGGAACAT</td>
<td>1</td>
<td>T</td>
<td>TAA, TGG, AAC</td>
<td>AT</td>
</tr>
<tr>
<td>TTAATGGAACAT</td>
<td>2</td>
<td>TT</td>
<td>AAT, GGA, ACA</td>
<td>T</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>TTAATGGAACAT is the <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> of ATGTTCCATTAA.</p>
</div>
</li>
<li>
<p><a name="BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi"></a><strong>encode</strong> - When a DNA string or its <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a> is made up of the <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s required for an <a href="#BM_(amino%20acid)%2Fi">amino acid</a> <a href="#BM_(sequence)%2Fi">sequence</a>. For example, ACAGTA <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>s for the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> <a href="#BM_(sequence)%2Fi">sequence</a>...</p>
<ul>
<li>Threonine-Valine</li>
<li>Tyrosine-Cysteine (derived from <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA%7Creverse%20complement)%2Fi">reverse complement</a>)</li>
</ul>
</li>
<li>
<p><a name="BM_(branch-and-bound%20algorithm%7Cbranch%20and%20bound%20algorithm)%2Fi"></a><strong>branch-and-bound algorithm</strong> - A bruteforce algorithm that enumerates candidates to explore at each step but also discards untenable candidates using various checks. The enumeration of candidates is the branching step, while the culling of untenable candidates is the bounding step.</p>
</li>
</ul>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>

        </body></html>