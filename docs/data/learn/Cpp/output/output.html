<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>C++</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><p></p>
<div class="toc">
<ul>
<li><a href="#H_TODOs">TODOs</a></li>
<li><a href="#H_Essentials">Essentials</a></li>
<ul>
<li><a href="#H_Language%20Basics">Language Basics</a></li>
<li><a href="#H_Example%20Program">Example Program</a></li>
<li><a href="#H_Compilation">Compilation</a></li>
<li><a href="#H_Header%20Files">Header Files</a></li>
</ul>
<li><a href="#H_Operators">Operators</a></li>
<ul>
<li><a href="#H_Bitwise%20Logical%20Operators">Bitwise Logical Operators</a></li>
<li><a href="#H_Boolean%20Logical%20Operators">Boolean Logical Operators</a></li>
<li><a href="#H_Arithmetic%20Operators">Arithmetic Operators</a></li>
<li><a href="#H_Assignment%20Operators">Assignment Operators</a></li>
<li><a href="#H_Comparison%20Operator">Comparison Operator</a></li>
<li><a href="#H_Member%20Access%20Operators">Member Access Operators</a></li>
<li><a href="#H_Dynamic%20Object%20Operators">Dynamic Object Operators</a></li>
<li><a href="#H_Size%20Operator">Size Operator</a></li>
<li><a href="#H_Other%20Operators">Other Operators</a></li>
</ul>
<li><a href="#H_Variables">Variables</a></li>
<ul>
<li><a href="#H_Core%20Types">Core Types</a></li>
<ul>
<li><a href="#H_Integral">Integral</a></li>
<li><a href="#H_Floating%20Point">Floating Point</a></li>
<li><a href="#H_Character%20String">Character String</a></li>
<li><a href="#H_Void">Void</a></li>
</ul>
<li><a href="#H_Arrays">Arrays</a></li>
<li><a href="#H_Pointers">Pointers</a></li>
<ul>
<li><a href="#H_Pointer%20Arithmetic">Pointer Arithmetic</a></li>
<li><a href="#H_Void%20Pointer">Void Pointer</a></li>
<li><a href="#H_Function%20Pointer">Function Pointer</a></li>
</ul>
<li><a href="#H_References">References</a></li>
<li><a href="#H_Rvalue%20References">Rvalue References</a></li>
<li><a href="#H_Size">Size</a></li>
<li><a href="#H_Aliasing">Aliasing</a></li>
<li><a href="#H_Constant">Constant</a></li>
<li><a href="#H_Volatile">Volatile</a></li>
<li><a href="#H_Deduction">Deduction</a></li>
<li><a href="#H_Implicit%20Conversion">Implicit Conversion</a></li>
<li><a href="#H_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Explicit%20Conversion">Explicit Conversion</a></li>
<ul>
<ul>
<li><a href="#H_Named%20Conversions">Named Conversions</a></li>
<li><a href="#H_C-style%20Casts">C-style Casts</a></li>
</ul>
</ul>
<li><a href="#H_Object%20Lifecycle">Object Lifecycle</a></li>
<ul>
<li><a href="#H_Static%20Objects">Static Objects</a></li>
<li><a href="#H_Dynamic%20Objects">Dynamic Objects</a></li>
</ul>
<li><a href="#H_User-defined%20Literals">User-defined Literals</a></li>
</ul>
<li><a href="#H_Functions">Functions</a></li>
<ul>
<li><a href="#H_Overloading">Overloading</a></li>
<li><a href="#H_Argument%20Matching">Argument Matching</a></li>
<li><a href="#H_Type%20Deduction">Type Deduction</a></li>
<li><a href="#H_Main%20Function">Main Function</a></li>
<li><a href="#H_Variadic">Variadic</a></li>
<li><a href="#H_No%20Exception">No Exception</a></li>
<li><a href="#H1_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Coroutines">Coroutines</a></li>
</ul>
<li><a href="#H_Enumerations">Enumerations</a></li>
<li><a href="#H_Classes">Classes</a></li>
<ul>
<li><a href="#H_This%20Pointer">This Pointer</a></li>
<li><a href="#H1_Constant">Constant</a></li>
<li><a href="#H1_Volatile">Volatile</a></li>
<li><a href="#H2_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Static">Static</a></li>
<li><a href="#H_Construction">Construction</a></li>
<li><a href="#H_Destruction">Destruction</a></li>
<li><a href="#H_Copying">Copying</a></li>
<li><a href="#H_Moving">Moving</a></li>
<li><a href="#H_Inheritance">Inheritance</a></li>
<li><a href="#H_Interfaces">Interfaces</a></li>
<li><a href="#H_Operator%20Overloading">Operator Overloading</a></li>
<li><a href="#H_Conversion%20Overloading">Conversion Overloading</a></li>
<li><a href="#H_Const%20%2F%20Volatile%20Overloading">Const / Volatile Overloading</a></li>
<li><a href="#H_Reference%20Overloading">Reference Overloading</a></li>
<li><a href="#H_Functors">Functors</a></li>
<li><a href="#H_Lambdas">Lambdas</a></li>
<li><a href="#H_Friends">Friends</a></li>
</ul>
<li><a href="#H_Templates">Templates</a></li>
<ul>
<li><a href="#H_Concepts">Concepts</a></li>
<li><a href="#H1_Variadic">Variadic</a></li>
<li><a href="#H_Specialization">Specialization</a></li>
</ul>
<li><a href="#H_Unions">Unions</a></li>
<li><a href="#H_Namespaces">Namespaces</a></li>
<li><a href="#H_Linker%20Behaviour">Linker Behaviour</a></li>
<ul>
<li><a href="#H_Static%20Linkage">Static Linkage</a></li>
<li><a href="#H_Inline%20Linkage">Inline Linkage</a></li>
<li><a href="#H_External%20Linkage">External Linkage</a></li>
</ul>
<li><a href="#H_Control%20Flow">Control Flow</a></li>
<ul>
<li><a href="#H_If%20Statement">If Statement</a></li>
<li><a href="#H_Switch%20Statement">Switch Statement</a></li>
<li><a href="#H_For%20Loop">For Loop</a></li>
<li><a href="#H_While%20Loop">While Loop</a></li>
<li><a href="#H_Goto%20Statement">Goto Statement</a></li>
<li><a href="#H_Branching%20Likelihood">Branching Likelihood</a></li>
</ul>
<li><a href="#H_Attributes">Attributes</a></li>
<li><a href="#H_Constant%20Expressions">Constant Expressions</a></li>
<li><a href="#H_Exceptions">Exceptions</a></li>
<li><a href="#H_Structured%20Binding">Structured Binding</a></li>
<li><a href="#H_Expression%20Categories">Expression Categories</a></li>
<li><a href="#H_Iterators">Iterators</a></li>
<li><a href="#H_Modules">Modules</a></li>
<li><a href="#H_Preprocessor">Preprocessor</a></li>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_TODOs"></a><h1>TODOs</h1>
<p>TODO: Set prereqs</p>
<p>TODO: Mention this website https://github.com/AnthonyCalandra/modern-cpp-features</p>
<p>TODO:  https://stackoverflow.com/questions/57363324/ramifications-of-c20-requiring-twos-complement</p>
<p>TODO:  https://www.reddit.com/r/cpp/comments/r3pmw2/writing_portable_c_code_and_undefined_unspecified/  + evaluation order of isn't defined (<strong>SEE CH7 -- EXECUTION ORDER SECTION</strong>)</p>
<p></p>
<blockquote>
<p>Evaluation order determines the execution sequence of operators in an expression. A common misconception is that precedence and evaluation order are equivalent: they are not. Precedence is a compile time concept that drives how operators bind to operands. Evaluation order is a runtime concept that drives the scheduling of operator execution.</p>
<p>In general, C++ has no clearly specified execution order for operands. Although operators bind to operands in the well-defined way explained in the preceding sections, those operands evaluate in an undefined order. The compiler can order operand evaluation however it likes.</p>
</blockquote>
<p>the last few paragraphs list out exceptions</p>
<p>SEE https://stackoverflow.com/a/5473530
</p>
<p>worth putting in associtivity and operator precedence in operator section????
implementaiton-specific behaviour with implict casts (see implicit casts section -- AVOIDABLE USING <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">BRACED INITIALIZATION</a>)</p>
<p>UNDEFINED OVERFLOW/UNDERFLOW: talk about how this can be used.
<code>c++ #include &lt;limits&gt; try {     auto c = a + std::numeric_limits&lt;unsigned int&gt;::max(); } catch(const std::overflow_error&amp; e) {     printf("(a + max) Exception: %s\n", e.what()); } </code></p>
<p>TODO: add more example code into terminology</p>
<p>TODO: ch 9 at std::function / std::callable</p>
<p>TODO: C++20 coroutines section needs to be fleshed out better (no good source for this)</p>
<p>TODO: C++20 spaceship operator (https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/)</p>
<p>TODO: add section on equals/hashcode/tostring equivalents
-- operator== <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>
-- std::hash <a href="#BM_(template)%2Fi">template</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>: https://en.cpp<a href="#BM_(reference)%2Fi">reference</a>.com/w/cpp/utility/hash
-- friend function to ostringstream</p>
<p>TODO: smart <a href="#BM_(pointer)%2Fi">pointer</a>s</p>
<p>TODO: add terminology for declarations and definitions</p>
<a name="H_Essentials"></a><h1>Essentials</h1>
<p>The following document is my attempt at charting out the various pieces of the modern C++ landscape, focusing on the 80% of features that gets used most of the time rather than the 20% of highly esoteric / confusing features. It isn't comprehensive and some of the information may not be entirely correct / may be missing large portions.</p>
<p>The key points of similarity to remember:</p>
<ol>
<li>Scope in C++ is similar to Java/C# (e.g. function scope, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> scope, etc...). Variables, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, etc.. come into and leave out of scopes in similar ways.</li>
<li>Compound statements in C++ are similar Java/C#. They create a scope, and things declared in that scope are gone once the scope is exited.</li>
<li>Control flow statements in C++ are similar to Java/C#. All the basics are there: for loops, for-each loops, while loops, if-else, switch, etc...</li>
<li>Data can exist on the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a> or stack similar to Java/C#.</li>
</ol>
<p>The key point of dissimilarity to remember:</p>
<ol>
<li><strong>C++ does not come with a garbage collector</strong>. You are responsible for releasing memory, although the C++ standard library has a lot of pieces to help with this.</li>
<li>C++ has a lot of legacy baggage and many edge cases. Compared to Java/C#, the language is powerful but also deeply convoluted with many foot-guns and esoteric syntax / semantics.</li>
<li>C++ has a lot of ambiguous behaviour. Compared to Java/C#, the language specifically carves out pieces of the spec and leaves it as platform-specific behaviour, undefined behaviour, etc.. so that <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s have more room to optimize code.</li>
</ol>
<a name="H_Language%20Basics"></a><h2>Language Basics</h2>
<p>The following are a base set of language constructs required for understanding the rest of the document.</p>
<ol>
<li>
<p>The general purpose integral type is <code>int</code>.</p>
</li>
<li>
<p>Variables use the format <code>modifiers type name initializer</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;
<span class="hljs-type">int</span> c {<span class="hljs-number">0</span>};
</code></pre>
<p>C++ provides a bewildering number of ways to initialize a variable, each with its own set of edge cases. For best results, stick to the curly braces.</p>
</li>
<li>
<p>Functions use the format <code>modifiers return-type name(param-type1 arg-name1, param-type2 arg-name2, ...) modifiers { body }</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> x + a;
}
</code></pre>
<p>C++ functions don't necessarily have to be <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s (<a href="#BM_%5Cb(member)%2Fi">member</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
</li>
<li>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a>es use either <code>struct</code> or <code>class</code>.</p>
<p><code>struct</code> makes all <a href="#BM_%5Cb(member)%2Fi">member</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> public by default, while <code>class</code> makes them all private by default. <a href="#BM_%5Cb(member)%2Fi">Member</a>s need to be grouped together by visibility, where a visibility (e.g. <code>private</code>) is a label within the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
      <span class="hljs-keyword">return</span> x + a;
   }
<span class="hljs-keyword">private</span>: <span class="hljs-comment">// everything under this label is private</span>
   <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};
</code></pre>
</li>
<li>
<p>Source code often comes in pairs: A header file usually contains declarations (e.g. just the function's signature / prototype) while a C++ file usually contains definitions (e.g. the function implementation).</p>
<pre class="hljs"><code><span class="hljs-comment">// MyCode.hpp (header file w/ declarations)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-comment">// MyCode.cpp (source file w/ definitions)</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyCode.hpp"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> x + a;
}
</code></pre>
<p>This isn't required. Source files may contain declarations and / or header files may contain definitions, but the split is typically done for a variety of reasons: faster compile times, sharing the same <a href="#BM_(object%7Cinstance)%2Fi">object</a> across multiple source files, compiling when there are cyclical <a href="#BM_(reference)%2Fi">reference</a>s, etc..</p>
</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The above points aren't entirely correct or complete. They're generalizations that help set up a base for the explanations in the rest of the document.</p>
</div>
<a name="H_Example%20Program"></a><h2>Example Program</h2>
<p>The following is an example C++ program that prints "hello world" to stdout.</p>
<pre class="hljs"><code><span class="hljs-comment">// hello.cpp file</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"hello world\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The ...</p>
<ul>
<li><code>#include &lt;iostream&gt;</code> pulls in a library that lets you interface with stdout, stderr, and stdin.</li>
<li><code>int main() { ... }</code> is the entry point of the program.</li>
<li><code>std:cout &lt;&lt; ...</code> is what prints to stdout.</li>
<li><code>return 0</code> returns from the <code>main()</code> function, ending the program with an exit code of 0.</li>
</ul>
<p>Pretty much any modern C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will compile the above code. The output below uses the GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to compile the example, then runs the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<pre><code>$ g++ hello.cpp
$ ./a.out
hello world
</code></pre>
<a name="H_Compilation"></a><h2>Compilation</h2>
<p>Several C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s exist, the most popular of which are the GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> and LLVM clang. C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s generally follow the same set of steps to go from C++ code to an <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<ol>
<li>C++ source files get fed into a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> to generate <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s. A <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> is the C++ source file after going through modifications based <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specifics, platform specifics, libraries used, compile options / library options, etc..</li>
<li><a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">Translation unit</a> files get fed into a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s. An <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a> is the intermediary compiled form of each individual <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</li>
<li><a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Object file</a>s get fed into a <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> to generate the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>. All <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s come together and linkages between them are made to form the final <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</li>
</ol>
<p><img src="svgbob_80c99337d0ee9d0afb6fdd8cc113d933be8d1ce9.svg" alt="Kroki diagram output"></p>
<p>The C++ language has a lot of legacy baggage, edge cases, and ambiguous behaviour. Regardless of the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> chosen, at least some of the following warning options should be enabled:</p>
<ul>
<li><code>-Wall</code> - Warns about questionable but easily avoidable constructs.</li>
<li><code>-Wextra</code> - Warns about other questionable constructs not covered by <code>-Wall</code>.</li>
<li><code>-Wpedantic</code> - Warns about ISO conformance.</li>
<li><code>-Weverything</code> - Turns on all warnings.</li>
</ul>
<p>Most <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s support some or all of the flags above.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A good online tool to try things in is <a href="https://cppinsights.io/">cppinsights</a>, which breaks down C++ code and allows you some visibility into what the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is doing / what the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> sees.</p>
</div>
<a name="H_Header%20Files"></a><h2>Header Files</h2>
<p>For each source code file that gets compiled, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> needs to know that the entities (variables, functions, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, etc..) accessed within that file actually exist. The scope at which the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> keeps track of these entities is per source code file. For example, imagine a source code file that defines a function named <code>myFunction</code> (definition). There are 5 other source code files that call <code>myFunction</code> at some point. Each of those 5 other files is required to tell the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> what <code>myFunction</code> is (declaration) before it can invoke it.</p>
<p>One way to handle this scenario is to put <code>myFunction</code>'s declaration in each source code file that calls it.</p>
<pre class="hljs"><code><span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;
</code></pre>
<p>The problem with doing this is that ...</p>
<ol>
<li>you're duplicating something 5 times, meaning you need to update 5 different places should anything change with the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</li>
<li>you need a declaration for more than just <code>myFunction</code> (e.g. <code>myFunction</code> requires <code>OtherClass</code>, which may require even more entities).</li>
<li>as a result of 1 and 2, source code file sizes explode and quickly becomes unmanageable.</li>
</ol>
<p>The preferred way to handle this scenario is to put <code>myFunction</code>'s declaration into a header file. Then, any file that needs to know about <code>myFunction</code> can use the <code>#include</code> directive.,,</p>
<pre class="hljs"><code><span class="hljs-comment">// MyFunction.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span></span>
<span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-comment">// UsageFile1.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyFunction.hpp"</span></span>
<span class="hljs-built_in">myFunction</span>(<span class="hljs-number">44</span>);
</code></pre>
<p>If an entity is declared once already by an <code>#include</code>, it shouldn't be declared again.  For example, imagine that the file <code>Main.cpp</code> includes <code>ParentA.hpp</code> and <code>ParentB.hpp</code>. Both <code>ParentA.hpp</code> and <code>ParentB.hpp</code> then go on to include <code>Child.hpp</code>....</p>
<p><img src="svgbob_b33513cc90f4ec659ecb36587de9b266289fe213.svg" alt="Kroki diagram output"></p>
<p>The problem the above example scenario creates is that <code>Child.hpp</code> gets <code>#include</code>'d twice, meaning that everything in it is declared twice. To mitigate this problem, an include guard is typically provided in each header file.</p>
<pre class="hljs"><code><span class="hljs-comment">// MyFunction.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_FUNCTION_H <span class="hljs-comment">// include guard</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_FUNCTION_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span></span>
<span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>#ifdef</code>, <code>#define</code>, and <code>#endif</code> are <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros that aren't covered here. Look them up online if you need to.</p>
</div>
<p>You may notice that sometimes <code>#include</code> puts quotes around the files and sometimes angle brackets. Use quotes when the files are in the same directory structure, angle brackets when the files are coming from some external library.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>          <span class="hljs-comment">// library header</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span>  <span class="hljs-comment">// local header</span></span>
</code></pre>
<a name="H_Operators"></a><h1>Operators</h1>
<p>The following subsections provide the list of operators available in C++. Some operators are obvious, while others are explained in other sections.</p>
<a name="H_Bitwise%20Logical%20Operators"></a><h2>Bitwise Logical Operators</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitwise AND         (<code>&amp;</code>)</td>
<td><code>0b1011 &amp; 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise OR          (<code>|</code>)</td>
<td><code>0b1011 | 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise XOR         (<code>^</code>)</td>
<td><code>0b1011 ^ 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise NOT         (<code>~</code>)</td>
<td><code>~0b1011</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise left-shift  (<code>&lt;&lt;</code>)</td>
<td><code>0b1011 &lt;&lt; 2</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise right-shift (<code>&gt;&gt;</code>)</td>
<td><code>0b1011 &gt;&gt; 2</code></td>
<td>Result on signed may be different than unsigned.</td>
</tr>
</tbody>
</table>
<a name="H_Boolean%20Logical%20Operators"></a><h2>Boolean Logical Operators</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logical AND (<code>&amp;&amp;</code>)</td>
<td><code>true &amp;&amp; true</code></td>
<td></td>
</tr>
<tr>
<td>Logical OR  (<code>||</code>)</td>
<td><code>true || false</code></td>
<td></td>
</tr>
<tr>
<td>Logical NOT (<code>!</code>)</td>
<td><code>!true</code></td>
<td></td>
</tr>
</tbody>
</table>
<a name="H_Arithmetic%20Operators"></a><h2>Arithmetic Operators</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unary Plus      (<code>+</code>)</td>
<td><code>+10</code></td>
<td></td>
</tr>
<tr>
<td>Unary Minus     (<code>-</code>)</td>
<td><code>-10</code></td>
<td></td>
</tr>
<tr>
<td>Addition        (<code>+</code>)</td>
<td><code>1 + 2</code></td>
<td></td>
</tr>
<tr>
<td>Subtraction     (<code>-</code>)</td>
<td><code>2 - 1</code></td>
<td></td>
</tr>
<tr>
<td>Multiplication  (<code>*</code>)</td>
<td><code>2 * 3</code></td>
<td></td>
</tr>
<tr>
<td>Division        (<code>/</code>)</td>
<td><code>6 / 2</code></td>
<td></td>
</tr>
<tr>
<td>Modulo          (<code>%</code>)</td>
<td><code>6 % 4</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>There are implicit rules for how <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>s get promoted. The general rule of thumb is that the result of the operator is promoted to the operand with the "greater" type. For example, if an <code>int</code> is added to a <code>float</code>, the result will be a <code>float</code>.</p>
<p>These rules are similar to those in other languages (e.g. Java and Python).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If confused, use type deduction via the <code>auto</code> keyword: <code>auto x = 5 + y</code>, then check to see what the type of <code>y</code> is in the IDE or using <code>typeid</code>.</p>
</div>
<a name="H_Assignment%20Operators"></a><h2>Assignment Operators</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Assignment                     (<code>=</code>)</td>
<td><code>x = 5</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise AND         (<code>&amp;=</code>)</td>
<td><code>x &amp;= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise OR          (<code>|=</code>)</td>
<td><code>x |= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise XOR         (<code>^=</code>)</td>
<td><code>x ^= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise left-shift  (<code>&lt;&lt;=</code>)</td>
<td><code>x &lt;&lt;= 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise right-shift (<code>&gt;&gt;=</code>)</td>
<td><code>x &gt;&gt;= 2</code></td>
<td>Result on signed may be different than unsigned.</td>
</tr>
<tr>
<td>Assignment Addition            (<code>+=</code>)</td>
<td><code>x += 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Subtraction         (<code>-=</code>)</td>
<td><code>x -= 1</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Multiplication      (<code>*=</code>)</td>
<td><code>x *= 3</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Division            (<code>/=</code>)</td>
<td><code>x /= 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Modulo              (<code>%=</code>)</td>
<td><code>x %= 4</code></td>
<td></td>
</tr>
<tr>
<td>Increment                      (<code>++</code>)</td>
<td><code>x++</code></td>
<td>Applicable BEFORE or AFTER the operand: <code>++x</code> returns the value AFTER modification, <code>x++</code> returns the value BEFORE modification.</td>
</tr>
<tr>
<td>Decrement                      (<code>--</code>)</td>
<td><code>x--</code></td>
<td>Applicable BEFORE or AFTER the operand: <code>--x</code> returns the value AFTER modification, <code>x--</code> returns the value BEFORE modification.</td>
</tr>
</tbody>
</table>
<p>All assignment operators work similar to those in Java except for the increment and decrement operators. Due to the confusion it causes, Java disallows the increment / decrement from returning a value, meaning that it can't be used in an expression. Not so in C++. In addition to modifying the variable passed as the operand, in C++ these operators also return a result, meaning that it's okay to an increment / decrement operator within some larger expression.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;
<span class="hljs-type">int</span> y = (x++) + <span class="hljs-number">2</span>;
<span class="hljs-comment">// at this point, x is 4, y is 5</span>
<span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;
<span class="hljs-type">int</span> b = (++a) + <span class="hljs-number">2</span>;
<span class="hljs-comment">// at this point, a is 4, b is 6</span>
</code></pre>
<a name="H_Comparison%20Operator"></a><h2>Comparison Operator</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equal To                 (<code>==</code>)</td>
<td><code>5 == 7</code></td>
<td></td>
</tr>
<tr>
<td>Not Equal To             (<code>!=</code>)</td>
<td><code>5 != 7</code></td>
<td></td>
</tr>
<tr>
<td>Less Than                (<code>&lt;</code>)</td>
<td><code>5 &lt; 7</code></td>
<td></td>
</tr>
<tr>
<td>Less Than Or Equal To    (<code>&lt;=</code>)</td>
<td><code>5 &lt;= 7</code></td>
<td></td>
</tr>
<tr>
<td>Greater Than             (<code>&gt;</code>)</td>
<td><code>5 &gt; 7</code></td>
<td></td>
</tr>
<tr>
<td>Greater Than Or Equal To (<code>&gt;=</code>)</td>
<td><code>5 &gt;= 7</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>In addition, the ternary conditional operator is a pseudo operator that takes in 3 operands similar to those found in other high-level languages: <code>CONDITION ? EXPRESSION_IF_TRUE : EXPRESSION_IF_FALSE</code>. It's essentially a shorthand if-else block.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x = n % <span class="hljs-number">7</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">1000</span> : <span class="hljs-number">-1000</span>;
<span class="hljs-comment">// equiv to...</span>
<span class="hljs-keyword">if</span> (n % <span class="hljs-number">7</span> == <span class="hljs-number">1</span>) {
    x = <span class="hljs-number">1000</span>;
} <span class="hljs-keyword">else</span> {
    x = <span class="hljs-number">-1000</span>;
}
</code></pre>
<a name="H_Member%20Access%20Operators"></a><h2>Member Access Operators</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Subscript         (<code>[]</code>)</td>
<td><code>x[0]</code></td>
<td></td>
</tr>
<tr>
<td>Indirection       (<code>*</code>)</td>
<td><code>*x</code></td>
<td>Doesn't conflict with arithmetic multiplication operator because this is a unary operator.</td>
</tr>
<tr>
<td><a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">Address Of</a>        (<code>&amp;</code>)</td>
<td><code>&amp;x</code></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi">Member Of Object</a>  (<code>.</code>)</td>
<td><code>x.member</code></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">Member Of Pointer</a> (<code>-&gt;</code>)</td>
<td><code>x-&gt;member</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>There operators are used in scenarios that deal with accessing the <a href="#BM_%5Cb(member)%2Fi">member</a>s of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. element in an array, <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) or dealing with memory addresses / <a href="#BM_(pointer)%2Fi">pointer</a>s. The subscript and and <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi">member of object</a> operators are similar to their counterparts in other high-level languages (e.g. Java, Python, C#, etc..). The others are unique to languages with support for lower-level programming like C++. Their usage is detailed in other sections.</p>
<a name="H_Dynamic%20Object%20Operators"></a><h2>Dynamic Object Operators</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a>       (<code>new</code>)</td>
<td><code>new int</code></td>
<td></td>
</tr>
<tr>
<td>Create <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Array</a>      (<code>new[]</code>)</td>
<td><code>new int[50]</code></td>
<td></td>
</tr>
<tr>
<td>Destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a>   (<code>delete</code>)</td>
<td><code>delete x</code></td>
<td></td>
</tr>
<tr>
<td>Destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Array</a>  (<code>delete[]</code>)</td>
<td><code>delete[] x</code></td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you already know about <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s and arrays and <a href="#BM_(constructor)%2Fi">constructor</a>s/<a href="#BM_(destructor)%2Fi">destructor</a>s, make sure you delete an array using <code>delete[]</code>. It makes sure to call the <a href="#BM_(destructor)%2Fi">destructor</a> for each element of the array.</p>
</div>
<a name="H_Size%20Operator"></a><h2>Size Operator</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size (<code>sizeof</code>)</td>
<td><code>sizeof x]</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>This operator gets the size of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> in bytes. Note that an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s byte size may not be indicative of the da may include padding required by the platform (e.g. an <a href="#BM_(object%7Cinstance)%2Fi">object</a> requiring 5 bytes may get expanded to 8 bytes because the platform requires 8 byte boundary alignments).</p>
<a name="H_Other%20Operators"></a><h2>Other Operators</h2>
<p>C++ provides a set of other operators such as the ...</p>
<ul>
<li>comma operator (<code>,</code>).</li>
<li><a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a> (<code>()</code>).</li>
<li>conversion operator (e.g. casting).</li>
<li><a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a> operator (e.g. <code>_</code>)</li>
</ul>
<p>While it isn't worth going into them in detail here, the reason the language explicitly lists them as operators is because they're <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>-able (e.g. operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing). <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">Overload</a>ing these operators is heavily discouraged since doing so causes confusion.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions the comma operator specifically. It doesn't look this is used for much and the book recommends against using it for anything (e.g. operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing) due to the confusion it causes. This gives off similar vibes to Python's tuple syntax, where you can pass an unenclosed tuple as a subscript to something. When I was learning Python, that also came off as very confusing.</p>
<pre class="hljs"><code>x = obj[<span class="hljs-string">'column name'</span>, <span class="hljs-number">100</span>]
</code></pre>
</div>
<a name="H_Variables"></a><h1>Variables</h1>
<p>C++ variable declarations have the following form: <code>modifiers type name initializer</code>.</p>
<ul>
<li>
<p><strong>type</strong> (required) - Type of variable.</p>
</li>
<li>
<p><strong>name</strong>: (required) - Name of variable.</p>
</li>
<li>
<p><strong>initializer</strong>: (optional) - Initia<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> to assign (<a href="#BM_(object%20initialization)%2Fi">object initialization</a>).</p>
<p>There are multiple ways to initialize a variable, each with their own advantages and disadvantages.</p>
<ul>
<li><a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> / <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">uniform initialization</a>: braces used for initialization (e.g. <code>int x {a + b}</code>).</li>
<li><a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a>: equals sign used for initialization (e.g. <code>int x = 5</code>).</li>
<li><a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>: equals sign and braces used for initialization (e.g. <code>int x = { a + b }</code>).</li>
<li>etc..</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The above is an over-simplification. The ways to initialize are vast and complex. See <a href="https://en.cppreference.com/w/cpp/language/initialization">here</a> for a full accounting and <a href="https://youtu.be/7DTlWPgX6zs">here</a> for an hour long talk about the edge cases.</p>
<p>It seems like the safest bet is to always use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">brace initialization</a> where possible. Just use the braces as if they were parenthesis or braces in Java (specific to the context). The others have surprising behaviour (e.g. they won't warn about <a href="#BM_(narrowing%20conversion)%2Fi">narrowing conversion</a>s).</p>
</div>
</li>
<li>
<p><strong><a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a variable.</p>
<p>(e.g. <code>const</code>, <code>volatile</code>, <code>constexpr</code>, <code>inline</code>, ...)</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">int</span> a;     <span class="hljs-comment">// no initializer -- garbage possibly contained at memory location</span>
<span class="hljs-type">int</span> b {};  <span class="hljs-comment">// empty initializer -- zeros out the memory for the int</span>
<span class="hljs-type">int</span> c {<span class="hljs-number">0</span>}; <span class="hljs-comment">// assign to constant 0</span>
<span class="hljs-type">int</span> d {c}; <span class="hljs-comment">// assign to value in c</span>
</code></pre>
<p>In C++, variables that are <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s (assigned to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) are called <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s. This section deals with non-<a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s (e.g. scoped somewhere other than a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> -- global, inside a function, etc..).</p>
<a name="H_Core%20Types"></a><h2>Core Types</h2>
<p>The following sections list out core C++ types and their analogs. These include numeric types, character types, and string types.</p>
<a name="H_Integral"></a><h3>Integral</h3>
<p>C++'s core integer types are as follows...</p>
<ol>
<li><code>short int</code></li>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ol>
<p>The above integer types come in two forms: signed and unsigned. Tha range of ...</p>
<ul>
<li>unsigned integers starts at 0 and ends at a positive integer.</li>
<li>signed integers starts at a negative integer and positive integer.</li>
</ul>
<p>By default, the integer types above are signed (speculation). Signed-ness can be explicitly stated by prefixing either <code>signed</code> or <code>unsigned</code> to the type, but if the type is signed the prefix is usually omitted.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short int</code>     / <code>signed short int</code></td>
<td><code>unsigned short int</code></td>
</tr>
<tr>
<td><code>int</code>           / <code>signed int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>long int</code>      / <code>signed long int</code></td>
<td><code>unsigned long int</code></td>
</tr>
<tr>
<td><code>long long int</code> / <code>signed long long int</code></td>
<td><code>unsigned long long int</code></td>
</tr>
</tbody>
</table>
<p>Integer types <code>char int</code>, <code>short int</code>, <code>long int</code>, and <code>long long int</code> can optionally omit the <code>int</code> keyword.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short</code>     / <code>signed short</code></td>
<td><code>unsigned short</code></td>
</tr>
<tr>
<td><code>int</code>       / <code>signed int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>long</code>      / <code>signed long</code></td>
<td><code>unsigned long</code></td>
</tr>
<tr>
<td><code>long long</code> / <code>signed long long</code></td>
<td><code>unsigned long long</code></td>
</tr>
</tbody>
</table>
<p>The only guarantees for core integer types are that ...</p>
<ul>
<li>each integer type tier must be able to cover the same range as the tier before it (e.g. range of <code>short</code> &gt;= range of <code>int</code>).</li>
<li>unsigned integer types start at 0.</li>
<li>unsigned integer types overflow behaviour is to wrap to 0.</li>
</ul>
<p>All other specifics are platform-dependent. Specifically, ...</p>
<ul>
<li>range is undefined.</li>
<li>bit length is undefined (e.g. 8, 16, etc..).</li>
<li>endian-ness is undefined (e.g. big-endian vs little-endian).</li>
<li>encoding scheme of <em>signed</em> types is two's complement (as of C++20), but underflow/overflow behaviour of <em>signed</em> types is undefined (e.g. crash, stay at boundary, wrap back around, etc..).</li>
</ul>
<p>Integer ranges, although platform-specific, are queryable in the climits header.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>min</th>
<th>max</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed short</code></td>
<td><code>SHRT_MIN</code></td>
<td><code>SHRT_MAX</code></td>
</tr>
<tr>
<td><code>signed int</code></td>
<td><code>INT_MIN</code></td>
<td><code>INT_MAX</code></td>
</tr>
<tr>
<td><code>signed long</code></td>
<td><code>LONG_MIN</code></td>
<td><code>LONG_MAX</code></td>
</tr>
<tr>
<td><code>signed long long</code></td>
<td><code>LLONG_MIN</code></td>
<td><code>LLONG_MAX</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td><code>0</code></td>
<td><code>USHRT_MAX</code></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td><code>0</code></td>
<td><code>UINT_MAX</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td><code>0</code></td>
<td><code>ULONG_MAX</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td><code>0</code></td>
<td><code>ULLONG_MAX</code></td>
</tr>
</tbody>
</table>
<p>By default, literals are represented using base10. Literals may be presented in different bases via the prefix.</p>
<table>
<thead>
<tr>
<th>base</th>
<th>literal prefix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 (binary)</td>
<td>0b</td>
<td><code>0b1111</code></td>
</tr>
<tr>
<td>8 (octal)</td>
<td>0</td>
<td><code>016</code></td>
</tr>
<tr>
<td>10 (decimal)</td>
<td></td>
<td><code>15</code></td>
</tr>
<tr>
<td>16 (hex)</td>
<td>0x</td>
<td><code>0xF</code></td>
</tr>
</tbody>
</table>
<p>Integer literals are targeted to specific integer types by their suffix.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>literal suffix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed short</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>signed int</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>signed long</code></td>
<td>L</td>
<td><code>2L</code></td>
</tr>
<tr>
<td><code>signed long long</code></td>
<td>LL</td>
<td><code>2LL</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>U</td>
<td><code>2U</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>UL</td>
<td><code>2UL</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td>ULL</td>
<td><code>2ULL</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Notice that <code>int</code>, <code>short</code>, and <code>unsigned short</code> don't have explicit suffixes. If no suffix is present, it's an int (speculation). To get it to a short, the easiest way is to cast it: <code>(short) 2</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits header. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<p>Integer types with standardized bit lengths are defined in the cstdlib header.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>intmax_t</code></td>
<td><code>uintmax_t</code></td>
<td>widest possible bit length</td>
</tr>
<tr>
<td><code>int8_t</code></td>
<td><code>uint8_t</code></td>
<td>exactly 8 bits</td>
</tr>
<tr>
<td><code>int16_t</code></td>
<td><code>uint16_t</code></td>
<td>exactly 16 bits</td>
</tr>
<tr>
<td><code>int32_t</code></td>
<td><code>uint32_t</code></td>
<td>exactly 32 bits</td>
</tr>
<tr>
<td><code>int64_t</code></td>
<td><code>uint64_t</code></td>
<td>exactly 64 bits</td>
</tr>
<tr>
<td><code>int_least8_t</code></td>
<td><code>uint_least8_t</code></td>
<td>8 bits  or greater</td>
</tr>
<tr>
<td><code>int_least16_t</code></td>
<td><code>uint_least16_t</code></td>
<td>16 bits or greater</td>
</tr>
<tr>
<td><code>int_least32_t</code></td>
<td><code>uint_least32_t</code></td>
<td>32 bits or greater</td>
</tr>
<tr>
<td><code>int_least64_t</code></td>
<td><code>uint_least64_t</code></td>
<td>64 bits or greater</td>
</tr>
<tr>
<td><code>int_fast8_t</code></td>
<td><code>uint_fast8_t</code></td>
<td>8 bits  or greater</td>
</tr>
<tr>
<td><code>int_fast16_t</code></td>
<td><code>uint_fast16_t</code></td>
<td>16 bits or greater</td>
</tr>
<tr>
<td><code>int_fast32_t</code></td>
<td><code>uint_fast32_t</code></td>
<td>32 bits or greater</td>
</tr>
<tr>
<td><code>int_fast64_t</code></td>
<td><code>uint_fast64_t</code></td>
<td>64 bits or greater</td>
</tr>
<tr>
<td><code>intptr_t</code></td>
<td><code>uintptr_t</code></td>
<td>wide enough to hold a void *</td>
</tr>
<tr>
<td></td>
<td><code>size_t</code></td>
<td>wide enough to hold the maximum number of bytes of something in memory</td>
</tr>
</tbody>
</table>
<p>The minimum and maximum extents of each type are defined in <code>{TYPE}_MIN</code> and <code>{TYPE}_MAX</code>, where <code>{TYPE}</code> doesn't include the <code>_t</code> suffix. For example the maximum value an <code>uint64_t</code> can be is <code>UINT64_MAX</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not all types guaranteed to be present (e.g. 64-bit types may be missing if platform can't support it). Unsigned types don't have a minimum extent defined because a minimum of any unsigned integer type is always 0 (e.g. uint64_t can't go any lower than 0).</p>
</div>
<p>To expand any integer <strong>literal</strong> to a ...</p>
<ul>
<li><code>intmax_t</code>, use the macro <code>INTMAX_C(...)</code>.</li>
<li><code>uintmax_t</code>, use the macro <code>UINTMAX_C(...)</code>.</li>
<li><code>int{N}_t</code>, use the macro <code>INT{N}_C(...)</code> (where <code>{N}</code> is the bit length).</li>
<li><code>uint{N}_t</code>, use the macro <code>UINT{N}_C(...)</code> (where <code>{N}</code> is the bit length).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There is no macro <code>SIZE_C(...)</code> for <code>size_t</code>. Best to just assign a `size_t to one of the other types's literals and hope the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warns about any <a href="#BM_(narrowing%20conversion)%2Fi">narrowing conversion</a>s that might happen.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What's the point of the above? You don't know what internal integer type each standardized type maps to. For example, <code>uint64_t</code> may map to <code>unsigned long long</code>, which means when you want to assign a literal to a variable of that type you need to add a <code>ULL</code> suffix...</p>
<p><code>uint64_t test = 9999999999999999999ULL</code></p>
<p>The macros above make it so that you don't need to know the underlying mapping...</p>
<p><code>uint64_t test = UINT64_C(9999999999999999999)</code></p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<a name="H_Floating%20Point"></a><h3>Floating Point</h3>
<p>C++'s core floating point types are as follows...</p>
<table>
<thead>
<tr>
<th>type</th>
<th>description</th>
<th>literal suffix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td>single precision</td>
<td><code>f</code></td>
<td><code>123.0f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>double precision</td>
<td></td>
<td><code>123.0</code></td>
</tr>
<tr>
<td><code>long double</code></td>
<td><a href="#BM_(extend%7Csubclass)%2Fi">extend</a>ed precision</td>
<td><code>L</code></td>
<td><code>123.0L</code></td>
</tr>
</tbody>
</table>
<p>The specifics of each type are platform-dependent. The only guarantee is that each each type has to hold at least the same range as the type before it (e.g. <code>double</code>'s range should cover <code>float</code>'s range). Other than that, ...</p>
<ul>
<li>rounding mode is undefined.</li>
<li>exponent bit length is undefined.</li>
<li>mantissa bit length is undefined.</li>
<li>subnormal number support is undefined.</li>
</ul>
<p>Floating point characteristics, although platform-specific, are queryable in the cfloat header.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>min</th>
<th>max</th>
<th>min exponent</th>
<th>max exponent</th>
<th>mantissa digits</th>
<th>radix</th>
<th>epsilon</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td><code>FLT_MIN</code></td>
<td><code>FLT_MAX</code></td>
<td><code>FLT_MIN_EXP</code></td>
<td><code>FLT_MAX_EXP</code></td>
<td><code>FLT_MANT_DIG</code></td>
<td><code>FLT_RADIX</code></td>
<td><code>FLT_EPSILON</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>DBL_MIN</code></td>
<td><code>DBL_MAX</code></td>
<td><code>DBL_MIN_EXP</code></td>
<td><code>DBL_MAX_EXP</code></td>
<td><code>DBL_MANT_DIG</code></td>
<td><code>DBL_RADIX</code></td>
<td><code>DBL_EPSILON</code></td>
</tr>
<tr>
<td><code>long double</code></td>
<td><code>LDBL_MIN</code></td>
<td><code>LDBL_MAX</code></td>
<td><code>LDBL_MIN_EXP</code></td>
<td><code>LDBL_MAX_EXP</code></td>
<td><code>LDBL_MANT_DIG</code></td>
<td><code>LDBL_RADIX</code></td>
<td><code>LDBL_EPSILON</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Mantissa digits is the number of digits (of the base specified in radix) that the floating point type uses (speculation).</p>
<p>Epsilon is the difference between 1 and the floating point number just before 1.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(sizeof)%2Fi">sizeof</a> operator should NOT be used to infer limits / characteristics of a floating point type. For example, a <code>sizeof(long double)</code> 16 doesn't necessarily mean that the type is a quadruple precision float (128-bit). Rather, it's likely that the floating point type has less precision but the platform requires padding.</p>
</div>
<p>The rounding behaviour of all floating point types is queryable via <code>FLT_ROUNDS</code>, where a ...</p>
<ul>
<li>-1 means undetermined.</li>
<li>0 means toward zero.</li>
<li>1 means toward nearest.</li>
<li>2 means toward positive infinity.</li>
<li>3 means toward negative infinity.</li>
</ul>
<p>The floating point evaluation behaviour is queryable via <code>FLT_EVAL_METHOD</code>, where a ...</p>
<ul>
<li>-1 means undetermined.</li>
<li>0 means evaluate just to the range and precision of the type.</li>
<li>1 means evaluate float and double as double, and long double as long double.</li>
<li>2 means evaluate all as long double</li>
<li>negative value other than -1 means platform-specific behavior.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unsure about the last point. How's the last point any different than -1?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I see online that <code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code>, and <code>DECIMAL_DIG</code> define the number of "decimal digits" that can be converted to floating point and back without a loss in precision. I'm assuming that just means the max number of digits that can be represented in a float where exp is 1?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits header. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<a name="H_Character%20String"></a><h3>Character String</h3>
<p>Core C++ strings are represented as an array of characters, where that array ends with a null character to signify its end. This is in contrast to other major platforms that typically structure strings a size integer along with the array (no null terminator).</p>
<p>Individual characters all map to integer types, where literals are defined by wrapping the character in single quotes. Even though they're integers, the signed-ness of each of the types below isn't guaranteed.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>bits</th>
<th>literal prefix</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>&gt;= 8</td>
<td></td>
<td><code>'T'</code></td>
<td>&gt;= 8-bit wide character (smallest unit of memory -- 1 byte)</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>16</td>
<td><code>u</code></td>
<td><code>u'T'</code></td>
<td>16-bit wide character (e.g. UTF-16)</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>32</td>
<td><code>U</code></td>
<td><code>U'T'</code></td>
<td>32-bit wide character (e.g. UTF-32)</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td></td>
<td><code>L</code></td>
<td><code>L'T'</code></td>
<td>at least as wide as <code>char</code></td>
</tr>
</tbody>
</table>
<p>Note that <code>char</code> and <code>wchar_t</code> don't have predefined bit lengths. They are platform-dependent. The bit length for...</p>
<ul>
<li><code>char</code> is defined in <code>CHAR_BIT</code> of climits and must be at least 8 bits.</li>
<li><code>wchar_t</code> must be equal to or greater than that of <code>char</code>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>char</code> literals can also be integers, but the signed-ness of the <code>char</code> type isn't defined by default (speculation). It can specifically be made to signed / unsigned by prefixing it as such: <code>signed char</code> / <code>unsigned char</code>.</p>
</div>
<p>Strings literals are wrapped in double quotes instead of single quotes, where they get transformed into an array terminated by a null character.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>literal prefix</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char *</code></td>
<td></td>
<td><code>"hello"</code></td>
<td>unknown encoding (platform specific?)</td>
</tr>
<tr>
<td><code>wchar_t *</code></td>
<td><code>L</code></td>
<td><code>L"hello"</code></td>
<td>unknown encoding (platform specific?)</td>
</tr>
<tr>
<td><code>char16_t *</code></td>
<td><code>u</code></td>
<td><code>u"hello"</code></td>
<td>encoded as UTF-16</td>
</tr>
<tr>
<td><code>char32_t *</code></td>
<td><code>U</code></td>
<td><code>U"hello"</code></td>
<td>encoded as UTF-32</td>
</tr>
<tr>
<td><code>char8_t *</code></td>
<td><code>u8</code></td>
<td><code>u8"hello"</code></td>
<td>encoded as UTF-8</td>
</tr>
</tbody>
</table>
<p>Typically escaping rules apply to string literals. Unescaped string literals are allowed by adding an <code>R</code> at the end of the literal prefix, which make it so that the ...</p>
<ol>
<li>starting quote requires a custom delimiter immediately after it.</li>
<li>finishing quote requires a custom delimited immediately before it.</li>
</ol>
<p>These delimiter characters are characters that aren't encountered in the contents of the string itself. For example, in <code>u8R"|hello|"</code>, the delimiter is <code>|</code> and isn't included in the resulting UTF-8 string.</p>
<a name="H_Void"></a><h3>Void</h3>
<p><code>void</code> is a type that represents an empty set of values. Since it can't hold a value, C++ won't allow you to declare an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type void. However, you can use it to declare that a function ...</p>
<ul>
<li>returns no value (<code>void</code> return).</li>
<li>accepts no arguments (<code>void</code> parameter list).</li>
</ul>
<a name="H_Arrays"></a><h2>Arrays</h2>
<p>C++ allows for the creation of arrays of constant length (size of the array must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a>). Elements of an array are guaranteed to be a contiguous in memory (speculation).</p>
<ul>
<li><code>int x[100]</code> - Creates an array of 100 ints where those 100 ints are junk values (data previously at that memory location is not zero'd out).</li>
<li><code>int x[] { 5, 5, 5 }</code> - Creates an array of 3 ints where each of those ints have been initialized to 5 (<a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>).</li>
<li><code>int x[] = { 5, 5, 5 }</code> - Equivalent to above (assignment does not do any extra work).</li>
<li><code>int x[3] {}</code> - Creates an array of 3 ints where each of those ints are 0 (memory zero'd out -- <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>).</li>
<li><code>int x[3] = {}</code> - Equivalent to above (assignment does not do any extra work).</li>
<li><code>int x[n]</code> - Disallowed by C++ if n isn't a constant. These types of arrays are allowed in C (called <a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>s / <a href="#BM_(VLA)%2F">VLA</a>), but not in C++ because C++ has collection <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that allow for sizes not known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</li>
</ul>
<p>Accessing arrays is done similarly to how it is in most other languages, by subscripting (e.g. <code>x[0] = 5</code>). The only difference is that array access isn't bounds-checked and array length information isn't automatically maintained at run-time. For example, if an array has 100 elements, C++ won't stop you from trying to access element 250 -- out-of-bounds array access is undefined behaviour.</p>
<p>One way to think of an arrays is as <a href="#BM_(pointer)%2Fi">pointer</a> to a contiguous block of elements of the array type. In fact, if an array type gets used where it isn't expected, that array type automatically decays to a <a href="#BM_(pointer)%2Fi">pointer</a> type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *x)</span> </span>{
   <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
   <span class="hljs-type">int</span> y = <span class="hljs-built_in">test</span>(x);
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>My understanding is that arrays are typically passed to functions as <a href="#BM_(pointer)%2Fi">pointer</a>s + array length. This is because the array length information is only available at <a href="#BM_(compile-time)%2Fi">compile-time</a>, meaning that if you have a function that takes in an array, how would it know the size of the array it's working with (it isn't the one who declared it). It looks like you can for the function to an array type of fixed size, but apparently that doesn't mean anything? The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> doesn't enforce that a caller use an array of that fixed size, and using <a href="#BM_(sizeof)%2Fi">sizeof</a> on the array will produce a warning saying that it's decaying into a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> x[<span class="hljs-number">10</span>])</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(x); <span class="hljs-comment">// compiler warning that this is returning sizeof(int *)</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
   <span class="hljs-type">size_t</span> y = <span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// compiler doesn't complain that test() expects int[10] but this is int[3]</span>
   cout &lt;&lt; y;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p>Be careful when using the <code>sizeof</code> operator on an array. If the type is the original array type, <code>sizeof</code> will return the number of bytes taken up by the elements of that array (known at <a href="#BM_(compile-time)%2Fi">compile-time</a>). However, if the type has decayed to a <a href="#BM_(pointer)%2Fi">pointer</a> type, <code>sizeof</code> will return the number of bytes to hold on to a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[<span class="hljs-number">3</span>];
<span class="hljs-type">int</span> *y = x;  <span class="hljs-comment">// equiv to setting to &amp;(x[0]);</span>
cout &lt;&lt; <span class="hljs-keyword">sizeof</span> x;  <span class="hljs-comment">// should be the size of 3 ints</span>
cout &lt;&lt; <span class="hljs-keyword">sizeof</span> y;  <span class="hljs-comment">// should be the size of a pointer</span>
</code></pre>
<p>Similarly, range-based for loops won't work if the type has decayed to a <a href="#BM_(pointer)%2Fi">pointer</a> type because the array size of that <a href="#BM_(pointer)%2Fi">pointer</a> isn't known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> *y = x;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// OK</span>
   cout &lt;&lt; y[i] &lt;&lt; endl;
}
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : x) { <span class="hljs-comment">// OK</span>
   cout &lt;&lt; v &lt;&lt; endl;
}
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : y) { <span class="hljs-comment">// ERROR</span>
   cout &lt;&lt; v &lt;&lt; endl;
}
</code></pre>
<p>You may be tempted to use <code>sizeof(array) / sizeof(type)</code> to determine the number of elements within an array. It's a better idea to use <code>std::size(array)</code> instead (found in the <a href="#BM_(iterator)%2Fi">iterator</a> header) because it should have logic to workaround and platform-specific behaviours that might cause inconsistent results / unexpected behaviour (speculation).</p>
<a name="H_Pointers"></a><h2>Pointers</h2>
<p>C++ provides types that <a href="#BM_(reference)%2Fi">reference</a> a memory address, called <a href="#BM_(pointer)%2Fi">pointer</a>s. Variables of these types can point to different memory addresses / <a href="#BM_(object%7Cinstance)%2Fi">object</a>s.</p>
<p>Adding an asterisk (*) to the end of any type makes it a <a href="#BM_(pointer)%2Fi">pointer</a> type (e.g. <code>int *</code> is a type that can contain a <a href="#BM_(pointer)%2Fi">pointer</a> to an <code>int</code>). A <a href="#BM_(pointer)%2Fi">pointer</a> to any <a href="#BM_(object%7Cinstance)%2Fi">object</a> can be retrieved using the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> unary operator (&amp;). Similarly, the value in any <a href="#BM_(pointer)%2Fi">pointer</a> can be retrieved using the deference unary operator (*).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *x { &amp;w }; <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> *y { &amp;w }; <span class="hljs-comment">// y points to w</span>
<span class="hljs-type">int</span> z = *x;    <span class="hljs-comment">// z is a copy of whatever x points to, which is w, which means it gets set to 5</span>
*x = <span class="hljs-number">7</span>;        <span class="hljs-comment">// w is set to 5 through x</span>

<span class="hljs-type">int</span> **a { &amp;x }; <span class="hljs-comment">// a points to x, which points to w (a pointer to a pointer to an int)</span>
</code></pre>
<p>As shown in the example above, it's perfectly valid to use the deference operator on the left-side of the equals. It defines where the result of the right side should go.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *x { &amp;w };  <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> **y { &amp;x }; <span class="hljs-comment">// y point to x, which points to w</span>

**y = <span class="hljs-number">7</span>;        <span class="hljs-comment">// y dereferenced twice and set to 7 -- w should now be 7 </span>
</code></pre>
<p>The notation is confusing because asterisk (*) has different meanings. In the context of a ...</p>
<ul>
<li>type declaration, an asterisk means that the type is a "<a href="#BM_(pointer)%2Fi">pointer</a> to" some other type.</li>
<li>unary operator in an expression, an asterisk means the <a href="#BM_(object%7Cinstance)%2Fi">object</a> being pointed to should be accessed.</li>
<li>binary operator in an expression, an asterisk means multiplication.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also: <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator.</p>
</div>
<p>In addition, a <a href="#BM_(pointer)%2Fi">pointer</a> can optionally be set to nothing via the <code>nullptr</code> literal. <code>nullptr</code> is actually of type <code>std::nullptr_t</code>, but the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will implicit conversion to/from other <a href="#BM_(pointer)%2Fi">pointer</a> types when required.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> *y = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// implicit conversion</span>
<span class="hljs-keyword">if</span> (y == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// report error</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It seems like there's some implicit conversions to boolean that are possible with <a href="#BM_(pointer)%2Fi">pointer</a>s. If whatever the <a href="#BM_(pointer)%2Fi">pointer</a> is going to expects a boolean, its implicitly converted to <code>ptr != nullptr</code>? So in if / while/ for conditions, you can just use the <a href="#BM_(pointer)%2Fi">pointer</a> as is without explicitly writing out a condition?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>How is this different than the NULL macro? I guess because it's a distance type, you can have a <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> that takes in param of type <code>std::nullptr_t</code>? But why would you ever want to do that?</p>
</div>
<a name="H_Pointer%20Arithmetic"></a><h3>Pointer Arithmetic</h3>
<p>Certain arithmetic operators are allowed on <a href="#BM_(pointer)%2Fi">pointer</a>s, called <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>. Adding or subtracting integer types on a <a href="#BM_(pointer)%2Fi">pointer</a> will move that <a href="#BM_(pointer)%2Fi">pointer</a> by the number of bytes that makes up its underlying type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> []x = {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-type">int</span> *ptrA = &amp;(x[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// points to idx 1 of x (5)</span>
<span class="hljs-type">int</span> *ptrB = ptrA + <span class="hljs-number">1</span>; <span class="hljs-comment">// points to idx 2 of x (7)</span>
</code></pre>
<p>This is similar to array access via the subscript operator. In fact, both arrays and <a href="#BM_(pointer)%2Fi">pointer</a>s can be accessed in the same way using the subscript operator and <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">int</span> *y = x;
*(y+<span class="hljs-number">1</span>) = <span class="hljs-number">99</span>;  <span class="hljs-comment">// equivalent to x[1] = 99</span>
x[<span class="hljs-number">2</span>] = <span class="hljs-number">101</span>;   <span class="hljs-comment">// equivalent to *(y+2) = 101;</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>An array guarantees that its elements appear contiguously and in order within memory (I think?), so if the <a href="#BM_(pointer)%2Fi">pointer</a> is from a decay'd array, using <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> to access its elements is perfectly fine.</p>
</div>
<a name="H_Void%20Pointer"></a><h3>Void Pointer</h3>
<p>A <a href="#BM_(pointer)%2Fi">pointer</a> to the void type means that the type being pointed to is unknown. Since the type is unknown, <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a void <a href="#BM_(pointer)%2Fi">pointer</a> isn't possible. In other words, it isn't possible to read or write to the data pointed to by a void * because the underlying type is void / unknown.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">void</span> *y = x;
*y = <span class="hljs-number">2</span>; <span class="hljs-comment">// fails</span>
</code></pre>
<p>Since the underlying type of the <a href="#BM_(pointer)%2Fi">pointer</a> is unknown, <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> isn't allowed either.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">void</span> *y = x;
y = y + <span class="hljs-number">2</span>; <span class="hljs-comment">// fails</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you have a <code>void *</code> and you want to do raw memory manipulation at that address, use a <code>std::byte *</code> instead. Why not just use <code>char *</code> instead? Is a <code>char</code> guaranteed to be 1 byte (I think it is)? According to <a href="https://stackoverflow.com/a/46151026">this</a>, it's because certain assumptions about <code>char</code>s may not hold with bytes? I don't know. Just remember <code>std::byte *</code> if you're working with raw data.</p>
</div>
<a name="H_Function%20Pointer"></a><h3>Function Pointer</h3>
<p>A <a href="#BM_(pointer)%2Fi">pointer</a> to a function means the type being pointed to is a function with some specific structure. All functions have a type associated with them, defined by their return type, parameter type, and owning <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> if the function is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// type is: int (int, int)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>To declare a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> to a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> or a static <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, write out the function type (return type and parameter list without names) but place the <a href="#BM_(pointer)%2Fi">pointer</a> name preceded by an asterisk (*) <em>wrapped in parenthesis</em> where the function name would be. Invoke it just like you would any other function.</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {}; <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a * b;
}

func_ptr = &amp;add;  <span class="hljs-comment">// point func_ptr to address of add()</span>
<span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// invoke</span>
</code></pre>
<p>To declare a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> to a non-static <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>), the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type needs to be included before the asterisk (*) using the scoped resolution operator (::).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (MyClass::*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {}; <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)  in or inherited from MyClass</span>

MyClass x {};

func_ptr = &amp;MyClass::multiply;  <span class="hljs-comment">// point to:  int MyClass::multiply(int, int)</span>
(x.*func_ptr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// provide x as the MyClass instance when invoking</span>
</code></pre>
<p>Unlike normal functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s cannot be assigned to raw <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s. A <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s equivalent of a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> is a <a href="#BM_(pointer)%2Fi">pointer</a> to the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (MyFunctor::*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {};  <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)  in or inherited from MyClass</span>

MyFunctor x {};

func_ptr = &amp;MyFunctor::<span class="hljs-built_in">operator</span>();
(x.*func_ptr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// provide x as the MyClass instance when invoking</span>
</code></pre>
<p>Alternatively, to support both functions and <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, the parameter expecting a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> should be changed to the <code>std::function</code> or the code doing the invocation should be changed to use the <code>std::invoke</code> wrapper. These wrappers abstract away the differences between <a href="#BM_(pointer)%2Fi">pointer</a>s to functions and <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s.</p>
<a name="H_References"></a><h2>References</h2>
<p>C++ provides a more sanitized version of <a href="#BM_(pointer)%2Fi">pointer</a>s called <a href="#BM_(reference)%2Fi">reference</a>s. A <a href="#BM_(reference)%2Fi">reference</a> type is declared by adding an ampersand (&amp;) after the type rather than an asterisk (*), and it implicitly takes the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> whatever is passed into it when its created.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};

<span class="hljs-type">int</span> *x { &amp;w }; <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> &amp;y { w };  <span class="hljs-comment">// y references to w (note address-of operator not used here)</span>
</code></pre>
<p>The main difference is between <a href="#BM_(pointer)%2Fi">pointer</a> types and <a href="#BM_(reference)%2Fi">reference</a> types is that a <a href="#BM_(reference)%2Fi">reference</a> type doesn't need to explicitly <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> to access the <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to. The <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to by the <a href="#BM_(reference)%2Fi">reference</a> type is accessed as if it were the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself.</p>
<pre class="hljs"><code>*x = <span class="hljs-number">10</span>;       <span class="hljs-comment">// x explicitly dereferenced to w and set to 10</span>
y = <span class="hljs-number">15</span>;        <span class="hljs-comment">// y implicitly dereferenced to w and set to 15</span>
</code></pre>
<p>As shown in the example above, assignment to a <a href="#BM_(reference)%2Fi">reference</a> type is assignment on the underlying <a href="#BM_(object%7Cinstance)%2Fi">object</a> being <a href="#BM_(reference)%2Fi">reference</a>d. As such, having the <a href="#BM_(reference)%2Fi">reference</a> type point a different <a href="#BM_(object%7Cinstance)%2Fi">object</a> isn't possible (<a href="#BM_(reseat)%2Fi">reseat</a>ing).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>One way to think of this is that it's implicitly <code>const</code> -- the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't let explicitly set a <a href="#BM_(reference)%2Fi">reference</a> to be <code>const</code>.</p>
</div>
<p>Similarly, it's not possible to have a <a href="#BM_(reference)%2Fi">reference</a> to a <a href="#BM_(reference)%2Fi">reference</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> &amp;&amp;z { y }; <span class="hljs-comment">// this isn't a thing -- fail</span>
</code></pre>
<a name="H_Rvalue%20References"></a><h2>Rvalue References</h2>
<p>An <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> is similar to a <a href="#BM_(reference)%2Fi">reference</a> except that it tells the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that it's working with is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a>. <a href="#BM_(rvalue%20reference)%2Fi">Rvalue reference</a>s are declared by adding two ampersands (&amp;&amp;) after the type rather than just one. It's initialized using the <code>std::move()</code> function within the utility header, which casts its input into an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>.</p>
<p><a href="#BM_(rvalue%20reference)%2Fi">Rvalue reference</a>s are typically used for moving <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (not copying, but actually moving the guts of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another). This is typically done through something called a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, which will be explained further on.</p>
<pre class="hljs"><code>MyObject a {};
MyObject &amp;&amp;b = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// get rvalue reference</span>
MyObject c {b};               <span class="hljs-comment">// move a into c (gut it into c) via the move constructor</span>
<span class="hljs-comment">// b is in an invalid state</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Once an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is moved, it's in an invalid state. The only two reliable operations you can perform on it is to either destroy or re-assign it to something else (assignments are discussed elsewhere).</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There's a piece here I don't fully understand about "forwarding <a href="#BM_(reference)%2Fi">reference</a>s". See <a href="https://github.com/AnthonyCalandra/modern-cpp-features#forwarding-references">here</a>.</p>
</div>
<a name="H_Size"></a><h2>Size</h2>
<p><code>sizeof</code> is a unary operator that returns the size of its operand in bytes as a <code>size_t</code> type. If the operand is a ...</p>
<ul>
<li>
<p>data type or a variable, it'll return the number of bytes needed to hold that type. For example, ...</p>
<ul>
<li><code>sizeof char</code> is guaranteed to be 1.</li>
<li><code>sizeof (char &amp;)</code> is guaranteed to be 1.</li>
<li><code>sizeof (char *)</code> is platform dependant, typically either 4 or 8.</li>
<li><code>char * x = "hi"; sizeof x</code> is equivalent to <code>sizeof (char *)</code> (see above).</li>
</ul>
</li>
<li>
<p>an expression such as a structure/<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> literal, array literal, or string literal, it'll return the number of bytes needed to hold it. For example, ...</p>
</li>
<li>
<p><code>sizeof "hi"</code> is 3 (added 1 for the null terminator at the end)</p>
</li>
<li>
<p><code>sizeof { 5, 5, 4 }</code> is platform dependent, typically either 12 or 24.</p>
</li>
<li>
<p><code>sizeof (int[3])</code> is platform dependent, typically either 12 or 24.</p>
</li>
<li>
<p><code>x = int[n]; sizeof x</code> is invalid C++ (<a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>s <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d on stack are not allowed in C++).</p>
</li>
</ul>
<p>In other words, <code>sizeof</code> returns the size of things known at <a href="#BM_(compile-time)%2Fi">compile-time</a>. If a variable is passed in, it outputs the size of the data type. For example, if the data type is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">struct</a> of type <code>MyStruct</code>, it'll return the number of bytes used to store a <code>MyStruct</code>. However, if the data type is a <a href="#BM_(pointer)%2Fi">pointer</a> to <code>MyStruct</code>, it'll return the number of bytes to hold that <a href="#BM_(pointer)%2Fi">pointer</a>. That is, you can't use it to get the size of something like a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamically allocated array</a> of integers.</p>
<p>In certain cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may add padding to <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (e.g. byte boundary alignments or performance reasons), meaning that the size returned by <code>sizeof</code> for an <a href="#BM_(object%7Cinstance)%2Fi">object</a> shouldn't be used to make inferences about the characteristics of that <a href="#BM_(object%7Cinstance)%2Fi">object</a>. For example, a <code>long double</code> may get reported as being 16 bytes, but that doesn't necessarily mean that a <code>long double</code> is a 128-bit quad floating point. It could be that only 12 of those bytes are used to represent the floating point number while the remainder is just padding for alignment reasons.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>As shown in the examples above, the <code>sizeof</code> a C++ <a href="#BM_(reference)%2Fi">reference</a> is equivalent to the raw size. For example, <code>sizeof char == sizeof (char &amp;)</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The last example is valid in C99 (called a <a href="#BM_(VLA)%2F">VLA</a> -- <a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>) but not C++. The reason is C++ has std::vector and std::array that give you basically the same thing as variable arrays.</p>
<p>In C, where <a href="#BM_(VLA)%2F">VLA</a>s are allowed, doing a <code>sizeof</code> on a <a href="#BM_(VLA)%2F">VLA</a> is undefined.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Remember that <code>sizeof</code> is a unary operator, similar to how the negative sign is a unary operator that negates whatever is to the right of it. People usually structure its usage in code as if it were a function (e.g. <code>sizeof(x)</code> vs <code>sizeof x</code>). This sometimes causes confusion for people coming from other languages.</p>
</div>
<a name="H_Aliasing"></a><h2>Aliasing</h2>
<p>The <code>using</code> keyword is used to give synonyms to types. Other than having a new name, a <a href="#BM_(type%20alias)%2Fi">type alias</a> is the exact same as the originating type.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> IntegerButWithNewName = <span class="hljs-type">int</span>;
<span class="hljs-type">int</span> x {<span class="hljs-number">42</span>};
IntegerButWithNewName y {<span class="hljs-number">42</span>};    <span class="hljs-comment">// equivalent to:  int y {42};</span>
IntegerButWithNewName z {x + y}; <span class="hljs-comment">// equivalent to:  int z {x + y};</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">float</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">short</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(IntegerButWithNewName x)</span></span>;  <span class="hljs-comment">// NOT ALLOWED -- this overload is equivalent to the overload above</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>To allow for use-cases such as the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing case in the example above, the cleanest solution is to wrap the type in a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a></p>
</div>
<p>The benefit of <a href="#BM_(type%20alias)%2Fi">type alias</a>ing is that it helps shorten type names, which can be especially useful when using a <a href="#BM_(template)%2Fi">template</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> BasicGraph = DirectedGraph::Graph&lt;std::string, std::map&lt;std::string, std::string&gt;, std::string, std::map&lt;std::string, std::string&gt;&gt;;

<span class="hljs-function">BasicGraph <span class="hljs-title">removeLimbs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BasicGraph &amp;g)</span></span>;
</code></pre>
<a name="H_Constant"></a><h2>Constant</h2>
<p>For types, any part of that type can be made unmodifiable by adding a <code>const</code> immediately after it.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a {<span class="hljs-number">5</span>};                <span class="hljs-comment">// a is changeable   -- set to 5</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">const</span> x {a};          <span class="hljs-comment">// x is unchangeable -- set to 5 (value in a)</span>
<span class="hljs-type">int</span> * <span class="hljs-keyword">const</span> y {&amp;a};       <span class="hljs-comment">// y is an unchangeable pointer to a changeable int -- set to a (points to a)</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> z {&amp;x}; <span class="hljs-comment">// z is an unchangeable pointer to a unchangeable int -- set to x (points to x)</span>
</code></pre>
<p>The simplest way to interpret <code>const</code>-ness of a type is to read it from right-to-left.</p>
<p><img src="svgbob_c061b9f9466df8b356db89cb60ae81dc9f42a79a.svg" alt="Kroki diagram output"></p>
<p>One caveat to the above is that a type beginning with <code>const</code> is equivalent to the first part of that type having <code>const</code> applied on it.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};  <span class="hljs-comment">// equivalent to int const x {5}</span>
</code></pre>
<p>All of the examples above were for <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>s. Appending a <code>const</code> on a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type works exactly the same way: None of its <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are modifiable ever, even by its own <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>}
};

MyStruct <span class="hljs-keyword">const</span> inst {};
inst.x = <span class="hljs-number">5</span>;  <span class="hljs-comment">// compiler error</span>
</code></pre>
<a name="H_Volatile"></a><h2>Volatile</h2>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unlike in Java, The <code>volatile</code> keyword in C++ is <em>not</em> used for thread-safety.</p>
</div>
<p>Adding the keyword <code>volatile</code> before a type makes it immune to <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> optimizations such as operation re-ordering and removal. Mutations and accesses, no matter how irrelevant they may seem, are kept in-place and in-order by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-type">int</span> x {a};
    x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y {x};
    <span class="hljs-type">int</span> x {y};
    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// at this point, x is always 6</span>
}
</code></pre>
<p>A <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> might be able to deduce that the function above always returns 6, and as such may replace the operations it performs with simply just returning 6. Adding <code>volatile</code> to the type of the variable prevents this from happening.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> x {a};  <span class="hljs-comment">// marked as volatile</span>
    x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y {x};
    <span class="hljs-type">int</span> x {y};
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>Using <code>volatile</code> is important when working with embedded devices, where platform-specific memory locations often need to be accessed in a specific order / at specific intervals in seemingly useless ways (e.g. kicking a watchdog by writing 0 to a memory location but never reading that memory location).</p>
<a name="H_Deduction"></a><h2>Deduction</h2>
<p>The keyword <code>auto</code> may be used during a variable declaration to deduce the resulting type of that variable from whatever it's being initialized with.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> a { <span class="hljs-number">1</span> };  <span class="hljs-comment">// int</span>
<span class="hljs-keyword">auto</span> b { <span class="hljs-number">1L</span> }; <span class="hljs-comment">// long</span>
<span class="hljs-keyword">auto</span> c { &amp;a }; <span class="hljs-comment">// int *</span>
<span class="hljs-keyword">auto</span> d { *c }; <span class="hljs-comment">// int</span>
<span class="hljs-keyword">auto</span> &amp;e { a }; <span class="hljs-comment">// int &amp;  &lt;-- THIS IS A SPECIAL CASE. YOU ALWAYS NEED TO USE auto&amp; FOR REFERENCES</span>
</code></pre>
<p>Note that the last variable in the example above explicitly the ampersand (&amp;) to declare e as a <a href="#BM_(reference)%2Fi">reference</a> type. This is required because <a href="#BM_(reference)%2Fi">reference</a> initialization works the same way as normal initialization (<code>auto</code> can't disambiguate).</p>
<a name="H_Implicit%20Conversion"></a><h2>Implicit Conversion</h2>
<p>An <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> is when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is converted (cast) automatically, without code explicitly changing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to a different type. For example, <code>long x {1}</code> implicitly converts the <code>int</code> literal in the initializer to a <code>long</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">long</span> y {x};  <span class="hljs-comment">// int to long</span>
</code></pre>
<p>The most common types of implicit conversions are ...</p>
<ul>
<li>when a <a href="#BM_(pointer)%2Fi">pointer</a> of a certain type gets implicitly converted to a void <a href="#BM_(pointer)%2Fi">pointer</a> (e.g. <code>int *</code> to <code>void *</code>).</li>
<li>when a numeric type gets converted to another numeric type via <a href="#BM_(promotion%20rule)%2Fi">promotion rule</a>s (e.g. <code>int</code> to <code>float</code>).</li>
<li>when a numeric type gets converted to a bool type (e.g. <code>0</code> to <code>false</code>)</li>
</ul>
<p>Depending on the operation performed or how an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is initialized, the results of an implicit conversion may do something specific to that platform and/or <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> implementation.</p>
<table>
<thead>
<tr>
<th>Source Type</th>
<th>Destination Type</th>
<th>Behaviour</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>Floating Point</td>
<td>Implementation-specific behaviour if can't fit in destination (speculation).</td>
</tr>
<tr>
<td>Floating Point</td>
<td>Integer</td>
<td>Rounded to integer (speculation - how?), implementation-specific behaviour if can't fit in destination (speculation).</td>
</tr>
<tr>
<td>Integer</td>
<td>Integer</td>
<td>Signed destination and value can't fit, implementation-specific behaviour. Unsigned destination and value can't fit, truncates higher-order bits.</td>
</tr>
<tr>
<td>Floating Point</td>
<td>Floating Point</td>
<td>Implementation-specific behaviour if value can't fit in destination.</td>
</tr>
<tr>
<td>Any Numeric</td>
<td>Boolean</td>
<td>0 converts to <code>false</code>, otherwise <code>true</code>.</td>
</tr>
<tr>
<td>Any <a href="#BM_(pointer)%2Fi">Pointer</a></td>
<td>Boolean</td>
<td><code>nullptr</code> converts to <code>false</code>, otherwise <code>true</code>.</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends to always use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> because when you do, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> produces warnings about types not fitting. However, those warnings don't seem to cover everything, at least that's the impression I get from what I've tried.</p>
</div>
<a name="H_Common%20Attributes"></a><h2>Common Attributes</h2>
<p>If a variable has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it sees it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Explicit%20Conversion"></a><h2>Explicit Conversion</h2>
<p>An <a href="#BM_(explicit%20type%20conversion)%2Fi">explicit type conversion</a> is the opposite of an <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>. It's when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is explicitly converted (cast) to another type in code.</p>
<pre class="hljs"><code><span class="hljs-type">long</span> x {<span class="hljs-number">5L</span>};
<span class="hljs-type">int</span> y {<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x)};   <span class="hljs-comment">// long to int</span>
</code></pre>
<p><a href="#BM_(explicit%20type%20conversion)%2Fi">Explicit type conversion</a>s come in two forms:</p>
<ul>
<li><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s are the official way to cast in C++.</li>
<li>C-style casts are the legacy way to cast in C++.</li>
</ul>
<p><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s should be preferred over C-style casts. Any C-style cast can be performed through a <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>.</p>
<a name="H_Named%20Conversions"></a><h4>Named Conversions</h4>
<p><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion function</a>s are a set of (seemingly <a href="#BM_(template)%2Fi">template</a>d) functions to convert an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s types. These functions provides safety mechanisms that aren't available in other older ways of casting.</p>
<ul>
<li>
<p><code>const_cast</code> removes the <code>const</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> from an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyType &amp;t)</span> </span>{
    T &amp;<span class="hljs-type">moddable_t</span> = <span class="hljs-built_in">const_cast</span>&lt;MyType &amp;&gt;(t);
}
</code></pre>
<p>Performing this type of conversion should only be done in extreme situations since it breaks contracts.</p>
</li>
<li>
<p><code>static_cast</code> forces the reverse of an implicit conversion.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
<span class="hljs-type">int</span> *b = a;  <span class="hljs-comment">// ok, implicit conversion (decay to pointer)</span>
<span class="hljs-type">void</span> *c = b; <span class="hljs-comment">// ok, implicit conversion</span>
<span class="hljs-type">int</span> *d = c;  <span class="hljs-comment">// error, can't go in reverse</span>
<span class="hljs-type">int</span> *e = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(c); <span class="hljs-comment">// ok</span>
</code></pre>
<p>In the above example, a <code>uint32_t *</code> implicitly converts to <code>void *</code>, but not the reverse. A <code>static_cast</code> makes going in reverse possible. However, that doesn't mean it's always safe to do. For example, <code>uint32_t</code> reads may need to be aligned to 4 byte boundaries on certain platforms. If the <code>void *</code> was arbitrary data (e.g. coming in over a network), it might cause a crash to just treat it as a <code>uint32_t *</code> and start reading.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why does a <code>uint32_t*</code> implicitly convert to a <code>void *</code>? Recall that <code>void *</code> just means "<a href="#BM_(pointer)%2Fi">pointer</a> to something unknown", which is something the language is okay automatically / implicitly converting.</p>
</div>
</li>
<li>
<p><code>reinterpret_cast</code> forces a reinterpretation of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> into an entirely different type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
<span class="hljs-type">int</span> *b = a;   <span class="hljs-comment">// ok, implicit conversion (decay to pointer)</span>
<span class="hljs-type">short</span> *c = b; <span class="hljs-comment">// error, you can't convert from an int* to a short* (not even with a static_cast because it's not an implicit conversion)</span>
<span class="hljs-type">short</span> *d = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">int</span> *&gt;;  <span class="hljs-comment">// ok</span>
</code></pre>
</li>
<li>
<p><code>narrow_cast</code> is similar to <code>static_cast</code> for numerics, except it ensures that no information loss occurred.</p>
<pre class="hljs"><code><span class="hljs-type">uint32_t</span> a = <span class="hljs-number">70000</span>;                     <span class="hljs-comment">// ok</span>
<span class="hljs-type">uint16_t</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(a);  <span class="hljs-comment">// ok, but since uint16_t has a max of65535, this object is mangled</span>
<span class="hljs-type">uint16_t</span> c = <span class="hljs-built_in">narrow_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(a);  <span class="hljs-comment">// runtime exception, narrow_cast sees that the object will be mangled</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Is this part of the standard? The book seems to give the code for <code>narrow_cast</code> and looking online it looks like people have their own implementations?</p>
</div>
</li>
</ul>
<a name="H_C-style%20Casts"></a><h4>C-style Casts</h4>
<p>C-style casts are similar to casts seen in Java. The type is bracketed before whatever is being evaluated.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>) <span class="hljs-number">9999999999L</span>;
</code></pre>
<p>The problem with C-style casts are that they don't provide the same safety mechanisms as <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>s do (e.g. inadvertently strip the <code>const</code>-ness). <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s provide these safety mechanisms and as such should be preferred over C-style casts. Any C-style cast can be performed using a <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>.</p>
<a name="H_Object%20Lifecycle"></a><h2>Object Lifecycle</h2>
<p>In C++, an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is a region of memory that has a type and a value (e.g. a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(object%7Cinstance)%2Fi">instance</a>, an integer, a <a href="#BM_(pointer)%2Fi">pointer</a> to an integer, etc..). Contrary to other more high-level languages (e.g. Java), C++ <a href="#BM_(object%7Cinstance)%2Fi">object</a>s aren't exclusive to <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es (e.g. an boolean is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>).</p>
<p>An <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s life cycle passes through the following stages:</p>
<ol>
<li>memory <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d</li>
<li><a href="#BM_(constructor)%2Fi">constructor</a> invoked</li>
<li><a href="#BM_(destructor)%2Fi">destructor</a> invoked</li>
<li>memory <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d</li>
</ol>
<p>The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> starts from when its memory is <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and ends when that memory is <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. An <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a>, on the other hand, starts when its <a href="#BM_(constructor)%2Fi">constructor</a> <em>completes</em> (meaning the <a href="#BM_(constructor)%2Fi">constructor</a> finishes) and ends when its <a href="#BM_(destructor)%2Fi">destructor</a> is <em>invoked</em> (meaning when the <a href="#BM_(destructor)%2Fi">destructor</a> starts).</p>
<p><img src="svgbob_5382fe6e4bca4e56d9147249ff0bb4082202935e.svg" alt="Kroki diagram output"></p>
<p>Since C++ doesn't have a garbage collector performing cleanup like other high-level languages, it's the user's responsibility to ensure how <a href="#BM_(object%7Cinstance)%2Fi">object</a> <a href="#BM_(lifetime)%2Fi">lifetime</a>s. The user is responsible for knowing when <a href="#BM_(object%7Cinstance)%2Fi">object</a>s should be destroyed and ensuring that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are only accessed within their <a href="#BM_(lifetime)%2Fi">lifetime</a>.</p>
<p>The typical <a href="#BM_(storage%20duration)%2Fi">storage duration</a>s supported by C++ are...</p>
<ul>
<li><a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a> - scoped to duration of some function within the program.</li>
<li><a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static storage duration</a> - scoped to the entire duration of the program.</li>
<li><a href="#BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi">thread storage duration</a> - scoped to the entire duration of a thread in the program.</li>
<li><a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic storage duration</a> - <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d on request of the user.</li>
</ul>
<a name="H_Static%20Objects"></a><h3>Static Objects</h3>
<p>By default, an <a href="#BM_(object%7Cinstance)%2Fi">object</a> declared within a function is said to be an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a>. <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">Automatic object</a>s have <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a>s: start at the beginning of the block and finish at the end of the block. When the keyword <code>static</code> (or <code>extern</code> in some cases) is added to the declaration, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of the function changes.</p>
<p>At global scope, if an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is declared as <code>static</code> or <code>extern</code>, <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> spans the entire duration of the program. The difference between the two is essentially just visibility:</p>
<ul>
<li><code>static</code> makes it so it's accessible to only the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's declared in.</li>
<li><code>extern</code> makes it so it's accessible to other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s as well as the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's declared in.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">// static variable</span>
<span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; <span class="hljs-comment">// static variable (accessible outside translation unit)</span>
</code></pre>
<p>At function scope, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s declared as <code>static</code> starts at the first invocation of that function and ends when the program exits.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; <span class="hljs-comment">// static variable</span>
    z += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> z;
}
</code></pre>
<p>At <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> level, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of a <a href="#BM_%5Cb(member)%2Fi">member</a> (<a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> or <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>) declared as <code>static</code> is essentially the same as if it were declared at global scope (they aren't bound to an individual <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the same way a normal <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> or <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is). The only differences are that the <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a> is accessed on the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself using the scoped resolution operator (::) and that <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a>s that are <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s must be initialized at global scope.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m;         <span class="hljs-comment">// static member (field initialized at end)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">// static member (method)</span>
        m += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> m;
    }
};

X::m = <span class="hljs-number">0</span>;                <span class="hljs-comment">// initialize static member</span>
</code></pre>
<p>If the <code>thread_local</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> is added before <code>static</code> (or <code>extern</code>), each thread gets its own copy of the <a href="#BM_(object%7Cinstance)%2Fi">object</a>. That is, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> essentially gets changed to when the thread starts and ends.</p>
<p><code>thread_local static</code> can be shortened to just <code>thread_local</code> (it's assumed to be static).</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;
<span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> c = <span class="hljs-number">2</span>;
</code></pre>
<a name="H_Dynamic%20Objects"></a><h3>Dynamic Objects</h3>
<p>An <a href="#BM_(object%7Cinstance)%2Fi">object</a> can be created in an ad-hoc manner, such that its <a href="#BM_(storage%20duration)%2Fi">storage duration</a> is entirely controlled by the user. The operator ...</p>
<ul>
<li><code>new</code> <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>s a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> and calling its the <a href="#BM_(constructor)%2Fi">constructor</a>.</li>
<li><code>delete</code> calls the <a href="#BM_(destructor)%2Fi">destructor</a> of some <a href="#BM_(object%7Cinstance)%2Fi">object</a> and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>s it.</li>
</ul>
<p>Both keywords work with <a href="#BM_(pointer)%2Fi">pointer</a>s: <code>new</code> returns a <a href="#BM_(pointer)%2Fi">pointer</a> while <code>delete</code> requires a <a href="#BM_(pointer)%2Fi">pointer</a>. To create a new <a href="#BM_(object%7Cinstance)%2Fi">object</a>, use <code>new</code> followed by the type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;
*ptr = <span class="hljs-number">0</span>;
<span class="hljs-keyword">delete</span> ptr;
</code></pre>
<p><a href="#BM_(object%7Cinstance)%2Fi">Object</a>s may be initialized directly within the <code>new</code> invocation just as if it were an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> initialization. The only caveat is that <a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a> and <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> won't work because the equal sign is already being used during <code>new</code> (speculation -- it doesn't work but I don't know the exact reason). As such, <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> is the best way to initialize a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">0</span>}; <span class="hljs-comment">// initialize to 0</span>
<span class="hljs-keyword">delete</span> ptr;
</code></pre>
<p>The same process can be used to create an array of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. Unlike <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> arrays, <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s don't have a constant size array lengths restriction.. However, the return value <code>new</code> will decay from an array type to a <a href="#BM_(pointer)%2Fi">pointer</a> type.</p>
<p>When deleting a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> array, square brackets need to be appended to <code>delete</code> operator: <code>delete[]</code>. Doing so ensures that the <a href="#BM_(destructor)%2Fi">destructor</a> for each <a href="#BM_(object%7Cinstance)%2Fi">object</a> in the array gets invoked before <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len];  <span class="hljs-comment">// len is some non-constant positive integer, decayed to pointer type because array length can be non-constant.</span>
<span class="hljs-keyword">delete</span>[] ptr;
</code></pre>
<p><a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> may be used when declaring <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s so long as the size of the array is at least the size of the initialization list.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};  <span class="hljs-comment">// initialize the first 3 elems of a 10 elem array</span>
<span class="hljs-type">int</span> * ptr2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};   <span class="hljs-comment">// throws exception  (size too small for initializer list)</span>
<span class="hljs-type">int</span> * ptr3 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};   <span class="hljs-comment">// okay -- so long as n &gt;= 3</span>
<span class="hljs-keyword">delete</span>[] ptr1;
<span class="hljs-keyword">delete</span>[] ptr2;
<span class="hljs-keyword">delete</span>[] ptr3;
</code></pre>
<p>By default, <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s are stored on a block of memory called the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a>, also sometimes referred to as the <a href="#BM_(heap%7Cfree%20store)%2Fi">free store</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing section to see how the <code>new</code> and <code>delete</code> operators may be overridden to customize where and how a specific type gets stored.</p>
<p>The <code>new</code> and <code>delete</code> operators may also be overridden globally rather than per-type. See the new header.</p>
</div>
<a name="H_User-defined%20Literals"></a><h2>User-defined Literals</h2>
<p>C++ provides a way for users to define their own literals through the use of operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing, called <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s. <a href="#BM_(user-defined%20literal)%2Fi">User-defined literal</a>s wrap built-in literals and perform some operation to convert them to either another type or anothe<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>. It's identified by a unique suffix that starts with an underscore (e.g. <code>_km</code>).</p>
<p>The operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> is identified by two quotes followed by the suffix.</p>
<pre class="hljs"><code>Distance <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _km (<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) {
    <span class="hljs-keyword">return</span> Distance {n * <span class="hljs-number">1000.0</span>};
}

Distance <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _mi (<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) {
    <span class="hljs-keyword">return</span> Distance {n * <span class="hljs-number">1609.34</span>};
}

Distance d = <span class="hljs-number">1.2</span>_km + <span class="hljs-number">4.0</span>_mi;
</code></pre>
<p>As stated above, <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s must wrap an existing built-in <a href="#BM_(literal%20type)%2Fi">literal type</a>.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>integral</td>
<td><code>return_type operator"" identifier (unsigned long long int)</code></td>
</tr>
<tr>
<td>floating point</td>
<td><code>return_type operator"" identifier (long double)</code></td>
</tr>
<tr>
<td>character</td>
<td><code>return_type operator"" identifier (char)</code></td>
</tr>
<tr>
<td>wide character</td>
<td><code>return_type operator"" identifier (wchar_t)</code></td>
</tr>
<tr>
<td>utf-8 character</td>
<td><code>return_type operator"" identifier (char8_t)</code></td>
</tr>
<tr>
<td>utf-16 character</td>
<td><code>return_type operator"" identifier (char16_t)</code></td>
</tr>
<tr>
<td>utf-32 character</td>
<td><code>return_type operator"" identifier (char32_t)</code></td>
</tr>
<tr>
<td>character string</td>
<td><code>return_type operator"" identifier (char *, size_t)</code></td>
</tr>
<tr>
<td>wide character string</td>
<td><code>return_type operator"" identifier (wchar_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-8 string</td>
<td><code>return_type operator"" identifier (char8_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-16 string</td>
<td><code>return_type operator"" identifier (char16_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-32 string</td>
<td><code>return_type operator"" identifier (char32_t *, size_t)</code></td>
</tr>
<tr>
<td>raw</td>
<td><code>return_type operator"" identifier (const char *)</code></td>
</tr>
</tbody>
</table>
<p>Note that, for ...</p>
<ul>
<li>numerics, the widest possible C++ type is used for both integral (unsigned long long int) and floating point (long double).</li>
<li>characters, each character type gets its own definition.</li>
<li>strings, each string type gets its own definition.</li>
</ul>
<p>The last definition in the table above, raw, will get a character string of any numeric literal used.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _as_str (<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * n) {
    std::cout &lt;&lt; <span class="hljs-string">"input str: "</span> &lt;&lt; n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-number">123.5e+12</span>_as_str;  <span class="hljs-comment">// outputs "input str: 123.5e+12"</span>
</code></pre>
<p>The standard C++ library makes use of <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s in various places, but its identifiers don't require an underscore (_) prefix.</p>
<ul>
<li>Date-time API (chrono header): <code>std:chrono::duration d  = 2h + 15ms</code>.</li>
<li>Complex numbers API (complex header): <code>std::complex&lt;double&gt; = (1.0 + 2.0i) * (3.0 + 4.0i)</code>.</li>
<li>String API (string): <code>std::string str = "hello"s + "world"s</code>.</li>
</ul>
<a name="H_Functions"></a><h1>Functions</h1>
<p>C++ function declarations and definitions have the following form: <code>prefix-modifiers return-type name(parameters) suffix-modifiers</code></p>
<ul>
<li>
<p><strong>return-type</strong> (required) - Type returned by function.</p>
</li>
<li>
<p><strong>name</strong>: (required) - Name of function.</p>
</li>
<li>
<p><strong>parameters</strong> (required) - Parameter list of function.</p>
</li>
<li>
<p><strong>prefix-<a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a function.</p>
<p>(e.g. <code>static</code>, <code>virtual</code>,  <code>constexpr</code>, <code>[[noreturn]]</code>, <code>inline</code>, ...)</p>
</li>
<li>
<p><strong>suffix-<a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a function.</p>
<p>(e.g. <code>noexcept</code>, <code>const</code>,  <code>final</code>, <code>override</code>, <code>volatile</code>, ...)</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}
</code></pre>
<p>In C++, functions that are ...</p>
<ul>
<li><a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s (assigned to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) are called <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s.</li>
<li>global are called <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</li>
</ul>
<p>This section deals with <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Some of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s listed above are for <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s, not <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
</div>
<a name="H_Overloading"></a><h2>Overloading</h2>
<p><a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">Function overload</a>ing is when there are multiple functions with the same name in the same scope. For <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, each <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> must have the same return type and a unique set of parameters.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0.0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a != b; }
</code></pre>
<p>When an <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overloaded function</a> is called, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will try to match argument types against parameter types to figure out which <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overloaded function</a> to call. If no exact match can be found, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> attempts to obtain a correct set of types through a set of conversions.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;
<span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// calls the first overload in the code above:  bool test(int a);</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See argument matching section.</p>
</div>
<a name="H_Argument%20Matching"></a><h2>Argument Matching</h2>
<p>When an function is called but the arguments types don't match the parameter list types, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> attempts to obtain a correct set of types through a set of conversions on the arguments. For example, if a parameter expects a <a href="#BM_(reference)%2Fi">reference</a> to an constant <a href="#BM_(object%7Cinstance)%2Fi">object</a> but what gets passed into the argument is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, the argument is automatically converted to a constant <a href="#BM_(object%7Cinstance)%2Fi">object</a> and its <a href="#BM_(reference)%2Fi">reference</a> is used.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp;obj)</span> </span>{ ... }

<span class="hljs-type">int</span> x {};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// x is turned into a "const int" and passed in as a reference</span>
</code></pre>
<p>For floating point and integral types, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will widen or <em>narrow</em> the if the exact type isn't found.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> a)</span> </span>{
    std::cout &lt;&lt; a;
    <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;
}

<span class="hljs-type">float</span> x {<span class="hljs-number">1.5</span>};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// automatic narrowing</span>
</code></pre>
<p>Similarly, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will convert between signed and unsigned integral types if the exact integral type isn't found.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a)</span> </span>{
    std::cout &lt;&lt; a;
    <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;
}

<span class="hljs-type">int64_t</span> x {<span class="hljs-number">10</span>};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// automatic narrowing and change to unsigned</span>
</code></pre>
<p>When <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>s are involved, the candidate with the arguments matching most closely is the one chosen.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The exact rules here seem hard to definitively pin down. If you have two <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s of a function, one accepting int16 and int64, it'll fail when you try to call it with int8 claiming that it's too ambiguous. The best thing to do is to just ask the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to either warn on implicit conversion (<code>-Wconversion</code>) flag or on narrowing implicit conversion (<code>-Wnarrowing</code> / <code>-Wno-narrowing</code>). These flags may not be included under <code>-Wall</code>.</p>
</div>
<a name="H_Type%20Deduction"></a><h2>Type Deduction</h2>
<p>Similar to variable declarations, the <code>auto</code> keyword is also usable to deduce a function's parameter and return types based on usage.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;
}
</code></pre>
<p>The use of <code>auto</code> is essentially short-hand for a function <a href="#BM_(template)%2Fi">template</a>. In the example above, each unique set of types used when invoking <code>add()</code> is a <a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>.</p>
<pre class="hljs"><code><span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);     <span class="hljs-comment">// uses  int add(int x)</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">6</span>);     <span class="hljs-comment">// uses  int add(int x)</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">5ULL</span>);  <span class="hljs-comment">// uses  unsigned long long add(unsigned long long x)</span>
</code></pre>
<p>When using <code>auto</code> for a return type, you can optionally add a <code>-&gt;</code> immediately after the parameter list followed by a type expression that defines what expression should generate the returning type.</p>
<pre class="hljs"><code><span class="hljs-comment">// return type should be whatever type the result of x + 5LL is, which is long long</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x+<span class="hljs-number">5LL</span>)</span> </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why is the above useful? Using <code>auto</code> on functions is discouraged because function definitions act as documentation. The <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> is with <a href="#BM_(template)%2Fi">template</a>s, where the types depend in potentially complex ways on <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
<p>By adding the type expression in, you're re-introducing a form of documentation.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Try running functions with auto through <a href="https://cppinsights.io">here</a> to get a feel for how this transforms to function <a href="#BM_(template)%2Fi">template</a>s.</p>
</div>
<a name="H_Main%20Function"></a><h2>Main Function</h2>
<p>The entry-point to any C++ program is the <code>main</code> function, which can take one of three possible forms:</p>
<ol>
<li>
<p><code>int main()</code></p>
<p>No arguments.</p>
</li>
<li>
<p><code>int main(int argc, char* argv[])</code></p>
<p>Command-line arguments, where <code>argv</code> is an array of size <code>argc</code> containing the null-terminated command-line arguments. On most modern platform, the first argument is the path of the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
</li>
<li>
<p><code>int main(int argc, char* argv[], EXTRA_PLATFORM_SPECIFIC_PARAMS)</code></p>
<p>Same as the above except extra arguments are supplied that are platform-specific.</p>
</li>
</ol>
<p>All three forms return an integer known as an exit code. On most modern day platforms, an exit code of 0 means success. If the code doesn't return an exit code, 0 is assumed.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; argv[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Should <code>argv</code> be <code>const char * const *</code>? In that you shouldn't be able to change the strings or the string <a href="#BM_(pointer)%2Fi">pointer</a> at each array index.</p>
</div>
<a name="H_Variadic"></a><h2>Variadic</h2>
<p>A <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> function is one that takes in a variable number of arguments, sometimes called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s in other languages. A function can be made <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> by placing <code>...</code> as the final parameter. The arguments for this final parameter are called the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments.</p>
<p>The <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments for a function are accessible through functionality provided by the cstdargs header.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdargs&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-type">float</span> sum {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        sum += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">return</span> sum /= n;
}
</code></pre>
<ul>
<li><code>va_list</code> - Access point to <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments.</li>
<li><code>va_start</code> - Initializes access to <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments (requires the <code>va_list</code> variable and the expected count of <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments).</li>
<li><code>va_args</code> - Gets the next <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> argument (requires the <code>va_list</code> variable and the expected type).</li>
<li><code>va_end</code> - Tears down access to the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments (requires the <code>va_list</code> variable).</li>
</ul>
<p>In addition, the <code>va_copy()</code> can be used to copy one <code>va_list</code> to another. The source will need to be initialized before the copy (via <code>va_start</code>). Once <code>va_copy</code> returns, copy will already be initialized (no need for <code>va_start</code>) but will need to be torn down before the function exits (via <code>va_end</code>).</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdargs&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">add_and_mult</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    va_list args2;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-built_in">va_copy</span>(args2, args);  <span class="hljs-comment">// 1st param is dst, 2nd param is src</span>
    <span class="hljs-type">float</span> res {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        res += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        res *= <span class="hljs-built_in">va_args</span>(args2, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args2);
    <span class="hljs-keyword">return</span> res;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends against using <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> functions due to confusing usage and having to explicitly know the count and types of the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments before hand (can become security problem is screwed up). Instead it recommends using <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> <a href="#BM_(template)%2Fi">template</a>s for functions instead.</p>
</div>
<a name="H_No%20Exception"></a><h2>No Exception</h2>
<p>In certain cases, it'll be impossible for a function to throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. Either the function (and the functions it calls into) never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> or the conditions imposed by the function make it impossible for any <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> to be thrown. In such cases, a function may be marked with the <code>noexcept</code> keyword. This keyword allows the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to perform certain optimizations that it otherwise wouldn't have been able to, but it doesn't necessarily mean that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will check to ensure an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> can't be thrown.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">noexcept</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions this is documented in "Item 16 of Effective Modern C++ by Scott Meyers". It goes on to say that, unless specified otherwise, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> assumes <a href="#BM_(move%20constructor)%2Fi">move constructor</a>s / move-assignment operators can thrown an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> if they try to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> memory but the system doesn't have any. This prevents it from making certain optimizations.</p>
</div>
<a name="H1_Common%20Attributes"></a><h2>Common Attributes</h2>
<p>If a function has no possibility of ever gracefully returning to the caller, adding a <code>[[noreturn]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to make certain optimizations and provide / remove relevant warnings around that function.</p>
<pre class="hljs"><code>[[noreturn]] <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-string">"error"</span>;
}
</code></pre>
<p>If a function returns something and it's of vital importance that the return value should be used by the invoker, adding a <code>[[nodicard]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning.</p>
<pre class="hljs"><code>[[nodiscard]] <span class="hljs-function">Result <span class="hljs-title">perform</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-comment">// perform some computation</span>
    <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> ERROR_CODE;
    }
    <span class="hljs-keyword">return</span> SUCCESS_CODE;
}
</code></pre>
<p>If a function's parameter isn't used but it's inclusion in the parameter list is intentional, adding a <code>[[maybe_used]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to remove any warnings that it might otherwise show up about it being unused.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, [[maybe_unused]] <span class="hljs-type">int</span> c)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>If a function has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Coroutines"></a><h2>Coroutines</h2>
<p>A coroutine that can suspend its own execution and have it be continued at a later time. Similar to async functions in Javascript, C++ coroutines can work with promise <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (<a href="#BM_(object%7Cinstance)%2Fi">object</a>s that do work asynchronously). A function can be made into a coroutine by using any of the following:</p>
<ul>
<li><code>co_await</code> - suspend execution waiting for a promise to finish.</li>
<li><code>co_yield</code> - suspend execution and optionally return a value.</li>
<li><code>co_return</code> - complete execution and optionally return a value.</li>
</ul>
<p>The return value of a coroutine is a "promise type", a C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that has a specific structure and specific set of functionality that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> calls to determine and control the coroutine's state.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is deeply convoluted and requires a lot more digging and documentation, possibly in its own section instead of sub-section under the Function header.</p>
</div>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resumable</span> {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span>; <span class="hljs-comment">// forward declaration</span>
    <span class="hljs-built_in">Resumable</span>(std::coroutine_handle&lt;promise_type&gt; coro) : <span class="hljs-built_in">coro</span>(coro) {}
    ~<span class="hljs-built_in">Resumable</span>() {
        coro.<span class="hljs-built_in">destroy</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{ coro.<span class="hljs-built_in">destroy</span>(); }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>{ coro.<span class="hljs-built_in">resume</span>(); }
<span class="hljs-keyword">private</span>:
    std::coroutine_handle&lt;promise_type&gt; coro;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resumable</span>::promise_type {
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Resumable</span>(std::coroutine_handle&lt;Resumable::promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">suspend_never</span>(); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">suspend_never</span>(); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{
        current_value = value;
        <span class="hljs-keyword">return</span> std::suspend_always{};
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>{ }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{ }
    <span class="hljs-type">int</span> current_value;
};

<span class="hljs-function">Resumable <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{
    <span class="hljs-keyword">while</span> (start &lt; end) {
        <span class="hljs-keyword">co_yield</span> start;
        std::cout &lt;&lt; start &lt;&lt; <span class="hljs-string">'\n'</span>;
        start++;
    }
    <span class="hljs-keyword">co_return</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 0</span>
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 1</span>
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 2</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It's said that the coroutine state is kept on the stack, resulting in C++ coroutines being a performance hog. Maybe it's possible to use a custom allocator to work around performance problems?</p>
</div>
<a name="H_Enumerations"></a><h1>Enumerations</h1>
<p>C++ <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>s are declared using <code>enum class</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MyEnum</span> {
   OptionA,
   OptionB,
   OptionC
};

MyEnum x = MyEnum::OptionC;

<span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">case</span> MyEnum::OptionA:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> MyEnum::OptionB:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> MyEnum::OptionC:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>An <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> may be brought into scope via <code>using</code> to removing the need to prefix with the <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>'s name.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span>;
    <span class="hljs-keyword">case</span> OptionA:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> OptionB:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> OptionC:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It's possible to remove the <code>class</code> from <code>enum class</code>, which heavily loosens type-safety and scope. By removing <code>class</code>, the options within have thei<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>s implicitly converted to integers and you don't need the resolution scope operator (their options are accessible at the same level as an <a href="#BM_(enumeration%7Cenum)%2Fi">enum</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> { <span class="hljs-comment">// no class keywrod</span>
   OptionA,
   OptionB,
   OptionC
};

MyEnum x = OptionC; <span class="hljs-comment">// this is okay -- don't have to use MyEnum::OptionC</span>
<span class="hljs-type">int</span> y = OptionC;    <span class="hljs-comment">// this is okay -- options are integers</span>
</code></pre>
<p>You should prefer <code>enum class</code>.</p>
</div>
<a name="H_Classes"></a><h1>Classes</h1>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are declared using either the <code>struct</code> keyword or <code>class</code> keyword. When ...</p>
<ul>
<li><code>struct</code> is used, the default visibility of <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a>s is public.</li>
<li><code>class</code> is used, the default visibility of <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a>s is private.</li>
</ul>
<p>Public and private visibility are the same as in most other languages: private <a href="#BM_%5Cb(member)%2Fi">member</a>s aren't accessible outside the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> while public <a href="#BM_%5Cb(member)%2Fi">member</a>s are. In C++ nomenclature, ...</p>
<ul>
<li><a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s are commonly referred to as <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s.</li>
<li><a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are commonly referred to as <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>{
        count += <span class="hljs-number">1</span>;
        flag = <span class="hljs-literal">false</span>;
    }
};
</code></pre>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that contain only data are called <a href="#BM_(plain-old-data%20class%7Cplain-old%20data%20class%7Cplain%20old%20data%20class%7Cplain-old-data%20structure%7Cplain-old%20data%20structure%7Cplain%20old%20data%20structure%7Cplain-old-data%20struct%7Cplain-old%20data%20struct%7Cplain%20old%20data%20struct)%2Fi">plain-old-data class</a>es (<a href="#BM_(POD)%2F">POD</a>), and they're typically created using the <code>struct</code> keyword so as their <a href="#BM_%5Cb(member)%2Fi">member</a>s are all accessible by default.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count;
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
   <span class="hljs-type">bool</span> flag;
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>C++ guarantees that a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>'s <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s will be sequentially stored in memory, but they may be padded / aligned based on the platform. Be aware when using the <a href="#BM_(sizeof)%2Fi">sizeof</a> operator.</p>
</div>
<a name="H_This%20Pointer"></a><h2>This Pointer</h2>
<p>Non-static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have access to an implicit <a href="#BM_(pointer)%2Fi">pointer</a> called <code>this</code>, which allows for accessing that <a href="#BM_(object%7Cinstance)%2Fi">instance</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s. As long as the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> doesn't conflict with a parameter name of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked, the usage of that name will implicitly <a href="#BM_(reference)%2Fi">reference</a> the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<p>The <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator (-&gt;) allows for <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a <a href="#BM_(pointer)%2Fi">pointer</a> and accessing a <a href="#BM_%5Cb(member)%2Fi">member</a> on the result in a more concise form.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">f1</span>(<span class="hljs-type">int</span> count) {
        <span class="hljs-keyword">this</span>-&gt;count = count;  <span class="hljs-comment">// equivalent to (*this).count = count</span>
        flag = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-built_in">f2</span>(<span class="hljs-type">int</span> count, <span class="hljs-type">bool</span> flag) {
        <span class="hljs-keyword">this</span>-&gt;count = count;  <span class="hljs-comment">// equivalent to (*this).count = count</span>
        <span class="hljs-keyword">this</span>-&gt;flag = flag;    <span class="hljs-comment">// equivalent to (*this).flag = flag</span>
    }
}
</code></pre>
<a name="H1_Constant"></a><h2>Constant</h2>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>const</code> before the type has the same meaning as a <code>const</code> type at global scope: It's unmodifiable.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>const</code> after the parameter list indicates that the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>'s <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s won't be modified (read-only). This is a deep check rather than a shallow check, meaning that the entire call graph is considered when checking for modification.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inner</span> {
    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-type">int</span> y = <span class="hljs-number">6</span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
        x = n;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
    Inner inner;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        a = <span class="hljs-number">5</span>;  <span class="hljs-comment">// NOT okay -- no mutation allowed</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        inner.x = <span class="hljs-number">15</span>; <span class="hljs-comment">// NOT okay -- no mutation allowed, even though this is deeper down</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        inner.<span class="hljs-built_in">change</span>(<span class="hljs-number">15</span>); <span class="hljs-comment">// NOT okay -- method being invoked must be const (otherwise mutation might happen)</span>
    }
};
</code></pre>
<a name="H1_Volatile"></a><h2>Volatile</h2>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>volatile</code> before the type has the same meaning as a <code>volatile</code> type at global scope: The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't optimize its access.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>volatile</code> after the parameter list indicates that all <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s should be treated as <code>volatile</code> (access won't be optimized away or re-ordered). This is a deep check rather than a shallow check, meaning that the entire call graph requires <code>volatile</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Another way to think of this is that the <code>volatile</code> on a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> makes it treat the <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> as if the variable that was declaring it were <code>volatile</code> -- meaning all of its <a href="#BM_%5Cb(member)%2Fi">member</a>s are treated as <code>volatile</code> recursively down the <a href="#BM_(object%7Cinstance)%2Fi">object</a> tree.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inner</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-keyword">volatile</span> </span>{
        x = n;
        x = n;
        x = n;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
    <span class="hljs-type">int</span> b {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> </span>{
        a = b;
        b = a;
        inner.<span class="hljs-built_in">change</span>(<span class="hljs-number">15</span>); 
    }
};
</code></pre>
<a name="H2_Common%20Attributes"></a><h2>Common Attributes</h2>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it sees it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Static"></a><h2>Static</h2>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>static</code> before the type indicates that the function is independent of any <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type: a <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> points the same memory across all <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>static</code> before the return type indicates that the function is independent of any <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type, meaning that the only <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s that a <code>static</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> can access are <code>static</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s.</p>
<p><code>static</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s and <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are accessed using the <a href="#BM_(scope%20resolution)%2Fi">scope resolution</a> (::) operator, where the scope is the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a {<span class="hljs-number">1</span>};
    <span class="hljs-type">int</span> b {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> <span class="hljs-title">double_it</span><span class="hljs-params">()</span> </span>{
        a *= <span class="hljs-number">2</span>; 
    }
};

X::<span class="hljs-built_in">double_it</span>();  <span class="hljs-comment">// call using scoped resolution</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Be careful, <code>static</code> has a different meaning for functions than it does for <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s.</p>
</div>
<a name="H_Construction"></a><h2>Construction</h2>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are allowed one or more <a href="#BM_(constructor)%2Fi">constructor</a>s that initialize the <a href="#BM_(object%7Cinstance)%2Fi">object</a>. Similar to Java, each <a href="#BM_(constructor)%2Fi">constructor</a> should have the same name as the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself, no return type, and a unique parameter list.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyStruct</span>() {
        count = <span class="hljs-number">0</span>;
        flag = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-type">int</span> initialCount, <span class="hljs-type">bool</span> initialFlag) {
        <span class="hljs-keyword">this</span>-&gt;count = initialCount;
        <span class="hljs-keyword">this</span>-&gt;flag = initialFlag;
    }
}
</code></pre>
<p>The above <a href="#BM_(constructor)%2Fi">constructor</a>s are using the <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator (-&gt;) to access the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>. Non-static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have access to an implicit <a href="#BM_(pointer)%2Fi">pointer</a> called <code>this</code>, which allows for accessing that <a href="#BM_(object%7Cinstance)%2Fi">instance</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s. The <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator allows for <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a <a href="#BM_(pointer)%2Fi">pointer</a> and accessing a <a href="#BM_%5Cb(member)%2Fi">member</a> on the result in a more concise form.</p>
<pre class="hljs"><code><span class="hljs-keyword">this</span>-&gt;count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// equivalent to (*this).member = 0</span>
</code></pre>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> offers <a href="#BM_(constructor)%2Fi">constructor</a>s, the least error-prone way to invoke it is to use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>: <code>MyStruct x { 5, true }</code>. The reason is that C++ has so many <a href="#BM_(object%20initialization)%2Fi">object initialization</a> foot-guns that, while simpler <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s may work (e.g. <code>MyStruct x(5, true)</code>), those <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s may end up being interpreted by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> as something else that's entirely different (e.g. function declaration).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This ambiguity is often referred to as the "most vexing parse" problem.</p>
</div>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a>es that don't have any <a href="#BM_(constructor)%2Fi">constructor</a>s declared get an implicit <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> that zeros out the memory of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (speculation). If the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a <a href="#BM_(POD)%2F">POD</a>, a <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> that is ...</p>
<ul>
<li>empty will zero out the memory for all <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s, (implicit default <a href="#BM_(constructor)%2Fi">constructor</a>).</li>
<li>non-empty will set the individual <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s, in the order they're declared in.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count;
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
   <span class="hljs-type">bool</span> flag;
};

MyStruct a;                    <span class="hljs-comment">// initialized to zero'd out memory (via implicit constructor)</span>
MyStruct b {};                 <span class="hljs-comment">// initialized to zero'd out memory (via implicit constructor)</span>
MyStruct b {<span class="hljs-number">5</span>, <span class="hljs-string">"steve"</span>, <span class="hljs-literal">true</span>}; <span class="hljs-comment">// initialized to supplied arguments</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/49802943">here</a> for more information. The = operator won't result in a copy or anything like that (meaning performance won't suffer).</p>
</div>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> does explicitly declare <a href="#BM_(constructor)%2Fi">constructor</a>s, the implicit <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> won't be generated. If desired, a <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> may be declared with the default behaviour of the implicit zero arg <a href="#BM_(constructor)%2Fi">constructor</a> by adding <code>= default</code> instead of a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> body.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyStruct</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-type">int</span> initialCount, <span class="hljs-type">bool</span> initialFlag) {
        <span class="hljs-keyword">this</span>-&gt;count = initialCount;
        <span class="hljs-keyword">this</span>-&gt;flag = initialFlag;
    }
}
</code></pre>
<p>A <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> may be initialized to a value either through <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>s or the <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer list</a>. For <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>s, the initialization is done directly in the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>'s declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count {<span class="hljs-number">5</span>};
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>] {<span class="hljs-string">"steve"</span>};
   <span class="hljs-type">bool</span> flag {<span class="hljs-literal">true</span>};
};
</code></pre>
<p>In contrast, a <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer list</a> is a comma separated list of <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>s for the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. It's specified just before a <a href="#BM_(constructor)%2Fi">constructor</a>'s body.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-built_in">MyStruct</span>(): count{<span class="hljs-number">0</span>}, flag{<span class="hljs-literal">false</span>} {
    }
}
</code></pre>
<p>Each item in the comma separated list is called a <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>How is this better than <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>, where initialization is done directly after the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> declaration? According to <a href="https://stackoverflow.com/a/48098997">this</a>, it's more-or-less the same?</p>
</div>
<a name="H_Destruction"></a><h2>Destruction</h2>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are allowed an explicit cleanup function called a <a href="#BM_(destructor)%2Fi">destructor</a> (e.g. closing an open file handle, zeroing out memory for security purposes, etc..). A <a href="#BM_(destructor)%2Fi">destructor</a> is declared similarly to a <a href="#BM_(constructor)%2Fi">constructor</a>, the only differences being ...</p>
<ol>
<li>a tilde must appear just before the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> / function name.</li>
<li>it doesn't take in any arguments.</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count {<span class="hljs-number">5</span>};
    <span class="hljs-type">bool</span> flag {<span class="hljs-literal">true</span>};

    <span class="hljs-keyword">public</span>:
    ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
<p><a href="#BM_(destructor)%2Fi">Destructor</a>s must never be called directly by the user. Treat any <a href="#BM_(destructor)%2Fi">destructor</a> as if it were marked with <code>noexcept</code>. That is, an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> should never be thrown in a <a href="#BM_(destructor)%2Fi">destructor</a>. When an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> gets thrown, the call stack unwinds. As each function exits, the <a href="#BM_(destructor)%2Fi">destructor</a>s for <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic variable</a>s of that function get invoked. Another <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> getting thrown while one is already in flight means two <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s would be in flight, which isn't supported.</p>
<p>If a <a href="#BM_(destructor)%2Fi">destructor</a> isn't declared, an empty one is implicitly generated.</p>
<a name="H_Copying"></a><h2>Copying</h2>
<p>There are two built-in mechanisms for copying in C++: the <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> and <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a>.</p>
<p>A <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is a <a href="#BM_(constructor)%2Fi">constructor</a> that has a single parameter, a <a href="#BM_(reference)%2Fi">reference</a> to a <code>const</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a default <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> if one hasn't been explicitly declared by the user. The <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> of this default <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is to copy each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> individually, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<p><a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">Member-wise copy</a>ing may not be the correct way to copy in certain cases, in which case a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> should be explicitly provided with the correct <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) {
        <span class="hljs-keyword">this</span>-&gt;db = DatabaseConnection {orig.db.host, orig.db.port}; <span class="hljs-comment">// make a new db connection instead of using orig's</span>
        <span class="hljs-keyword">this</span>-&gt;max = orig.max;
    }
}


MyStruct x {host, port};
MyStruct y {x}; <span class="hljs-comment">// both x and y are independent and equal, but y has its own DatabaseConnection</span>
</code></pre>
<p>Similarly, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked when the assignment operator is used, called an operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>. Unlike <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>s, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> is required to clean up any resources in the destination <a href="#BM_(object%7Cinstance)%2Fi">object</a> prior to copying. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> if one hasn't been explicitly declared by the user. The <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> of this default <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is to assign each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> individually, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) { <span class="hljs-comment">// only do if assigning to self</span>
            <span class="hljs-keyword">this</span>-&gt;db.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// close existing db connection</span>
            <span class="hljs-keyword">this</span>-&gt;db = DatabaseConnection {orig.db.host, orig.db.port}; <span class="hljs-comment">// make a new db connection</span>
            <span class="hljs-keyword">this</span>-&gt;max = orig.max;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return self -- this should always be the case??</span>
    }
}
</code></pre>
<p>To suppress the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> from allowing copying or assignment of an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, add <code> = delete</code> after both signatures instead of specifying a body. This is important if the <a href="#BM_(object%7Cinstance)%2Fi">object</a> holds on to an un-copyable resource such as a lock.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">delete</span>;
    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">delete</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If using the defaults, the book recommends explicitly declaring the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s but adding <code> = default</code> after both signatures instead of specifying a body. The reason is that the default is almost always wrong, so if you tack this on it makes it explicit to other that you intended this.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">default</span>;
    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">default</span>;
}
</code></pre>
<p>ALSO, there's ambiguity around when the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates default move/copy/<a href="#BM_(destructor)%2Fi">destructor</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s. It might be <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specific. The book recommends that if you're using the defaults, always set them to <code>= default</code> (or do <code>= delete</code> to disallow them).</p>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> MyStruct {
...</p>
<pre><code>// copy
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// move
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// destructor
~MyStruct() = default;
</code></pre>
<p>}
```</p>
</div>
<a name="H_Moving"></a><h2>Moving</h2>
<p>There are two built-in mechanisms for moving in C++: the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> and <a href="#BM_(move%20assignment)%2Fi">move assignment</a>. Moving is different from copying in that moving actually guts the insides (data) of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> and transfers it into another, leaving that <a href="#BM_(object%7Cinstance)%2Fi">object</a> in an invalid state. If the scenario allows for it, moving is often times more efficient than copying.</p>
<p>A <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is a <a href="#BM_(constructor)%2Fi">constructor</a> that has a single parameter, an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a default <a href="#BM_(move%20constructor)%2Fi">move constructor</a> if one hasn't been explicitly declared by the user. The move semantics of this default <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is to <em>copy</em> each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> rather than actually move anything, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(MyStruct &amp;&amp;orig) <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">this</span>-&gt;str_ptr = orig.str_ptr;
        <span class="hljs-keyword">this</span>-&gt;max = orig.max;
        orig.str_ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// mark orig object as invalid</span>
        orig.max = <span class="hljs-number">-1</span>; <span class="hljs-comment">// mark orig object as invalid</span>
    }
}

MyStruct a {};
MyStruct &amp;&amp;b = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// get rvalue reference for a</span>
MyStruct c {b};               <span class="hljs-comment">// move a into c (gut it into c) via the move constructor</span>
<span class="hljs-comment">// b is in an invalid state</span>
</code></pre>
<p>In the example above, the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> has <code>noexcept</code> set to indicate that it will never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. <a href="#BM_(move%20constructor)%2Fi">Move constructor</a>s that can throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s are problematic for the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to use. If a <a href="#BM_(move%20constructor)%2Fi">move constructor</a> throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, the source <a href="#BM_(object%7Cinstance)%2Fi">object</a> will likely enter into an inconsistent state, meaning the program will likely be in an inconsistent state. As such, if the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> sees that the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> can throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, it'll prefer to copy it instead.</p>
<p>Similarly to the <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, <a href="#BM_(move%20assignment)%2Fi">move assignment</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked when the assignment operator is used, called an operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>. It has the same parameter list and it shouldn't throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s either (<code>noexcept</code>), the only difference is that it return a <a href="#BM_(reference)%2Fi">reference</a> to itself at the end.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    MyStruct&amp; <span class="hljs-keyword">operator</span>=(MyStruct &amp;&amp;orig) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) { <span class="hljs-comment">// only do if assigning to self</span>
            <span class="hljs-keyword">this</span>-&gt;str_ptr = orig.str_ptr;
            <span class="hljs-keyword">this</span>-&gt;max = orig.max;
            orig.str_ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// mark orig object as invalid</span>
            orig.max = <span class="hljs-number">-1</span>; <span class="hljs-comment">// mark orig object as invalid</span>
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return self -- this should always be the case??</span>
    }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There's ambiguity around when the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates default move/copy/<a href="#BM_(destructor)%2Fi">destructor</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s. It might be <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specific. The book recommends that if you're using the defaults, always set them to <code>= default</code> (or do <code>= delete</code> to disallow them).</p>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> MyStruct {
...</p>
<pre><code>// copy
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// move
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// destructor
~MyStruct() = default;
</code></pre>
<p>}
```</p>
</div>
<a name="H_Inheritance"></a><h2>Inheritance</h2>
<p>In C++, a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inherits another <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> by, just after its name, appending a colon (:) followed by the name of the parent <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyChild</span> : MyParent {
};
</code></pre>
<p>Like in most other <a href="#BM_(object%7Cinstance)%2Fi">object</a> oriented languages, a child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>...</p>
<ul>
<li>can access the non-private <a href="#BM_%5Cb(member)%2Fi">member</a>s of any of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es it inherits.</li>
<li>is assignable to the type of any of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es it inherits.</li>
</ul>
<pre class="hljs"><code>MyChild c {};
MyParent p {x}; <span class="hljs-comment">// MyChild inherits from MyParent, meaning that it's assignable to MyParent</span>
</code></pre>
<p>To be able to override a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in a child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the same way as its done in other languages (e.g. Java), the base call must have the <code>virtual</code> keyword prepended on the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, making it a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>. Similarly, any <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> that overrides a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> should have the <code>override</code> keyword appended just after the parameter list.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>override</code> isn't strictly required, but it's a hint that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> can use to prevent you from making a mistake (e.g. it sees <code>override</code> but what's being overridden isn't <code>virtual</code>). It's similar to Java's <code>@Override</code> annotation.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">()</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
};
</code></pre>
<p>If the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> and child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have the exact same non-<a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>, which <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> gets called depends the type of the variable.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ ... }
};


MyChild c {};
MyChild  &amp;cref {x};
MyParent &amp;pref {x};
cref.<span class="hljs-built_in">non_virt_method</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// calls MyChild::non_virt_method()</span>
pref.<span class="hljs-built_in">non_virt_method</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// calls MyParent::non_virt_method() even though object is a MyChild</span>
</code></pre>
<p>To prevent a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> from being overriddable at all, add the <code>final</code> keyword just after the parameter list.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{ ... }  <span class="hljs-comment">// ERROR HERE -- not allowed</span>
};
</code></pre>
<p>Similarly, to prevent the entire <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself from being inheritable, add the <code>final</code> keyword just after the name.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> <span class="hljs-keyword">final</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{ ... }
};
</code></pre>
<p>C++ chains <a href="#BM_(constructor)%2Fi">constructor</a> and <a href="#BM_(destructor)%2Fi">destructor</a> invocations appropriately as expected. The one caveat is that <a href="#BM_(destructor)%2Fi">destructor</a>, if not a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>, will use the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> resolution mechanism described above: If the type of the variable doesn't match the <a href="#BM_(object%7Cinstance)%2Fi">object</a> (variable type is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but <a href="#BM_(object%7Cinstance)%2Fi">object</a> is not), the wrong <a href="#BM_(destructor)%2Fi">destructor</a> gets invoked, resulting in <a href="#BM_(object%7Cinstance)%2Fi">object</a> potentially not cleaning up resources (e.g. closing file handles).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    ~<span class="hljs-built_in">MyParent</span>() { ... };
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    ~<span class="hljs-built_in">MyChild</span>() { ... };
};


MyParent *c = <span class="hljs-keyword">new</span> MyChild{};
<span class="hljs-keyword">delete</span> c;  <span class="hljs-comment">// calls MyParent's destructor instead of MyChild's destructor</span>
</code></pre>
<p>When inheritance is involved, it's almost always a good idea to enforce a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>. Since not having a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a> sometimes makes sense (e.g. user determined that it's safe to omit it and as such omitted it to improve performance), the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't produce a warning if it isn't virtual.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() { ... };
};
</code></pre>
<a name="H_Interfaces"></a><h2>Interfaces</h2>
<p>Interfaces and abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are supported in C++, but not in the same way as other high-level languages. The C++ approach to interfaces is to explicitly mark certain <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s as requiring an implementation. This is done by appending <code>= 0</code> to the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};
</code></pre>
<p>A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> that is both a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> and requires an implementation is called a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>. A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that contains all <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s is called a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi">pure virtual class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() {};  <span class="hljs-comment">// also okay to do   "virtual ~MyParent() = default"</span>
};
</code></pre>
<p>As shown in the example above, a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi">pure virtual class</a> should have a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>. While not required, failing to do so means that the wrong <a href="#BM_(destructor)%2Fi">destructor</a> may get invoked if the type of the variable doesn't match the <a href="#BM_(object%7Cinstance)%2Fi">object</a> (variable type is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but <a href="#BM_(object%7Cinstance)%2Fi">object</a> is not), resulting in <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> resources being left open (e.g. file handles).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See inheritance section for a more thorough explanation.</p>
</div>
<a name="H_Operator%20Overloading"></a><h2>Operator Overloading</h2>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es support operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing.</p>
<p>Operators are <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>-able in two ways. To <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> an operator the first way, introduce a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> but instead of naming it, add the <code>operator</code> keyword followed by the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed. The parameters and return type of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> need to match whatever types the operator is intended to deal with.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...

    <span class="hljs-comment">// MyClass + int -- notice whitespace between 'operator' keyword and operator -- this is okay.</span>
    MyClass <span class="hljs-keyword">operator</span> +(<span class="hljs-type">int</span> rhs) <span class="hljs-keyword">const</span> {
        MyClass ret { <span class="hljs-keyword">this</span>-&gt;value + x };
        <span class="hljs-keyword">return</span> ret;
    };

    <span class="hljs-comment">// MyClass + MyClass</span>
    MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;rhs) <span class="hljs-keyword">const</span> {
        MyClass ret { <span class="hljs-keyword">this</span>-&gt;value + rhs.value };
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-comment">// MyClass += MyClass</span>
    MyClass&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyClass &amp;rhs) {
        <span class="hljs-keyword">this</span>-&gt;value += x-&gt;value;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>
<p>To <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> an operator the second way, introduce a function (not a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>) using the <code>operator</code> keyword followed by the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed. In the examples above, the left-hand side was the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>. When using this second way, a left-hand side needs to be explicitly provided as the first parameter while the right-hand side is the second argument.</p>
<pre class="hljs"><code><span class="hljs-comment">// MyClass + int</span>
MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-type">int</span> rhs) <span class="hljs-keyword">const</span> {
    MyClass ret { lhs.value + x };
    <span class="hljs-keyword">return</span> ret;
};

<span class="hljs-comment">// MyClass + MyClass</span>
MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) <span class="hljs-keyword">const</span> {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">// MyClass += MyClass</span>
MyClass &amp; <span class="hljs-keyword">operator</span>+=(MyClass &amp;rhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    lhs.value += rhs.value;
    <span class="hljs-keyword">return</span> lhs;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Evidently the two ways described above aren't equivalent. The second way has some added benefits. See <a href="https://stackoverflow.com/a/10958716">here</a>.</p>
</div>
<p>Note how the <code>const</code> keyword is added to the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in cases where the operator shouldn't modify itself. Similarly, when the argument for a parameter shouldn't be changed, <code>const</code> is used on that parameter. <code>const</code>-ness depends on the scenario. For example, the second <code>operator+</code> requires two <a href="#BM_(reference)%2Fi">reference</a>s to <code>const</code> types.</p>
<pre class="hljs"><code>MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) <span class="hljs-keyword">const</span> {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p>Those <code>const</code>s ensures that the operands aren't changed in the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>. Imagine that you're performing <code>x = y + z</code>. It doesn't make sense for <code>y</code> or <code>z</code> to get modified.</p>
<p>The signature could have just as well been modified to be the types themselves rather than <code>const</code> <a href="#BM_(reference)%2Fi">reference</a>s, in which case both the left-hand side and right-hand side would get copied on invocation of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> (modifications to copies don't matter).</p>
<pre class="hljs"><code>MyClass <span class="hljs-keyword">operator</span>+(MyClass lhs, MyClass rhs) <span class="hljs-keyword">const</span> {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://gist.github.com/beached/38a4ae52fcadfab68cb6de05403fa393">here</a> for a list of operators and their signatures (still incomplete).</p>
<p>There's also the option to create operators that allow for implicit type casting and explicit type casting. See the type casting section for more information.</p>
</div>
<a name="H_Conversion%20Overloading"></a><h2>Conversion Overloading</h2>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es support both <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>s and <a href="#BM_(explicit%20type%20conversion)%2Fi">explicit type conversion</a>s via operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing. <a href="#BM_(implicit%20type%20conversion)%2Fi">Implicit type conversion</a>s are represented as operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s where the name of the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed is the destination type and the return type is omitted.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt; value / <span class="hljs-number">42</span>;
    }
};
...
MyClass cls {};
<span class="hljs-type">int</span> x = cls; <span class="hljs-comment">// triggers operator overload method</span>
</code></pre>
<p><a href="#BM_(explicit%20type%20conversion)%2Fi">Explicit type conversion</a>s are enabled the same way as <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>s, except the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is preceded by the <code>explicit</code> keyword. The <code>explicit</code> keyword makes it so that conversion to that type requires a <code>static_cast</code></p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt; value / <span class="hljs-number">42</span>;
    }
};
...
MyClass cls {};
<span class="hljs-type">int</span> x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(cls);  <span class="hljs-comment">// static_cast required to trigger operator overload method</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends not preferring explicit over implicit because implicit is a source for confusion.</p>
<p>Do these still qualify as operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s? Return types should be there.</p>
</div>
<a name="H_Const%20%2F%20Volatile%20Overloading"></a><h2>Const / Volatile Overloading</h2>
<p>In addition to following the same <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing rules as <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> may be <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed based on whether the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a> is to a <code>volatile</code> and / or <code>const</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"non-const non-volatile\n"</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"const non-volatile\n"</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"non-const volatile\n"</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"const volatile\n"</span>;
        <span class="hljs-keyword">return</span> counter;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> counter;
};


MyClass c1{};
c1.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "non-const non-volatile"</span>
<span class="hljs-keyword">const</span> MyClass c2{};
c2.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "const non-volatile"</span>
<span class="hljs-keyword">volatile</span> MyClass c3{};
c3.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "non-const volatile"</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span> MyClass c4{};
c4.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "const volatile"</span>
</code></pre>
<a name="H_Reference%20Overloading"></a><h2>Reference Overloading</h2>
<p>In addition to following the same <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing rules as <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> may be <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed based on whether the <code>this</code> <a href="#BM_(reference)%2Fi">reference</a> is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a> or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a>. To target ...</p>
<ul>
<li><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a>, add an ampersand (&amp;) after the parameter list</li>
<li><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a>, add two ampersands (&amp;&amp;) after the parameter list</li>
</ul>
<p>The benefit of <a href="#BM_(reference)%2Fi">reference</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing is being able to define a version of the function with efficient move semantics when the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is transient.</p>
<pre class="hljs"><code><span class="hljs-comment">// THIS EXAMPLE WAS LIFTED FROM https://docs.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170#ref-qualifiers</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>() {<span class="hljs-comment">/*expensive initialization*/</span>}
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> &amp; </span>{
        std::cout &lt;&lt; <span class="hljs-string">"lvalue\n"</span>;
        <span class="hljs-keyword">return</span> _data;
    }
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> &amp;&amp; </span>{
        std::cout &lt;&lt; <span class="hljs-string">"rvalue\n"</span>;
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(_data);
    }
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; _data;
};


MyClass c {};
<span class="hljs-keyword">auto</span> v = c.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// get a copy. prints "lvalue".</span>
<span class="hljs-keyword">auto</span> v2 = <span class="hljs-built_in">C</span>().<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// get the original. prints "rvalue"</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The website said <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a>, but does it mean <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">gl-value</a>?</p>
</div>
<a name="H_Functors"></a><h2>Functors</h2>
<p>A <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, also called a <a href="#BM_(functor%7Cfunction%20object)%2Fi">function object</a>, is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can invoke as if it were a function because it has an operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s for function-call.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};

MyFunctor inst{};
<span class="hljs-built_in">inst</span>(<span class="hljs-number">15</span>);  <span class="hljs-comment">// computes -15 + 5</span>
</code></pre>
<p><a href="#BM_(functor%7Cfunction%20object)%2Fi">Functor</a>s are useful because they allow for state (via <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s) and parameterization (via <a href="#BM_(constructor)%2Fi">constructor</a> arguments) but still retain a function-like syntax.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unlike normal functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s cannot be assigned to <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s. See section on <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s.</p>
</div>
<a name="H_Lambdas"></a><h2>Lambdas</h2>
<p><a href="#BM_(lambda)%2Fi">Lambda</a>s are unnamed <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s (not functions) that are expressed in a succinct form. <a href="#BM_(lambda)%2Fi">Lambda</a>s in C++ work similarly to <a href="#BM_(lambda)%2Fi">lambda</a>s in other high-level languages. They allow for capturing <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope and pulling them into the body, where they can be used for whatever processing the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s body performs.</p>
<pre class="hljs"><code><span class="hljs-comment">// as a function</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> x) {
        <span class="hljs-keyword">this</span>-&gt;x = x;
    };
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};

MyFunction f1{}
<span class="hljs-built_in">f1</span>(<span class="hljs-number">42</span>);

<span class="hljs-comment">// as a lambda</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-keyword">auto</span> f2 = [=] (<span class="hljs-type">int</span> y) { <span class="hljs-keyword">return</span> -y + x; };

<span class="hljs-built_in">f2</span>(<span class="hljs-number">42</span>);
</code></pre>
<p>The general syntax of a <a href="#BM_(lambda)%2Fi">lambda</a> is as follows: <code>[captures] (parameters) modifiers -&gt; return-type { body }</code>.</p>
<ul>
<li>
<p><strong>capture</strong> (required) - <a href="#BM_(object%7Cinstance)%2Fi">Object</a>s to pull in from outer scopes.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> y = <span class="hljs-number">6</span>;
<span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z / <span class="hljs-number">2</span>; };           <span class="hljs-comment">// no capture</span>
<span class="hljs-keyword">auto</span> f2 = [x, y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };   <span class="hljs-comment">// explicitly copy x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f3 = [&amp;x, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; }; <span class="hljs-comment">// explicitly reference x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f4 = [=] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };      <span class="hljs-comment">// automatically copy x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f5 = [&amp;] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };      <span class="hljs-comment">// automatically reference x and y from outer scope</span>
<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;
<span class="hljs-keyword">auto</span> f6 = [&amp;, y] () -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + t; };        <span class="hljs-comment">// automatically reference x and t but force y to be a copy</span>
</code></pre>
<p>Capture lists are essentially the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <a href="#BM_(constructor)%2Fi">constructor</a>. When the capture was pulled in ...</p>
<ul>
<li>because it was explicitly stated, it's called to as a <a href="#BM_(named%20capture)%2Fi">named capture</a>.</li>
<li>automatically, it's called a <a href="#BM_(default%20capture)%2Fi">default capture</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends against <a href="#BM_(default%20capture)%2Fi">default capture</a>s.</p>
</div>
<p><a href="#BM_(named%20capture)%2Fi">Named capture</a>s can also be initializer expressions by adding an equal sign after the name of the capture.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> y = <span class="hljs-number">6</span>;
<span class="hljs-keyword">auto</span> f1 = [modified_x=x/<span class="hljs-number">2</span>, y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };
</code></pre>
<p>If used within an enclosing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the this <a href="#BM_(pointer)%2Fi">pointer</a> can be captured.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [*<span class="hljs-keyword">this</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z / <span class="hljs-number">2</span>; };  <span class="hljs-comment">// capture a COPY OF *this and pass it in as a pointer</span>
<span class="hljs-keyword">auto</span> f1 = [<span class="hljs-keyword">this</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z / <span class="hljs-number">2</span>; };   <span class="hljs-comment">// capture this as pointer</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It's mentioned that prior to C++20, automatic copy capturing (<code>[=]</code>) would pull in <code>this</code>. That feature has been deprecated.</p>
</div>
</li>
<li>
<p><strong>parameters</strong> (optional) - Parameter list of <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };
<span class="hljs-keyword">auto</span> f2 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">99</span>) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };  <span class="hljs-comment">// default args</span>
<span class="hljs-keyword">auto</span> f3 = [] (<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) { <span class="hljs-keyword">return</span> x + y; };            <span class="hljs-comment">// generic params (compiler deduces types based on usage)</span>
</code></pre>
</li>
<li>
<p><strong><a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Function <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-keyword">constexpr</span> -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };  <span class="hljs-comment">// constant expression</span>
</code></pre>
</li>
<li>
<p><strong>return-type</strong> (optional) - Return type.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) { <span class="hljs-keyword">return</span> x + y; };                    <span class="hljs-comment">// deduced by compiler if not set</span>
<span class="hljs-keyword">auto</span> f2 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };
<span class="hljs-keyword">auto</span> f3 = [] (<span class="hljs-type">int</span> x, <span class="hljs-keyword">auto</span> y) -&gt; <span class="hljs-keyword">decltype</span>(x+y) { <span class="hljs-keyword">return</span> x + y; };  <span class="hljs-comment">// generic param + decltype (compiler sets return type to resulting type of x + y)</span>
</code></pre>
</li>
<li>
<p><strong>body</strong> (required) - Function body.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) { <span class="hljs-keyword">return</span> x + y; };
</code></pre>
</li>
</ul>
<p>If the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> decides that a <a href="#BM_(lambda)%2Fi">lambda</a> can be turned into a <a href="#BM_(constant%20expression)%2Fi">constant expression</a>, it will automatically do so. Alternatively, you can force a <a href="#BM_(lambda)%2Fi">lambda</a> to be a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> by adding <code>constexpr</code> as one of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>In many cases, you need to return a <a href="#BM_(lambda)%2Fi">lambda</a> from a function. The easiest way to do this is to set the function's return type to <code>auto</code> and return the <a href="#BM_(lambda)%2Fi">lambda</a> as if it were any other variable.</p>
</div>
<a name="H_Friends"></a><h2>Friends</h2>
<p>A friend is a function or <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that can access the non-public <a href="#BM_%5Cb(member)%2Fi">member</a>s of some other <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that it wasn't declared in.</p>
<p>For friend functions, the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be accessed needs to declare the function's prototype (function declaration) before implementations of a friend function (function definition) can exist. The prototype is included in the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> just like any other <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, but the <code>friend</code> prefix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> is tacked on.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// prototype</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span> </span>{  <span class="hljs-comment">// implementation -- friend of MyClass</span>
    <span class="hljs-keyword">return</span> -(n + obj.x);
}

<span class="hljs-comment">// test</span>
MyClass obj{};
cout &lt;&lt; <span class="hljs-built_in">addAndNegate</span>(obj,<span class="hljs-number">5</span>);
</code></pre>
<p>For friend <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be accessed needs to specify which outside <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is able to access it using <code>friend class</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>;  <span class="hljs-comment">// state that MyFriend can access MyClass's non-public members</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span> </span>{  <span class="hljs-comment">// function in MyFriend accessing non-public members of MyClass</span>
        <span class="hljs-keyword">return</span> -(n + obj.x);
    }
};


<span class="hljs-comment">// test</span>
MyFriend obj_friend{};
MyClass obj{};
cout &lt;&lt; obj_friend.<span class="hljs-built_in">addAndNegate</span>(obj,<span class="hljs-number">5</span>);
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <code>class</code> in <code>friend class</code> may be omitted if <code>MyFriend</code> was already declared before <code>MyClass</code>. Adding the word <code>class</code> is a <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a> -- it tells the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to just believe that it exists even though it may not have come across it yet.</p>
</div>
<p>Friend functions and friend <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es may also target <a href="#BM_(template)%2Fi">template</a>d types.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, T n)</span></span>;  <span class="hljs-comment">// every addAndNegate(MyClass&amp;, T) will be a friend</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is how C++ provides its equivalent of Java's <code>Object.toString()</code>. For each <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you want to be able to print as a string, you implement a <a href="#BM_(template)%2Fi">template</a>d friend function of the left-shift operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> (&lt;&lt;) that targets the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <code>ostream</code>, making it usable in something like <code>std::cout</code>.</p>
<pre class="hljs"><code>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> MyClass &amp;obj) {
    os &lt;&lt; obj.x &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> os;
}
</code></pre>
<p>It seems like a convoluted way to do it.</p>
</div>
<a name="H_Templates"></a><h1>Templates</h1>
<p><a href="#BM_(template)%2Fi">Template</a>s are loosely similar to generics in other high-level languages such as Java. A <a href="#BM_(template)%2Fi">template</a> defines a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function where some of the types and code are unknown, called <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. Each <a href="#BM_(template%20parameter)%2Fi">template parameter</a> in a <a href="#BM_(template)%2Fi">template</a> either maps to a ...</p>
<ul>
<li>a type (e.g. <code>int</code>).</li>
<li>an integra<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>5</code>).</li>
<li>floating point value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>5.5f</code>).</li>
<li>an <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>MyEnum::Value</code>).</li>
<li><a href="#BM_(object%7Cinstance)%2Fi">object</a> <a href="#BM_(pointer)%2Fi">pointer</a> type value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>&amp;MyClass::MyStaticField</code>).</li>
<li><a href="#BM_(function%20pointer)%2Fi">function pointer</a> type value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>&amp;MyClass::MyStaticMember</code>).</li>
<li><code>std::nullptr_t</code> value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>nullptr</code>).</li>
</ul>
<p><a href="#BM_(template)%2Fi">Template</a>s are created using the <code>template</code> keyword, where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are a comma separated list sandwiched within angle brackets. When the user makes use of a <a href="#BM_(template)%2Fi">template</a>, its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s get substituted with what the user specified.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
        <span class="hljs-keyword">return</span> (var1 + var2) * N;
    }
};
</code></pre>
<p>As shown above, each <a href="#BM_(template%20parameter)%2Fi">template parameter</a> for a ...</p>
<ul>
<li>type substitution is prefixed with the keyword <code>typename</code>. The keyword <code>class</code> may be used instead of <code>typename</code>. The meaning is exactly the same (<code>typename</code> should be preferred).</li>
<li>value substitution is prefixed with the type name.</li>
</ul>
<p>To use a <a href="#BM_(template)%2Fi">template</a>, use it just as you would a non-<a href="#BM_(template)%2Fi">template</a> but provide substitutions (<a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>). To instantiate a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(template)%2Fi">template</a>, use the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> as if it were a normal <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but immediately after the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> name add in a comma separated list of <a href="#BM_(template%20parameter)%2Fi">template parameter</a> substitutions sandwiched within angle brackets. These substitutions should be in the same order as the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
<pre class="hljs"><code>MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; obj {}; <span class="hljs-comment">// X = float, Y = int, Z = int, N = 2</span>
<span class="hljs-type">float</span> x = obj.<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);
</code></pre>
<p>Declaring <a href="#BM_(template)%2Fi">template</a>d functions is done in the same manner as <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, and using <a href="#BM_(template)%2Fi">template</a>d functions is done similarly to <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es: Use the function as if it were a normal function but immediately after the function name add in a common separated list of substitutions sandwiched within angle brackets.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * N;
}

<span class="hljs-comment">// use</span>
<span class="hljs-type">float</span> x = <span class="hljs-built_in">perform</span>&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);
</code></pre>
<p>When the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are for types only (not values), it's possible to leave out substitutions during usage. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will deduce the types from the argument you pass in and substitute them automatically.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> var1 + var2;
}

<span class="hljs-comment">// use</span>
<span class="hljs-type">float</span> x = <span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// template arguments omitted, deduced by compiler</span>
</code></pre>
<p>It's possible to supply a default substitution for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> by appending it with <code>=</code> followed by the substitution, called <a href="#BM_(default%20template%20argument)%2Fi">default template argument</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y = <span class="hljs-type">long</span>, <span class="hljs-keyword">typename</span> Z = <span class="hljs-type">long</span>&gt;
X <span class="hljs-built_in">perform</span>(Y &amp;var1, Z &amp;var2) {
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You would think that once a default is supplied, all other <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s after it need a default as well. For whatever reason the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> isn't erroring out when I do this.</p>
</div>
<p>Similarly, it's possible to use <a href="#BM_(template)%2Fi">template</a>s with <a href="#BM_(type%20alias)%2Fi">type alias</a>ing to create shorthand names where only some of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s need to be set, called <a href="#BM_(partial%20template)%2Fi">partial template</a>s.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-keyword">using</span> MyClassPartialTemplate = MyClass&lt;<span class="hljs-type">float</span>, Y, Z, <span class="hljs-number">42</span>&gt;;

<span class="hljs-comment">// use</span>
MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt; x{}; 
MyClassPartialTemplate&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; y{};  <span class="hljs-comment">// same type as previous line</span>
</code></pre>
<p>Normally, C++ code is split into two files: a header file that contains declarations (e.g. function signatures) and a C++ file that contains definitions (e.g. function signatures with their bodies). When accessing C++ code that isn't local, typically only the declarations of that non-local code need to be included. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> binds those non-local declarations to their definitions when it comes time to build the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<p><a href="#BM_(template)%2Fi">Template</a>s work differently from Java generics in that the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates a new code for each unique set of substitutions it sees used (<a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>). Doing so produces more code than if there was only one copy, but also ensures any performance optimizations unique to that specific set of substitutions. Also, because each usage of a <a href="#BM_(template)%2Fi">template</a> may result in newly generated code, that usage typically needs access to both the declaration and definition. The simplest way to handle this is to put the entirety of the <a href="#BM_(template)%2Fi">template</a> (both definition and declaration) into a header, which gets included into the same file as the usage.</p>
<a name="H_Concepts"></a><h2>Concepts</h2>
<p>In certain cases, a set of types substituted in for a <a href="#BM_(template)%2Fi">template</a> won't produce working code.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
<p>In the example above, <code>X perform(Y &amp;var1, Z &amp;var2) { ... }</code> needs <code>Y</code> and <code>Z</code> to be types that support the plus operator (+) on each other (e.g. <code>int</code> and <code>short</code>). Setting them to types that don't support the plus operator typically causes cryptic compilation error, especially if the user is only making use of the <a href="#BM_(template)%2Fi">template</a> and isn't familiar with its innards.</p>
<p>To mitigate this problems, <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s may be provided within a <a href="#BM_(template)%2Fi">template</a>: A <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> is a predicate, evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> (not <a href="#BM_(runtime)%2Fi">runtime</a>), to determine if the substituted types on some <a href="#BM_(template)%2Fi">template</a> have the properties needed to be used within it. <a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s themselves are <a href="#BM_(template)%2Fi">template</a>s where the <code>concept</code> keyword is used followed by a named expression that return a <code>bool</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
<span class="hljs-keyword">concept</span> MyConcept = std::is_default_constructible&lt;T1&gt;::value
        &amp;&amp; std::is_default_constructible&lt;T2&gt;::value
        &amp;&amp; <span class="hljs-built_in">requires</span>(T1 a, T2 b) {
            { a + b } -&gt; std::same_as&lt;TR&gt;;
            { a * b } -&gt; std::same_as&lt;TR&gt;;
            { std::hash&lt;T1&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
            { std::hash&lt;T2&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
        };
</code></pre>
<p>The <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> above checks a combination of three types: <code>T1</code>, <code>T2</code>, and <code>TR</code>. The first two checks are done through functionality provided by the type_traits header. In the example above, <code>std::is_default_constructible</code> provides a <a href="#BM_(compile-time)%2Fi">compile-time</a> check to ensure the types <code>T1</code> and <code>T2</code> both have a default initializer (e.g. default <a href="#BM_(constructor)%2Fi">constructor</a>). Examples of other checks baked provided by the type_traits header (and concepts header):</p>
<ul>
<li><code>std::is_signed</code> - ensures a type is signed.</li>
<li><code>std::is_unsigned</code> - ensures a type is unsigned.</li>
<li><code>std::is_integral</code> - ensures a type is an integer (e.g. <code>short int</code>, <code>int</code>, <code>unsigned long long int</code>, etc..)</li>
<li><code>std::is_pod</code> - ensures a type is a <a href="#BM_(POD)%2F">POD</a>.</li>
<li><code>std::is_fundamental</code> - ensures a type is a <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>.</li>
<li><code>std::is_abstract</code> - ensures a type is an abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (has at least one <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual function</a>).</li>
<li><code>std::is_copy_constructible</code> - ensures type has a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>.</li>
<li><code>std::is_copy_assignable</code> - ensures type has <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a>.</li>
<li><code>std::is_move_constructible</code> - ensures type has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>.</li>
<li><code>std::is_nothrow_move_constructible</code> - ensures type has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a> that never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> (<code>noexcept</code>).</li>
<li><code>std::is_move_assignable</code> - ensures type has <a href="#BM_(move%20assignment)%2Fi">move assignment</a>.</li>
</ul>
<p>The remaining checks are done through a <code>requires</code> clause, which lists out the required set of expressions the substituted types must support and the resulting type of each of those expressions. The example above lists that types <code>T1</code> and <code>T2</code> are ...</p>
<ol>
<li>addable, returning an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type <code>TR</code>.</li>
<li>multiply-able, returning an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type <code>TR</code>.</li>
<li>hashable (when passed into <code>std::hash()</code>, returns an <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's convertible to <code>size_t</code>).</li>
</ol>
<p>Each item in the list has the syntax <code>{ EXPRESSION } -&gt; RESULT</code>, where the result is wrapped with functionality from the concepts header. This functionality describes how the result of the expression should behave. In the example above, ...</p>
<ul>
<li><code>std::same_as&lt;TR&gt;</code> means that the expression should return the exact type as specified by <code>TR</code>.</li>
<li><code>std::convertible_to&lt;std::size_t&gt;</code> means that the expression should return a type can implicitly convert to <code>std::size_t</code> (e.g. a <code>short</code> can implicitly convert to an <code>int</code> without requiring any kind of casting).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book says that these are / are related to "type functions". I can't find much information on this or how to create new "type functions".</p>
</div>
<p>Use the <code>requires</code> keyword immediately after the <a href="#BM_(template)%2Fi">template</a> to target a set of <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s to a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-keyword">requires</span> MyConcept&lt;T1, T2, T1&gt;  <span class="hljs-comment">// refers to the concept defined in the example above</span>
<span class="hljs-function">T1 <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(T1 &amp;var1, T2 &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a> may also be directly embedded into the <a href="#BM_(template)%2Fi">template</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-keyword">requires</span> std::is_default_constructible&lt;T1&gt;::value   <span class="hljs-comment">// same as above, but "MyConcept&lt;T1, T2, T1&gt;" has been embedded</span>
            &amp;&amp; std::is_default_constructible&lt;T2&gt;::<span class="hljs-function">value
            &amp;&amp; <span class="hljs-title">requires</span><span class="hljs-params">(T1 a, T2 b)</span> </span>{
                { a + b } -&gt; std::same_as&lt;T1&gt;;
                { a * b } -&gt; std::same_as&lt;T!&gt;;
                { std::hash&lt;T1&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
                { std::hash&lt;T2&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
            };
<span class="hljs-function">T1 <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(T1 &amp;var1, T2 &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
<p>If a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> only checks a single type, it's possible to use it just by substituting its name in place of the <code>typename</code> / <code>class</code> for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> that requires it (as opposed to using <code>requires</code> shown above).</p>
<pre class="hljs"><code><span class="hljs-comment">// concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> SingleTypeConcept = <span class="hljs-built_in">requires</span>(T a, T b) {
            { a + b } -&gt; std::same_as&lt;T&gt;;
            { a * b } -&gt; std::same_as&lt;T&gt;;
        };

<span class="hljs-comment">// usage of concept</span>
<span class="hljs-keyword">template</span> &lt;SingleTypeConcept X&gt;  <span class="hljs-comment">// this line is updated -- "typename T" replaced with "SingleTypeConcept T"</span>
<span class="hljs-function">X <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(X &amp;var1, X &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
<a name="H1_Variadic"></a><h2>Variadic</h2>
<p>A <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> function is one that takes in a variable number of arguments, sometimes called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s in other languages. A <a href="#BM_(template)%2Fi">template</a> can be made <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> by placing a final <a href="#BM_(template%20parameter)%2Fi">template parameter</a> with <code>...</code> preceding the name, where this <a href="#BM_(template%20parameter)%2Fi">template parameter</a> is referred to as <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>.</p>
<p>One common use-case for <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>s is invoking functions where the parameter list isn't known beforehand.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function">X <span class="hljs-title">create</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> X {args...};
}
</code></pre>
<p>Another less common use-case is specifying the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to inherit from (multiple inheritance).</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> : R... {
    <span class="hljs-built_in">X</span>(<span class="hljs-keyword">const</span> R&amp;... args) : <span class="hljs-built_in">R</span>(args)... { <span class="hljs-comment">// member initializer list calls constructors of base class</span>
    }
}
</code></pre>
<p>Another less common use-case is to apply an repeatedly apply some operator or function.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T t)</span> </span>{
    <span class="hljs-keyword">return</span> t;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; first, R... rest)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(first) + <span class="hljs-built_in">sum</span>(rest...);
}
</code></pre>
<p>Alternatively, rather than using recursion to exhaustively apply a binary operator, a <a href="#BM_(fold%20expression)%2Fi">fold expression</a> may be applied to the <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>. A <a href="#BM_(fold%20expression)%2Fi">fold expression</a> applies a binary operator to the contents of a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a> and return the final result.</p>
<p>The syntax for <a href="#BM_(fold%20expression)%2Fi">fold expression</a>s is <code>...</code> and the <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>'s name sandwiched in between the operator, all encapsulated within a pair of brackets. Which side of the operator the <code>...</code> appears at defines if the <a href="#BM_(fold%20expression)%2Fi">fold expression</a> will be left <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> or right <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(R... args)</span> </span>{
    R l_ass_res = (... - args);  <span class="hljs-comment">// ((((a-b)-c)-d)-...)</span>
    R r_ass_res = (args - ...);  <span class="hljs-comment">// (...-(w-(x-(y-z))))</span>
    <span class="hljs-keyword">return</span> l_ass_res + r_ass_res;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Just a heads up that, depending on the operator, <a href="#BM_(associativity%7Cassociative)%2Fi">associativity</a> matters. For example <code>((5-4)-3)</code> is not equal to <code>(5-(4-3))</code>.</p>
</div>
<p>To get the size of a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>, add <code>...</code> after the <code>sizeof</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">calculate_size</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">sizeof</span>...(args);
}
</code></pre>
<p><a href="#BM_(parameter%20pack)%2Fi">Parameter pack</a>s are used internally within C++'s implementation of analogues to Python's tuples and zip: <code>std::pair</code>, <code>std::tuple</code>, and <code>std::zip</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Examples adapted from <a href="https://crascit.com/2015/03/21/practical-uses-for-variadic-templates/">here</a>.</p>
</div>
<a name="H_Specialization"></a><h2>Specialization</h2>
<p>Given a specific set of substitutions for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s of a <a href="#BM_(template)%2Fi">template</a>, a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is code that overrides the <a href="#BM_(template)%2Fi">template</a> generated code. Often times <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are introduced because they're more memory or computationally efficient than the standard <a href="#BM_(template)%2Fi">template</a> generated code. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>ic example is a <a href="#BM_(template)%2Fi">template</a> that holds on to an array. Most C++ implementations represent a <code>bool</code> as a single byte, however it's more compact to store an array of <code>bool</code>s as a set of bits.</p>
<p>Declare a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> with the <code>template</code> keyword but without any <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s (empty angle brackets). The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function that follows should list out substitutions after its name and the code within it should be real (non-<a href="#BM_(template)%2Fi">template</a>d).</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// template specialization for bool: bit-wise or</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-type">bool</span> <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b) {
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
<p><a href="#BM_(template%20specialization)%2Fi">Template specialization</a> doesn't have to substitute all <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. When a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> only provides substitutes some of its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s, leaving other <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s as-is or partially refined, it's called a <a href="#BM_(partial%20template)%2Fi">partial template</a> specialization.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">R <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
};

<span class="hljs-comment">// template specialization for pointers of unknown type: already return false</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">bool</span>, X*&gt; {
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(X * a, X* b)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(partial%20template)%2Fi">Partial template</a> specializations for functions isn't supported (yet?). See <a href="https://stackoverflow.com/a/8061522">here</a>.</p>
</div>
<p>In certain cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is able to deduce the types for a specialization from its usage, meaning explicitly listing substitutions after the name may not be required.</p>
<pre class="hljs"><code><span class="hljs-comment">// first example without explicitly listing out substitutions</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b)</span> </span>{  <span class="hljs-comment">// type removed after name: "sum&lt;bool&gt;" to just "sum"</span>
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
<a name="H_Unions"></a><h1>Unions</h1>
<p>C++ <a href="#BM_(union)%2Fi">union</a>s are a set of variables that point to the same underlying memory. Each <a href="#BM_(union)%2Fi">union</a> takes up only as much memory as its largest <a href="#BM_%5Cb(member)%2Fi">member</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> {
   <span class="hljs-type">char</span> raw[<span class="hljs-number">100</span>];
   <span class="hljs-type">short</span> num_int;
   <span class="hljs-type">double</span> num_dbl;
}

MyUnion x;
<span class="hljs-comment">// set all bytes of raw to 0</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(x.raw); i++) {
   x.raw[i] = <span class="hljs-number">0</span>;
}
<span class="hljs-comment">// since all members of the union start at the same memory location, these</span>
<span class="hljs-comment">// will by likely both be 0 (unless short or double has a byte size of over</span>
<span class="hljs-comment">// 100).</span>
cout &lt;&lt; x.num_int &lt;&lt; endl;
cout &lt;&lt; x.num_dbl &lt;&lt; endl;
</code></pre>
<pre><code>Consider using std::variant instead of unions.
</code></pre>
<a name="H_Namespaces"></a><h1>Namespaces</h1>
<p>Namespaces are C++'s way of organizing code into a logical hierarchy / avoiding naming conflicts, similar to packages in Java or Python. Unlike packages, namespaces don't use the filesystem to define their logical hierarchy. Instead, the hierarchy is specified directly in code using <code>namespace</code> blocks.</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> FirstLevel {
    <span class="hljs-keyword">namespace</span> MiddleLevel {
        <span class="hljs-keyword">namespace</span> LastLevel {
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
                <span class="hljs-type">int</span> count;
                <span class="hljs-type">bool</span> flag;
            };
        }
    }
}
</code></pre>
<p>The nesting in the example above is avoidable via the scope operator (::).</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> FirstLevel::MiddleLevel::LastLevel {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
        <span class="hljs-type">int</span> count;
        <span class="hljs-type">bool</span> flag;
    };
}
</code></pre>
<p>To use the symbols within a namespace, either include the namespace in symbol or bring all symbols within the namespace to the forefront via the <code>using</code> keyword (similar to Java's <code>import</code> or Python's <code>from</code> / <code>import</code>).</p>
<pre class="hljs"><code><span class="hljs-comment">// Use namespace directly.</span>
FirstLevel:MiddleLevel::LastLevel::MyStruct x{};

<span class="hljs-comment">// Bring all symbols within a namespace to the forefront.</span>
<span class="hljs-keyword">using</span> FirstLevel:MiddleLevel::LastLevel;
MyStruct y{};

<span class="hljs-comment">// Bring a single symbol within a namespace to the forefront.</span>
<span class="hljs-keyword">using</span> FirstLevel:MiddleLevel::LastLevel::MyStruct;
MyStruct z{};
</code></pre>
<a name="H_Linker%20Behaviour"></a><h1>Linker Behaviour</h1>
<p><a href="#BM_(specifier%7Cmodifier)%2Fi">Modifier</a>s on a variable or function declaration are used to control how the <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> behaves. Specifically, the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s can ask the <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> to automatically ...</p>
<ul>
<li>merge the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>inline</code>)</li>
<li>find the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>extern</code>)</li>
<li>keep hidden the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>static</code>).</li>
</ul>
<a name="H_Static%20Linkage"></a><h2>Static Linkage</h2>
<p>A static function or variable is one that's only visible to other code in the same <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will make sure that the function doesn't intermingle with other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s.</p>
<p>Static functions/variables have the <code>static</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is only for non-<a href="#BM_%5Cb(member)%2Fi">member</a>s (not belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<p>The meaning of <code>static</code> changes when the function or variables belongs to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>). When applied on a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, it means that it isn't bound to any <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> -- it can't access <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s belonging to an <a href="#BM_(object%7Cinstance)%2Fi">instance</a>.</p>
</div>
<a name="H_Inline%20Linkage"></a><h2>Inline Linkage</h2>
<p>An inline function or variable is one that may be defined in multiple different <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will make sure all <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s use a single <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of that function/variable even though it may have been defined multiple times.</p>
<p>Inline functions/variables have the <code>inline</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">inline</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/1759575">this</a>. Typically, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> applies <code>inline</code> automatically based on what it sees, meaning that it isn't something that should be adding in most cases. The only <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> to that seems to be <a href="#BM_(template)%2Fi">template</a>s? See some of the other answers in the linked stack overflow question.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The original intent of <code>inline</code> was to indicate to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that embedding a copy of the function for an invocation was preferred over an function call. The reason being that is certain cases the code would be faster if it were embedded rather than having it branch into a function call.</p>
</div>
<a name="H_External%20Linkage"></a><h2>External Linkage</h2>
<p>An external function or variable is a one that's usable within the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> but isn't defined. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will sort out where the function is when the time comes.</p>
<p><a href="#BM_(external%20linkage)%2Fi">External linkage</a> functions/variables have the <code>extern</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Sounds similar to <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a> but across different <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s?</p>
</div>
<a name="H_Control%20Flow"></a><h1>Control Flow</h1>
<p>C++ flow control structures are similar to those in other high-level languages (e.g. Java), with the <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> that ...</p>
<ul>
<li>it's possible to have initializer statements in control structures other than for loops.</li>
<li>jumping to arbitrary labels are allowed (goto statements).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>An important caveat about loops in C++ from <a href="https://en.cppreference.com/w/cpp/language/while">cpp</a><a href="#BM_(reference)%2Fi">reference</a>.com:</p>
<blockquote>
<p>As part of the C++ forward progress guarantee, the behavior is undefined if a loop that has no observable behavior (does not make calls to I/O functions, access <a href="#BM_(volatile)%2Fi">volatile</a> <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, or perform atomic or synchronization operations) does not terminate. <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a>s are permitted to remove such loops.</p>
</blockquote>
</div>
<a name="H_If%20Statement"></a><h2>If Statement</h2>
<p>If statements follow a similar structure to if statements in Java. The only major difference is that an initializer statement is allowed before the condition in the initial <code>if</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>(); r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" div by 5"</span>;
} <span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
}
</code></pre>
<p>In the example above, an initializer statement has been added that sets a variable to a random number. That variable is only accessible inside the different branches of the if statement.</p>
<a name="H_Switch%20Statement"></a><h2>Switch Statement</h2>
<p>Switch statements follow a similar structure to switch statements in Java. The only major difference is that an initializer statement is allowed before the condition.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (<span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>(); r % <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
    std::cout &lt;&lt; <span class="hljs-string">"this should never happen"</span>;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>To indicate to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that a fallthrough case is intended behaviour, use the <code>[[fallthrough]]</code> <a href="#BM_(attribute)%2Fi">attribute</a>.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: [[fallthrough]]
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
    std::cout &lt;&lt; <span class="hljs-string">"this should never happen"</span>;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<a name="H_For%20Loop"></a><h2>For Loop</h2>
<p>For loops follow a similar structure to for loop in Java.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)  {
    std::cout &lt;&lt; i;
}
</code></pre>
<p>Similarly, an analog to Java's for-each loop exists called range-based for loops. The only major difference is that an initializer statement is allowed before the range declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>(); <span class="hljs-type">int</span> val : array)  {
    std::cout &lt;&lt; (r + val) &lt;&lt; <span class="hljs-string">' '</span>;
}
</code></pre>
<a name="H_While%20Loop"></a><h2>While Loop</h2>
<p>While and do-while loops follow a similar structure to their counterparts in Java.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span>;
<span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" "</span>;
    r--;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span>;
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" "</span>;
    r--;
} <span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// semicolon required at the end</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unlike other control structures, these loops cannot have initializer statements.</p>
</div>
<a name="H_Goto%20Statement"></a><h2>Goto Statement</h2>
<p>Unlike most other high-level languages (e.g. Java), C++ allows the use of goto statements. However, note that goto statements are generally considered bad practice and should somehow be refactored to higher-level constructs (e.g. loops, if statements, etc..).</p>
<pre class="hljs"><code>retry:
<span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>();
<span class="hljs-keyword">if</span> (r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">goto</span> retry;
}
std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
</code></pre>
<a name="H_Branching%20Likelihood"></a><h2>Branching Likelihood</h2>
<p>Conditional branching operations in flow control statements may have the <code>[[likely]]</code> and <code>[[unlikely]]</code> <a href="#BM_(attribute)%2Fi">attribute</a>s applied to hint at the likelihood / unlikelihood that of the path execution will take. This allows for better optimization by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (based on your assumptions).</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (exit_code) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    <span class="hljs-comment">// happy path</span>
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    <span class="hljs-comment">// recognized error path</span>
    <span class="hljs-keyword">break</span>;
    [[unlikely]] <span class="hljs-keyword">default</span>:
    <span class="hljs-comment">// unrecognized error path</span>
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_valid</span>(email)) [[likely]] {
    <span class="hljs-comment">// happy path</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// error path</span>
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) [[unlikely]] {
  <span class="hljs-comment">// do something</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I read something online saying you shouldn't use both <code>[[likely]]</code> and <code>[[unlikely]]</code> on the same switch/if/while/etc...</p>
</div>
<a name="H_Attributes"></a><h1>Attributes</h1>
<p>C++ <a href="#BM_(attribute)%2Fi">attribute</a>s are similar to annotations in Java, providing information to the user / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> about the code that it's applied to. Unlike Java, C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s are free to pick and choose which <a href="#BM_(attribute)%2Fi">attribute</a>s they support and how they support them. There is no guarantee what action a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will take, if any, when it sees an <a href="#BM_(attribute)%2Fi">attribute</a> (e.g. <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warnings).</p>
<p>An <a href="#BM_(attribute)%2Fi">attribute</a> is applied by nesting it in double squared brackets (e.g. <code>[[noreturn]]</code>) and placing it as a <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> on the function.</p>
<pre class="hljs"><code>[[noreturn]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fail</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">throw</span> std::runtime_error { <span class="hljs-string">"Failed"</span> };
}
</code></pre>
<p>Common <a href="#BM_(attribute)%2Fi">attribute</a>s:</p>
<table>
<thead>
<tr>
<th><a href="#BM_(attribute)%2Fi">Attribute</a></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[deprecated("msg")]]</code></td>
<td>Indicates that a function is deprecated. Message is optional.</td>
</tr>
<tr>
<td><code>[[noreturn]]</code></td>
<td>Indicates that a function doesn't return.</td>
</tr>
<tr>
<td><code>[[fallthrough]]</code></td>
<td>Indicates that a switch case was explicitly designed to fall through to the next case (no <code>break</code> / <code>return</code> / etc.. intended).</td>
</tr>
<tr>
<td><code>[[nodiscard]]</code></td>
<td>Indicates that a function's result should be used somehow (produce <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warning).</td>
</tr>
<tr>
<td><code>[[maybe_unused]]</code></td>
<td>Indicates that a function's result doesn't have to be used (avoid compile warning).</td>
</tr>
</tbody>
</table>
<a name="H_Constant%20Expressions"></a><h1>Constant Expressions</h1>
<p>A <a href="#BM_(constant%20expression)%2Fi">constant expression</a> is an expression that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, such that any invocation of it gets swapped out for the result computed at <a href="#BM_(compile-time)%2Fi">compile-time</a>. It comes in two forms: variable and function.</p>
<p>A <a href="#BM_(constant%20expression)%2Fi">constant expression</a> variable requires using <code>constexpr</code> instead of <code>const</code>. The difference between a <code>const</code> variable and <code>constexpr</code> variable is that the former only guarantees the variable is unmodifiable. It doesn't actually guarantee that the expression within is evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span> + <span class="hljs-number">5</span>};      <span class="hljs-comment">// COULD BE evaluated at run-time or compile-time, but guaranteed to be unmodifiable</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> y {<span class="hljs-number">5</span> + <span class="hljs-number">5</span>};  <span class="hljs-comment">// MUST BE evaluated at compile-time and guaranteed to be unmodifiable</span>
</code></pre>
<p>Similarly, a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> function requires prefixing <code>constexpr</code> to a function. The entire compilation can be terminated at any point through the use of <code>static_assert</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(n &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">"ERROR: negative value passed as n"</span>);  <span class="hljs-comment">// error msg is optional</span>
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fibonacci</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fibonacci</span>(n<span class="hljs-number">-2</span>);
    }
}

<span class="hljs-type">int</span> x {<span class="hljs-built_in">fibonacci</span>(<span class="hljs-number">7</span>)}; <span class="hljs-comment">// at compile-time, fibonacci(7) is executed and its return value substituted into the initializer</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>An alternate version of <a href="#BM_(constant%20expression)%2Fi">constant expression</a> functions, called <a href="#BM_(immediate%20function)%2Fi">immediate function</a>s, have the restriction that they must produce a <a href="#BM_(compile-time)%2Fi">compile-time</a> constants. An <a href="#BM_(immediate%20function)%2Fi">immediate function</a> requires a requires prefixing <code>consteval</code> to a function instead of <code>constexpr</code>.</p>
<p>What's the point on this? According to <a href="https://stackoverflow.com/a/53347377">here</a>...</p>
<blockquote>
<p>constexpr functions may be evaluated at compile time or run time, and need not produce a constant in all cases.</p>
</blockquote>
<p>Here's an example from <a href="https://github.com/AnthonyCalandra/modern-cpp-features">here</a>...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
  <span class="hljs-keyword">return</span> n * n;
}

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> r = <span class="hljs-built_in">sqr</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// OK</span>
<span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;
<span class="hljs-type">int</span> r2 = <span class="hljs-built_in">sqr</span>(x); <span class="hljs-comment">// ERROR: the value of 'x' is not usable in a constant expression</span>
                 <span class="hljs-comment">// OK if `sqr` were a `constexpr` function</span>
</code></pre>
</div>
<p>The restrictions on <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s are vast. At a high-level, a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> is only allowed inputs and outputs that are <a href="#BM_(literal%20type)%2Fi">literal type</a>s:</p>
<ul>
<li><strong>Scalar</strong>: Floating point types, integral types, <a href="#BM_(pointer)%2Fi">pointer</a> types, <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> types, <code>std::nullptr_t</code>, etc..</li>
<li><strong><a href="#BM_(reference)%2Fi">Reference</a></strong></li>
<li><strong>Array</strong>: Every element must be a literal.</li>
<li><strong><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a></strong>: <a href="#BM_(constructor)%2Fi">Constructor</a> must be a <a href="#BM_(constant%20expression)%2Fi">constant expression</a>. Non-<a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a>s initializers using <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>, <a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a>, or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> must use <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s. The <a href="#BM_(destructor)%2Fi">destructor</a> must be a trivial <a href="#BM_(destructor)%2Fi">destructor</a> (non-virtual, does nothing, and all base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(destructor)%2Fi">destructor</a>s do nothing).</li>
<li><strong><a href="#BM_(union)%2Fi">Union</a></strong>: Must have at least one non-<a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a> that is a <a href="#BM_(literal%20type)%2Fi">literal type</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The rules here are vast and complicated. The above might not be entirely correct, may be missing some conditions, or may not cover certain aspects. In the type_traits header, there's a function called <code>std::is_literal_type</code> that can be used to test if a type is a <a href="#BM_(literal%20type)%2Fi">literal type</a>.</p>
</div>
<p>There are several benefits to <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s. First, <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s help with reducing the use of hard coded numbers whose origins are obtuse, called magic numbers. A <a href="#BM_(constant%20expression)%2Fi">constant expression</a> uses the computation to get to that obtuse magic number rather than the number itself, meaning its easier to understand and requires less effort to tweak (via the parameters of the <a href="#BM_(constant%20expression)%2Fi">constant expression</a>).</p>
<p>Second, there exists a special type of <a href="#BM_(compile-time)%2Fi">compile-time</a> if-else where the chosen path is the only one in which code is generated for. These <a href="#BM_(compile-time)%2Fi">compile-time</a> if-elses, identified by the <code>constexpr</code> keyword immediately after the <code>if</code>, use <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s in their conditionals when deciding which path to choose. These are use-cases such as ...</p>
<ul>
<li>omitting parts of a program from compilation (e.g. demonstration software).</li>
<li>working around <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>-specific / platform-specific inconsistencies (e.g. only include code if <code>int</code>'s ma<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">x value</a> is above some threshold).</li>
<li>performing specific actions based on the types chosen for <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s (e.g. include code path 1 if <a href="#BM_(pointer)%2Fi">pointer</a>, otherwise code path 2).</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(y == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span> </span>{
    <span class="hljs-comment">// constant expression y is equivalent to the number of bytes for an int, so compile this block</span>
    ...
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// constant expression y is NOT equivalent to the number of bytes for an int, so compile this block</span>
    ...
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Type information is queryable at <a href="#BM_(compile-time)%2Fi">compile-time</a> through the type_traits. Information about numeric types is queryable at <a href="#BM_(compile-time)%2Fi">compile-time</a> using numeric_limits, cstdlib, and cfloat headers.</p>
<p>Those are what you would commonly use in <code>if constexpr</code> blocks. They help with building portable software.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>All of this seems to replace the need for C <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros <code>#define</code> / <code>#ifdef</code> / etc...</p>
</div>
<a name="H_Exceptions"></a><h1>Exceptions</h1>
<p>C++ <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s work similarly to <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s in other languages, except that there is no <code>finally</code> block. The idea behind this is that resources should be bound to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a> (<a href="#BM_(destructor)%2Fi">destructor</a>). As the call stack unwinds and the <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a>s that each function owns are destroyed, the <a href="#BM_(destructor)%2Fi">destructor</a>s of those <a href="#BM_(object%7Cinstance)%2Fi">object</a>s should be cleaning up any resources that would have been cleaned up by the <code>finally</code> block. This concept is referred to as resource acquisition is initialization (<a href="#BM_(RAII%7CCADRe)%2F">RAII</a>).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What does accordingly mean? For example, wrap the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamically allocated object</a> in a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> where <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> happens in the <a href="#BM_(constructor)%2Fi">constructor</a> / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a> happens in the <a href="#BM_(destructor)%2Fi">destructor</a>. An <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type will cleanup properly when the function exits.</p>
</div>
<p>To throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, use the <code>throw</code> keyword followed by the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to throw. Most <a href="#BM_(object%7Cinstance)%2Fi">object</a> types are throwable, but thrown <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are typically limited to types either in or derived from those in the stdexcept header.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">no_negatives_check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> std::runtime_error { <span class="hljs-string">"no negatives"</span> };
    }
}
</code></pre>
<p>Similar to Java and Python, C++ provides a standard set of <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s in stdexcept complete with a hierarchy.</p>
<p><img src="svgbob_0347537f32e15529524b9ab7c34cb1f41f86ec3a.svg" alt="Kroki diagram output"></p>
<p>To catch a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> potentially being thrown, wrap code in a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block. Typical inheritance rules apply when catching an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. For example, catching a <code>std:runtime_error</code> type will also catch anything that <a href="#BM_(extend%7Csubclass)%2Fi">extend</a>s from it as well (e.g. <code>std:overflow_error</code>).</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">55</span>);
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// do something</span>
}
</code></pre>
<p>To catch any <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> regardless of type, use <code>...</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-comment">// do something, note the exception object is not accessible here</span>
}
</code></pre>
<p>Multiple catches may exist in the same <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block.</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::range_error &amp;e) {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// do something -- this block will get chosen</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::exception &amp;e) {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-comment">// do something, note the exception object is not accessible here</span>
}
</code></pre>
<a name="H_Structured%20Binding"></a><h1>Structured Binding</h1>
<p><a href="#BM_(structured%20binding)%2Fi">Structured binding</a> declaration is a C++ language feature similar to Python's unpacking of lists and tuples. Given an array or a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the values contained within are unpackable to individual variables.</p>
<pre class="hljs"><code><span class="hljs-comment">// array example</span>
<span class="hljs-type">int</span> x[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
<span class="hljs-keyword">auto</span> [a, b] = x;  <span class="hljs-comment">// a is a copy of x[0], b is a copy of x[1]</span>
<span class="hljs-keyword">auto</span> &amp;[c, d] = x; <span class="hljs-comment">// c is a REFERENCE to a[0], d is a REFERENCE to a[1]</span>

<span class="hljs-comment">// class example</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;
};
MyStruct y {<span class="hljs-number">5</span>,<span class="hljs-literal">true</span>};
<span class="hljs-keyword">auto</span> [i, j] = y;  <span class="hljs-comment">// i is a copy of y.count, b is a copy of y.flag</span>
<span class="hljs-keyword">auto</span> &amp;[k, l] = y; <span class="hljs-comment">// k is a REFERENCE to y.count, l is a REFERENCE to y.flag</span>
</code></pre>
<a name="H_Expression%20Categories"></a><h1>Expression Categories</h1>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">Value categories</a> are a classification of expressions in C++. At their core, these categories are used for determining when <a href="#BM_(object%7Cinstance)%2Fi">object</a>s get <em>moved</em> vs copied, where a move means that the guts of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> and scooped out and transferred to another <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<p><img src="svgbob_636a9684b4155de37000338d0777e9a56174ac26.svg" alt="Kroki diagram output"></p>
<p>This is explicitly categorizing expressions, not <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, variables or types. Each expression is categorized as either an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>, or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>.</p>
<p>A <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is an expression that generates some transient result, where that result is typically either used for assignment or passed into a function invocation by <em>moving</em> it.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">// move -- 0 is being generated and MOVED into a (the expression 0 is a prvalue)</span>
<span class="hljs-comment">//      ^</span>
<span class="hljs-comment">//      |</span>
<span class="hljs-comment">//   rvalue</span>

<span class="hljs-type">int</span> b = a; <span class="hljs-comment">// copy -- a already exists and its being COPIED into b (the expression a is NOT a prvalue)</span>
</code></pre>
<p>In essence, the way to think of a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is that its an expression that meets the following 3 conditions ...</p>
<ol>
<li>
<p>can't have the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator used on it.</p>
<pre class="hljs"><code>MyStruct* a = &amp;<span class="hljs-built_in">MyStruct</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// error -- right-hand expression is transient, not a var that you can get the address of   </span>
<span class="hljs-type">int</span>* b = &amp;(<span class="hljs-number">5</span>)                  <span class="hljs-comment">// error -- right-hand expression is a literal, not a var that you can get the address of</span>
<span class="hljs-type">int</span>* c = &amp;<span class="hljs-built_in">get_int</span>()            <span class="hljs-comment">// error -- right-hand expression is the return val of function, not a var that you can get the address of</span>
</code></pre>
</li>
<li>
<p>can have its guts be scooped out and moved into something else.</p>
<pre class="hljs"><code>x = <span class="hljs-number">55</span> + y;  <span class="hljs-comment">// expression 55 + y is evaluated and the result is MOVED into x (its guts are scooped out and moved into x)</span>
</code></pre>
</li>
<li>
<p>doesn't persist once the expression has been executed.</p>
<pre class="hljs"><code>x = <span class="hljs-number">55</span> + y;  <span class="hljs-comment">// expression 55 + y is a prvalue -- doesn't persist after this line (its not something you can access)</span>
x = c;       <span class="hljs-comment">// expression c is NOT a prvalue -- DOES persist after this line (it IS something you can keep accessing)</span>
</code></pre>
</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The name <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is short for pure right value. It's called that because <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> expressions are usually found on the right side of an assignment.</p>
</div>
<p>An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> is an expression is the opposite of a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>. An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expression CAN use the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator (opposite of point 1 above), it CANNOT have guts scooped out and moved into something else (opposite of point 2 above), and it DOES persist (opposite of point 3 above). The typical example of an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> is an expression that's solely a variable name or function name.</p>
<pre class="hljs"><code>x = y;  <span class="hljs-comment">// both x and y are lvalue</span>
x = <span class="hljs-number">0</span>;  <span class="hljs-comment">// x is an lvalue while 0 is a prvalue</span>
</code></pre>
<p>The key takeaway with <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>s is that you might be able to <em>copy</em> over its contents to something else, but you can't scoop out its guts and <em>move</em> it over to something different. Doing so would make whatever that <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> points to no longer usable.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The name <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> is short for left value. It's called that because <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expressions are usually found on the left side of an assignment.</p>
</div>
<p>An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> is an expression which can have the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator used on it but also <em>can be moved</em>. The general idea with an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> expression is that the <a href="#BM_(object%7Cinstance)%2Fi">object</a> it represents is nearing the end of its <a href="#BM_(lifetime)%2Fi">lifetime</a> and as such moving its guts is fine. There are a very limited number of cases where this happens or is required.</p>
<pre class="hljs"><code>MyObject a {};
MyObject &amp;&amp;b = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// get rvalue reference</span>
MyObject c {b};               <span class="hljs-comment">// move a into c (gut it into c) via the move constructor</span>
<span class="hljs-comment">// b is in an invalid state</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The example above is using features that haven't been introduced yet (std::move, <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s, <a href="#BM_(move%20constructor)%2Fi">move constructor</a>). Just ignore it if you don't know those pieces yet. They're explained in other sections.</p>
</div>
<p>This is in contrast to <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expressions, which the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator is usable on but <em>CANNOT be moved</em>. If the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator works on it, regardless of if it's moveable (<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>) or not (<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>), it's called a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">glvalue</a>.</p>
<p><img src="svgbob_2a2d0a00b43ce9677954ebe489b0081560222ce3.svg" alt="Kroki diagram output"></p>
<p>Similarly, if it's an expression that can be <em>moved</em> (gutted), its called an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> regardless of if the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator can be used on it or not.</p>
<p><img src="svgbob_cfa8451d53907631139a68a6093bf7bd5bf2c0c4.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="http://zhaoyan.website/xinzhi/cpp/html/cppsu32.html">here</a> for what I used to clarify what's going on here.</p>
</div>
<a name="H_Iterators"></a><h1>Iterators</h1>
<p><a href="#BM_(iterator)%2Fi">Iterator</a>s in C++ are similar to <a href="#BM_(iterator)%2Fi">iterator</a>s in Java. In Java, <a href="#BM_(object%7Cinstance)%2Fi">object</a>s that...</p>
<ul>
<li>produce an <a href="#BM_(iterator)%2Fi">iterator</a> typically implement the <code>Iterable</code> interface (e.g. <code>ArrayList</code>)</li>
<li>are <a href="#BM_(iterator)%2Fi">iterator</a>s must implement the <code>Iterator</code> interface.</li>
</ul>
<p>In C++, there is no requirement to <a href="#BM_(extend%7Csubclass)%2Fi">extend</a> from any base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es or interfaces. Instead, any type can act as an <a href="#BM_(iterator)%2Fi">iterator</a> so long as it supports as set of operators:</p>
<ul>
<li><code>!=</code> - test if the position of one <a href="#BM_(iterator)%2Fi">iterator</a> doesn't match the position of another <a href="#BM_(iterator)%2Fi">iterator</a> (e.g. <code>my_iterator != end_iterator</code>).</li>
<li><code>++</code> - move to the next item (e.g. <code>my_iterator++</code>).</li>
<li><code>*</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>) - access the next item (e.g. <code>int value = *my_iterator</code>).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Notice that the operators are more or less array / <a href="#BM_(pointer)%2Fi">pointer</a> behaviour. Given something like <code>int *</code> pointing to the beginning of an array, ...</p>
<ul>
<li>incrementing it by 1 (<code>++</code>) moves it to the next element of the array via <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>.</li>
<li><a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> it (<code>*</code>) provides the value at the array element its points to.</li>
<li>testing it using inequality (<code>!=</code>) is a way to check if it hasn't gone past the last array element.</li>
</ul>
<p>An <a href="#BM_(iterator)%2Fi">iterator</a> is basically a set of operators that walk elements in the same way as you would an array. A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can implement the operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s and behave the same way.</p>
</div>
<p>Similarly, any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can act as an iterable by implementing begin and end <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s, commonly referred to as a range:</p>
<ul>
<li><code>begin()</code> - returns an <a href="#BM_(iterator)%2Fi">iterator</a> pointing to the first item.</li>
<li><code>end()</code> - returns an <a href="#BM_(iterator)%2Fi">iterator</a> pointing to <em>past-the-end</em> (just after the last element).</li>
</ul>
<pre class="hljs"><code>MyIterator it {collection.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">while</span> (it != collection.<span class="hljs-built_in">end</span>()) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
    ++iterator;
}
</code></pre>
<p>C++ iterables and <a href="#BM_(iterator)%2Fi">iterator</a>s can be used together in range-based for loops.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (MyIterator it : collection) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<p>In total, 5 kinds of <a href="#BM_(iterator)%2Fi">iterator</a>s are supported by C++. The kind of <a href="#BM_(iterator)%2Fi">iterator</a> described above is called an <a href="#BM_(input%20iterator)%2Fi">input iterator</a> and it typically requires an equality operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> (<code>operator ==()</code>) in addition to inequality. <a href="#BM_(input%20iterator)%2Fi">Input iterator</a>s are the closest thing to a standard Java <code>Iterator</code> -- read-only and forward-only. Other kinds of <a href="#BM_(iterator)%2Fi">iterator</a>s require different operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s.</p>
<ul>
<li><a href="#BM_(input%20iterator)%2Fi">Input iterator</a>, steps forwards one element at a time and gets items of the container.</li>
<li><a href="#BM_(output%20iterator)%2Fi">Output iterator</a>, steps forwards one element at a time and sets items of the container.</li>
<li><a href="#BM_(forward%20iterator)%2Fi">Forward iterator</a>, combination of <a href="#BM_(input%20iterator)%2Fi">input iterator</a> and <a href="#BM_(output%20iterator)%2Fi">output iterator</a>.</li>
<li><a href="#BM_(bidirectional%20iterator)%2Fi">Bidirectional iterator</a>, <a href="#BM_(forward%20iterator)%2Fi">forward iterator</a> with the ability to move back.</li>
<li><a href="#BM_(random%20access%20iterator)%2Fi">Random access iterator</a>, <a href="#BM_(bidirectional%20iterator)%2Fi">bidirectional iterator</a> with the ability to jump to different positions.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input</th>
<th>Output</th>
<th>Forward</th>
<th>Bidirectional</th>
<th>Random access</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>++it</code> and <code>it++</code> (move forward)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>--it</code> and <code>it--</code> (move backward)</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 == it2</code> and<code>it1 != it2</code> (test if at same position)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &lt; it2</code> (test if before)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &lt;= it2</code> (test if before or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &gt; it2</code> (test if after)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &gt;= it2</code> (test if after or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>x = *it</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and get)</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>*it = x</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and set)</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 += n</code> and <code>it1 + n</code> (add integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 -= n</code> and <code>it1 - n</code> (subtract integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it2 - it1</code> (subtract <a href="#BM_(iterator)%2Fi">iterator</a>s to get positional difference)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 + it2</code> (add <a href="#BM_(iterator)%2Fi">iterator</a>s)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Note that the adding of <a href="#BM_(iterator)%2Fi">iterator</a>s is listed above but is not supported by any of the <a href="#BM_(iterator)%2Fi">iterator</a> types. It's there to make it explicit that adding together two <a href="#BM_(iterator)%2Fi">iterator</a>s isn't a thing.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you're dealing with the STL, there's also special <a href="#BM_(iterator)%2Fi">iterator</a> implementations that allow insertions rather than setting elements. See <code>insert_iterator</code>, <code>back_insert_iterator</code>, and <code>front_insert_iterator</code>.</p>
</div>
<a name="H_Modules"></a><h1>Modules</h1>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Source is <a href="https://vector-of-bool.github.io/2019/03/10/modules-1.html">this website</a>.</p>
</div>
<p>C++ modules change how C++ source code files interface with each other. Normally, a C++ source / header file would use <code>#include &lt;...&gt;</code> directives to pull in other source code files that it needs access to. Those outside source code files provided things like <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros, function declarations, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> declarations, global variable constants, <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a>s, <a href="#BM_(template)%2Fi">template</a>s, etc...</p>
<p>Instead of dealing with source code files directly, C++ modules allow for independently "compiling" source code files and importing them for use into different source code files, similar to how a Java source code file imports compiled Java <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> files for use. Modules reduce some of the complexities of using header files but certain functionality is also gone. Specifically, before modules go through compilation, <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros and <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives aren't included.</p>
<p>To create a module from a single file, add <code>export module</code> followed by the name of the module in the beginning of the file. Then, prefix <code>export</code> to any function, <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, etc.. that the module should expose.</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>To make use of a module in some other source code, use <code>import</code> followed by the module's name.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> my_module;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
}
</code></pre>
<p>Similar to how non-module C++ source code is broken up into a source file containing definitions and its accompanying header file would containing declarations, a module may also be broken up into separate definition and declaration files. The declarations go in a file with <code>export module</code> at the top (as shown above) and the definitions go in a file with just <code>module</code>. Declaration files aren't allowed to use <code>export</code> at all.</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;

<span class="hljs-comment">// my_module_impl.cpp</span>
<span class="hljs-keyword">module</span> my_module;  <span class="hljs-comment">// no "export" in module declaration, meaning export not allowed anywhere else in this file</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>Modules may be broken up into several pieces using module partitions, with each piece in its own file, using colons (:).</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module:addition;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
<span class="hljs-keyword">export</span> my_module:multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :addition;        <span class="hljs-comment">// export everything under my_module:addition partition</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :multiplication;  <span class="hljs-comment">// export everything under my_module:multiplication partition</span>
</code></pre>
<p>Module partitions may be made non-exportable as well, similar to the definition / declaration example earlier. The parent would need to re-define anything it wants to explicitly export.</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module:addition;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
my_module:multiplication;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">import</span> :addition;
<span class="hljs-keyword">import</span> :multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;      <span class="hljs-comment">// explicitly export this function (imported from my_module:addition partition)</span>
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>; <span class="hljs-comment">// explicitly export this function (imported from my_module:multiplication partition)</span>
</code></pre>
<p>Note that there can only ever be 1 parent for a partition. All partitions are a part of their parent module, not modules themselves. The parent module must import all of its partitions using either <code>import</code> or <code>export import</code> as shown in the examples above. No module can directly import a partition that doesn't belong to it.</p>
<p>One way to work around these restrictions is to simply make the partitions their own modules. The most common way to do this is to replace the colons (:) in each partition name with a dot (.), making sure to use the full name in the import lines (because the pieces being imported are no longer partitions of the parent module).</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module.addition;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
<span class="hljs-keyword">export</span> my_module.multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> my_module.addition;        <span class="hljs-comment">// export everything under my_module.addition (FULL NAME USED)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> my_module.multiplication;  <span class="hljs-comment">// export everything under my_module.multiplication (FULL NAME USED)</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Last I recall using this, each <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> required a special flag to turn on modules. Just because you're code uses modules doesn't mean the internal C++ libraries (e.g. standard <a href="#BM_(template)%2Fi">template</a> library, <code>cstdint</code>, etc..) are going to expose things as modules. You still have to include those using the <code>#include &lt;...&gt;</code> directives (maybe -- I think I remember there being some roundabout way of getting modules to work).</p>
</div>
<a name="H_Preprocessor"></a><h1>Preprocessor</h1>
<p>The <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> is a component of the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>. Before the programming statements in a source code file are compiled, the processor goes over the file looking for <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives. <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">Preprocessor</a> directives either...</p>
<ol>
<li>perform some basic text manipulation.</li>
<li>signal certain things to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (e.g. use a specific feature, turn off a specific feature, etc..).</li>
</ol>
<p>The first case (text manipulation) is primarily what the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> is used for. Unlike normal C++ programming statements, <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives start with the pound sign (#) and shouldn't include a semicolon (;) at the end.</p>
<p>To include one file in another file, use <code>#include</code>. Local files should be wrapped in quotes while files coming from libraries should be wrapped in a angled brackets.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>          <span class="hljs-comment">// library header</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span>  <span class="hljs-comment">// local header</span></span>
</code></pre>
<p>To replace strings in a file with another string, use <code>#define</code>.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 500</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-type">int</span> y {INITIAL_VALUE};
</code></pre>
<p>To replace strings in a file with a <em>parameterized replacement</em>, use <code>#define</code> with parenthesis.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADDED_VALUE(x, y) x + y - 15</span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-type">int</span> y {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>To stop replacing a string, use <code>#undef</code>.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 500</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> INITIAL_VALUE</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 8</span>
<span class="hljs-type">int</span> y {INITIAL_VALUE};
</code></pre>
<p>To conditionally include / ignore portions of a file, use an <code>#ifdef</code> / <code>#else</code> / <code>#endif</code> block.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>Similarly, <code>#ifndef</code> may be used to conditionally include / ignore portions of a file (<code>#ifndef</code> -- note the n, if NOT defined).</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>Conditional inclusion <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives come in an alternate form that allows for more flexible conditions: <code>#if</code> / <code>#elif</code> /<code>#else</code> / <code>#endif</code> block.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">1</span>}
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> INITIAL_VALUE &gt; 50</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE - <span class="hljs-number">50</span>}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {INITIAL_VALUE}
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a> / compilation options may be controlled through <code>#pragma</code>s. I've left <code>#pragma</code>s out of the document because they're specific to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> and platform.</p>
</div>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(preprocessor%7Ctranslation%20unit)%2Fi"></a><strong>processor</strong> - A tool that takes in a C++ source file and performs basic manipulation on it to produce what's called a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</p>
<p><img src="svgbob_212eb4f5da36a915c157410252db4d63381c77c9.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi"></a><strong>compiler</strong> - A tool that takes in a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> to produce an intermediary format called an <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>.</p>
<p><img src="svgbob_212eb4f5da36a915c157410252db4d63381c77c9.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(linker%7Cexecutable)%2Fi"></a><strong>linker</strong> - A tool that takes multiple <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s to produce an <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>. <a href="#BM_(linker%7Cexecutable)%2Fi">Linker</a>s are are also responsible for finding libraries used by the program and integrating them into the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<p><img src="svgbob_212eb4f5da36a915c157410252db4d63381c77c9.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(enumeration%7Cenum)%2Fi"></a><strong>enumeration</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> that can be set to one of a set of possibilities.</p>
</li>
<li>
<p><a name="BM_(class%7C%5Cbstruct)%2Fi"></a><strong>class</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> that pairs together data and the functions that operate on that data.</p>
</li>
<li>
<p><a name="BM_(union)%2Fi"></a><strong>union</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> where all <a href="#BM_%5Cb(member)%2Fi">member</a>s share the same memory location (different representations of the same data).</p>
</li>
<li>
<p><a name="BM_(plain-old-data%20class%7Cplain-old%20data%20class%7Cplain%20old%20data%20class%7Cplain-old-data%20structure%7Cplain-old%20data%20structure%7Cplain%20old%20data%20structure%7Cplain-old-data%20struct%7Cplain-old%20data%20struct%7Cplain%20old%20data%20struct)%2Fi"></a><strong>plain-old-data class</strong> <a name="BM_(POD)%2F"></a><strong></strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that contains only data, not functions.</p>
</li>
<li>
<p><a name="BM_%5Cb(member)%2Fi"></a><strong>member</strong> - Data or function belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(method%7C%5Cbmember%20function)%2Fi"></a><strong>method</strong> - Function belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> that is a function).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    ...
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x + y; }
};
</code></pre>
</li>
<li>
<p><a name="BM_(free%20function%7Cnon-member%20function)%2Fi"></a><strong>free function</strong> - Function not belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> -x; }
</code></pre>
</li>
<li>
<p><a name="BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi"></a><strong>field</strong> - Variable belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> that is a variable).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-type">int</span> x;
};
</code></pre>
</li>
<li>
<p><a name="BM_(class%20invariant)%2Fi"></a><strong>class invariant</strong> - When using some <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <a href="#BM_(class%20invariant)%2Fi">class invariant</a> is a feature of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that is always true (never varies). For example, if a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is used to hold on to an IP and port combination, and it ensures that the port can never be 0, that's a <a href="#BM_(class%20invariant)%2Fi">class invariant</a>.</p>
</li>
<li>
<p><a name="BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi"></a><strong>fundamental type</strong> - C++ type that's built into the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> itself rather than being declared through code. Examples include <code>void</code>, <code>bool</code>, <code>int</code>, <code>char</code>, etc..</p>
</li>
<li>
<p><a name="BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi"></a><strong>user-defined type</strong> - A type that's defined by a user, typically derived from existing types. Examples include <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>s, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, <a href="#BM_(union)%2Fi">union</a>s, etc..</p>
</li>
<li>
<p><a name="BM_(object%20initialization)%2Fi"></a><strong>object initialization</strong> - The process by which a C++ program initializes an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. an <code>int</code>, array of <code>int</code>s, <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type, etc..).</p>
</li>
<li>
<p><a name="BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi"></a><strong>braced initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where braces are used to set values (e.g. <code>int x {1}</code>, <code>MyStruct x{ 1, true }</code>, etc..). <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> is often the least error-prone form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a>, where other forms may introduce ambiguity.</p>
<pre class="hljs"><code>MyStruct x{<span class="hljs-built_in">int</span>(a), <span class="hljs-built_in">int</span>(b)};  <span class="hljs-comment">// call the constructor taking in two ints</span>
<span class="hljs-function">MyStruct <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-type">int</span>(a), <span class="hljs-type">int</span>(b))</span></span>;  <span class="hljs-comment">// possibly interpreted as function declaration -- equiv to MyStruct(int a, int b)</span>

<span class="hljs-type">float</span> a{<span class="hljs-number">1</span>}, b{<span class="hljs-number">2</span>};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span> <span class="hljs-params">(a/b)</span></span>; <span class="hljs-comment">// no compiler warning generated about narrowing (why? -- book doesn't say)</span>
<span class="hljs-type">int</span> b {a/b}; <span class="hljs-comment">// compiler warning generated about narrowing</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is also called <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">uniform initialization</a>.</p>
</div>
</li>
<li>
<p><a name="BM_(equals%3F%20initialization)%2Fi"></a><strong>equals initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where the equals sign is used (e.g. <code>int x = 5</code>).</p>
</li>
<li>
<p><a name="BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi"></a><strong>braces-plus-equals initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where both the equals sign and braces are used for initialization (e.g. <code>MyStruct x = { 1, true }</code>). This is mostly equivalent to <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/20733537">here</a>. Even though there's an equal sign (=), there is no <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> / move semantics.</p>
</div>
</li>
<li>
<p><a name="BM_(constructor)%2Fi"></a><strong>constructor</strong> - A function used for initializing an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(destructor)%2Fi"></a><strong>destructor</strong> - A function used for cleanup when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is destroyed.</p>
</li>
<li>
<p><a name="BM_(pointer)%2Fi"></a><strong>pointer</strong> - A data type used to point to a different piece of memory (e.g. <code>int yPtr { &amp;y }</code>).</p>
</li>
<li>
<p><a name="BM_(reference)%2Fi"></a><strong>reference</strong> - A data type used to point to a different piece of memory, but in a more sanitized / less confusing manner (e.g. <code>int &amp;yRef { y };</code>).</p>
</li>
<li>
<p><a name="BM_(sizeof)%2Fi"></a><strong>sizeof</strong> - An operator that returns the size of a type or <a href="#BM_(object%7Cinstance)%2Fi">object</a> (known at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</p>
</li>
<li>
<p><a name="BM_(address%5B%5C-%5Cs%5Dof)%2Fi"></a><strong>address-of (&amp;)</strong> - A unary operator used to obtain the memory <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (<a href="#BM_(pointer)%2Fi">pointer</a>) (e.g. <code>int *ptr {&amp;x}</code>).</p>
</li>
<li>
<p><a name="BM_(dereference%7Cdereferencing)%2Fi"></a><strong>dereference (*)</strong> - A unary operator used to obtain the <a href="#BM_(object%7Cinstance)%2Fi">object</a> at some memory address (e.g. <code>int x {*ptr}</code>).</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi"></a><strong>member-of-pointer (-&gt;)</strong> - An operator that <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>s a <a href="#BM_(pointer)%2Fi">pointer</a> and access a <a href="#BM_%5Cb(member)%2Fi">member</a> of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to (e.g. <code>ptr-&gt;x</code>).</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi"></a><strong>member-of-object (.)</strong> - An operator that accesses a <a href="#BM_%5Cb(member)%2Fi">member</a> of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> to (e.g. <code>obj.x</code>).</p>
</li>
<li>
<p><a name="BM_(pointer%20arithmetic)%2Fi"></a><strong>pointer arithmetic</strong> - Adding or subtracting integer types to a <a href="#BM_(pointer)%2Fi">pointer</a> will move that <a href="#BM_(pointer)%2Fi">pointer</a> by the number of bytes that makes up its underlying type (e.g. <code>uint32_t *ptrB = ptrA + 1</code> will set <code>ptrB</code> to 4 bytes ahead of ptrA).</p>
</li>
<li>
<p><a name="BM_(reseat)%2Fi"></a><strong>reseating</strong> - The concept of a variable that points to something updating to point to something else. <a href="#BM_(pointer)%2Fi">Pointer</a>s can be <a href="#BM_(reseat)%2Fi">reseat</a>ed, but <a href="#BM_(reference)%2Fi">reference</a>s cannot.</p>
</li>
<li>
<p><a name="BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi"></a><strong>member initializer list</strong> - A comma separated list of <a href="#BM_(object%20initialization)%2Fi">object initialization</a>s for the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> appearing just before a <a href="#BM_(constructor)%2Fi">constructor</a>'s body.</p>
</li>
<li>
<p><a name="BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi"></a><strong>default member initialization</strong> - The <a href="#BM_(object%20initialization)%2Fi">object initialization</a> of a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> directly where that <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is declared.</p>
</li>
<li>
<p><a name="BM_(object%7Cinstance)%2Fi"></a><strong>object</strong> - A region of memory that has a type and a value (e.g. <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, an integer, a <a href="#BM_(pointer)%2Fi">pointer</a> to an integer, etc..).</p>
</li>
<li>
<p><a name="BM_(allocation%7Callocate)%2Fi"></a><strong>allocation</strong> - The act of reserving memory for an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(deallocation%7Cdeallocate)%2Fi"></a><strong>deallocation</strong> - The act of releasing the memory used by an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(storage%20duration)%2Fi"></a><strong>storage duration</strong> - The duration between an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>.</p>
</li>
<li>
<p><a name="BM_(lifetime)%2Fi"></a><strong>lifetime</strong> - The duration between when an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(constructor)%2Fi">constructor</a> <em>completes</em> (meaning the <a href="#BM_(constructor)%2Fi">constructor</a> finishes) and when its <a href="#BM_(destructor)%2Fi">destructor</a> is <em>invoked</em> (meaning when the <a href="#BM_(destructor)%2Fi">destructor</a> starts).</p>
</li>
<li>
<p><a name="BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi"></a><strong>automatic object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's declared within an enclosing code block. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the block and finish at the end of the block.</p>
</li>
<li>
<p><a name="BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi"></a><strong>static object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's declared using <code>static</code> or <code>extern</code>. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the program and finish at the end of the program.</p>
</li>
<li>
<p><a name="BM_(local%20static%20object%7Clocal%20static%20variable%7Clocal%20static%20storage%20duration)%2Fi"></a><strong>local static object</strong> - A <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static object</a> but declared at function scope. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the first invocation of the function and finish at the end of the program.</p>
</li>
<li>
<p><a name="BM_(static%20field%7Cstatic%20member)%2Fi"></a><strong>static member</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's a <a href="#BM_%5Cb(member)%2Fi">member</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but bound globally rather than on an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. A <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> is essentially a <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static object</a> that's accessible through the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself (not an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>). Similarly, a static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is essentially a global function that's accessed through the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (not an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
</li>
<li>
<p><a name="BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi"></a><strong>thread local object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> where each thread has access to its own copy. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the thread and finish when the thread ends.</p>
</li>
<li>
<p><a name="BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi"></a><strong>dynamically allocated object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d at the user's behest, meaning that it's <a href="#BM_(storage%20duration)%2Fi">storage duration</a> is also controlled by the user.</p>
</li>
<li>
<p><a name="BM_(internal%20linkage)%2Fi"></a><strong>internal linkage</strong> - A variable only visible to the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's in.</p>
</li>
<li>
<p><a name="BM_(external%20linkage)%2Fi"></a><strong>external linkage</strong> - A variable visible to the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s that it's in as well as other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s.</p>
</li>
<li>
<p><a name="BM_(scope%20resolution)%2Fi"></a><strong>scope resolution (::)</strong> - A operator that's used to access <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a>s (e.g. <code>MyStruct::static_func()</code>).</p>
</li>
<li>
<p><a name="BM_(extend%7Csubclass)%2Fi"></a><strong>extend</strong> - Another way of expressing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inheritance (e.g. B <a href="#BM_(extend%7Csubclass)%2Fi">extend</a>s A is equivalent to saying B is a child of A).</p>
</li>
<li>
<p><a name="BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi"></a><strong>exception</strong> - An <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> operation accepts an <a href="#BM_(object%7Cinstance)%2Fi">object</a> and unwinds the call stack until reaching a special region specifically intended to stop the unwinding for <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of that type, called a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block. <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">Exception</a>s are a way for code to signal that something unexpected / <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>al happened.</p>
</li>
<li>
<p><a name="BM_(structured%20binding)%2Fi"></a><strong>structured binding</strong> - A language feature that allows for unpacking an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s / array's elements into a set of variables (e.g. <code>auto [x, y] = two_elem_array</code>).</p>
</li>
<li>
<p><a name="BM_(copy%20semantics)%2Fi"></a><strong>copy semantics</strong> - The rules used for making copies of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of some type. A copy, once made, should be equivalent to its source. A modification on the copy shouldn't modify the source as well.</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi"></a><strong>member-wise copy</strong> - The default <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> for <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es. Each individual <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is copied.</p>
</li>
<li>
<p><a name="BM_(copy%20constructor)%2Fi"></a><strong>copy constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> with a single parameter that takes in a <a href="#BM_(reference)%2Fi">reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type (e.g. <code>T(const T &amp;) { ... }</code>). A <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is used to specify the <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> for that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(copy%20assignment)%2Fi"></a><strong>copy assignment</strong> - An assignment operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> that copies one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another (e.g. <code>x = y</code>). <a href="#BM_(copy%20assignment)%2Fi">Copy assignment</a> requires that resources in the destination <a href="#BM_(object%7Cinstance)%2Fi">object</a> be cleaned up prior to performing the copy.</p>
</li>
<li>
<p><a name="BM_(RAII%7CCADRe)%2F"></a><strong>RAII</strong> - Short for resource acquisition is initialization, the concept that the life cycle of some resource (e.g. open file, database <a href="#BM_(object%7Cinstance)%2Fi">object</a>, etc..) is bound to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a> via it's <a href="#BM_(constructor)%2Fi">constructor</a> and <a href="#BM_(destructor)%2Fi">destructor</a>.</p>
<p>Sometimes also referred to <a href="#BM_(constructor)%2Fi">constructor</a> acquires <a href="#BM_(destructor)%2Fi">destructor</a> releases (<a href="#BM_(RAII%7CCADRe)%2F">CADRe</a>).</p>
</li>
<li>
<p><a name="BM_(moved%5B%5C-%5Cs%5Dfrom%20object%7Cmoved%5B%5C-%5Cs%5Dfrom%20state)%2Fi"></a><strong>moved-from object</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is moved to another <a href="#BM_(object%7Cinstance)%2Fi">object</a>, that <a href="#BM_(object%7Cinstance)%2Fi">object</a> enters a special state where the only possible operation allowed on it is either destruction or re-assignment.</p>
</li>
<li>
<p><a name="BM_(move%20constructor)%2Fi"></a><strong>move constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> with a single parameter that takes in an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type (e.g. <code>T(T &amp;&amp;) { ... }</code>). A <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is used to specify the move semantics for that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(move%20assignment)%2Fi"></a><strong>move assignment</strong> - An assignment operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> that moves one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another (e.g. <code>x = y</code>).</p>
</li>
<li>
<p><a name="BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi"></a><strong>value categories</strong> - A classification hierarchy for C++ expressions. Any C++ expression falls into one of the following categories: <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>, or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>.</p>
<p>The intent of this hierarchy is to enable the <em>moving</em> of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. In this case, moving doesn't mean copying. It means gutting out the contents of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> and moving it into another <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<p><img src="svgbob_98c47b0782577adc03415029a6512cbe5425620a.svg" alt="Kroki diagram output"></p>
<ul>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> - An expression that, once evaluated, is a transient / temporary <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code>(x + <span class="hljs-number">51</span>) / n    <span class="hljs-comment">// this is a prvalue      (the result is temporary, needing to go somewhere)</span>
x               <span class="hljs-comment">// this is NOT a prvalue  (the result of x is just x -- it's an exist object)</span>
</code></pre>
</li>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> - An expression that, once evaluated, is an addressable <a href="#BM_(object%7Cinstance)%2Fi">object</a> (NOT transient / NOT temporary / the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator is usable on it).</p>
<pre class="hljs"><code>(x + <span class="hljs-number">51</span>) / n    <span class="hljs-comment">// this is NOT an lvalue (the result is temporary, needing to go somewhere)</span>
x               <span class="hljs-comment">// this is a lvalue      (the result of x is just x -- it's an exist object)</span>
</code></pre>
</li>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> - An expression that, similar to <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, is an addressable <a href="#BM_(object%7Cinstance)%2Fi">object</a>. But, unlike <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is marked as being near the end of its <a href="#BM_(lifetime)%2Fi">lifetime</a>.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See the expression categories for more information.</p>
</div>
</li>
<li>
<p><a name="BM_(variable%20length%20array)%2Fi"></a><strong>variable length array</strong> <a name="BM_(VLA)%2F"></a><strong></strong> - A feature of C99 that allows for declaring an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a> array whose length is determined at <a href="#BM_(runtime)%2Fi">runtime</a> (non-constant length). This feature is not available in C++ because C++ provides higher-level abstractions for collections of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s in its STL (speculation).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-type">int</span> x[] = <span class="hljs-type">int</span>[n];  <span class="hljs-comment">// okay in C99, but not in C++</span>
}
</code></pre>
</li>
<li>
<p><a name="BM_(rvalue%20reference)%2Fi"></a><strong>rvalue reference</strong> - A data type that's more-or-less the same as a <a href="#BM_(reference)%2Fi">reference</a> but conveys to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that the data its pointing to is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> (e.g. <code>MyType &amp;&amp;rref { y }</code>).</p>
</li>
<li>
<p><a name="BM_(virtual%20method%7Cvirtual%20function)%2Fi"></a><strong>virtual method</strong> - A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in a base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that is overridable by any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that inherits from that base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi"></a><strong>pure virtual method</strong> - A <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> that requires an implementation (no implementation has been provided by the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that declares it). For a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be instantiable, it cannot have any <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s (similar to an abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> in Java).</p>
</li>
<li>
<p><a name="BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi"></a><strong>pure virtual class</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that only contains <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s.</p>
</li>
<li>
<p><a name="BM_(virtual%20destructor)%2Fi"></a><strong>virtual destructor</strong> - A <a href="#BM_(destructor)%2Fi">destructor</a> that's a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>.</p>
</li>
<li>
<p><a name="BM_(vtable)%2Fi"></a><strong>vtable</strong> - A table of <a href="#BM_(pointer)%2Fi">pointer</a>s to <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a>s, generated by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>. When a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a> gets invoked (<a href="#BM_(runtime)%2Fi">runtime</a>) <a href="#BM_(vtable)%2Fi">vtable</a>s are used to determining which <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> implementation to use.</p>
</li>
<li>
<p><a name="BM_(template)%2Fi"></a><strong>template</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function where parts of the code are intended for substitution (by other code). At <a href="#BM_(compile-time)%2Fi">compile-time</a>, a user supplies a set of substitutions for each usage of a <a href="#BM_(template)%2Fi">template</a>, customizing it for the specific use-case that user is dealing with.</p>
</li>
<li>
<p><a name="BM_(template%20parameter)%2Fi"></a><strong>template parameter</strong> - An identifier within the <a href="#BM_(template)%2Fi">template</a>. At compile time, any time a <a href="#BM_(template)%2Fi">template</a> is used its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are substituted with code that the usage supplies.</p>
<p>A <a href="#BM_(template%20parameter)%2Fi">template parameter</a> may be used multiple times throughout the <a href="#BM_(template)%2Fi">template</a>. At <a href="#BM_(compile-time)%2Fi">compile-time</a>, each usage is substituted with the same piece of code.</p>
</li>
<li>
<p><a name="BM_(template%20instantiation)%2Fi"></a><strong>template instantiation</strong> - The process of substituting the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s in a <a href="#BM_(template)%2Fi">template</a> with real code.</p>
</li>
<li>
<p><a name="BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi"></a><strong>named conversion</strong> - A set of language features / functions used for converting types (casting): <code>const_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>, and <code>narrow_cast</code>.</p>
</li>
<li>
<p><a name="BM_(concept)_TEMPLATE%2Fi"></a><strong>concept</strong> - A <a href="#BM_(compile-time)%2Fi">compile-time</a> check to ensure that the type substituted for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> matches a set of requirements (e.g. the type support certain operators).</p>
</li>
<li>
<p><a name="BM_(compile-time)%2Fi"></a><strong>compile-time</strong> - Used in <a href="#BM_(reference)%2Fi">reference</a> to something that happens during the compilation process.</p>
</li>
<li>
<p><a name="BM_(runtime)%2Fi"></a><strong>runtime</strong> - Used in <a href="#BM_(reference)%2Fi">reference</a> to something that happens when the compiled program is running.</p>
</li>
<li>
<p><a name="BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi"></a><strong>zero-arg</strong> - Short for zero argument. A function with zero parameters.</p>
</li>
<li>
<p><a name="BM_(parameter%20pack)%2Fi"></a><strong>parameter pack</strong> - In the context of <a href="#BM_(template)%2Fi">template</a>s, a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a> is a single <a href="#BM_(template%20parameter)%2Fi">template parameter</a> declaration that can take in zero or more substitutions (<a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a>).</p>
</li>
<li>
<p><a name="BM_(variadic%7Cvararg)%2Fi"></a><strong>variadic</strong> - A function that takes in a variable number of arguments, sometimes also called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s.</p>
</li>
<li>
<p><a name="BM_(template%20specialization)%2Fi"></a><strong>template specialization</strong> - Given a specific substitutions set substitutions for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s of a <a href="#BM_(template)%2Fi">template</a>, a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is code that overrides the <a href="#BM_(template)%2Fi">template</a> generated code. Often times <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are introduced because they're more memory or computationally efficient than the standard <a href="#BM_(template)%2Fi">template</a> generated code.</p>
</li>
<li>
<p><a name="BM_(partial%20template%20specialization%20%7C%20template%20partial%20specialization)%2Fi"></a><strong>partial template specialization</strong> - A <a href="#BM_(template%20specialization)%2Fi">template specialization</a> where not all of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s have been removed.</p>
</li>
<li>
<p><a name="BM_(partial%20template)%2Fi"></a><strong>partial template</strong> - A <a href="#BM_(template)%2Fi">template</a> with some of its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s set (not all).</p>
</li>
<li>
<p><a name="BM_(default%20template%20argument)%2Fi"></a><strong>default template argument</strong> - The default substitute in use for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</p>
</li>
<li>
<p><a name="BM_(heap%7Cfree%20store)%2Fi"></a><strong>heap</strong> - An implementation-specific block of memory used for <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s. Also called the <a href="#BM_(heap%7Cfree%20store)%2Fi">free store</a>.</p>
</li>
<li>
<p><a name="BM_(implicit%20type%20conversion)%2Fi"></a><strong>implicit type conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is converted automatically, without code explicitly changing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to a different type (e.g. <code>long x {1}</code> implicitly converts the <code>int</code> literal in the initializer to the <code>long</code> type).</p>
</li>
<li>
<p><a name="BM_(explicit%20type%20conversion)%2Fi"></a><strong>explicit type conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is explicitly converted to another type: casting and <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>s.</p>
</li>
<li>
<p><a name="BM_(promotion%20rule)%2Fi"></a><strong>promotion rule</strong> - An <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> that may occur when an operator's operands are of differing integral and floating point types. For example, adding an integral type with a smaller integral type will cause the result to be of the same type as the larger type.</p>
</li>
<li>
<p><a name="BM_(narrowing%20conversion)%2Fi"></a><strong>narrowing conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is truncated to a lesser type (e.g. <code>int</code> to <code>short</code>).</p>
<p><a href="#BM_(narrowing%20conversion)%2Fi">Narrowing conversion</a>s may be implicit during <a href="#BM_(object%20initialization)%2Fi">object initialization</a>. To erroneous cases of narrowing, use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> to force the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning.</p>
</li>
<li>
<p><a name="BM_(constant%20expression)%2Fi"></a><strong>constant expression</strong> - A function that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, such that at run-time any invocation of it simply returns the result computed at <a href="#BM_(compile-time)%2Fi">compile-time</a>. <a href="#BM_(constant%20expression)%2Fi">Constant expression</a>s are represented as functions prefixed with <code>constexpr</code>.</p>
</li>
<li>
<p><a name="BM_(immediate%20function)%2Fi"></a><strong>immediate function</strong> - A function that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> and must produce a <a href="#BM_(compile-time)%2Fi">compile-time</a> constant. <a href="#BM_(immediate%20function)%2Fi">Immediate function</a>s expressions are represented as functions prefixed with <code>consteval</code>.</p>
</li>
<li>
<p><a name="BM_(literal%20type)%2Fi"></a><strong>literal type</strong> - A type that's usable in a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> (for parameters and return), meaning that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of this type can have a value that's knowable at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
</li>
<li>
<p><a name="BM_(volatile)%2Fi"></a><strong>volatile</strong> - A <a href="#BM_(volatile)%2Fi">volatile</a> variable's usage in code is immune to <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> optimizations such as operation re-ordering and removal. Mutations and accesses, no matter how irrelevant they may seem, are kept in-place and in-order by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
</li>
<li>
<p><a name="BM_(type%20alias)%2Fi"></a><strong>type alias</strong> - A synonym (different name) for an existing type.</p>
</li>
<li>
<p><a name="BM_(attribute)%2Fi"></a><strong>attribute</strong> - A tag applied to code that provides information to the user / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> about whatever it is that it's applied to. Similar to Java annotations.</p>
</li>
<li>
<p><a name="BM_(iterator)%2Fi"></a><strong>iterator</strong> - A type used to access elements within some sequence (e.g. array, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> representing a list, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> representing an infinite stream of <code>int</code>s, etc..). An <a href="#BM_(iterator)%2Fi">iterator</a> requires a specific set of operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s.</p>
</li>
<li>
<p><a name="BM_(input%20iterator)%2Fi"></a><strong>input iterator</strong> - An <a href="#BM_(iterator)%2Fi">iterator</a> that can only move forward in the sequence one element at a time and can only get elements of the sequence.</p>
</li>
<li>
<p><a name="BM_(output%20iterator)%2Fi"></a><strong>output iterator</strong> - An <a href="#BM_(iterator)%2Fi">iterator</a> that can only move forward in the sequence one element at a time and can only set elements of the sequence.</p>
</li>
<li>
<p><a name="BM_(forward%20iterator)%2Fi"></a><strong>forward iterator</strong> - An <a href="#BM_(iterator)%2Fi">iterator</a> that combines the functionality of both <a href="#BM_(input%20iterator)%2Fi">input iterator</a> and <a href="#BM_(output%20iterator)%2Fi">output iterator</a>.</p>
</li>
<li>
<p><a name="BM_(bidirectional%20iterator)%2Fi"></a><strong>bidirectional iterator</strong> - An <a href="#BM_(iterator)%2Fi">iterator</a> that has the same functionality as <a href="#BM_(forward%20iterator)%2Fi">forward iterator</a> but also allows for moving backward in the sequence one element at a time, meaning it can move forward as well as backward.</p>
</li>
<li>
<p><a name="BM_(random%20access%20iterator)%2Fi"></a><strong>random access iterator</strong> - An <a href="#BM_(iterator)%2Fi">iterator</a> that has the same functionality as <a href="#BM_(bidirectional%20iterator)%2Fi">bidirectional iterator</a> but also allows randomly jumping to different elements within the sequence.</p>
</li>
<li>
<p><a name="BM_(specifier%7Cmodifier)%2Fi"></a><strong>modifier</strong> - Optional marker that alters a function. With functions, a <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> may be required to go either before the return type (prefix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>) or after the parameter list (suffix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>).</p>
<p><a href="#BM_(specifier%7Cmodifier)%2Fi">Modifier</a>s are also sometimes referred to as <a href="#BM_(specifier%7Cmodifier)%2Fi">specifier</a>s.</p>
</li>
<li>
<p><a name="BM_(fold%20expression)%2Fi"></a><strong>fold expression</strong> - Exhaustively applies a binary operator to the contents of a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a> and return the final result.</p>
</li>
<li>
<p><a name="BM_(associativity%7Cassociative)%2Fi"></a><strong>associativity</strong> - In the context of binary operators, <a href="#BM_(associativity%7Cassociative)%2Fi">associativity</a> refers to the order in which an expression with a chain of the same binary operator is evaluated. The term ...</p>
<ul>
<li>
<p>left <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> means that the chain is evaluated left-to-right (left-most first, right-most last).</p>
<pre class="hljs"><code>a ? b ? c ? d == (((a ? b) ? c) ? d)
</code></pre>
</li>
<li>
<p>right <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> means that the chain is evaluated right-to-left (right-most first, left-most last).</p>
<pre class="hljs"><code>a ? b ? c ? d == (a ? (b ? (c ? d)))
</code></pre>
</li>
</ul>
</li>
<li>
<p><a name="BM_(function%20pointer)%2Fi"></a><strong>function pointer</strong> - A <a href="#BM_(pointer)%2Fi">pointer</a> to a function.</p>
</li>
<li>
<p><a name="BM_(functor%7Cfunction%20object)%2Fi"></a><strong>functor</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can invoke as if it were a function because it has an operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s for function-call.</p>
</li>
<li>
<p><a name="BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi"></a><strong>function call operator</strong> - The operator used for making function calls (parenthesis), may be operator <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed on <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to turn them into <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s.</p>
</li>
<li>
<p><a name="BM_(lambda)%2Fi"></a><strong>lambda</strong> - Shorthand notation for an unnamed <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> -z; };
</code></pre>
</li>
<li>
<p><a name="BM_(named%20capture)%2Fi"></a><strong>named capture</strong> - Pulling in <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope into a <a href="#BM_(lambda)%2Fi">lambda</a> by explicitly listing their names in the capture clause, adding <code>&amp;</code> before each name if wanting to pull it in by <a href="#BM_(reference)%2Fi">reference</a> rather than by copy.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [&amp;x, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; }; <span class="hljs-comment">// x and y from outer scope</span>
</code></pre>
</li>
<li>
<p><a name="BM_(default%20capture)%2Fi"></a><strong>default capture</strong> - Pulling in <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope into a <a href="#BM_(lambda)%2Fi">lambda</a> automatically (based on their usage) but putting either an <code>=</code> (for copying into <a href="#BM_(lambda)%2Fi">lambda</a>) or <code>&amp;</code> (for referencing into <a href="#BM_(lambda)%2Fi">lambda</a>) in the capture clause.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [=] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };
</code></pre>
</li>
<li>
<p><a name="BM_(init%20capture%7Cinitializer%20capture)%2Fi"></a><strong>init capture</strong> - An initializer expression used as a <a href="#BM_(lambda)%2Fi">lambda</a> <a href="#BM_(named%20capture)%2Fi">named capture</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [new_x=x/<span class="hljs-number">2</span>, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> new_x + y + z; };
</code></pre>
</li>
<li>
<p><a name="BM_(callable%20object)%2Fi"></a><strong>callable object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that can be invoked: a function, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, or <a href="#BM_(lambda)%2Fi">lambda</a>.</p>
</li>
<li>
<p><a name="BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi"></a><strong>function overload</strong> - A function that has the same name as another function within the same scope.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0.0</span>; }
</code></pre>
</li>
<li>
<p><a name="BM_(forward%20declaration)%2Fi"></a><strong>forward declaration</strong> - To use a function, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, variable, etc.. within some C++ code, only its declaration is needed, not its definition (implementation). The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> wll ensure that the usage points to the implementation when the time comes.</p>
<p>The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> needs this to handle cyclical <a href="#BM_(reference)%2Fi">reference</a>s. It can also significantly reduce build times.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span>; <span class="hljs-comment">// forward declaration of MyClassA</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassB</span>; <span class="hljs-comment">// forward declaration of MyClassB</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClassA &amp;objA, MyClassB &amp;objB)</span></span>; <span class="hljs-comment">// forward declaration of a function</span>


<span class="hljs-comment">// implement myFunction, using MyClassA and MyClassB before implementation is defined</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClassA &amp;objA, MyClassB &amp;objB)</span> </span>{
    ...
}
<span class="hljs-comment">// implement MyClassA, using MyClassB before implementation is defined</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span> {
    ...
<span class="hljs-keyword">private</span>:
    MyClassB objB;
}
<span class="hljs-comment">// implement MyClassB</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span> {
    ...
<span class="hljs-keyword">private</span>:
    MyClassA objA;
}
</code></pre>
</li>
<li>
<p><a name="BM_(user-defined%20literal)%2Fi"></a><strong>user-defined literal</strong> - A literal suffix defined by a user, where when that suffix is applied to some literal, some computation is performed.</p>
<pre class="hljs"><code>Distance d = <span class="hljs-number">42.0</span>_km;  <span class="hljs-comment">// the suffix _km converts the literal 42.0 to an instance of the Distance type</span>
</code></pre>
</li>
<li>
<p><a name="BM_(module%20unit)%2Fi"></a><strong>module unit</strong> - A <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> that contains a module declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> MyModule;  <span class="hljs-comment">// module declaration</span>

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
</li>
</ul>
<p>


</p>
<p>
</p>

        </body></html>