<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>C++</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><p></p>
<div class="toc">
<ul>
<li><a href="#H_How%20to%20Read">How to Read</a></li>
<li><a href="#H_Essentials">Essentials</a></li>
<ul>
<li><a href="#H_Language%20Basics">Language Basics</a></li>
<li><a href="#H_Compilation%20Basics">Compilation Basics</a></li>
<li><a href="#H_Header%20Files">Header Files</a></li>
<li><a href="#H_Development%20Environment">Development Environment</a></li>
</ul>
<li><a href="#H_Core%20Language">Core Language</a></li>
<ul>
<li><a href="#H_Operators">Operators</a></li>
<li><a href="#H_Variables">Variables</a></li>
<ul>
<li><a href="#H_Core%20Types">Core Types</a></li>
<ul>
<li><a href="#H_Integral">Integral</a></li>
<li><a href="#H_Floating%20Point">Floating Point</a></li>
<li><a href="#H_Character%20String">Character String</a></li>
<li><a href="#H_Void">Void</a></li>
</ul>
<li><a href="#H_Arrays">Arrays</a></li>
<li><a href="#H_Pointers">Pointers</a></li>
<ul>
<li><a href="#H_Pointer%20Arithmetic">Pointer Arithmetic</a></li>
<li><a href="#H_Void%20Pointer">Void Pointer</a></li>
<li><a href="#H_Function%20Pointer">Function Pointer</a></li>
</ul>
<li><a href="#H_References">References</a></li>
<li><a href="#H_Rvalue%20References">Rvalue References</a></li>
<li><a href="#H_Size">Size</a></li>
<li><a href="#H_Aliasing">Aliasing</a></li>
<li><a href="#H_Constant">Constant</a></li>
<li><a href="#H_Volatile">Volatile</a></li>
<li><a href="#H_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Implicit%20Conversion">Implicit Conversion</a></li>
<li><a href="#H_Explicit%20Conversion">Explicit Conversion</a></li>
<ul>
<li><a href="#H_Named%20Conversions">Named Conversions</a></li>
<li><a href="#H_C-style%20Casts">C-style Casts</a></li>
</ul>
</ul>
<li><a href="#H_Object%20Lifecycle">Object Lifecycle</a></li>
<ul>
<li><a href="#H_Static%20Objects">Static Objects</a></li>
<li><a href="#H_Dynamic%20Objects">Dynamic Objects</a></li>
</ul>
<li><a href="#H_Functions">Functions</a></li>
<ul>
<li><a href="#H_Overloading">Overloading</a></li>
<li><a href="#H_Argument%20Matching">Argument Matching</a></li>
<li><a href="#H_Main%20Function">Main Function</a></li>
<li><a href="#H_Variadic">Variadic</a></li>
<li><a href="#H_No%20Exception">No Exception</a></li>
<li><a href="#H1_Common%20Attributes">Common Attributes</a></li>
</ul>
<li><a href="#H_Enumerations">Enumerations</a></li>
<li><a href="#H_Classes">Classes</a></li>
<ul>
<li><a href="#H_This%20Pointer">This Pointer</a></li>
<li><a href="#H1_Constant">Constant</a></li>
<li><a href="#H1_Volatile">Volatile</a></li>
<li><a href="#H2_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Static">Static</a></li>
<li><a href="#H_Construction">Construction</a></li>
<li><a href="#H_Destruction">Destruction</a></li>
<li><a href="#H_Copying">Copying</a></li>
<li><a href="#H_Moving">Moving</a></li>
<li><a href="#H_Default%20Implementations">Default Implementations</a></li>
<li><a href="#H_Deleted%20Implementations">Deleted Implementations</a></li>
<li><a href="#H_Inheritance">Inheritance</a></li>
<li><a href="#H_Interfaces">Interfaces</a></li>
<li><a href="#H_Operator%20Overloading">Operator Overloading</a></li>
<li><a href="#H_Three-way%20Comparison%20Overloading">Three-way Comparison Overloading</a></li>
<li><a href="#H_Conversion%20Overloading">Conversion Overloading</a></li>
<li><a href="#H_Const%20%2F%20Volatile%20Overloading">Const / Volatile Overloading</a></li>
<li><a href="#H_Reference%20Overloading">Reference Overloading</a></li>
<li><a href="#H_Functors">Functors</a></li>
<li><a href="#H_Friends">Friends</a></li>
<li><a href="#H_User-defined%20Literals">User-defined Literals</a></li>
</ul>
<li><a href="#H_Lambdas">Lambdas</a></li>
<ul>
<li><a href="#H_Capture%20List">Capture List</a></li>
<li><a href="#H_Parameter%20List">Parameter List</a></li>
<li><a href="#H_Return%20Type">Return Type</a></li>
<li><a href="#H_Modifiers">Modifiers</a></li>
<li><a href="#H_Template%20Parameters">Template Parameters</a></li>
</ul>
<li><a href="#H_Templates">Templates</a></li>
<ul>
<li><a href="#H_Universal%20References">Universal References</a></li>
<li><a href="#H_Auto%20Syntax">Auto Syntax</a></li>
<li><a href="#H_Type%20Cloning">Type Cloning</a></li>
<li><a href="#H_Type%20Deduction">Type Deduction</a></li>
<ul>
<li><a href="#H_Deduction%20Rules">Deduction Rules</a></li>
<li><a href="#H_Type%20Cloning%20Deduction">Type Cloning Deduction</a></li>
</ul>
<li><a href="#H_Concepts">Concepts</a></li>
<ul>
<li><a href="#H_Ordered%20Type%20Concept">Ordered Type Concept</a></li>
<li><a href="#H_Semi-regular%20Type%20Concept">Semi-regular Type Concept</a></li>
<li><a href="#H_Regular%20Type%20Concept">Regular Type Concept</a></li>
<li><a href="#H_Union%20Type%20Concept">Union Type Concept</a></li>
<li><a href="#H_Callable%20Type%20Concept">Callable Type Concept</a></li>
<ul>
<li><a href="#H_Parameter%20Counts">Parameter Counts</a></li>
<li><a href="#H_Parameter%20Types">Parameter Types</a></li>
<li><a href="#H_Return%20Types">Return Types</a></li>
</ul>
</ul>
<li><a href="#H1_Variadic">Variadic</a></li>
<li><a href="#H_Specialization">Specialization</a></li>
<li><a href="#H_Type%20Aliasing">Type Aliasing</a></li>
<li><a href="#H_Callable%20Type%20Unpacking">Callable Type Unpacking</a></li>
<ul>
<li><a href="#H1_Functions">Functions</a></li>
<li><a href="#H1_Functors">Functors</a></li>
</ul>
</ul>
<li><a href="#H_Coroutines">Coroutines</a></li>
<ul>
<li><a href="#H_Handler">Handler</a></li>
<li><a href="#H_Promise">Promise</a></li>
<li><a href="#H_Awaitable">Awaitable</a></li>
</ul>
<li><a href="#H_Unions">Unions</a></li>
<li><a href="#H_Namespaces">Namespaces</a></li>
<li><a href="#H_Linker%20Behaviour">Linker Behaviour</a></li>
<ul>
<li><a href="#H_Static%20Linkage">Static Linkage</a></li>
<li><a href="#H_Inline%20Linkage">Inline Linkage</a></li>
<li><a href="#H_External%20Linkage">External Linkage</a></li>
</ul>
<li><a href="#H_Control%20Flow">Control Flow</a></li>
<ul>
<li><a href="#H_If%20Statement">If Statement</a></li>
<li><a href="#H_Switch%20Statement">Switch Statement</a></li>
<li><a href="#H_For%20Loop">For Loop</a></li>
<li><a href="#H_While%20Loop">While Loop</a></li>
<li><a href="#H_Goto%20Statement">Goto Statement</a></li>
<li><a href="#H_Branching%20Likelihood">Branching Likelihood</a></li>
</ul>
<li><a href="#H_Attributes">Attributes</a></li>
<li><a href="#H_Compile-time%20Evaluation">Compile-time Evaluation</a></li>
<li><a href="#H_Exceptions">Exceptions</a></li>
<li><a href="#H_Structured%20Binding">Structured Binding</a></li>
<li><a href="#H_Expression%20Categories">Expression Categories</a></li>
<li><a href="#H_Modules">Modules</a></li>
<li><a href="#H_Preprocessor">Preprocessor</a></li>
<li><a href="#H_Inconsistent%20Behaviour">Inconsistent Behaviour</a></li>
<ul>
<li><a href="#H_Implementation-defined%20Behaviour">Implementation-defined Behaviour</a></li>
<li><a href="#H_Unspecified%20Behaviour">Unspecified Behaviour</a></li>
<li><a href="#H_Undefined%20Behaviour">Undefined Behaviour</a></li>
</ul>
</ul>
<li><a href="#H_Library%20Functions">Library Functions</a></li>
<ul>
<li><a href="#H_Type%20Traits">Type Traits</a></li>
<li><a href="#H_Allocators">Allocators</a></li>
<li><a href="#H_Smart%20Pointers">Smart Pointers</a></li>
<ul>
<li><a href="#H_Scoped%20Pointer">Scoped Pointer</a></li>
<li><a href="#H_Unique%20Pointer">Unique Pointer</a></li>
<li><a href="#H_Shared%20Pointer">Shared Pointer</a></li>
<li><a href="#H_Weak%20Pointer">Weak Pointer</a></li>
<li><a href="#H_Intrusive%20Pointer">Intrusive Pointer</a></li>
</ul>
<li><a href="#H_Wrappers">Wrappers</a></li>
<ul>
<li><a href="#H_Optional">Optional</a></li>
<li><a href="#H_Tuple">Tuple</a></li>
<li><a href="#H_Any">Any</a></li>
<li><a href="#H_Variant">Variant</a></li>
<li><a href="#H_Function">Function</a></li>
<li><a href="#H_Bind">Bind</a></li>
<li><a href="#H_Reference%20Wrapper">Reference Wrapper</a></li>
</ul>
<li><a href="#H_Containers">Containers</a></li>
<ul>
<li><a href="#H_Sequential">Sequential</a></li>
<ul>
<li><a href="#H_Array">Array</a></li>
<li><a href="#H_Vector">Vector</a></li>
<li><a href="#H_Deque">Deque</a></li>
<li><a href="#H_List">List</a></li>
</ul>
<li><a href="#H_Ordered%20Associative">Ordered Associative</a></li>
<ul>
<li><a href="#H_Set">Set</a></li>
<li><a href="#H_Multiset">Multiset</a></li>
<li><a href="#H_Map">Map</a></li>
<li><a href="#H_Multimap">Multimap</a></li>
</ul>
<li><a href="#H_Unordered%20Associative">Unordered Associative</a></li>
<ul>
<li><a href="#H1_Set">Set</a></li>
<li><a href="#H1_Multiset">Multiset</a></li>
<li><a href="#H1_Map">Map</a></li>
<li><a href="#H1_Multimap">Multimap</a></li>
</ul>
<li><a href="#H_Adapters">Adapters</a></li>
<ul>
<li><a href="#H_Stack">Stack</a></li>
<li><a href="#H_Queue">Queue</a></li>
<li><a href="#H_Priority%20Queue">Priority Queue</a></li>
</ul>
</ul>
<li><a href="#H_Iterators">Iterators</a></li>
<ul>
<li><a href="#H1_Concepts">Concepts</a></li>
<li><a href="#H_Helpers">Helpers</a></li>
<li><a href="#H1_Adapters">Adapters</a></li>
<ul>
<li><a href="#H_Insert">Insert</a></li>
<li><a href="#H_Move">Move</a></li>
<li><a href="#H_Reverse">Reverse</a></li>
</ul>
</ul>
<li><a href="#H_Ranges">Ranges</a></li>
<ul>
<li><a href="#H2_Concepts">Concepts</a></li>
<li><a href="#H_Owning%20Views">Owning Views</a></li>
<li><a href="#H_Type-erasure">Type-erasure</a></li>
<li><a href="#H_Custom%20Views">Custom Views</a></li>
</ul>
<li><a href="#H_Time">Time</a></li>
<ul>
<li><a href="#H_Timestamps">Timestamps</a></li>
<ul>
<li><a href="#H_Clocks">Clocks</a></li>
<li><a href="#H_Conversions">Conversions</a></li>
</ul>
<li><a href="#H_Durations">Durations</a></li>
<li><a href="#H_Date%20and%20Time">Date and Time</a></li>
</ul>
<li><a href="#H_Numbers">Numbers</a></li>
<ul>
<li><a href="#H_Random%20Numbers">Random Numbers</a></li>
<li><a href="#H_Numeric%20Type%20Information">Numeric Type Information</a></li>
<li><a href="#H_Numeric%20Type%20Casting">Numeric Type Casting</a></li>
<li><a href="#H_Numeric%20String%20Conversion">Numeric String Conversion</a></li>
<li><a href="#H_Math">Math</a></li>
<li><a href="#H_Bit%20Manipulation">Bit Manipulation</a></li>
<li><a href="#H_Bitset">Bitset</a></li>
<li><a href="#H_Safe%20Integer%20Comparison">Safe Integer Comparison</a></li>
</ul>
<li><a href="#H_Strings">Strings</a></li>
<ul>
<li><a href="#H_String">String</a></li>
<li><a href="#H_String%20View">String View</a></li>
<li><a href="#H_Formatter">Formatter</a></li>
<li><a href="#H_Regular%20Expressions">Regular Expressions</a></li>
</ul>
<li><a href="#H_Streams">Streams</a></li>
<ul>
<li><a href="#H1_String">String</a></li>
<li><a href="#H_File">File</a></li>
<li><a href="#H_Global">Global</a></li>
</ul>
<li><a href="#H_Span">Span</a></li>
<li><a href="#H_Debug%20Utilities">Debug Utilities</a></li>
<ul>
<li><a href="#H_Source%20Location">Source Location</a></li>
<li><a href="#H_Object%20Address">Object Address</a></li>
<li><a href="#H_Compile-time%20Evaluation%20Test">Compile-time Evaluation Test</a></li>
</ul>
</ul>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_How%20to%20Read"></a><h1>How to Read</h1>
<p>This document is broken down into sections and sub-sections. To understand a specific section, you need to understand all of its parent sections as well as any prerequisites that it lists. For example, if section <code>Fruits/Apples/Granny Smith</code> has prerequisites <code>Vegetables/Peas</code> and <code>Fish</code> listed, you'll need to have read ...</p>
<ul>
<li><code>Fruits</code> (just that section, not its sub-sections)</li>
<li><code>Fruits/Apples</code> (just that section, not its sub-sections)</li>
<li><code>Vegetables/Peas</code> (that section and including ALL of its sub-sections)</li>
<li><code>Fish</code> (that section including ALL of its sub-sections)</li>
</ul>
<p>This is essentially a tree where each section is a node. To understand a node, you need to understand ...</p>
<ol>
<li>its ancestor nodes <strong>not including</strong> the children of those ancestors (these are the parent sections).</li>
<li>any nodes it links to <strong>as well as</strong> their descendants (these are the sections listed as prerequisites).</li>
</ol>
<a name="H_Essentials"></a><h1>Essentials</h1>
<p><a name="BM_(Essentials)_TOPIC%2F"></a><strong></strong></p>
<p>The following document is my attempt at charting out the various pieces of the modern C++ landscape, focusing on the 80% of features that get used most of the time rather than the 20% of highly esoteric / confusing features. It isn't comprehensive and some of the information may not be entirely correct / may be missing large portions.</p>
<p>The key points of similarity to remember:</p>
<ol>
<li>Scope in C++ is similar to Java/C# (e.g. function scope, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> scope, etc...). Variables, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, etc.. come into and leave out of scopes in similar ways.</li>
<li>Compound statements in C++ are similar Java/C#. They create a scope, and things declared in that scope are gone once the scope is exited.</li>
<li>Control flow statements in C++ are similar to Java/C#. All the basics are there: for loops, for-each loops, while loops, if-else, switch, etc...</li>
<li>Data can exist on the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a> or stack similar to Java/C#.</li>
</ol>
<p>The key point of dissimilarity to remember:</p>
<ol>
<li><strong>C++ does not come with a garbage collector</strong>. You are responsible for releasing memory, although the C++ standard library has a lot of pieces to help with this.</li>
<li>C++ has a lot of legacy baggage and many edge cases. Compared to Java/C#, the language is powerful but also deeply convoluted with many foot-guns and esoteric syntax / semantics.</li>
<li>C++ has a lot of ambiguous behaviour. Compared to Java/C#, the language specifically carves out pieces of the spec and leaves it as platform-specific behaviour, undefined behaviour, etc.. so that <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s have more room to optimize code.</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FInconsistent%20Behaviour)_TOPIC%2F">Core Language/Inconsistent Behaviour</a></li>
</ul>
</div>
<a name="H_Language%20Basics"></a><h2>Language Basics</h2>
<p><a name="BM_(Essentials%5C%2FLanguage%20Basics)_TOPIC%2F"></a><strong></strong></p>
<p>The following are a base set of language constructs required for understanding the rest of the document.</p>
<ol>
<li>
<p>The general purpose integral type is <code>int</code>.</p>
</li>
<li>
<p>Variables use the format <code>modifiers type name initializer</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// parenthesis</span>
<span class="hljs-type">int</span> c {<span class="hljs-number">0</span>}; <span class="hljs-comment">// curly braces</span>
</code></pre>
<p>C++ provides a bewildering number of ways to initialize a variable, each with its own set of edge cases. For best results, stick to the curly braces.</p>
</li>
<li>
<p>Functions use the format <code>modifiers return-type name(param-type1 arg-name1, param-type2 arg-name2, ...) modifiers { body }</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> x + a;
}
</code></pre>
<p>C++ functions don't necessarily have to be <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s (<a href="#BM_%5Cb(member)%2Fi">member</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
</li>
<li>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a>es use either <code>struct</code> or <code>class</code>.</p>
<p><code>struct</code> makes all <a href="#BM_%5Cb(member)%2Fi">member</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> public by default, while <code>class</code> makes them all private by default. <a href="#BM_%5Cb(member)%2Fi">Member</a>s need to be grouped together by visibility, where a visibility (e.g. <code>private</code>) is a label within the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
      <span class="hljs-keyword">return</span> x + a;
   }
<span class="hljs-keyword">private</span>: <span class="hljs-comment">// everything under this label is private</span>
   <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};
</code></pre>
</li>
<li>
<p>Source code often comes in pairs: A header file usually contains declarations (e.g. just the function's signature / prototype) while a C++ file usually contains definitions (e.g. the function implementation).</p>
<pre class="hljs"><code><span class="hljs-comment">// MyCode.hpp (header file w/ declarations)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-comment">// MyCode.cpp (source file w/ definitions)</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyCode.hpp"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> x + a;
}
</code></pre>
<p>This isn't required. Source files may contain declarations and / or header files may contain definitions, but the split is typically done for a variety of reasons: faster compile times, sharing the same <a href="#BM_(object%7Cinstance)%2Fi">object</a> across multiple source files, compiling when there are cyclical <a href="#BM_(reference)%2Fi">reference</a>s, etc..</p>
</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The above points aren't entirely correct or complete. They're generalizations that help set up a base for the explanations in the rest of the document.</p>
</div>
<p>The following is an example C++ program that prints "hello world" to stdout.</p>
<pre class="hljs"><code><span class="hljs-comment">// hello.cpp file</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"hello world\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The ...</p>
<ul>
<li><code>#include &lt;iostream&gt;</code> pulls in a library that lets you interface with stdout, stderr, and stdin.</li>
<li><code>int main() { ... }</code> is the entry point of the program.</li>
<li><code>std:cout &lt;&lt; ...</code> is what prints to stdout.</li>
<li><code>return 0</code> returns from the <code>main()</code> function, ending the program with an exit code of 0.</li>
</ul>
<p>Pretty much any modern C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will compile the above code. The output below uses the GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to compile the example, then runs the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<pre><code>$ g++ hello.cpp
$ ./a.out
hello world
</code></pre>
<a name="H_Compilation%20Basics"></a><h2>Compilation Basics</h2>
<p><a name="BM_(Essentials%5C%2FCompilation%20Basics)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Essentials%5C%2FLanguage%20Basics)_TOPIC%2F">Essentials/Language Basics</a></li>
</ul>
</div>
<p>Several C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s exist, the most popular of which are the GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> and LLVM clang. C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s generally follow the same set of steps to go from C++ code to an <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<ol>
<li>C++ source files get fed into a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> to generate <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s. A <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> is the C++ source file after going through modifications based on <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specifics, platform specifics, libraries used, compile options / library options, etc..</li>
<li><a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">Translation unit</a> files get fed into a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s. An <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a> is the intermediary compiled form of each individual <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</li>
<li><a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Object file</a>s get fed into a <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> to generate the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>. All <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s come together and linkages between them are made to form the final <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</li>
</ol>
<p><img src="svgbob_80c99337d0ee9d0afb6fdd8cc113d933be8d1ce9.svg" alt="Kroki diagram output"></p>
<p>The C++ language has a lot of legacy baggage, edge cases, and ambiguous behaviour. Regardless of the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> chosen, at least some of the following warning options should be enabled:</p>
<ul>
<li><code>-Wall</code> - Warns about questionable but easily avoidable constructs.</li>
<li><code>-Wextra</code> - Warns about other questionable constructs not covered by <code>-Wall</code>.</li>
<li><code>-Wpedantic</code> - Warns about ISO conformance.</li>
<li><code>-Weverything</code> - Turns on all warnings.</li>
</ul>
<p>Most <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s support some or all of the flags above.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>A good online tool to try things in is <a href="https://cppinsights.io/">cppinsights</a>, which breaks down C++ code and allows you some visibility into what the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is doing / what the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> sees.</p>
</div>
<a name="H_Header%20Files"></a><h2>Header Files</h2>
<p><a name="BM_(Essentials%5C%2FHeader%20Files)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Essentials%5C%2FLanguage%20Basics)_TOPIC%2F">Essentials/Language Basics</a></li>
<li><a href="#BM_(Essentials%5C%2FCompilation%20Basics)_TOPIC%2F">Essentials/Compilation Basics</a></li>
</ul>
</div>
<p>For each source code file that gets compiled, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> needs to know that the entities (variables, functions, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, etc..) accessed within that file actually exist. The scope at which the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> keeps track of these entities is per source code file. For example, imagine a source code file that defines a function named <code>myFunction</code> (definition). There are 5 other source code files that call <code>myFunction</code> at some point. Each of those 5 other files is required to tell the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> what <code>myFunction</code> is (declaration) before it can invoke it.</p>
<p>One way to handle this scenario is to put <code>myFunction</code>'s declaration in each source code file that calls it.</p>
<pre class="hljs"><code><span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;
</code></pre>
<p>The problem with doing this is that ...</p>
<ol>
<li>you're duplicating something 5 times, meaning you need to update 5 different places should anything change with the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</li>
<li>you need a declaration for more than just <code>myFunction</code> (e.g. <code>myFunction</code> requires <code>OtherClass</code>, which may require even more entities).</li>
<li>as a result of 1 and 2, source code file sizes explode and quickly become unmanageable.</li>
</ol>
<p>The preferred way to handle this scenario is to put <code>myFunction</code>'s declaration into a header file. Then, any file that needs to know about <code>myFunction</code> can use the <code>#include</code> directive.,,</p>
<pre class="hljs"><code><span class="hljs-comment">// MyFunction.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span></span>
<span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-comment">// UsageFile1.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyFunction.hpp"</span></span>
<span class="hljs-built_in">myFunction</span>(<span class="hljs-number">44</span>);
</code></pre>
<p>If an entity is declared once already by an <code>#include</code>, it shouldn't be declared again.  For example, imagine that the file <code>Main.cpp</code> includes <code>ParentA.hpp</code> and <code>ParentB.hpp</code>. Both <code>ParentA.hpp</code> and <code>ParentB.hpp</code> then go on to include <code>Child.hpp</code>....</p>
<p><img src="svgbob_b33513cc90f4ec659ecb36587de9b266289fe213.svg" alt="Kroki diagram output"></p>
<p>The problem the above example scenario creates is that <code>Child.hpp</code> gets <code>#include</code>'d twice, meaning that everything in it is declared twice. To mitigate this problem, an include guard is typically provided in each header file.</p>
<pre class="hljs"><code><span class="hljs-comment">// MyFunction.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_FUNCTION_H <span class="hljs-comment">// include guard</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_FUNCTION_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span></span>
<span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>#ifdef</code>, <code>#define</code>, and <code>#endif</code> are <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros that aren't covered here. Look them up online if you need to.</p>
</div>
<p>You may notice that sometimes <code>#include</code> puts quotes around the files and sometimes angle brackets. Use quotes when the files are in the same directory structure, angle brackets when the files are coming from some external library.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>          <span class="hljs-comment">// library header</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span>  <span class="hljs-comment">// local header</span></span>
</code></pre>
<a name="H_Development%20Environment"></a><h2>Development Environment</h2>
<p><a name="BM_(Essentials%5C%2FDevelopment%20Environment)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Essentials%5C%2FCompilation%20Basics)_TOPIC%2F">Essentials/Compilation Basics</a></li>
</ul>
</div>
<p>There are many different <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s, IDEs, build systems, and dependency managers for C++.</p>
<p>Common <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s:</p>
<ul>
<li>GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a></li>
<li>LLVM Clang</li>
<li>Microsoft Visual C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a></li>
</ul>
<p>Common IDEs:</p>
<ul>
<li>Visual Studio Code (open-source, multi-platform), commonly referred to as vscode</li>
<li>Visual Studio C++ (proprietary, Windows only)</li>
<li>CLion (proprietary, multi-platform)</li>
<li>KDevelop  (open-source, multi-platform)</li>
</ul>
<p>Common build systems:</p>
<ul>
<li>Make</li>
<li>Automake / Autoconf / Autotools</li>
<li>CMake</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>CMake isn't a build system itself, but a tool that generates the configuration needed for build systems. The idea is that, since C++ code can be compiled on many different platforms and build systems, this high-level tool can be used to generate the configuration for those build systems. For example, building on Linux is commonly done using Make while on Windows it's commonly done through Microsoft Visual Studio IDE project files. CMake can configure both using the same CMake script.</p>
</div>
<p>Common dependency managers:</p>
<ul>
<li>Conan</li>
<li>Vcpkg</li>
<li>Spack</li>
</ul>
<p>Of the tools above, the best mixture I've found so far is to use ...</p>
<ol>
<li>LLVM Clang as the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (installable via apt -- <code>apt install clang-12</code>)</li>
<li>Visual Studio Code as the editor (installable via snap -- <code>snap install --classic code</code>)</li>
<li>CMake as the build system  (installable via apt -- <code>apt install cmake</code>)</li>
<li>Conan as the dependency manager (install deb file from website)</li>
<li>C++ extension pack for vscode (install via extension section of vscode)</li>
<li>LLVM clangd extension for vscode (install via extension section of vscode)</li>
<li>C-Mantic extension for vscode (install via extension section of vscode)</li>
</ol>
<p>There are basic guides / tutorials for each of these tools available online. With the C++ extensions (5, 6, and 7), vscode (3) works similar to a professional IDE. It will parse a CMake configuration (3) to figure out how the code should be built as well as to provide C++ intellisense / auto-complete / formatting / debugging / etc.. support. Conan (4) integrates with CMake, so intellisense and builds through vscode automatically include the libraries.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Make sure to turn off the C++ extension's intellisense support or else it'll interfere with clangd's superior intellisense support. You can do this by adding the following to your <code>.vscode/settings.json file</code>...</p>
<pre class="hljs"><code><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"C_Cpp.intelliSenseEngine"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Disabled"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"C_Cpp.autocomplete"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Disabled"</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// So you don't get autocomplete from both extensions.</span>
    <span class="hljs-attr">"C_Cpp.errorSquiggles"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Disabled"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// So you don't get error squiggles from both extensions (clangd's seem to be more reliable anyway).</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Make sure that you don't have other C++ extensions installed. I'd initially installed a Makefile plugin into vscode that was tripping up the CMake plugin and breaking my intellisense.</p>
</div>
<p>Assuming you have all the software above installed, <a href="my_cpp_template.tar.xz">this cookie cutter template</a> can be used to set up a simple project structure that you can open directly in vscode. The <a href="#BM_(template)%2Fi">template</a> primes the project by ...</p>
<ol>
<li>creating a main source folder (<code>src/main</code>).</li>
<li>creating a test source folder (<code>src/test</code>).</li>
<li>setting Conan to download POCO C++ Libraries and Google Test.</li>
<li>setting CMake and Conan to use LLVM Clang 12.</li>
<li>setting CMake to build using C++20.</li>
<li>setting CMake to integrate with Conan.</li>
<li>setting CMake to recursive glob compile.</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I keep reading that globs aren't recommended in CMake. If you don't use globs, you'll have to go in and manually add in each source file into the CMake configuration.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Recall that ...</p>
<ul>
<li>vscode will automatically reconfigure CMake on any change to the configuration file.</li>
<li>vscode will build your code when you hit F7.</li>
</ul>
<p>Conan changes ARE NOT automatically picked up. You need to re-run conan (from <code>./build</code> -- see the cookie cutter <a href="#BM_(template)%2Fi">template</a> post hook) to pick up any library changes.</p>
</div>
<a name="H_Core%20Language"></a><h1>Core Language</h1>
<p><a name="BM_(Core%20Language)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Essentials)_TOPIC%2F">Essentials</a></li>
</ul>
</div>
<p>The following subsection loosely details core C++ language features. It isn't comprehensive and some of the information may not be entirely correct / may be missing large portions.</p>
<a name="H_Operators"></a><h2>Operators</h2>
<p><a name="BM_(Core%20Language%5C%2FOperators)_TOPIC%2F"></a><strong></strong></p>
<p>The following is a list of operators available in C++. Some operators are obvious, while others are explained in other sections.</p>
<p><strong>Bitwise Logical Operators</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitwise AND         (<code>&amp;</code>)</td>
<td><code>0b1011 &amp; 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise OR          (<code>|</code>)</td>
<td><code>0b1011 | 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise XOR         (<code>^</code>)</td>
<td><code>0b1011 ^ 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise NOT         (<code>~</code>)</td>
<td><code>~0b1011</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise left-shift  (<code>&lt;&lt;</code>)</td>
<td><code>0b1011 &lt;&lt; 2</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise right-shift (<code>&gt;&gt;</code>)</td>
<td><code>0b1011 &gt;&gt; 2</code></td>
<td>Results on signed may be different than unsigned.</td>
</tr>
</tbody>
</table>
<p><strong>Boolean Logical Operators</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logical AND (<code>&amp;&amp;</code>)</td>
<td><code>true &amp;&amp; true</code></td>
<td></td>
</tr>
<tr>
<td>Logical OR  (<code>||</code>)</td>
<td><code>true || false</code></td>
<td></td>
</tr>
<tr>
<td>Logical NOT (<code>!</code>)</td>
<td><code>!true</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Arithmetic Operators</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unary Plus      (<code>+</code>)</td>
<td><code>+10</code></td>
<td></td>
</tr>
<tr>
<td>Unary Minus     (<code>-</code>)</td>
<td><code>-10</code></td>
<td></td>
</tr>
<tr>
<td>Addition        (<code>+</code>)</td>
<td><code>1 + 2</code></td>
<td></td>
</tr>
<tr>
<td>Subtraction     (<code>-</code>)</td>
<td><code>2 - 1</code></td>
<td></td>
</tr>
<tr>
<td>Multiplication  (<code>*</code>)</td>
<td><code>2 * 3</code></td>
<td></td>
</tr>
<tr>
<td>Division        (<code>/</code>)</td>
<td><code>6 / 2</code></td>
<td></td>
</tr>
<tr>
<td>Modulo          (<code>%</code>)</td>
<td><code>6 % 4</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>There are implicit rules for how <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>s get promoted. The general rule of thumb is that the result of the operator is promoted to the operand with the "greater" type. For example, if an <code>int</code> is added to a <code>float</code>, the result will be a <code>float</code>.</p>
<p>These rules are similar to those in other languages (e.g. Java and Python).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>If confused, use type deduction via the <code>auto</code> keyword: <code>auto x {5 + y}</code>, then check to see what the type of <code>y</code> is in the IDE or using <code>typeid</code>.</p>
</div>
<p><strong>Assignment Operators</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Assignment                     (<code>=</code>)</td>
<td><code>x = 5</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise AND         (<code>&amp;=</code>)</td>
<td><code>x &amp;= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise OR          (<code>|=</code>)</td>
<td><code>x |= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise XOR         (<code>^=</code>)</td>
<td><code>x ^= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise left-shift  (<code>&lt;&lt;=</code>)</td>
<td><code>x &lt;&lt;= 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise right-shift (<code>&gt;&gt;=</code>)</td>
<td><code>x &gt;&gt;= 2</code></td>
<td>Result  on signed may be different than unsigned.</td>
</tr>
<tr>
<td>Assignment Addition            (<code>+=</code>)</td>
<td><code>x += 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Subtraction         (<code>-=</code>)</td>
<td><code>x -= 1</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Multiplication      (<code>*=</code>)</td>
<td><code>x *= 3</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Division            (<code>/=</code>)</td>
<td><code>x /= 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Modulo              (<code>%=</code>)</td>
<td><code>x %= 4</code></td>
<td></td>
</tr>
<tr>
<td>Increment                      (<code>++</code>)</td>
<td><code>x++</code></td>
<td>Applicable BEFORE or AFTER the operand: <code>++x</code> returns the value AFTER modification, <code>x++</code> returns the value BEFORE modification.</td>
</tr>
<tr>
<td>Decrement                      (<code>--</code>)</td>
<td><code>x--</code></td>
<td>Applicable BEFORE or AFTER the operand: <code>--x</code> returns the value AFTER modification, <code>x--</code> returns the value BEFORE modification.</td>
</tr>
</tbody>
</table>
<p>All assignment operators work similar to those in Java except for the increment and decrement operators. Due to the confusion it causes, Java disallows the increment / decrement from returning a value, meaning that it can't be used in an expression. Not so in C++. In addition to modifying the variable passed as the operand, in C++ these operators also return a result, meaning that it's okay to increment / decrement operator within some larger expression.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> y {(x++) + <span class="hljs-number">2</span>};
<span class="hljs-comment">// at this point, x is 4, y is 5</span>
<span class="hljs-type">int</span> a {<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> b {(++a) + <span class="hljs-number">2</span>};
<span class="hljs-comment">// at this point, a is 4, b is 6</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>You probably shouldn't do this because it gets confusing. Also, incrementing/decrementing the same variable more than once in the same expression isn't defined behaviour: The order of  incrementing/decrementing can change based on whatever the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> thinks is best, meaning that the results won't be consistent across different platforms / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> options / etc...</p>
</div>
<p><strong>Comparison Operator</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equal To                 (<code>==</code>)</td>
<td><code>5 == 7</code></td>
<td></td>
</tr>
<tr>
<td>Not Equal To             (<code>!=</code>)</td>
<td><code>5 != 7</code></td>
<td></td>
</tr>
<tr>
<td>Less Than                (<code>&lt;</code>)</td>
<td><code>5 &lt; 7</code></td>
<td></td>
</tr>
<tr>
<td>Less Than Or Equal To    (<code>&lt;=</code>)</td>
<td><code>5 &lt;= 7</code></td>
<td></td>
</tr>
<tr>
<td>Greater Than             (<code>&gt;</code>)</td>
<td><code>5 &gt; 7</code></td>
<td></td>
</tr>
<tr>
<td>Greater Than Or Equal To (<code>&gt;=</code>)</td>
<td><code>5 &gt;= 7</code></td>
<td></td>
</tr>
<tr>
<td>Three-way Comparison     (<code>&lt;=&gt;</code>)</td>
<td><code>5 &lt;=&gt; 7</code></td>
<td>Returns a special ordering type, not boolean (discussed in <a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a> section).</td>
</tr>
</tbody>
</table>
<p>In addition, the ternary conditional operator is a pseudo operator that takes in 3 operands similar to those found in other high-level languages: <code>CONDITION ? EXPRESSION_IF_TRUE : EXPRESSION_IF_FALSE</code>. It's essentially a shorthand if-else block.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {n % <span class="hljs-number">7</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">1000</span> : <span class="hljs-number">-1000</span>};
<span class="hljs-comment">// equiv to...</span>
<span class="hljs-keyword">if</span> (n % <span class="hljs-number">7</span> == <span class="hljs-number">1</span>) {
    x = <span class="hljs-number">1000</span>;
} <span class="hljs-keyword">else</span> {
    x = <span class="hljs-number">-1000</span>;
}
</code></pre>
<p><strong><a href="#BM_%5Cb(member)%2Fi">Member</a> Access Operators</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Subscript         (<code>[]</code>)</td>
<td><code>x[0]</code></td>
<td></td>
</tr>
<tr>
<td>Indirection       (<code>*</code>)</td>
<td><code>*x</code></td>
<td>Doesn't conflict with arithmetic multiplication operator because this is a unary operator.</td>
</tr>
<tr>
<td><a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">Address Of</a>        (<code>&amp;</code>)</td>
<td><code>&amp;x</code></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi">Member Of Object</a>  (<code>.</code>)</td>
<td><code>x.member</code></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">Member Of Pointer</a> (<code>-&gt;</code>)</td>
<td><code>x-&gt;member</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>These operators are used in scenarios that deal with accessing the <a href="#BM_%5Cb(member)%2Fi">member</a>s of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. element in an array, <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) or dealing with memory addresses / <a href="#BM_(pointer)%2Fi">pointer</a>s. The subscript and and <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi">member of object</a> operators are similar to their counterparts in other high-level languages (e.g. Java, Python, C#, etc..). The others are unique to languages with support for lower-level programming like C++. Their usage is detailed in other sections.</p>
<p><strong><a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a> Operators</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a>       (<code>new</code>)</td>
<td><code>new int</code></td>
<td></td>
</tr>
<tr>
<td>Create <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Array</a>      (<code>new[]</code>)</td>
<td><code>new int[50]</code></td>
<td></td>
</tr>
<tr>
<td>Destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a>   (<code>delete</code>)</td>
<td><code>delete x</code></td>
<td></td>
</tr>
<tr>
<td>Destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Array</a>  (<code>delete[]</code>)</td>
<td><code>delete[] x</code></td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>If you already know about <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s and arrays and <a href="#BM_(constructor)%2Fi">constructor</a>s/<a href="#BM_(destructor)%2Fi">destructor</a>s, make sure you delete an array using <code>delete[]</code>. It makes sure to call the <a href="#BM_(destructor)%2Fi">destructor</a> for each element of the array.</p>
</div>
<p><strong>Size Operator</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>example</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size (<code>sizeof</code>)</td>
<td><code>sizeof x]</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>This operator gets the size of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> in bytes. Note that an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s byte size may not be indicative of the da may include padding required by the platform (e.g. an <a href="#BM_(object%7Cinstance)%2Fi">object</a> requiring 5 bytes may get expanded to 8 bytes because the platform requires 8 byte boundary alignments).</p>
<p><strong>Other Operators</strong></p>
<p>C++ provides a set of other operators such as the ...</p>
<ul>
<li>comma operator (<code>,</code>).</li>
<li><a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a> (<code>()</code>).</li>
<li>conversion operator (e.g. casting).</li>
<li><a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a> operator (e.g. <code>_</code>)</li>
</ul>
<p>While it isn't worth going into them in detail here, the reason the language explicitly lists them as operators is because they're <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>-able (e.g. <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing). <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">Overload</a>ing these operators is heavily discouraged since doing so causes confusion.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions the comma operator specifically. It doesn't look like this is used for much and the book recommends against using it for anything (e.g. <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing) due to the confusion it causes. This gives off similar vibes to Python's tuple syntax, where you can pass an unenclosed tuple as a subscript to something. When I was learning Python, that also came off as very confusing.</p>
<pre class="hljs"><code>x = obj[<span class="hljs-string">'column name'</span>, <span class="hljs-number">100</span>]
</code></pre>
</div>
<a name="H_Variables"></a><h2>Variables</h2>
<p><a name="BM_(Core%20Language%5C%2FVariables)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FOperators)_TOPIC%2F">Core Language/Operators</a>: Just basic ones like comparison and arithmetic.</li>
</ul>
</div>
<p>C++ variable declarations have the following form: <code>modifiers type name initializer</code>.</p>
<ul>
<li>
<p><strong>type</strong> (required) - Type of variable.</p>
</li>
<li>
<p><strong>name</strong>: (required) - Name of variable.</p>
</li>
<li>
<p><strong>initializer</strong>: (optional) - Initia<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> to assign (<a href="#BM_(object%20initialization)%2Fi">object initialization</a>).</p>
<p>There are multiple ways to initialize a variable, each with their own advantages and disadvantages.</p>
<ul>
<li><a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> / <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">uniform initialization</a>: braces used for initialization (e.g. <code>int x {a + b}</code>).</li>
<li><a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a>: equals sign used for initialization (e.g. <code>int x = 5</code>).</li>
<li><a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>: equals sign and braces used for initialization (e.g. <code>int x = { a + b }</code>).</li>
<li>etc..</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The above is an over-simplification. The ways to initialize are vast and complex. See <a href="https://en.cppreference.com/w/cpp/language/initialization">here</a> for a full accounting and <a href="https://youtu.be/7DTlWPgX6zs">here</a> for an hour long talk about the edge cases.</p>
<p>It seems like the safest bet is to always use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">brace initialization</a> where possible. Just use the braces as if they were parentheses or braces in Java (specific to the context). The others have surprising behaviour (e.g. they won't warn about <a href="#BM_(narrowing%20conversion)%2Fi">narrowing conversion</a>s).</p>
</div>
</li>
<li>
<p><strong><a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a variable.</p>
<p>(e.g. <code>const</code>, <code>volatile</code>, <code>constexpr</code>, <code>inline</code>, ...)</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">int</span> a;     <span class="hljs-comment">// no initializer -- garbage possibly contained at memory location</span>
<span class="hljs-type">int</span> b {};  <span class="hljs-comment">// empty initializer -- zeros out the memory for the int</span>
<span class="hljs-type">int</span> c {<span class="hljs-number">0</span>}; <span class="hljs-comment">// assign to constant 0</span>
<span class="hljs-type">int</span> d {c}; <span class="hljs-comment">// assign to value in c</span>
</code></pre>
<p>In C++, variables that are <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s (assigned to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) are called <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s. This section deals with non-<a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s (e.g. scoped somewhere other than a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> -- global, inside a function, etc..).</p>
<a name="H_Core%20Types"></a><h3>Core Types</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FOperators)_TOPIC%2F">Core Language/Operators</a> (just the basics like comparison and arithmetic)</li>
</ul>
</div>
<p>The following sections list out core C++ types and their analogs. These include numeric types, character types, and string types.</p>
<a name="H_Integral"></a><h4>Integral</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FIntegral)_TOPIC%2F"></a><strong></strong></p>
<p>C++'s core integer types are as follows...</p>
<ol>
<li><code>short int</code></li>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ol>
<p>The above integer types come in two forms: signed and unsigned. The range of ...</p>
<ul>
<li>unsigned integers start at 0 and end at a positive integer.</li>
<li>signed integers start at a negative integer and positive integer.</li>
</ul>
<p>By default, the integer types above are signed (speculation). Signed-ness can be explicitly stated by prefixing either <code>signed</code> or <code>unsigned</code> to the type, but if the type is signed the prefix is usually omitted.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short int</code>     / <code>signed short int</code></td>
<td><code>unsigned short int</code></td>
</tr>
<tr>
<td><code>int</code>           / <code>signed int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>long int</code>      / <code>signed long int</code></td>
<td><code>unsigned long int</code></td>
</tr>
<tr>
<td><code>long long int</code> / <code>signed long long int</code></td>
<td><code>unsigned long long int</code></td>
</tr>
</tbody>
</table>
<p>Integer types <code>char int</code>, <code>short int</code>, <code>long int</code>, and <code>long long int</code> can optionally omit the <code>int</code> keyword.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short</code>     / <code>signed short</code></td>
<td><code>unsigned short</code></td>
</tr>
<tr>
<td><code>int</code>       / <code>signed int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>long</code>      / <code>signed long</code></td>
<td><code>unsigned long</code></td>
</tr>
<tr>
<td><code>long long</code> / <code>signed long long</code></td>
<td><code>unsigned long long</code></td>
</tr>
</tbody>
</table>
<p>The only guarantees for core integer types are that ...</p>
<ul>
<li>each integer type tier must be able to cover the same range as the tier before it (e.g. range of <code>short</code> &gt;= range of <code>int</code>).</li>
<li>unsigned integer types start at 0.</li>
<li>unsigned integer types overflow behaviour is to wrap to 0.</li>
</ul>
<p>All other specifics are platform-dependent. Specifically, ...</p>
<ul>
<li>range is undefined.</li>
<li>bit length is undefined (e.g. 8, 16, etc..).</li>
<li>endian-ness is undefined (e.g. big-endian vs little-endian).</li>
<li>encoding scheme of <em>signed</em> types is two's complement (as of C++20), but underflow/overflow behaviour of <em>signed</em> types is undefined (e.g. crash, stay at boundary, wrap back around, etc..).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FNumbers%2FBit%20Manipulation)_TOPIC%2F">Library Functions/Numbers/Bit Manipulation</a> (determine endian-ness of scalar types via <code>std::endian</code>)</li>
</ul>
</div>
<p>Integer ranges, although platform-specific, are queryable in the climits header.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>min</th>
<th>max</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed short</code></td>
<td><code>SHRT_MIN</code></td>
<td><code>SHRT_MAX</code></td>
</tr>
<tr>
<td><code>signed int</code></td>
<td><code>INT_MIN</code></td>
<td><code>INT_MAX</code></td>
</tr>
<tr>
<td><code>signed long</code></td>
<td><code>LONG_MIN</code></td>
<td><code>LONG_MAX</code></td>
</tr>
<tr>
<td><code>signed long long</code></td>
<td><code>LLONG_MIN</code></td>
<td><code>LLONG_MAX</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td><code>0</code></td>
<td><code>USHRT_MAX</code></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td><code>0</code></td>
<td><code>UINT_MAX</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td><code>0</code></td>
<td><code>ULONG_MAX</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td><code>0</code></td>
<td><code>ULLONG_MAX</code></td>
</tr>
</tbody>
</table>
<p>By default, literals are represented using base10. Literals may be presented in different bases via the prefix.</p>
<table>
<thead>
<tr>
<th>base</th>
<th>literal prefix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 (binary)</td>
<td>0b</td>
<td><code>0b1111</code></td>
</tr>
<tr>
<td>8 (octal)</td>
<td>0</td>
<td><code>016</code></td>
</tr>
<tr>
<td>10 (decimal)</td>
<td></td>
<td><code>15</code></td>
</tr>
<tr>
<td>16 (hex)</td>
<td>0x</td>
<td><code>0xF</code></td>
</tr>
</tbody>
</table>
<p>Integer literals are targeted to specific integer types by their suffix.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>literal suffix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed short</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>signed int</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>signed long</code></td>
<td>L</td>
<td><code>2L</code></td>
</tr>
<tr>
<td><code>signed long long</code></td>
<td>LL</td>
<td><code>2LL</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>U</td>
<td><code>2U</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>UL</td>
<td><code>2UL</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td>ULL</td>
<td><code>2ULL</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Notice that <code>int</code>, <code>short</code>, and <code>unsigned short</code> don't have explicit suffixes. If no suffix is present, it's an int (speculation). To get it to a short, the easiest way is to cast it: <code>static_cast&lt;short&gt;(2)</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FNumbers%2FNumeric%20Type%20Information)_TOPIC%2F">Library Functions/Numbers/Numeric Type Information</a> (determine min, max, and other properties of a numeric type)</li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion)_TOPIC%2F">Core Language/Variables/Explicit Conversion</a> (casting)</li>
<li><a href="#BM_(Library%20Functions%5C%2FNumbers%2FNumeric%20Type%20Casting)_TOPIC%2F">Library Functions/Numbers/Numeric Type Casting</a> (cast one numeric type to another)</li>
</ul>
</div>
<p>Integer types with standardized bit lengths are defined in the cstdlib header.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>intmax_t</code></td>
<td><code>uintmax_t</code></td>
<td>widest possible bit length</td>
</tr>
<tr>
<td><code>int8_t</code></td>
<td><code>uint8_t</code></td>
<td>exactly 8 bits</td>
</tr>
<tr>
<td><code>int16_t</code></td>
<td><code>uint16_t</code></td>
<td>exactly 16 bits</td>
</tr>
<tr>
<td><code>int32_t</code></td>
<td><code>uint32_t</code></td>
<td>exactly 32 bits</td>
</tr>
<tr>
<td><code>int64_t</code></td>
<td><code>uint64_t</code></td>
<td>exactly 64 bits</td>
</tr>
<tr>
<td><code>int_least8_t</code></td>
<td><code>uint_least8_t</code></td>
<td>8 bits  or greater</td>
</tr>
<tr>
<td><code>int_least16_t</code></td>
<td><code>uint_least16_t</code></td>
<td>16 bits or greater</td>
</tr>
<tr>
<td><code>int_least32_t</code></td>
<td><code>uint_least32_t</code></td>
<td>32 bits or greater</td>
</tr>
<tr>
<td><code>int_least64_t</code></td>
<td><code>uint_least64_t</code></td>
<td>64 bits or greater</td>
</tr>
<tr>
<td><code>int_fast8_t</code></td>
<td><code>uint_fast8_t</code></td>
<td>8 bits  or greater</td>
</tr>
<tr>
<td><code>int_fast16_t</code></td>
<td><code>uint_fast16_t</code></td>
<td>16 bits or greater</td>
</tr>
<tr>
<td><code>int_fast32_t</code></td>
<td><code>uint_fast32_t</code></td>
<td>32 bits or greater</td>
</tr>
<tr>
<td><code>int_fast64_t</code></td>
<td><code>uint_fast64_t</code></td>
<td>64 bits or greater</td>
</tr>
<tr>
<td><code>intptr_t</code></td>
<td><code>uintptr_t</code></td>
<td>wide enough to hold a void *</td>
</tr>
<tr>
<td></td>
<td><code>size_t</code></td>
<td>wide enough to hold the maximum number of bytes of something in memory</td>
</tr>
</tbody>
</table>
<p>The minimum and maximum extents of each type are defined in <code>{TYPE}_MIN</code> and <code>{TYPE}_MAX</code>, where <code>{TYPE}</code> doesn't include the <code>_t</code> suffix. For example the maximum value an <code>uint64_t</code> can be is <code>UINT64_MAX</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Not all types guaranteed to be present (e.g. 64-bit types may be missing if the platform can't support it). Unsigned types don't have a minimum extent defined because a minimum of any unsigned integer type is always 0 (e.g. uint64_t can't go any lower than 0).</p>
</div>
<p>To expand any integer <strong>literal</strong> to a ...</p>
<ul>
<li><code>intmax_t</code>, use the macro <code>INTMAX_C(...)</code>.</li>
<li><code>uintmax_t</code>, use the macro <code>UINTMAX_C(...)</code>.</li>
<li><code>int{N}_t</code>, use the macro <code>INT{N}_C(...)</code> (where <code>{N}</code> is the bit length).</li>
<li><code>uint{N}_t</code>, use the macro <code>UINT{N}_C(...)</code> (where <code>{N}</code> is the bit length).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There is no macro <code>SIZE_C(...)</code> for <code>size_t</code>. Best to just assign a `size_t to one of the other types's literals and hope the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warns about any <a href="#BM_(narrowing%20conversion)%2Fi">narrowing conversion</a>s that might happen.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>What's the point of the above? You don't know what internal integer type each standardized type maps to. For example, <code>uint64_t</code> may map to <code>unsigned long long</code>, which means when you want to assign a literal to a variable of that type you need to add a <code>ULL</code> suffix...</p>
<p><code>uint64_t test {9999999999999999999ULL}</code></p>
<p>The macros above make it so that you don't need to know the underlying mapping...</p>
<p><code>uint64_t test {UINT64_C(9999999999999999999)}</code></p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<a name="H_Floating%20Point"></a><h4>Floating Point</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FFloating%20Point)_TOPIC%2F"></a><strong></strong></p>
<p>C++'s core floating point types are as follows...</p>
<table>
<thead>
<tr>
<th>type</th>
<th>description</th>
<th>literal suffix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td>single precision</td>
<td><code>f</code></td>
<td><code>123.0f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>double precision</td>
<td></td>
<td><code>123.0</code></td>
</tr>
<tr>
<td><code>long double</code></td>
<td><a href="#BM_(extends%3F%7Csubclass)%2Fi">extend</a>ed precision</td>
<td><code>L</code></td>
<td><code>123.0L</code></td>
</tr>
</tbody>
</table>
<p>The specifics of each type are platform-dependent. The only guarantee is that each type has to hold at least the same range as the type before it (e.g. <code>double</code>'s range should cover <code>float</code>'s range). Other than that, ...</p>
<ul>
<li>rounding mode is undefined.</li>
<li>exponent bit length is undefined.</li>
<li>mantissa bit length is undefined.</li>
<li>subnormal number support is undefined.</li>
</ul>
<p>Floating point characteristics, although platform-specific, are queryable in the cfloat header.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>min</th>
<th>max</th>
<th>min exponent</th>
<th>max exponent</th>
<th>mantissa digits</th>
<th>radix</th>
<th>epsilon</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td><code>FLT_MIN</code></td>
<td><code>FLT_MAX</code></td>
<td><code>FLT_MIN_EXP</code></td>
<td><code>FLT_MAX_EXP</code></td>
<td><code>FLT_MANT_DIG</code></td>
<td><code>FLT_RADIX</code></td>
<td><code>FLT_EPSILON</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>DBL_MIN</code></td>
<td><code>DBL_MAX</code></td>
<td><code>DBL_MIN_EXP</code></td>
<td><code>DBL_MAX_EXP</code></td>
<td><code>DBL_MANT_DIG</code></td>
<td><code>DBL_RADIX</code></td>
<td><code>DBL_EPSILON</code></td>
</tr>
<tr>
<td><code>long double</code></td>
<td><code>LDBL_MIN</code></td>
<td><code>LDBL_MAX</code></td>
<td><code>LDBL_MIN_EXP</code></td>
<td><code>LDBL_MAX_EXP</code></td>
<td><code>LDBL_MANT_DIG</code></td>
<td><code>LDBL_RADIX</code></td>
<td><code>LDBL_EPSILON</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Mantissa digits is the number of digits (of the base specified in radix) that the floating point type uses (speculation).</p>
<p>Epsilon is the difference between 1 and the floating point number just before 1.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The <a href="#BM_(sizeof)%2Fi">sizeof</a> operator should NOT be used to infer limits / characteristics of a floating point type. For example, a <code>sizeof(long double)</code> 16 doesn't necessarily mean that the type is a quadruple precision float (128-bit). Rather, it's likely that the floating point type has less precision but the platform requires padding.</p>
</div>
<p>The rounding behaviour of all floating point types is queryable via <code>FLT_ROUNDS</code>, where a ...</p>
<ul>
<li>-1 means undetermined.</li>
<li>0 means toward zero.</li>
<li>1 means toward whichever is nearest.</li>
<li>2 means toward positive infinity.</li>
<li>3 means toward negative infinity.</li>
</ul>
<p>The floating point evaluation behaviour is queryable via <code>FLT_EVAL_METHOD</code>, where a ...</p>
<ul>
<li>-1 means undetermined.</li>
<li>0 means evaluate just to the range and precision of the type.</li>
<li>1 means evaluate float and double as double, and long double as long double.</li>
<li>2 means evaluate all as long double</li>
<li>negative value other than -1 means platform-specific behavior.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Unsure about the last point. How's the last point any different than -1?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I see online that <code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code>, and <code>DECIMAL_DIG</code> define the number of "decimal digits" that can be converted to floating point and back without a loss in precision. I'm assuming that just means the max number of digits that can be represented in a float where exp is 1?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits header. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<a name="H_Character%20String"></a><h4>Character String</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FCharacter%20String)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FIntegral)_TOPIC%2F">Core Language/Variables/Core Types/Integral</a></li>
</ul>
</div>
<p>Core C++ strings are represented as an array of characters, where that array ends with a null character to signify its end. This is in contrast to other major platforms that typically structure strings a size integer along with the array (no null terminator).</p>
<p>Individual characters all map to integer types, where literals are defined by wrapping the character in single quotes. Even though they're integers, the signed-ness of each of the types below isn't guaranteed.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>bits</th>
<th>literal prefix</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>&gt;= 8</td>
<td></td>
<td><code>'T'</code></td>
<td>&gt;= 8-bit wide character (smallest unit of memory -- 1 byte)</td>
</tr>
<tr>
<td><code>char8_t</code></td>
<td>8</td>
<td><code>u8</code></td>
<td><code>u8'T'</code></td>
<td>16-bit wide character (e.g. UTF-8)</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>16</td>
<td><code>u</code></td>
<td><code>u'T'</code></td>
<td>16-bit wide character (e.g. UTF-16)</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>32</td>
<td><code>U</code></td>
<td><code>U'T'</code></td>
<td>32-bit wide character (e.g. UTF-32)</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td></td>
<td><code>L</code></td>
<td><code>L'T'</code></td>
<td>at least as wide as <code>char</code></td>
</tr>
</tbody>
</table>
<p>Note that <code>char</code> and <code>wchar_t</code> don't have predefined bit lengths. They are platform-dependent. The bit length for...</p>
<ul>
<li><code>char</code> is defined in <code>CHAR_BIT</code> of climits and must be at least 8 bits.</li>
<li><code>wchar_t</code> must be equal to or greater than that of <code>char</code>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>char</code> literals can also be integers, but the signed-ness of the <code>char</code> type isn't defined by default (speculation). It can specifically be made to be signed / unsigned by prefixing it as such: <code>signed char</code> / <code>unsigned char</code>.</p>
</div>
<p>Strings literals are wrapped in double quotes instead of single quotes, where they get transformed into an array terminated by a null character.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>literal prefix</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char *</code></td>
<td></td>
<td><code>"hello"</code></td>
<td>unknown encoding (platform specific?)</td>
</tr>
<tr>
<td><code>wchar_t *</code></td>
<td><code>L</code></td>
<td><code>L"hello"</code></td>
<td>unknown encoding (platform specific?)</td>
</tr>
<tr>
<td><code>char16_t *</code></td>
<td><code>u</code></td>
<td><code>u"hello"</code></td>
<td>encoded as UTF-16</td>
</tr>
<tr>
<td><code>char32_t *</code></td>
<td><code>U</code></td>
<td><code>U"hello"</code></td>
<td>encoded as UTF-32</td>
</tr>
<tr>
<td><code>char8_t *</code></td>
<td><code>u8</code></td>
<td><code>u8"hello"</code></td>
<td>encoded as UTF-8</td>
</tr>
</tbody>
</table>
<p>Typically escaping rules apply to string literals. Unescaped string literals are allowed by adding an <code>R</code> at the end of the literal prefix, which make it so that the ...</p>
<ol>
<li>starting quote requires a custom delimiter immediately after it.</li>
<li>finishing quote requires a custom delimited immediately before it.</li>
</ol>
<p>These delimiter characters are characters that aren't encountered in the contents of the string itself. For example, in <code>u8R"|hello|"</code>, the delimiter is <code>|</code> and isn't included in the resulting UTF-8 string.</p>
<a name="H_Void"></a><h4>Void</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FVoid)_TOPIC%2F"></a><strong></strong></p>
<p><code>void</code> is a type that represents an empty set of values. Since it can't hold a value, C++ won't allow you to declare an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type void. However, you can use it to declare that a function ...</p>
<ul>
<li>returns no value (<code>void</code> return).</li>
<li>accepts no arguments (<code>void</code> parameter list).</li>
</ul>
<a name="H_Arrays"></a><h3>Arrays</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a>: Just the main section, not any of the subsections.</li>
</ul>
</div>
<p>C++ allows for the creation of arrays of constant length (size of the array must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a>). Elements of an array are guaranteed to be contiguous in memory (speculation).</p>
<ul>
<li><code>int x[100]</code> - Creates an array of 100 ints where those 100 ints are junk values (data previously at that memory location is not zeroed out).</li>
<li><code>int x[] { 5, 5, 5 }</code> - Creates an array of 3 ints where each of those ints have been initialized to 5 (<a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>).</li>
<li><code>int x[] = { 5, 5, 5 }</code> - Equivalent to above (assignment does not do any extra work).</li>
<li><code>int x[3] {}</code> - Creates an array of 3 ints where each of those ints are 0 (memory zeroed out -- <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>).</li>
<li><code>int x[3] = {}</code> - Equivalent to above (assignment does not do any extra work).</li>
<li><code>int x[n]</code> - Disallowed by C++ if n isn't a constant. These types of arrays are allowed in C (called <a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>s / <a href="#BM_(VLA)%2F">VLA</a>), but not in C++ because C++ has collection <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that allow for sizes not known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</li>
</ul>
<p>Accessing arrays is done similarly to how it is in most other languages, by subscripting (e.g. <code>x[0] = 5</code>). The only difference is that array access isn't bounds-checked and array length information isn't automatically maintained at run-time. For example, if an array has 100 elements, C++ won't stop you from trying to access element 250 -- out-of-bounds array access is undefined behaviour.</p>
<p>One way to think of an array is as a <a href="#BM_(pointer)%2Fi">pointer</a> to a contiguous block of elements of the array type. In fact, if an array type gets used where it isn't expected, that array type automatically decays to a <a href="#BM_(pointer)%2Fi">pointer</a> type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *x)</span> </span>{
   <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
   <span class="hljs-type">int</span> y { <span class="hljs-built_in">test</span>(x) };
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>My understanding is that arrays are typically passed to functions as <a href="#BM_(pointer)%2Fi">pointer</a>s + array length. This is because the array length information is only available at <a href="#BM_(compile-time)%2Fi">compile-time</a>, meaning that if you have a function that takes in an array, how would it know the size of the array it's working with when it runs (it isn't the one who declared it). It looks like a function parameter can be an array type of fixed size, but apparently that doesn't mean anything? The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> doesn't enforce that a caller use an array of that fixed size, and using <a href="#BM_(sizeof)%2Fi">sizeof</a> on the array will produce a warning saying that it's decaying into a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> x[<span class="hljs-number">10</span>])</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(x); <span class="hljs-comment">// compiler warning that this is returning sizeof(int *)</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
   <span class="hljs-type">size_t</span> y { <span class="hljs-built_in">test</span>(x) }; <span class="hljs-comment">// compiler doesn't complain that test() expects int[10] but this is int[3]</span>
   cout &lt;&lt; y;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p>Be careful when using the <code>sizeof</code> operator on an array. If the type is the original array type, <code>sizeof</code> will return the number of bytes taken up by the elements of that array (known at <a href="#BM_(compile-time)%2Fi">compile-time</a>). However, if the type has decayed to a <a href="#BM_(pointer)%2Fi">pointer</a> type, <code>sizeof</code> will return the number of bytes to hold on to a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[<span class="hljs-number">3</span>];
<span class="hljs-type">int</span> *y {x};  <span class="hljs-comment">// equiv to setting to &amp;(x[0]);</span>
std::cout &lt;&lt; <span class="hljs-keyword">sizeof</span> x;  <span class="hljs-comment">// should be the size of 3 ints</span>
std::cout &lt;&lt; <span class="hljs-keyword">sizeof</span> y;  <span class="hljs-comment">// should be the size of a pointer</span>
</code></pre>
<p>Similarly, range-based for loops won't work if the type has decayed to a <a href="#BM_(pointer)%2Fi">pointer</a> type because the array size of that <a href="#BM_(pointer)%2Fi">pointer</a> isn't known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> *y {x};
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i {<span class="hljs-number">0</span>}; i &lt; <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// OK</span>
   std::cout &lt;&lt; y[i] &lt;&lt; std::endl;
}
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : x) { <span class="hljs-comment">// OK</span>
   std::cout &lt;&lt; v &lt;&lt; std::endl;
}
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : y) { <span class="hljs-comment">// ERROR</span>
   std::cout &lt;&lt; v &lt;&lt; std::endl;
}
</code></pre>
<p>You may be tempted to use <code>sizeof(array) / sizeof(type)</code> to determine the number of elements within an array. It's a better idea to use <code>std::size(array)</code> instead (found in the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> header) because it should have logic to workaround and platform-specific behaviours that might cause inconsistent results / unexpected behaviour (speculation).</p>
<a name="H_Pointers"></a><h3>Pointers</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
</ul>
</div>
<p>C++ provides types that <a href="#BM_(reference)%2Fi">reference</a> a memory address, called <a href="#BM_(pointer)%2Fi">pointer</a>s. Variables of these types can point to different memory addresses / <a href="#BM_(object%7Cinstance)%2Fi">object</a>s.</p>
<p>Adding an asterisk (*) to the end of any type makes it a <a href="#BM_(pointer)%2Fi">pointer</a> type (e.g. <code>int *</code> is a type that can contain a <a href="#BM_(pointer)%2Fi">pointer</a> to an <code>int</code>). A <a href="#BM_(pointer)%2Fi">pointer</a> to any <a href="#BM_(object%7Cinstance)%2Fi">object</a> can be retrieved using the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> unary operator (&amp;). Similarly, the value in any <a href="#BM_(pointer)%2Fi">pointer</a> can be retrieved using the <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> unary operator (*).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *x { &amp;w }; <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> *y { &amp;w }; <span class="hljs-comment">// y points to w</span>
<span class="hljs-type">int</span> z { *x };   <span class="hljs-comment">// z is a copy of whatever x points to, which is w, which means it gets set to 5</span>
*x = <span class="hljs-number">7</span>;        <span class="hljs-comment">// w is set to 5 through x</span>

<span class="hljs-type">int</span> **a { &amp;x }; <span class="hljs-comment">// a points to x, which points to w (a pointer to a pointer to an int)</span>
</code></pre>
<p>As shown in the example above, it's perfectly valid to use the <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> operator on the left-side of the equals. It defines where the result of the right side should go.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *x { &amp;w };  <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> **y { &amp;x }; <span class="hljs-comment">// y point to x, which points to w</span>

**y = <span class="hljs-number">7</span>;        <span class="hljs-comment">// y dereferenced twice and set to 7 -- w should now be 7 </span>
</code></pre>
<p>The notation is confusing because asterisk (*) has different meanings. In the context of a ...</p>
<ul>
<li>type declaration, an asterisk means that the type is a "<a href="#BM_(pointer)%2Fi">pointer</a> to" some other type.</li>
<li>unary operator in an expression, an asterisk means the <a href="#BM_(object%7Cinstance)%2Fi">object</a> being pointed to should be accessed.</li>
<li>binary operator in an expression, an asterisk means multiplication.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See also: <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator.</p>
</div>
<p>In addition, a <a href="#BM_(pointer)%2Fi">pointer</a> can optionally be set to nothing via the <code>nullptr</code> literal. <code>nullptr</code> is actually of type <code>std::nullptr_t</code>, but the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will implicit conversion to/from other <a href="#BM_(pointer)%2Fi">pointer</a> types when required.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> *y { <span class="hljs-literal">nullptr</span> }; <span class="hljs-comment">// implicit conversion</span>
<span class="hljs-keyword">if</span> (y == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// report error</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It seems like there's some implicit conversions to boolean that are possible with <a href="#BM_(pointer)%2Fi">pointer</a>s. If whatever the <a href="#BM_(pointer)%2Fi">pointer</a> is going to expect a boolean, it's implicitly converted to <code>ptr != nullptr</code>? So in if / while/ for conditions, you can just use the <a href="#BM_(pointer)%2Fi">pointer</a> as is without explicitly writing out a condition?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>How is this different than the NULL macro? I guess because it's a distance type, you can have a <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> that takes in param of type <code>std::nullptr_t</code>? But why would you ever want to do that?</p>
</div>
<a name="H_Pointer%20Arithmetic"></a><h4>Pointer Arithmetic</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers%2FPointer%20Arithmetic)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<p>Certain arithmetic operators are allowed on <a href="#BM_(pointer)%2Fi">pointer</a>s, called <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>. Adding or subtracting integer types on a <a href="#BM_(pointer)%2Fi">pointer</a> will move that <a href="#BM_(pointer)%2Fi">pointer</a> by the number of bytes that makes up its underlying type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> []x = {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-type">int</span> *ptrA { &amp;(x[<span class="hljs-number">1</span>]) };  <span class="hljs-comment">// points to idx 1 of x (5)</span>
<span class="hljs-type">int</span> *ptrB { ptrA + <span class="hljs-number">1</span> }; <span class="hljs-comment">// points to idx 2 of x (7)</span>
</code></pre>
<p>This is similar to array access via the subscript operator. In fact, both arrays and <a href="#BM_(pointer)%2Fi">pointer</a>s can be accessed in the same way using the subscript operator and <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">int</span> *y {x};
*(y+<span class="hljs-number">1</span>) = <span class="hljs-number">99</span>;  <span class="hljs-comment">// equivalent to x[1] = 99</span>
x[<span class="hljs-number">2</span>] = <span class="hljs-number">101</span>;   <span class="hljs-comment">// equivalent to *(y+2) = 101;</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>An array guarantees that its elements appear contiguously and in order within memory (I think?), so if the <a href="#BM_(pointer)%2Fi">pointer</a> is from a decayed array, using <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> to access its elements is perfectly fine.</p>
</div>
<a name="H_Void%20Pointer"></a><h4>Void Pointer</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers%2FVoid%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(pointer)%2Fi">pointer</a> to the void type means that the type being pointed to is unknown. Since the type is unknown, <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a void <a href="#BM_(pointer)%2Fi">pointer</a> isn't possible. In other words, it isn't possible to read or write to the data pointed to by a void * because the underlying type is void / unknown.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">void</span> *y { x };
*y = <span class="hljs-number">2</span>; <span class="hljs-comment">// fails</span>
</code></pre>
<p>Since the underlying type of the <a href="#BM_(pointer)%2Fi">pointer</a> is unknown, <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> isn't allowed either.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">void</span> *y { x };
y = y + <span class="hljs-number">2</span>; <span class="hljs-comment">// fails</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>If you have a <code>void *</code> and you want to do raw memory manipulation at that address, use a <code>std::byte *</code> instead. Why not just use <code>char *</code> instead? Is a <code>char</code> guaranteed to be 1 byte (I think it is)? According to <a href="https://stackoverflow.com/a/46151026">this</a>, it's because certain assumptions about <code>char</code>s may not hold with bytes? I don't know. Just remember <code>std::byte *</code> if you're working with raw data.</p>
</div>
<a name="H_Function%20Pointer"></a><h4>Function Pointer</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers%2FFunction%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know what a function is / how to define one.</li>
</ul>
</div>
<p>A <a href="#BM_(pointer)%2Fi">pointer</a> to a function means the type being pointed to is a function with some specific structure. All functions have a type associated with them, defined by their return type, parameter type, and owning <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> if the function is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// type is: int (int, int)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>To declare a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> to a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> or a static <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, write out the function type (return type and parameter list without names) but place the <a href="#BM_(pointer)%2Fi">pointer</a> name preceded by an asterisk (*) <em>wrapped in parenthesis</em> where the function name would be. Invoke it just like you would any other function.</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {}; <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a * b;
}

func_ptr = &amp;add;  <span class="hljs-comment">// point func_ptr to address of add()</span>
<span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// invoke</span>
</code></pre>
<p>To declare a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> to a non-static <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>), the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type needs to be included before the asterisk (*) using the scoped resolution operator (::).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (MyClass::*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {}; <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)  in or inherited from MyClass</span>

MyClass x {};

func_ptr { &amp;MyClass::multiply }; <span class="hljs-comment">// point to:  int MyClass::multiply(int, int)</span>
(x.*func_ptr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);             <span class="hljs-comment">// provide x as the MyClass instance when invoking</span>
</code></pre>
<p>Unlike normal functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s cannot be assigned to raw <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s. A <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s equivalent of a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> is a <a href="#BM_(pointer)%2Fi">pointer</a> to the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (MyFunctor::*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {};  <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)  in or inherited from MyClass</span>

MyFunctor x {};

func_ptr { &amp;MyFunctor::<span class="hljs-built_in">operator</span>() };
(x.*func_ptr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// provide x as the MyClass instance when invoking</span>
</code></pre>
<p>Alternatively, to support both functions and <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, the parameter expecting a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> should be changed to the <code>std::function</code> or the code doing the invocation should be changed to use the <code>std::invoke</code> wrapper. These wrappers abstract away the differences between <a href="#BM_(pointer)%2Fi">pointer</a>s to functions and <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s.</p>
<a name="H_References"></a><h3>References</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>C++ provides a more sanitized version of <a href="#BM_(pointer)%2Fi">pointer</a>s called <a href="#BM_(reference)%2Fi">reference</a>s. A <a href="#BM_(reference)%2Fi">reference</a> type is declared by adding an ampersand (&amp;) after the type rather than an asterisk (*), and it implicitly takes the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> whatever is passed into it when it's created.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};

<span class="hljs-type">int</span> *x { &amp;w }; <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> &amp;y { w };  <span class="hljs-comment">// y references to w (note address-of operator not used here)</span>
</code></pre>
<p>The main difference between <a href="#BM_(pointer)%2Fi">pointer</a> types and <a href="#BM_(reference)%2Fi">reference</a> types is that a <a href="#BM_(reference)%2Fi">reference</a> type doesn't need to explicitly <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> to access the <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to. The <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to by the <a href="#BM_(reference)%2Fi">reference</a> type is accessed as if it were the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself.</p>
<pre class="hljs"><code>*x = <span class="hljs-number">10</span>;       <span class="hljs-comment">// x explicitly dereferenced to w and set to 10</span>
y = <span class="hljs-number">15</span>;        <span class="hljs-comment">// y implicitly dereferenced to w and set to 15</span>
</code></pre>
<p>As shown in the example above, assignment to a <a href="#BM_(reference)%2Fi">reference</a> type is assignment on the underlying <a href="#BM_(object%7Cinstance)%2Fi">object</a> being <a href="#BM_(reference)%2Fi">reference</a>d. As such, having the <a href="#BM_(reference)%2Fi">reference</a> type point to a different <a href="#BM_(object%7Cinstance)%2Fi">object</a> isn't possible (referred to as <a href="#BM_(reseat)%2Fi">reseat</a>ing).</p>
<p>Similarly, it's not possible to have a <a href="#BM_(reference)%2Fi">reference</a> to a <a href="#BM_(reference)%2Fi">reference</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> &amp;&amp;z { y }; <span class="hljs-comment">// this isn't a thing -- fail</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The way to think of <a href="#BM_(reference)%2Fi">reference</a>s is documented <a href="https://stackoverflow.com/a/1164267">here</a>. Don't consider a <a href="#BM_(reference)%2Fi">reference</a> as an <a href="#BM_(object%7Cinstance)%2Fi">object</a> the same way a <a href="#BM_(pointer)%2Fi">pointer</a> is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>. In the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>'s eyes, a <a href="#BM_(reference)%2Fi">reference</a> doesn't store anything like a <a href="#BM_(pointer)%2Fi">pointer</a> does (stores a memory address). It's just a "<a href="#BM_(reference)%2Fi">reference</a>" to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> -- the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself has storage, but the <a href="#BM_(reference)%2Fi">reference</a> to that <a href="#BM_(object%7Cinstance)%2Fi">object</a> doesn't.</p>
<p>In that sense, it's impossible to have ...</p>
<ul>
<li>a <code>const</code> <a href="#BM_(reference)%2Fi">reference</a> like you have a <code>const</code> <a href="#BM_(pointer)%2Fi">pointer</a> or an array of <a href="#BM_(reference)%2Fi">reference</a>s.</li>
<li>an array of <a href="#BM_(reference)%2Fi">reference</a>s</li>
<li>etc...</li>
</ul>
<p>... the same way that you can have with a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
</div>
<a name="H_Rvalue%20References"></a><h3>Rvalue References</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FExpression%20Categories)_TOPIC%2F">Core Language/Expression Categories</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates)_TOPIC%2F">Core Language/Templates</a></li>
</ul>
</div>
<p>An <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> is similar to a <a href="#BM_(reference)%2Fi">reference</a> except that it tells the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that it's working with an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a>. <a href="#BM_(rvalue%20reference)%2Fi">Rvalue reference</a>s are declared by adding two ampersands (&amp;&amp;) after the type rather than just one.</p>
<pre class="hljs"><code><span class="hljs-comment">// Function return type is an rvalue reference</span>
<span class="hljs-function">MyObject &amp;&amp; <span class="hljs-title">gimmie_an_rvalueref</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    ...
}
</code></pre>
<p>A variable of type <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> is actually an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> to an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>. As such, passing a variable of type revalue <a href="#BM_(reference)%2Fi">reference</a> as a function argument will treat it as if it were an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Confused? Recall from the expression categories section that, if it has a name (named variable or function), it's probably an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>.</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_func</span><span class="hljs-params">(MyObject &amp; x)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"NO RREF"</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_func</span><span class="hljs-params">(MyObject &amp;&amp; xRref)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"YES RREF"</span>;
}
MyObject &amp;&amp;a { <span class="hljs-built_in">gimmie_an_rvalueref</span>(<span class="hljs-number">42</span>) }; <span class="hljs-comment">// a has a name, meaning its an lvalue to an rvalue reference</span>
<span class="hljs-built_in">my_func</span>(a);  <span class="hljs-comment">// calls "NO RREF" version</span>
</code></pre>
<p>If you need to pass a variable of type <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> as a function argument, the typical approach is to either never store it as a variable or to use <code>std::forward</code> to ensure the <a href="#BM_(object%7Cinstance)%2Fi">object</a> remains an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>.</p>
<pre class="hljs"><code><span class="hljs-built_in">my_func</span>(<span class="hljs-built_in">gimmie_an_rvalueref</span>(<span class="hljs-number">42</span>));      <span class="hljs-comment">// calls "YES RREF" version</span>
<span class="hljs-built_in">my_func</span>(std::forward&lt;MyObject &amp;&amp;&gt;(b)); <span class="hljs-comment">// calls "YES RREF" version</span>
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> you MUST specify the full type in std::forward's template parameter -- automatic type inference not supported</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://github.com/AnthonyCalandra/modern-cpp-features#forwarding-references">here</a>.</p>
</div>
<p><a href="#BM_(rvalue%20reference)%2Fi">Rvalue reference</a>s are typically used for moving <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (not copying, but actually moving the guts of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another). This is done through something called a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, which is explained in another section.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<a name="H_Size"></a><h3>Size</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FSize)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p><code>sizeof</code> is a unary operator that returns the size of its operand in bytes as a <code>size_t</code> type. If the operand is a ...</p>
<ul>
<li>
<p>data type or a variable, it'll return the number of bytes needed to hold that type. For example, ...</p>
<ul>
<li><code>sizeof char</code> is guaranteed to be 1.</li>
<li><code>sizeof (char &amp;)</code> is guaranteed to be 1.</li>
<li><code>sizeof (char *)</code> is platform dependent, typically either 4 or 8.</li>
<li><code>char * x { "hi" }; sizeof x</code> is equivalent to <code>sizeof (char *)</code> (see above).</li>
</ul>
</li>
<li>
<p>an expression such as a structure/<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> literal, array literal, or string literal, it'll return the number of bytes needed to hold it. For example, ...</p>
</li>
<li>
<p><code>sizeof "hi"</code> is 3 (added 1 for the null terminator at the end)</p>
</li>
<li>
<p><code>sizeof { 5, 5, 4 }</code> is platform dependent, typically either 12 or 24.</p>
</li>
<li>
<p><code>sizeof (int[3])</code> is platform dependent, typically either 12 or 24.</p>
</li>
<li>
<p><code>x = int[n]; sizeof x</code> is invalid C++ (<a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>s <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d on stack are not allowed in C++).</p>
</li>
</ul>
<p>In other words, <code>sizeof</code> returns the size of things known at <a href="#BM_(compile-time)%2Fi">compile-time</a>. If a variable is passed in, it outputs the size of the data type. For example, if the data type is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">struct</a> of type <code>MyStruct</code>, it'll return the number of bytes used to store a <code>MyStruct</code>. However, if the data type is a <a href="#BM_(pointer)%2Fi">pointer</a> to <code>MyStruct</code>, it'll return the number of bytes to hold that <a href="#BM_(pointer)%2Fi">pointer</a>. That is, you can't use it to get the size of something like a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamically allocated array</a> of integers.</p>
<p>In certain cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may add padding to <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (e.g. byte boundary alignments or performance reasons), meaning that the size returned by <code>sizeof</code> for an <a href="#BM_(object%7Cinstance)%2Fi">object</a> shouldn't be used to make inferences about the characteristics of that <a href="#BM_(object%7Cinstance)%2Fi">object</a>. For example, a <code>long double</code> may get reported as being 16 bytes, but that doesn't necessarily mean that a <code>long double</code> is a 128-bit quad floating point. It could be that only 12 of those bytes are used to represent the floating point number while the remainder is just padding for alignment reasons.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>As shown in the examples above, the <code>sizeof</code> a C++ <a href="#BM_(reference)%2Fi">reference</a> is equivalent to the raw size. For example, <code>sizeof char == sizeof (char &amp;)</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The last example is valid in C99 (called a <a href="#BM_(VLA)%2F">VLA</a> -- <a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>) but not C++. The reason is C++ has std::vector and std::array that give you basically the same thing as variable arrays.</p>
<p>In C, where <a href="#BM_(VLA)%2F">VLA</a>s are allowed, doing a <code>sizeof</code> on a <a href="#BM_(VLA)%2F">VLA</a> is undefined.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Remember that <code>sizeof</code> is a unary operator, similar to how the negative sign is a unary operator that negates whatever is to the right of it. People usually structure its usage in code as if it were a function (e.g. <code>sizeof(x)</code> vs <code>sizeof x</code>). This sometimes causes confusion for people coming from other languages.</p>
</div>
<a name="H_Aliasing"></a><h3>Aliasing</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FAliasing)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>The <code>using</code> keyword is used to give synonyms to types. Other than having a new name, a <a href="#BM_(type%20alias)%2Fi">type alias</a> is the exact same as the originating type.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> IntegerButWithNewName = <span class="hljs-type">int</span>;
<span class="hljs-type">int</span> x {<span class="hljs-number">42</span>};
IntegerButWithNewName y {<span class="hljs-number">42</span>};    <span class="hljs-comment">// equivalent to:  int y {42};</span>
IntegerButWithNewName z {x + y}; <span class="hljs-comment">// equivalent to:  int z {x + y};</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">float</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">short</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(IntegerButWithNewName x)</span></span>;  <span class="hljs-comment">// NOT ALLOWED -- this overload is equivalent to the overload above</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>To allow for use-cases such as the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing case in the example above, the cleanest solution is to wrap the type in a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a></p>
</div>
<p>The benefit of <a href="#BM_(type%20alias)%2Fi">type alias</a>ing is that it helps shorten type names, which can be especially useful when using a <a href="#BM_(template)%2Fi">template</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> BasicGraph = DirectedGraph::Graph&lt;std::string, std::map&lt;std::string, std::string&gt;, std::string, std::map&lt;std::string, std::string&gt;&gt;;

<span class="hljs-function">BasicGraph <span class="hljs-title">removeLimbs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BasicGraph &amp;g)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Aliasing)_TOPIC%2F">Core Language/Templates/Type Aliasing</a></li>
</ul>
</div>
<a name="H_Constant"></a><h3>Constant</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FConstant)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>For types, any part of that type can be made unmodifiable by adding a <code>const</code> immediately after it.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a {<span class="hljs-number">5</span>};                <span class="hljs-comment">// a is changeable   -- set to 5</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">const</span> x {a};          <span class="hljs-comment">// x is unchangeable -- set to 5 (value in a)</span>
<span class="hljs-type">int</span> * <span class="hljs-keyword">const</span> y {&amp;a};       <span class="hljs-comment">// y is an unchangeable pointer to a changeable int -- set to a (points to a)</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> z {&amp;x}; <span class="hljs-comment">// z is an unchangeable pointer to a unchangeable int -- set to x (points to x)</span>
</code></pre>
<p>The simplest way to interpret <code>const</code>-ness of a type is to read it from right-to-left.</p>
<p><img src="svgbob_fd16b9b8d1538355ffda7cde58e62b3e35887712.svg" alt="Kroki diagram output"></p>
<p>One caveat to the above is that a type beginning with <code>const</code> is equivalent to the first part of that type having <code>const</code> applied on it.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};  <span class="hljs-comment">// equivalent to int const x {5}</span>
</code></pre>
<p>All of the examples above were for <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>s. Appending a <code>const</code> on a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type works exactly the same way: None of its <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are modifiable ever, even by its own <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>}
};

MyStruct <span class="hljs-keyword">const</span> inst {};
inst.x = <span class="hljs-number">5</span>;  <span class="hljs-comment">// compiler error</span>
</code></pre>
<a name="H_Volatile"></a><h3>Volatile</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FVolatile)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Unlike in Java, The <code>volatile</code> keyword in C++ is <em>not</em> used for thread-safety.</p>
</div>
<p>Adding the keyword <code>volatile</code> before a type makes it immune to <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> optimizations such as operation re-ordering and removal. Mutations and accesses, no matter how irrelevant they may seem, are kept in-place and in-order by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-type">int</span> x {a};
    x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y {x};
    <span class="hljs-type">int</span> x {y};
    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// at this point, x is always 6</span>
}
</code></pre>
<p>A <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> might be able to deduce that the function above always returns 6, and as such may replace the operations it performs with simply just returning 6. Adding <code>volatile</code> to the type of the variable prevents this from happening.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> x {a};  <span class="hljs-comment">// marked as volatile</span>
    x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y {x};
    <span class="hljs-type">int</span> x {y};
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>Using <code>volatile</code> is important when working with embedded devices, where platform-specific memory locations often need to be accessed in a specific order / at specific intervals in seemingly useless ways (e.g. kicking a watchdog by writing 0 to a memory location but never reading that memory location).</p>
<a name="H_Common%20Attributes"></a><h3>Common Attributes</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCommon%20Attributes)_TOPIC%2F"></a><strong></strong></p>
<p>If a variable has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it sees it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-type">int</span> my_variable;
</code></pre>
<a name="H_Implicit%20Conversion"></a><h3>Implicit Conversion</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FImplicit%20Conversion)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
</ul>
</div>
<p>An <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> is when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is converted (cast) automatically, without code explicitly changing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to a different type. For example, <code>long x {1}</code> implicitly converts the <code>int</code> literal in the initializer to a <code>long</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">long</span> y {x};  <span class="hljs-comment">// int to long</span>
</code></pre>
<p>The most common types of implicit conversions are ...</p>
<ul>
<li>when a <a href="#BM_(pointer)%2Fi">pointer</a> of a certain type gets implicitly converted to a void <a href="#BM_(pointer)%2Fi">pointer</a> (e.g. <code>int *</code> to <code>void *</code>).</li>
<li>when a numeric type gets converted to another numeric type via <a href="#BM_(promotion%20rule)%2Fi">promotion rule</a>s (e.g. <code>int</code> to <code>float</code>).</li>
<li>when a numeric type gets converted to a bool type (e.g. <code>0</code> to <code>false</code>)</li>
</ul>
<p>Depending on the operation performed or how an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is initialized, the results of an implicit conversion may do something specific to that platform and/or <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> implementation.</p>
<table>
<thead>
<tr>
<th>source type</th>
<th>destination type</th>
<th>behaviour</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>Floating Point</td>
<td>Implementation-specific behaviour if can't fit in destination (speculation).</td>
</tr>
<tr>
<td>Floating Point</td>
<td>Integer</td>
<td>Rounded to integer (speculation - how?), implementation-specific behaviour if can't fit in destination (speculation).</td>
</tr>
<tr>
<td>Integer</td>
<td>Integer</td>
<td>Signed destination and value can't fit, implementation-specific behaviour. Unsigned destination and value can't fit, truncates higher-order bits.</td>
</tr>
<tr>
<td>Floating Point</td>
<td>Floating Point</td>
<td>Implementation-specific behaviour if value can't fit in destination.</td>
</tr>
<tr>
<td>Any Numeric</td>
<td>Boolean</td>
<td>0 converts to <code>false</code>, otherwise <code>true</code>.</td>
</tr>
<tr>
<td>Any <a href="#BM_(pointer)%2Fi">Pointer</a></td>
<td>Boolean</td>
<td><code>nullptr</code> converts to <code>false</code>, otherwise <code>true</code>.</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book recommends to always use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> because when you do, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> produces warnings about types not fitting. However, those warnings don't seem to cover everything, at least that's the impression I get from what I've tried.</p>
</div>
<a name="H_Explicit%20Conversion"></a><h3>Explicit Conversion</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
</ul>
</div>
<p>An <a href="#BM_(explicit%20type%20conversion)%2Fi">explicit type conversion</a> is the opposite of an <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>. It's when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is explicitly converted (cast) to another type in code.</p>
<pre class="hljs"><code><span class="hljs-type">long</span> x {<span class="hljs-number">5L</span>};
<span class="hljs-type">int</span> y {<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x)};   <span class="hljs-comment">// long to int</span>
</code></pre>
<p><a href="#BM_(explicit%20type%20conversion)%2Fi">Explicit type conversion</a>s come in two forms:</p>
<ul>
<li><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s are the official way to cast in C++.</li>
<li>C-style casts are the legacy way to cast in C++.</li>
</ul>
<p><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s should be preferred over C-style casts. Any C-style cast can be performed through a <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>.</p>
<a name="H_Named%20Conversions"></a><h4>Named Conversions</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion%2FNamed%20Conversions)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion function</a>s are a set of (seemingly <a href="#BM_(template)%2Fi">template</a>d) functions to convert an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s types. These functions provide safety mechanisms that aren't available in other older ways of casting.</p>
<ul>
<li>
<p><code>const_cast</code> removes the <code>const</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> from an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyType &amp;t)</span> </span>{
    T &amp;<span class="hljs-type">moddable_t</span> { <span class="hljs-built_in">const_cast</span>&lt;MyType &amp;&gt;(t) };
}
</code></pre>
<p>Performing this type of conversion should only be done in extreme situations since it breaks contracts.</p>
</li>
<li>
<p><code>static_cast</code> forces the reverse of an implicit conversion.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
<span class="hljs-type">int</span> *b { a };  <span class="hljs-comment">// ok, implicit conversion (decay to pointer)</span>
<span class="hljs-type">void</span> *c { b }; <span class="hljs-comment">// ok, implicit conversion</span>
<span class="hljs-type">int</span> *d { c };  <span class="hljs-comment">// error, can't go in reverse</span>
<span class="hljs-type">int</span> *e { <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(c) }; <span class="hljs-comment">// ok</span>
</code></pre>
<p>In the above example, a <code>uint32_t *</code> implicitly converts to <code>void *</code>, but not the reverse. A <code>static_cast</code> makes going in reverse possible. However, that doesn't mean it's always safe to do. For example, <code>uint32_t</code> reads may need to be aligned to 4 byte boundaries on certain platforms. If the <code>void *</code> was arbitrary data (e.g. coming in over a network), it might cause a crash to just treat it as a <code>uint32_t *</code> and start reading.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Why does a <code>uint32_t*</code> implicitly convert to a <code>void *</code>? Recall that <code>void *</code> just means "<a href="#BM_(pointer)%2Fi">pointer</a> to something unknown", which is something the language is okay automatically / implicitly converting.</p>
</div>
</li>
<li>
<p><code>reinterpret_cast</code> forces a reinterpretation of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> into an entirely different type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
<span class="hljs-type">int</span> *b { a };   <span class="hljs-comment">// ok, implicit conversion (decay to pointer)</span>
<span class="hljs-type">short</span> *c { b }; <span class="hljs-comment">// error, you can't convert from an int* to a short* (not even with a static_cast because it's not an implicit conversion)</span>
<span class="hljs-type">short</span> *d { <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">int</span> *&gt;; } <span class="hljs-comment">// ok</span>
</code></pre>
</li>
<li>
<p><code>narrow_cast</code> is similar to <code>static_cast</code> for numerics, except it ensures that no information loss occurred.</p>
<pre class="hljs"><code><span class="hljs-type">uint32_t</span> a { <span class="hljs-number">70000</span> };                     <span class="hljs-comment">// ok</span>
<span class="hljs-type">uint16_t</span> b { <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(a) };  <span class="hljs-comment">// ok, but since uint16_t has a max of65535, this object is mangled</span>
<span class="hljs-type">uint16_t</span> c { <span class="hljs-built_in">narrow_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(a) };  <span class="hljs-comment">// runtime exception, narrow_cast sees that the object will be mangled</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Is this part of the standard? The book seems to give the code for <code>narrow_cast</code> and looking online it looks like people have their own implementations?</p>
</div>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FAny)_TOPIC%2F">Library Functions/Wrappers/Any</a> (<code>any_cast</code> for an "any" container)</li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a> (<code>clock_cast</code> for converting times between different types of clocks)</li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F">Library Functions/Time/Durations</a> (<code>duration_cast</code> for converting between different types of durations)</li>
</ul>
</div>
<a name="H_C-style%20Casts"></a><h4>C-style Casts</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion%2FC-style%20Casts)_TOPIC%2F"></a><strong></strong></p>
<p>C-style casts are similar to casts seen in Java. The type is bracketed before whatever is being evaluated.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { (<span class="hljs-type">int</span>) <span class="hljs-number">9999999999L</span> };
</code></pre>
<p>The problem with C-style casting is that it doesn't provide the same safety mechanisms as <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>s do (e.g. inadvertently strip the <code>const</code>-ness). <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s provide these safety mechanisms and as such should be preferred over C-style casts. Any C-style cast can be performed using a <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>.</p>
<a name="H_Object%20Lifecycle"></a><h2>Object Lifecycle</h2>
<p><a name="BM_(Core%20Language%5C%2FObject%20Lifecycle)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>In C++, an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is a region of memory that has a type and a value (e.g. a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(object%7Cinstance)%2Fi">instance</a>, an integer, a <a href="#BM_(pointer)%2Fi">pointer</a> to an integer, etc..). Contrary to other more high-level languages (e.g. Java), C++ <a href="#BM_(object%7Cinstance)%2Fi">object</a>s aren't exclusive to <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es (e.g. a boolean is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>).</p>
<p>An <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s life cycle passes through the following stages:</p>
<ol>
<li>memory <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d</li>
<li><a href="#BM_(constructor)%2Fi">constructor</a> invoked</li>
<li><a href="#BM_(destructor)%2Fi">destructor</a> invoked</li>
<li>memory <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d</li>
</ol>
<p>The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> starts from when its memory is <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and ends when that memory is <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. An <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a>, on the other hand, starts when its <a href="#BM_(constructor)%2Fi">constructor</a> <em>completes</em> (meaning the <a href="#BM_(constructor)%2Fi">constructor</a> finishes) and ends when its <a href="#BM_(destructor)%2Fi">destructor</a> is <em>invoked</em> (meaning when the <a href="#BM_(destructor)%2Fi">destructor</a> starts).</p>
<p><img src="svgbob_5382fe6e4bca4e56d9147249ff0bb4082202935e.svg" alt="Kroki diagram output"></p>
<p>Since C++ doesn't have a garbage collector performing cleanup like other high-level languages, it's the user's responsibility to ensure <a href="#BM_(object%7Cinstance)%2Fi">object</a> <a href="#BM_(lifetime)%2Fi">lifetime</a>s. The user is responsible for knowing when <a href="#BM_(object%7Cinstance)%2Fi">object</a>s should be destroyed and ensuring that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are only accessed within their <a href="#BM_(lifetime)%2Fi">lifetime</a>.</p>
<p>The typical <a href="#BM_(storage%20duration)%2Fi">storage duration</a>s supported by C++ are...</p>
<ul>
<li><a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a> - scoped to duration of some function within the program.</li>
<li><a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static storage duration</a> - scoped to the entire duration of the program.</li>
<li><a href="#BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi">thread storage duration</a> - scoped to the entire duration of a thread in the program.</li>
<li><a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic storage duration</a> - <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d on request of the user.</li>
</ul>
<a name="H_Static%20Objects"></a><h3>Static Objects</h3>
<p><a name="BM_(Core%20Language%5C%2FObject%20Lifecycle%2FStatic%20Objects)_TOPIC%2F"></a><strong></strong></p>
<p>By default, an <a href="#BM_(object%7Cinstance)%2Fi">object</a> declared within a function is said to be an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a>. <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">Automatic object</a>s have <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a>s: start at the beginning of the block and finish at the end of the block. When the keyword <code>static</code> (or <code>extern</code> in some cases) is added to the declaration, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of the function changes.</p>
<p>At global scope, if an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is declared as <code>static</code> or <code>extern</code>, <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> spans the entire duration of the program. The difference between the two is essentially just visibility:</p>
<ul>
<li><code>static</code> makes it so it's accessible to only the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's declared in.</li>
<li><code>extern</code> makes it so it's accessible to other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s as well as the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's declared in.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a { <span class="hljs-number">0</span> }; <span class="hljs-comment">// static variable</span>
<span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b { <span class="hljs-number">1</span> }; <span class="hljs-comment">// static variable (accessible outside translation unit)</span>
</code></pre>
<p>At function scope, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s declared as <code>static</code> starts at the first invocation of that function and ends when the program exits.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> z {<span class="hljs-number">0</span>}; <span class="hljs-comment">// static variable</span>
    z += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> z;
}
</code></pre>
<p>At <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> level, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of a <a href="#BM_%5Cb(member)%2Fi">member</a> (<a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> or <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>) declared as <code>static</code> is essentially the same as if it were declared at global scope (they aren't bound to an individual <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the same way a normal <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> or <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is). The only differences are that the <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a> is accessed on the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself using the scoped resolution operator (::) and that <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a>s that are <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s must be initialized at global scope.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m;         <span class="hljs-comment">// static member (field initialized at end)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">// static member (method)</span>
        m += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> m;
    }
};

X::m = <span class="hljs-number">0</span>;                <span class="hljs-comment">// initialize static member</span>
</code></pre>
<p>If the <code>thread_local</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> is added before <code>static</code> (or <code>extern</code>), each thread gets its own copy of the <a href="#BM_(object%7Cinstance)%2Fi">object</a>. That is, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> essentially gets changed to when the thread starts and ends.</p>
<p><code>thread_local static</code> can be shortened to just <code>thread_local</code> (it's assumed to be static).</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
<span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b {<span class="hljs-number">1</span>};
<span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> c {<span class="hljs-number">2</span>};
</code></pre>
<a name="H_Dynamic%20Objects"></a><h3>Dynamic Objects</h3>
<p><a name="BM_(Core%20Language%5C%2FObject%20Lifecycle%2FDynamic%20Objects)_TOPIC%2F"></a><strong></strong></p>
<p>An <a href="#BM_(object%7Cinstance)%2Fi">object</a> can be created in an ad-hoc manner, such that its <a href="#BM_(storage%20duration)%2Fi">storage duration</a> is entirely controlled by the user. The operator ...</p>
<ul>
<li><code>new</code> <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>s a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> and calls its <a href="#BM_(constructor)%2Fi">constructor</a>.</li>
<li><code>delete</code> calls the <a href="#BM_(destructor)%2Fi">destructor</a> of some <a href="#BM_(object%7Cinstance)%2Fi">object</a> and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>s it.</li>
</ul>
<p>Both keywords work with <a href="#BM_(pointer)%2Fi">pointer</a>s: <code>new</code> returns a <a href="#BM_(pointer)%2Fi">pointer</a> while <code>delete</code> requires a <a href="#BM_(pointer)%2Fi">pointer</a>. To create a new <a href="#BM_(object%7Cinstance)%2Fi">object</a>, use <code>new</code> followed by the type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> };
*ptr = <span class="hljs-number">0</span>;
<span class="hljs-keyword">delete</span> ptr;
</code></pre>
<p><a href="#BM_(object%7Cinstance)%2Fi">Object</a>s may be initialized directly within the <code>new</code> invocation just as if it were an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> initialization. The only caveat is that <a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a> and <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> won't work because the equal sign is already being used during <code>new</code> (speculation -- it doesn't work but I don't know the exact reason). As such, <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> is the best way to initialize a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">0</span>} }; <span class="hljs-comment">// initialize to 0</span>
<span class="hljs-keyword">delete</span> ptr;
</code></pre>
<p>The same process can be used to create an array of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. Unlike <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> arrays, <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s don't have a constant size array length restriction. However, the return value of <code>new</code> will decay from an array type to a <a href="#BM_(pointer)%2Fi">pointer</a> type.</p>
<p>When deleting a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> array, square brackets need to be appended to <code>delete</code> operator: <code>delete[]</code>. Doing so ensures that the <a href="#BM_(destructor)%2Fi">destructor</a> for each <a href="#BM_(object%7Cinstance)%2Fi">object</a> in the array gets invoked before <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len] };  <span class="hljs-comment">// len is some non-constant positive integer, decayed to pointer type because array length can be non-constant.</span>
<span class="hljs-keyword">delete</span>[] ptr;
</code></pre>
<p><a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> may be used when declaring <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s so long as the size of the array is at least the size of the initialization list.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr1 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };  <span class="hljs-comment">// initialize the first 3 elems of a 10 elem array</span>
<span class="hljs-type">int</span> * ptr2 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };   <span class="hljs-comment">// throws exception  (size too small for initializer list)</span>
<span class="hljs-type">int</span> * ptr3 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };   <span class="hljs-comment">// okay -- so long as n &gt;= 3</span>
<span class="hljs-keyword">delete</span>[] ptr1;
<span class="hljs-keyword">delete</span>[] ptr2;
<span class="hljs-keyword">delete</span>[] ptr3;
</code></pre>
<p>By default, <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s are stored on a block of memory called the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a>, also sometimes referred to as the <a href="#BM_(heap%7Cfree%20store)%2Fi">free store</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing section to see how the <code>new</code> and <code>delete</code> operators may be overridden to customize where and how a specific type gets stored.</p>
<p>The <code>new</code> and <code>delete</code> operators may also be overridden globally rather than per-type. See the new header.</p>
</div>
<a name="H_Functions"></a><h2>Functions</h2>
<p><a name="BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ function declarations and definitions have the following form: <code>prefix-modifiers return-type name(parameters) suffix-modifiers</code></p>
<ul>
<li>
<p><strong>return-type</strong> (required) - Type returned by function.</p>
</li>
<li>
<p><strong>name</strong>: (required) - Name of function.</p>
</li>
<li>
<p><strong>parameters</strong> (required) - Parameter list of function.</p>
</li>
<li>
<p><strong>prefix-<a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a function.</p>
<p>(e.g. <code>static</code>, <code>virtual</code>,  <code>constexpr</code>, <code>[[noreturn]]</code>, <code>inline</code>, ...)</p>
</li>
<li>
<p><strong>suffix-<a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a function.</p>
<p>(e.g. <code>noexcept</code>, <code>const</code>,  <code>final</code>, <code>override</code>, <code>volatile</code>, ...)</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}
</code></pre>
<p>In C++, functions that are ...</p>
<ul>
<li><a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s (assigned to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) are called <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s.</li>
<li>global are called <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</li>
</ul>
<p>This section deals with <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Some of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s listed above are for <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s, not <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
</div>
<a name="H_Overloading"></a><h3>Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FOverloading)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">Function overload</a>ing is when there are multiple functions with the same name in the same scope. For <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, each <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> must have the same return type and a unique set of parameters.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0.0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a != b; }
</code></pre>
<p>When an <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overloaded function</a> is called, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will try to match argument types against parameter types to figure out which <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overloaded function</a> to call. If no exact match can be found, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> attempts to obtain a correct set of types through a set of conversions.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> num { <span class="hljs-number">1</span> };
<span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// calls the first overload in the code above:  bool test(int a);</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See argument matching section.</p>
</div>
<a name="H_Argument%20Matching"></a><h3>Argument Matching</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FArgument%20Matching)_TOPIC%2F"></a><strong></strong></p>
<p>When a function is called but the arguments types don't match the parameter list types, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> attempts to obtain a correct set of types through a set of conversions on the arguments. For example, if a parameter expects a <a href="#BM_(reference)%2Fi">reference</a> to a constant <a href="#BM_(object%7Cinstance)%2Fi">object</a> but what gets passed into the argument is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, the argument is automatically converted to a constant <a href="#BM_(object%7Cinstance)%2Fi">object</a> and its <a href="#BM_(reference)%2Fi">reference</a> is used.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp;obj)</span> </span>{ ... }

<span class="hljs-type">int</span> x {};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// x is turned into a "const int" and passed in as a reference</span>
</code></pre>
<p>For floating point and integral types, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will widen or <em>narrow</em> the if the exact type isn't found.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> a)</span> </span>{
    std::cout &lt;&lt; a;
    <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;
}

<span class="hljs-type">float</span> x {<span class="hljs-number">1.5</span>};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// automatic narrowing</span>
</code></pre>
<p>Similarly, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will convert between signed and unsigned integral types if the exact integral type isn't found.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a)</span> </span>{
    std::cout &lt;&lt; a;
    <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;
}

<span class="hljs-type">int64_t</span> x {<span class="hljs-number">10</span>};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// automatic narrowing and change to unsigned</span>
</code></pre>
<p>When <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>s are involved, the candidate with the arguments matching most closely is the one chosen.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The exact rules here seem hard to definitively pin down. If you have two <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s of a function, one accepting int16 and int64, it'll fail when you try to call it with int8 claiming that it's too ambiguous. The best thing to do is to just ask the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to either warn on implicit conversion (<code>-Wconversion</code>) flag or on narrowing implicit conversion (<code>-Wnarrowing</code> / <code>-Wno-narrowing</code>). These flags may not be included under <code>-Wall</code>.</p>
</div>
<a name="H_Main%20Function"></a><h3>Main Function</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FMain%20Function)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<p>The entry-point to any C++ program is the <code>main</code> function, which can take one of three possible forms:</p>
<ol>
<li>
<p><code>int main()</code></p>
<p>No arguments.</p>
</li>
<li>
<p><code>int main(int argc, char* argv[])</code></p>
<p>Command-line arguments, where <code>argv</code> is an array of size <code>argc</code> containing the null-terminated command-line arguments. On most modern platforms, the first argument is the path of the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
</li>
<li>
<p><code>int main(int argc, char* argv[], EXTRA_PLATFORM_SPECIFIC_PARAMS)</code></p>
<p>Same as the above except extra arguments are supplied that are platform-specific.</p>
</li>
</ol>
<p>All three forms return an integer known as an exit code. On most modern day platforms, an exit code of 0 means success. If the code doesn't return an exit code, 0 is assumed.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; argv[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Should <code>argv</code> be <code>const char * const *</code>? In that you shouldn't be able to change the strings or the string <a href="#BM_(pointer)%2Fi">pointer</a> at each array index.</p>
</div>
<a name="H_Variadic"></a><h3>Variadic</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FVariadic)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<p>A <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> function is one that takes in a variable number of arguments, sometimes called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s in other languages. A function can be made <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> by placing <code>...</code> as the final parameter. The arguments for this final parameter are called the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments.</p>
<p>The <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments for a function are accessible through functionality provided by the cstdargs header.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdargs&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-type">float</span> sum {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        sum += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">return</span> sum /= n;
}
</code></pre>
<ul>
<li><code>va_list</code> - Access point to <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments.</li>
<li><code>va_start</code> - Initializes access to <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments (requires the <code>va_list</code> variable and the expected count of <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments).</li>
<li><code>va_args</code> - Gets the next <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> argument (requires the <code>va_list</code> variable and the expected type).</li>
<li><code>va_end</code> - Tears down access to the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments (requires the <code>va_list</code> variable).</li>
</ul>
<p>In addition, the <code>va_copy()</code> can be used to copy one <code>va_list</code> to another. The source will need to be initialized before the copy (via <code>va_start</code>). Once <code>va_copy</code> returns, copy will already be initialized (no need for <code>va_start</code>) but will need to be torn down before the function exits (via <code>va_end</code>).</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdargs&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">add_and_mult</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    va_list args2;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-built_in">va_copy</span>(args2, args);  <span class="hljs-comment">// 1st param is dst, 2nd param is src</span>
    <span class="hljs-type">float</span> res {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        res += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        res *= <span class="hljs-built_in">va_args</span>(args2, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args2);
    <span class="hljs-keyword">return</span> res;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book recommends against using <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> functions due to confusing usage and having to explicitly know the count and types of the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments before hand (can become security problem if screwed up). Instead it recommends using <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> <a href="#BM_(template)%2Fi">template</a>s for functions instead.</p>
</div>
<a name="H_No%20Exception"></a><h3>No Exception</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FNo%20Exception)_TOPIC%2F"></a><strong></strong></p>
<p>In certain cases, it'll be impossible for a function to throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. Either the function (and the functions it calls into) never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> or the conditions imposed by the function make it impossible for any <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> to be thrown. In such cases, a function may be marked with the <code>noexcept</code> keyword. This keyword allows the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to perform certain optimizations that it otherwise wouldn't have been able to, but it doesn't necessarily mean that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will check to ensure an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> can't be thrown.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">noexcept</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions this is documented in "Item 16 of Effective Modern C++ by Scott Meyers". It goes on to say that, unless specified otherwise, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> assumes <a href="#BM_(move%20constructor)%2Fi">move constructor</a>s / move-assignment operators can throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> if they try to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> memory but the system doesn't have any. This prevents it from making certain optimizations.</p>
</div>
<a name="H1_Common%20Attributes"></a><h3>Common Attributes</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FCommon%20Attributes)_TOPIC%2F"></a><strong></strong></p>
<p>If a function has no possibility of ever gracefully returning to the caller, adding a <code>[[noreturn]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to make certain optimizations and provide / remove relevant warnings around that function.</p>
<pre class="hljs"><code>[[noreturn]] <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-string">"error"</span>;
}
</code></pre>
<p>If a function returns something and it's of vital importance that the return value should be used by the invoker, adding a <code>[[nodicard]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning.</p>
<pre class="hljs"><code>[[nodiscard]] <span class="hljs-function">Result <span class="hljs-title">perform</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-comment">// perform some computation</span>
    <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> ERROR_CODE;
    }
    <span class="hljs-keyword">return</span> SUCCESS_CODE;
}
</code></pre>
<p>If a function's parameter isn't used but it's inclusion in the parameter list is intentional, adding a <code>[[maybe_used]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to remove any warnings that it might otherwise show up about it being unused.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, [[maybe_unused]] <span class="hljs-type">int</span> c)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>If a function has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it's being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Enumerations"></a><h2>Enumerations</h2>
<p><a name="BM_(Core%20Language%5C%2FEnumerations)_TOPIC%2F"></a><strong></strong></p>
<p>C++ <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>s are declared using <code>enum class</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MyEnum</span> {
   OptionA,
   OptionB,
   OptionC
};

MyEnum x {MyEnum::OptionC};

<span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">case</span> MyEnum::OptionA:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> MyEnum::OptionB:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> MyEnum::OptionC:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>An <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> may be brought into scope via <code>using</code> to remove the need to prefix with the <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>'s name.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span>;
    <span class="hljs-keyword">case</span> OptionA:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> OptionB:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> OptionC:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It's possible to remove the <code>class</code> from <code>enum class</code>, which heavily loosens type-safety and scope. By removing <code>class</code>, the options within have thei<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>s implicitly converted to integers and you don't need the resolution scope operator (their options are accessible at the same level as an <a href="#BM_(enumeration%7Cenum)%2Fi">enum</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> { <span class="hljs-comment">// no class keyword</span>
   OptionA,
   OptionB,
   OptionC
};

MyEnum x {OptionC}; <span class="hljs-comment">// this is okay -- don't have to use MyEnum::OptionC</span>
<span class="hljs-type">int</span> y {OptionC};    <span class="hljs-comment">// this is okay -- options are integers</span>
</code></pre>
<p>You should prefer <code>enum class</code>.</p>
</div>
<a name="H_Classes"></a><h2>Classes</h2>
<p><a name="BM_(Core%20Language%5C%2FClasses)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are declared using either the <code>struct</code> keyword or <code>class</code> keyword. When ...</p>
<ul>
<li><code>struct</code> is used, the default visibility of <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a>s is public.</li>
<li><code>class</code> is used, the default visibility of <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a>s is private.</li>
</ul>
<p>Public and private visibility are the same as in most other languages: private <a href="#BM_%5Cb(member)%2Fi">member</a>s aren't accessible outside the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> while public <a href="#BM_%5Cb(member)%2Fi">member</a>s are. In C++ nomenclature, ...</p>
<ul>
<li><a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s are commonly referred to as <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s.</li>
<li><a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are commonly referred to as <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>{
        count += <span class="hljs-number">1</span>;
        flag = <span class="hljs-literal">false</span>;
    }
};
</code></pre>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that contain only data are called <a href="#BM_(plain-old-data%20class%7Cplain-old%20data%20class%7Cplain%20old%20data%20class%7Cplain-old-data%20structure%7Cplain-old%20data%20structure%7Cplain%20old%20data%20structure%7Cplain-old-data%20struct%7Cplain-old%20data%20struct%7Cplain%20old%20data%20struct)%2Fi">plain-old-data class</a>es (<a href="#BM_(POD)%2F">POD</a>), and they're typically created using the <code>struct</code> keyword so as their <a href="#BM_%5Cb(member)%2Fi">member</a>s are all accessible by default.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count;
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
   <span class="hljs-type">bool</span> flag;
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>C++ guarantees that a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>'s <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s will be sequentially stored in memory, but they may be padded / aligned based on the platform. Be aware when using the <a href="#BM_(sizeof)%2Fi">sizeof</a> operator.</p>
</div>
<a name="H_This%20Pointer"></a><h3>This Pointer</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>Non-static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have access to an implicit <a href="#BM_(pointer)%2Fi">pointer</a> called <code>this</code>, which allows for accessing that <a href="#BM_(object%7Cinstance)%2Fi">instance</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s. As long as the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> doesn't conflict with any parameter name of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked, the usage of that name will implicitly <a href="#BM_(reference)%2Fi">reference</a> the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<p>The <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator (-&gt;) allows for <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a <a href="#BM_(pointer)%2Fi">pointer</a> and accessing a <a href="#BM_%5Cb(member)%2Fi">member</a> on the result in a more concise form.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">f1</span>(<span class="hljs-type">int</span> count) {
        <span class="hljs-keyword">this</span>-&gt;count = count;  <span class="hljs-comment">// equivalent to (*this).count = count</span>
        flag = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-built_in">f2</span>(<span class="hljs-type">int</span> count, <span class="hljs-type">bool</span> flag) {
        <span class="hljs-keyword">this</span>-&gt;count = count;  <span class="hljs-comment">// equivalent to (*this).count = count</span>
        <span class="hljs-keyword">this</span>-&gt;flag = flag;    <span class="hljs-comment">// equivalent to (*this).flag = flag</span>
    }
}
</code></pre>
<a name="H1_Constant"></a><h3>Constant</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConstant)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FConstant)_TOPIC%2F">Core Language/Variables/Constant</a></li>
</ul>
</div>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>const</code> before the type has the same meaning as a <code>const</code> variable at global scope: It's unmodifiable.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>const</code> after the parameter list indicates that the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>'s <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s won't be modified (read-only). This is a deep check rather than a shallow check, meaning that the entire call graph is considered when checking for modification.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inner</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
        x = n;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
    Inner inner;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        a = <span class="hljs-number">5</span>;  <span class="hljs-comment">// NOT okay -- no mutation allowed</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        inner.x = <span class="hljs-number">15</span>; <span class="hljs-comment">// NOT okay -- no mutation allowed, even though this is deeper down</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        inner.<span class="hljs-built_in">change</span>(<span class="hljs-number">15</span>); <span class="hljs-comment">// NOT okay -- method being invoked must be const (otherwise mutation might happen)</span>
    }
};
</code></pre>
<a name="H1_Volatile"></a><h3>Volatile</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FVolatile)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FVolatile)_TOPIC%2F">Core Language/Variables/Volatile</a></li>
</ul>
</div>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>volatile</code> before the type has the same meaning as a <code>volatile</code> variable at global scope: The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't optimize its access.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>volatile</code> after the parameter list indicates that all <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s should be treated as <code>volatile</code> (access won't be optimized away or re-ordered). This is a deep check rather than a shallow check, meaning that the entire call graph requires <code>volatile</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Another way to think of this is that the <code>volatile</code> on a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> makes it treat the <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> as if the variable that was declaring it were <code>volatile</code> -- meaning all of its <a href="#BM_%5Cb(member)%2Fi">member</a>s are treated as <code>volatile</code> recursively down the <a href="#BM_(object%7Cinstance)%2Fi">object</a> tree.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inner</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-keyword">volatile</span> </span>{
        x = n;
        x = n;
        x = n;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
    <span class="hljs-type">int</span> b {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> </span>{
        a = b;
        b = a;
        inner.<span class="hljs-built_in">change</span>(<span class="hljs-number">15</span>); 
    }
};
</code></pre>
<a name="H2_Common%20Attributes"></a><h3>Common Attributes</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FCommon%20Attributes)_TOPIC%2F"></a><strong></strong></p>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it sees it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Static"></a><h3>Static</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FStatic)_TOPIC%2F"></a><strong></strong></p>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>static</code> before the type indicates that the function is independent of any <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type: a <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> points the same memory across all <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>static</code> before the return type indicates that the function is independent of any <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type, meaning that the only <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s that a <code>static</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> can access are <code>static</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s.</p>
<p><code>static</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s and <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are accessed using the <a href="#BM_(scope%20resolution)%2Fi">scope resolution</a> (::) operator, where the scope is the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a {<span class="hljs-number">1</span>};
    <span class="hljs-type">int</span> b {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> <span class="hljs-title">double_it</span><span class="hljs-params">()</span> </span>{
        a *= <span class="hljs-number">2</span>; 
    }
};

X::<span class="hljs-built_in">double_it</span>();  <span class="hljs-comment">// call using scoped resolution</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Be careful, <code>static</code> has a different meaning for functions than it does for <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FObject%20Lifecycle%2FStatic%20Objects)_TOPIC%2F">Core Language/Object Lifecycle/Static Objects</a></li>
<li><a href="#BM_(Core%20Language%5C%2FLinker%20Behaviour%2FStatic%20Linkage)_TOPIC%2F">Core Language/Linker Behaviour/Static Linkage</a></li>
</ul>
</div>
<a name="H_Construction"></a><h3>Construction</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are allowed one or more <a href="#BM_(constructor)%2Fi">constructor</a>s that initialize the <a href="#BM_(object%7Cinstance)%2Fi">object</a>. Similar to Java, each <a href="#BM_(constructor)%2Fi">constructor</a> should have the same name as the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself, no return type, and a unique parameter list.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyStruct</span>() {
        count = <span class="hljs-number">0</span>;
        flag = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-type">int</span> initialCount, <span class="hljs-type">bool</span> initialFlag) {
        <span class="hljs-keyword">this</span>-&gt;count = initialCount;
        <span class="hljs-keyword">this</span>-&gt;flag = initialFlag;
    }
}
</code></pre>
<p>The above <a href="#BM_(constructor)%2Fi">constructor</a>s are using the <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator (-&gt;) to access the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>. Non-static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have access to an implicit <a href="#BM_(pointer)%2Fi">pointer</a> called <code>this</code>, which allows for accessing that <a href="#BM_(object%7Cinstance)%2Fi">instance</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s. The <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator allows for <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a <a href="#BM_(pointer)%2Fi">pointer</a> and accessing a <a href="#BM_%5Cb(member)%2Fi">member</a> on the result in a more concise form.</p>
<pre class="hljs"><code><span class="hljs-keyword">this</span>-&gt;count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// equivalent to (*this).member = 0</span>
</code></pre>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> offers <a href="#BM_(constructor)%2Fi">constructor</a>s, the least error-prone way to invoke it is to use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>: <code>MyStruct x { 5, true }</code>. The reason is that C++ has so many <a href="#BM_(object%20initialization)%2Fi">object initialization</a> foot-guns that, while simpler <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s may work (e.g. <code>MyStruct x(5, true)</code>), those <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s may end up being interpreted by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> as something else that's entirely different (e.g. function declaration).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This ambiguity is often referred to as the "most vexing parse" problem.</p>
</div>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a>es that don't have any <a href="#BM_(constructor)%2Fi">constructor</a>s declared get an implicit <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> that zeros out the memory of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (speculation). If the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a <a href="#BM_(POD)%2F">POD</a>, a <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> that is ...</p>
<ul>
<li>empty will zero out the memory for all <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s, (implicit <a href="#BM_(default%20constructor)%2Fi">default constructor</a>).</li>
<li>non-empty will set the individual <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s, in the order they're declared in.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count;
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
   <span class="hljs-type">bool</span> flag;
};

MyStruct a;                    <span class="hljs-comment">// initialized to zeroed out memory (via implicit constructor)</span>
MyStruct b {};                 <span class="hljs-comment">// initialized to zeroed out memory (via implicit constructor)</span>
MyStruct b {<span class="hljs-number">5</span>, <span class="hljs-string">"steve"</span>, <span class="hljs-literal">true</span>}; <span class="hljs-comment">// initialized to supplied arguments</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://stackoverflow.com/a/49802943">here</a> for more information. The = operator won't result in a copy or anything like that (meaning performance won't suffer).</p>
</div>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> does explicitly declare <a href="#BM_(constructor)%2Fi">constructor</a>s, the implicit <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> won't be generated. If desired, a <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> may be declared with the default behaviour of the implicit zero arg <a href="#BM_(constructor)%2Fi">constructor</a> by adding <code>= default</code> instead of a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> body.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyStruct</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-type">int</span> initialCount, <span class="hljs-type">bool</span> initialFlag) {
        <span class="hljs-keyword">this</span>-&gt;count = initialCount;
        <span class="hljs-keyword">this</span>-&gt;flag = initialFlag;
    }
}
</code></pre>
<p>A <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> may be initialized to a value either through <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a> or the <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer list</a>. For <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>s, the initialization is done directly in the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>'s declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count {<span class="hljs-number">5</span>};
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>] {<span class="hljs-string">"steve"</span>};
   <span class="hljs-type">bool</span> flag {<span class="hljs-literal">true</span>};
};
</code></pre>
<p>In contrast, a <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer list</a> is a comma separated list of <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>s for the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. It's specified just before a <a href="#BM_(constructor)%2Fi">constructor</a>'s body.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-built_in">MyStruct</span>(): count{<span class="hljs-number">0</span>}, flag{<span class="hljs-literal">false</span>} {
    }
}
</code></pre>
<p>Each item in the comma separated list is called a <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>How is this better than <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>, where initialization is done directly after the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> declaration? According to <a href="https://stackoverflow.com/a/48098997">this</a>, it's more-or-less the same?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FDeleted%20Implementations)_TOPIC%2F">Core Language/Classes/Deleted Implementations</a></li>
</ul>
</div>
<a name="H_Destruction"></a><h3>Destruction</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FDestruction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are allowed an explicit cleanup function called a <a href="#BM_(destructor)%2Fi">destructor</a> (e.g. closing an open file handle, zeroing out memory for security purposes, etc..). A <a href="#BM_(destructor)%2Fi">destructor</a> is declared similarly to a <a href="#BM_(constructor)%2Fi">constructor</a>, the only differences being ...</p>
<ol>
<li>a tilde must appear just before the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> / function name.</li>
<li>it doesn't take in any arguments.</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count {<span class="hljs-number">5</span>};
    <span class="hljs-type">bool</span> flag {<span class="hljs-literal">true</span>};

    <span class="hljs-keyword">public</span>:
    ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
<p><a href="#BM_(destructor)%2Fi">Destructor</a>s must never be called directly by the user. Treat any <a href="#BM_(destructor)%2Fi">destructor</a> as if it were marked with <code>noexcept</code>. That is, an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> should never be thrown in a <a href="#BM_(destructor)%2Fi">destructor</a>. When an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> gets thrown, the call stack unwinds. As each function exits, the <a href="#BM_(destructor)%2Fi">destructor</a>s for <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic variable</a>s of that function get invoked. Another <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> getting thrown while one is already in flight means two <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s would be in flight, which isn't supported.</p>
<p>If a <a href="#BM_(destructor)%2Fi">destructor</a> isn't declared, an empty one is implicitly generated.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>When inheritance is involved, it's almost always to make the <a href="#BM_(destructor)%2Fi">destructor</a> a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FInheritance)_TOPIC%2F">Core Language/Classes/Inheritance</a></li>
</ul>
</div>
<a name="H_Copying"></a><h3>Copying</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FDeleted%20Implementations)_TOPIC%2F">Core Language/Classes/Deleted Implementations</a></li>
</ul>
</div>
<p>There are two built-in mechanisms for copying in C++: the <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> and <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a>.</p>
<p>A <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is a <a href="#BM_(constructor)%2Fi">constructor</a> that has a single parameter, a <a href="#BM_(reference)%2Fi">reference</a> to a <code>const</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a default <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> if one hasn't been explicitly declared by the user. The <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> of this default <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is to copy each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> individually, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<p><a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">Member-wise copy</a>ing may not be the correct way to copy in certain cases, in which case a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> should be explicitly provided with the correct <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) {
        <span class="hljs-keyword">this</span>-&gt;db = DatabaseConnection {orig.db.host, orig.db.port}; <span class="hljs-comment">// make a new db connection instead of using orig's</span>
        <span class="hljs-keyword">this</span>-&gt;max = orig.max;
    }
}


MyStruct x {host, port};
MyStruct y {x}; <span class="hljs-comment">// both x and y are independent and equal, but y has its own DatabaseConnection</span>
</code></pre>
<p>Similarly, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked when the assignment operator is used, called an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>. Unlike <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>s, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> is required to clean up any resources in the destination <a href="#BM_(object%7Cinstance)%2Fi">object</a> prior to copying. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> if one hasn't been explicitly declared by the user. The <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> of this default <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is to assign each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> individually, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) { <span class="hljs-comment">// only do if assigning to self</span>
            <span class="hljs-keyword">this</span>-&gt;db.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// close existing db connection</span>
            <span class="hljs-keyword">this</span>-&gt;db = DatabaseConnection {orig.db.host, orig.db.port}; <span class="hljs-comment">// make a new db connection</span>
            <span class="hljs-keyword">this</span>-&gt;max = orig.max;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return self -- this should always be the case??</span>
    }
}
</code></pre>
<p>To suppress the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> from allowing copying or assignment of an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, add <code> = delete</code> after both signatures instead of specifying a body. This is important if the <a href="#BM_(object%7Cinstance)%2Fi">object</a> holds on to an uncopyable resource such as a lock.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">delete</span>;
    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">delete</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>If using the defaults, the book recommends explicitly declaring the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s but adding <code> = default</code> after both signatures instead of specifying a body. The reason is that the default is almost always wrong, so if you tack this on it makes it explicit to others that you intended this.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">default</span>;
    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">default</span>;
}
</code></pre>
<p>ALSO, there's ambiguity around when the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates default move/copy/<a href="#BM_(destructor)%2Fi">destructor</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s. It might be <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specific. The book recommends that if you're using the defaults, always set them to <code>= default</code> (or do <code>= delete</code> to disallow them).</p>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> MyStruct {
...</p>
<pre><code>// copy
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// move
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// destructor
~MyStruct() = default;
</code></pre>
<p>}
```</p>
</div>
<a name="H_Moving"></a><h3>Moving</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F">Core Language/Classes/Copying</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FDeleted%20Implementations)_TOPIC%2F">Core Language/Classes/Deleted Implementations</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
</ul>
</div>
<p>There are two built-in mechanisms for moving in C++: the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> and <a href="#BM_(move%20assignment)%2Fi">move assignment</a>. Moving is different from copying in that moving actually guts the insides (data) of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> and transfers it into another, leaving that <a href="#BM_(object%7Cinstance)%2Fi">object</a> in an invalid state. If the scenario allows for it, moving is oftentimes more efficient than copying.</p>
<p>A <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is a <a href="#BM_(constructor)%2Fi">constructor</a> that has a single parameter, an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a default <a href="#BM_(move%20constructor)%2Fi">move constructor</a> if one hasn't been explicitly declared by the user. The move semantics of this default <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is to <em>copy</em> each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> rather than actually move anything, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(MyStruct &amp;&amp;orig) <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">this</span>-&gt;str_ptr = orig.str_ptr;
        <span class="hljs-keyword">this</span>-&gt;max = orig.max;
        orig.str_ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// mark orig object as invalid</span>
        orig.max = <span class="hljs-number">-1</span>; <span class="hljs-comment">// mark orig object as invalid</span>
    }
}

MyStruct a {};
MyStruct c { std::<span class="hljs-built_in">move</span>(a) };  <span class="hljs-comment">// std::move returns MyObject &amp;&amp; type, which calls MyObject's move constructor</span>
<span class="hljs-comment">// a is in an invalid state</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Don't <code>std::move</code> into a variable and pass that variable to the <a href="#BM_(constructor)%2Fi">constructor</a>. The reason is that the variable will be treated as an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> (an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> to an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>), meaning that the <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> will get invoked instead of the <a href="#BM_(move%20constructor)%2Fi">move constructor</a>.</p>
</div>
<p>In the example above, the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> has <code>noexcept</code> set to indicate that it will never throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. <a href="#BM_(move%20constructor)%2Fi">Move constructor</a>s that can throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s are problematic for the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to use. If a <a href="#BM_(move%20constructor)%2Fi">move constructor</a> throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, the source <a href="#BM_(object%7Cinstance)%2Fi">object</a> will likely enter into an inconsistent state, meaning the program will likely be in an inconsistent state. As such, if the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> sees that the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> can throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, it'll prefer to copy it instead.</p>
<p>Similarly to the <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, <a href="#BM_(move%20assignment)%2Fi">move assignment</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked when the assignment operator is used, called an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>. It has the same parameter list and it shouldn't throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s either (<code>noexcept</code>), the only difference is that it returns a <a href="#BM_(reference)%2Fi">reference</a> to itself at the end.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    MyStruct&amp; <span class="hljs-keyword">operator</span>=(MyStruct &amp;&amp;orig) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) { <span class="hljs-comment">// only do if assigning to self</span>
            <span class="hljs-keyword">this</span>-&gt;str_ptr = orig.str_ptr;
            <span class="hljs-keyword">this</span>-&gt;max = orig.max;
            orig.str_ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// mark orig object as invalid</span>
            orig.max = <span class="hljs-number">-1</span>; <span class="hljs-comment">// mark orig object as invalid</span>
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return self -- this should always be the case??</span>
    }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's ambiguity around when the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates default move/copy/<a href="#BM_(destructor)%2Fi">destructor</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s. It might be <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specific. The book recommends that if you're using the defaults, always set them to <code>= default</code> (or do <code>= delete</code> to disallow them).</p>
<pre><code>class MyStruct {
    ...

    // copy
    MyStruct(MyStruct &amp;&amp;orig) = default;
    MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
    // move
    MyStruct(MyStruct &amp;&amp;orig) = default;
    MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
    // destructor
    ~MyStruct() = default;
}
</code></pre>
</div>
<a name="H_Default%20Implementations"></a><h3>Default Implementations</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FDefault%20Implementations)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
</ul>
</div>
<p>The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may automatically generate default implementations for some <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s (e.g. <a href="#BM_(default%20constructor)%2Fi">default constructor</a>), called <a href="#BM_(special%20member%20function)%2Fi">special member function</a>s. However, under certain conditions, it may choose to omit generating them. If the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> chooses to not generate a default implementation where one was expected, it's possible to force the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate that function by explicitly declaring it but replacing the function body <code>= default</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-built_in">MyStruct</span>() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">// forcefully generate default constructor</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Reasons why a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may decide to skip generating a function: it doesn't think it's needed, it doesn't think the behavior will be correct, ...?</p>
</div>
<a name="H_Deleted%20Implementations"></a><h3>Deleted Implementations</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FDeleted%20Implementations)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
</ul>
</div>
<p>The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may automatically generate default implementations for some <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s (e.g. <a href="#BM_(default%20constructor)%2Fi">default constructor</a>), called <a href="#BM_(special%20member%20function)%2Fi">special member function</a>s. There are two ways to turn off these automatically generated <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s. The first way is to declare the function but make it privately scoped so that nothing outside can access it.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">MyStruct</span>() { };             <span class="hljs-comment">// default constructor is private</span>
}
</code></pre>
<p>The second way is to explicitly declare the function but mark it as deleted by appending <code>= delete</code> in place of the function body.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-built_in">MyStruct</span>() = <span class="hljs-keyword">delete</span>;        <span class="hljs-comment">// default constructor is forcefully deleted</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The 2nd way is the more "modern" way to do it.</p>
</div>
<a name="H_Inheritance"></a><h3>Inheritance</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FInheritance)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FDestruction)_TOPIC%2F">Core Language/Classes/Destruction</a></li>
</ul>
</div>
<p>In C++, a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inherits another <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> by, just after its name, appending a colon (:) followed by the name of the parent <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyChild</span> : MyParent {
};
</code></pre>
<p>Like in most other <a href="#BM_(object%7Cinstance)%2Fi">object</a> oriented languages, a child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>...</p>
<ul>
<li>can access the non-private <a href="#BM_%5Cb(member)%2Fi">member</a>s of any of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es it inherits.</li>
<li>is assignable to the type of any of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es it inherits.</li>
</ul>
<pre class="hljs"><code>MyChild c {};
MyParent p {x}; <span class="hljs-comment">// MyChild inherits from MyParent, meaning that it's assignable to MyParent</span>
</code></pre>
<p>To be able to override a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in a child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the same way as it's done in other languages (e.g. Java), the base call must have the <code>virtual</code> keyword prepended on the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, making it a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>. Similarly, any <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> that overrides a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> should have the <code>override</code> keyword appended just after the parameter list.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>override</code> isn't strictly required, but it's a hint that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> can use to prevent you from making a mistake (e.g. it sees <code>override</code> but what's being overridden isn't <code>virtual</code>). It's similar to Java's <code>@Override</code> annotation.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">()</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
};
</code></pre>
<p>If the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> and child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have the exact same non-<a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>, which <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> gets called depends on the type of the variable.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ ... }
};


MyChild c {};
MyChild  &amp;cref {x};
MyParent &amp;pref {x};
cref.<span class="hljs-built_in">non_virt_method</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// calls MyChild::non_virt_method()</span>
pref.<span class="hljs-built_in">non_virt_method</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// calls MyParent::non_virt_method() even though object is a MyChild</span>
</code></pre>
<p>To prevent a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> from being overridable at all, add the <code>final</code> keyword just after the parameter list.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{ ... }  <span class="hljs-comment">// ERROR HERE -- not allowed</span>
};
</code></pre>
<p>Similarly, to prevent the entire <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself from being inheritable, add the <code>final</code> keyword just after the name.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> <span class="hljs-keyword">final</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{ ... }
};
</code></pre>
<p>C++ chains <a href="#BM_(constructor)%2Fi">constructor</a> and <a href="#BM_(destructor)%2Fi">destructor</a> invocations appropriately as expected. The one caveat is that <a href="#BM_(destructor)%2Fi">destructor</a>, if not a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>, will use the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> resolution mechanism described above: If the type of the variable doesn't match the <a href="#BM_(object%7Cinstance)%2Fi">object</a> (variable type is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but <a href="#BM_(object%7Cinstance)%2Fi">object</a> is not), the wrong <a href="#BM_(destructor)%2Fi">destructor</a> gets invoked, resulting in <a href="#BM_(object%7Cinstance)%2Fi">object</a> potentially not cleaning up resources (e.g. closing file handles).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    ~<span class="hljs-built_in">MyParent</span>() { ... };
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    ~<span class="hljs-built_in">MyChild</span>() { ... };
};


MyParent *c {<span class="hljs-keyword">new</span> MyChild{}};
<span class="hljs-keyword">delete</span> c;  <span class="hljs-comment">// calls MyParent's destructor instead of MyChild's destructor</span>
</code></pre>
<p>When inheritance is involved, it's almost always a good idea to enforce a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>. Since not having a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a> sometimes makes sense (e.g. user determined that it's safe to omit it and as such omitted it to improve performance), the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't produce a warning if it isn't virtual.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() { ... };
};
</code></pre>
<a name="H_Interfaces"></a><h3>Interfaces</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FInterfaces)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FInheritance)_TOPIC%2F">Core Language/Classes/Inheritance</a></li>
</ul>
</div>
<p>Interfaces and abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are supported in C++, but not in the same way as other high-level languages. The C++ approach to interfaces is to explicitly mark certain <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s as requiring an implementation. This is done by appending <code>= 0</code> to the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};
</code></pre>
<p>A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> that is both a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> and requires an implementation is called a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>. A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that contains all <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s is called a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi">pure virtual class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() {};  <span class="hljs-comment">// also okay to do   "virtual ~MyParent() = default"</span>
};
</code></pre>
<p>As shown in the example above, a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi">pure virtual class</a> should have a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>. While not required, failing to do so means that the wrong <a href="#BM_(destructor)%2Fi">destructor</a> may get invoked if the type of the variable doesn't match the <a href="#BM_(object%7Cinstance)%2Fi">object</a> (variable type is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but <a href="#BM_(object%7Cinstance)%2Fi">object</a> is not), resulting in <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> resources being left open (e.g. file handles).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See inheritance section for a more thorough explanation.</p>
</div>
<a name="H_Operator%20Overloading"></a><h3>Operator Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FOperators)_TOPIC%2F">Core Language/Operators</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es support <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing.</p>
<p>Operators are <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>-able in two ways. To <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> an operator the first way, introduce a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> but instead of naming it, add the <code>operator</code> keyword followed by the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed. The parameters and return type of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> need to match whatever types the operator is intended to deal with.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...

    <span class="hljs-comment">// MyClass + int -- notice whitespace between 'operator' keyword and operator -- this is okay.</span>
    MyClass <span class="hljs-keyword">operator</span> +(<span class="hljs-type">int</span> rhs) <span class="hljs-keyword">const</span> {
        MyClass ret { <span class="hljs-keyword">this</span>-&gt;value + x };
        <span class="hljs-keyword">return</span> ret;
    };

    <span class="hljs-comment">// MyClass + MyClass</span>
    MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;rhs) <span class="hljs-keyword">const</span> {
        MyClass ret { <span class="hljs-keyword">this</span>-&gt;value + rhs.value };
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-comment">// MyClass += MyClass</span>
    MyClass&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyClass &amp;rhs) {
        <span class="hljs-keyword">this</span>-&gt;value += x-&gt;value;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>
<p>To <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> an operator the second way, introduce a function (not a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>) using the <code>operator</code> keyword followed by the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed. In the examples above, the left-hand side was the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>. When using this second way, a left-hand side needs to be explicitly provided as the first parameter while the right-hand side is the second argument.</p>
<pre class="hljs"><code><span class="hljs-comment">// MyClass + int</span>
MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-type">int</span> rhs) {
    MyClass ret { lhs.value + x };
    <span class="hljs-keyword">return</span> ret;
};

<span class="hljs-comment">// MyClass + MyClass</span>
MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">// MyClass += MyClass</span>
MyClass &amp; <span class="hljs-keyword">operator</span>+=(MyClass &amp;rhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    lhs.value += rhs.value;
    <span class="hljs-keyword">return</span> lhs;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Evidently the two ways described above aren't equivalent. The second way has some added benefits. See <a href="https://stackoverflow.com/a/10958716">here</a>.</p>
</div>
<p>Note how the <code>const</code> keyword is added to the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in cases where the operator shouldn't modify itself. Similarly, when the argument for a parameter shouldn't be changed, <code>const</code> is used on that parameter. <code>const</code>-ness depends on the scenario. For example, the second <code>operator+</code> requires two <a href="#BM_(reference)%2Fi">reference</a>s to <code>const</code> types.</p>
<pre class="hljs"><code>MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p>Those <code>const</code>s ensure that the operands aren't changed in the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>. Imagine that you're performing <code>x = y + z</code>. It doesn't make sense for <code>y</code> or <code>z</code> to get modified.</p>
<p>The signature could have just as well been modified to be the types themselves rather than <code>const</code> <a href="#BM_(reference)%2Fi">reference</a>s, in which case both the left-hand side and right-hand side would get copied on invocation of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> (modifications to copies don't matter).</p>
<pre class="hljs"><code>MyClass <span class="hljs-keyword">operator</span>+(MyClass lhs, MyClass rhs) {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://gist.github.com/beached/38a4ae52fcadfab68cb6de05403fa393">here</a> for a list of operators and their signatures (still incomplete).</p>
<p>There's also the option to create operators that allow for implicit type casting and explicit type casting. See the type casting section for more information.</p>
</div>
<a name="H_Three-way%20Comparison%20Overloading"></a><h3>Three-way Comparison Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FThree-way%20Comparison%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p>The three-way comparison operator, also called the <a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a>, is a more terse way of providing comparison operators for a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. Typically, if a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is sortable and comparable, it should provide <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s for the typical comparison operators:</p>
<ul>
<li>equality (==)</li>
<li>inequality (!=)</li>
<li>less-than (&lt;)</li>
<li>less-than or equal (&lt;=)</li>
<li>greater-than (&gt;)</li>
<li>greater-than or equal (&gt;=)</li>
</ul>
<p>The three-way comparison operator bundles <em>at least</em> the last four of those (potentially all of them) into a single operator, where the symbol for that operator is an equal-sign sandwiched between angle brackets (&lt;=&gt;).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">int</span> hour;
    <span class="hljs-type">int</span> minute;
};

std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(MyClass&amp; lhs, MyClass&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">if</span> (lhs.hour &lt; rhs.hour) {
        <span class="hljs-keyword">return</span> std::strong_ordering::less;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lhs.hour &gt; rhs.hour) {
        <span class="hljs-keyword">return</span> std::strong_ordering::greater;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (lhs.minute &lt; rhs.minute) {
            <span class="hljs-keyword">return</span> std::strong_ordering::less;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lhs.minute &gt; rhs.minute) {
            <span class="hljs-keyword">return</span> std::strong_ordering::greater;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> std::strong_ordering::equal;
        }
    }
}

<span class="hljs-comment">// Test</span>
MyClass lunch_time {<span class="hljs-number">12</span>, <span class="hljs-number">00</span>};
MyClass sleep_time {<span class="hljs-number">22</span>, <span class="hljs-number">00</span>};
std::cout &lt;&lt; <span class="hljs-string">"&lt;= via spaceship operator: "</span> &lt;&lt; (lunch_time &lt;= sleep_time) &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// You can also call the spaceship operator directly:   std::strong_ordering res {lunch_time &lt;=&gt; sleep_time}</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Not sure why but when the above <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> (instead of a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>) the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> starts producing a bunch of warnings.</p>
</div>
<p>Note that the above is comparing each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a> in the order it's declared. The default <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> implementation of the <a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a> will do exactly the same thing. Had the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inherited from some other <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the default implementation would first compare the parent <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es (left-right order -- C++ has multiple inheritance) before comparing the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s in the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">int</span> hour;
    <span class="hljs-type">int</span> minute;
    std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(MyClass&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;
};
</code></pre>
<p>In addition, a default <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> implementation provides both equality (==) and inequality (!=) support. The <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> implementation in the first example does not support either -- their <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s need to be added manually.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://stackoverflow.com/a/58780946">here</a> for reasoning.</p>
</div>
<p>There are three types of ordering supported by the <a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a>:</p>
<ul>
<li>
<p><code>std::strong_ordering</code> - equality (==) means that one <a href="#BM_(object%7Cinstance)%2Fi">object</a> may be substituted for the other (they are the same).</p>
<p>Possible values:</p>
<ul>
<li><code>std::strong_ordering::less</code> for less-than</li>
<li><code>std::strong_ordering::greater</code> for greater-than</li>
<li><code>std::strong_ordering::equal</code> for equality</li>
</ul>
<p>Examples:</p>
<ul>
<li>Comparing circles by their radius. A circle with a radius of 5 is the same as another circle with a radius of 5.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Strong ordering is sometimes also referred to as total ordering.</p>
</div>
</li>
<li>
<p><code>std::weak_ordering</code> - equality (==) means that one <a href="#BM_(object%7Cinstance)%2Fi">object</a> substitution isn't guaranteed (they may not be the same even though they're equivalent).</p>
<p>Possible values:</p>
<ul>
<li><code>std::weak_ordering::less</code> for less-than</li>
<li><code>std::weak_ordering::greater</code> for greater-than</li>
<li><code>std::weak_ordering::equivalent</code> for equivalence (note that this is NOT equality -- it's equivalence)</li>
</ul>
<p>Examples:</p>
<ul>
<li>Comparing rectangles by their area: A rectangle that's 1-by-15 has the same area as a rectangle that's 5-by-3, but those rectangles are not the same.</li>
<li>Comparing strings while ignoring case: The string <code>"hello world"</code> is equivalent to <code>"HELLO WORLD"</code>, but the two strings aren't the same.</li>
</ul>
</li>
<li>
<p><code>std::partial_ordering</code> -- same as <code>std::weak_ordering</code>, but with the addition that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s may not be comparable at all.</p>
<p>Possible values:</p>
<ul>
<li><code>std::partial_ordering::less</code> for less-than</li>
<li><code>std::partial_ordering::greater</code> for greater-than</li>
<li><code>std::partial_ordering::equivalent</code> for equivalence (Note that this is NOT equality -- it's equivalence)</li>
<li><code>std::partial_ordering::unordered</code> the <a href="#BM_(object%7Cinstance)%2Fi">object</a>s weren't comparable</li>
</ul>
<p>Examples:</p>
<ul>
<li>Comparing floating point numbers: The number <code>3.5</code> is not comparable at all to <code>NaN</code> (not a number).</li>
</ul>
</li>
</ul>
<p>The return type defined for the <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> provides context to the user as to how the <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are comparable.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Source of ordering types is <a href="https://news.ycombinator.com/item?id=20551212">here</a>.</p>
<p><a href="https://news.ycombinator.com/item?id=20550165">Here</a> talks about the importance of choosing the right ordering type.</p>
<p>The rectangle example was lifted from <a href="https://blog.tartanllama.xyz/spaceship-operator/">here</a>.</p>
</div>
<a name="H_Conversion%20Overloading"></a><h3>Conversion Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConversion%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FImplicit%20Conversion)_TOPIC%2F">Core Language/Variables/Implicit Conversion</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion)_TOPIC%2F">Core Language/Variables/Explicit Conversion</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es support both <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>s and <a href="#BM_(explicit%20type%20conversion)%2Fi">explicit type conversion</a>s via <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing. <a href="#BM_(implicit%20type%20conversion)%2Fi">Implicit type conversion</a>s are represented as <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s where the name of the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed is the destination type and the return type is omitted.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt; value / <span class="hljs-number">42</span>;
    }
};
...
MyClass cls {};
<span class="hljs-type">int</span> x {cls}; <span class="hljs-comment">// triggers operator overload method</span>
</code></pre>
<p><a href="#BM_(explicit%20type%20conversion)%2Fi">Explicit type conversion</a>s are enabled the same way as <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>s, except the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is preceded by the <code>explicit</code> keyword. The <code>explicit</code> keyword makes it so that conversion to that type requires a <code>static_cast</code></p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt; value / <span class="hljs-number">42</span>;
    }
};
...
MyClass cls {};
<span class="hljs-type">int</span> x {<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(cls)};  <span class="hljs-comment">// static_cast required to trigger operator overload method</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book recommends preferring explicit over implicit because implicit is a source for confusion.</p>
<p>Do these still qualify as <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s? Return types should be there.</p>
</div>
<a name="H_Const%20%2F%20Volatile%20Overloading"></a><h3>Const / Volatile Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConst%20%2F%20Volatile%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstant)_TOPIC%2F">Core Language/Classes/Constant</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FVolatile)_TOPIC%2F">Core Language/Classes/Volatile</a></li>
</ul>
</div>
<p>In addition to following the same <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing rules as <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> may be <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed based on whether the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a> is to a <code>volatile</code> and / or <code>const</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"non-const non-volatile\n"</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"const non-volatile\n"</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"non-const volatile\n"</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"const volatile\n"</span>;
        <span class="hljs-keyword">return</span> counter;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> counter;
};


MyClass c1{};
c1.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "non-const non-volatile"</span>
<span class="hljs-keyword">const</span> MyClass c2{};
c2.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "const non-volatile"</span>
<span class="hljs-keyword">volatile</span> MyClass c3{};
c3.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "non-const volatile"</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span> MyClass c4{};
c4.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "const volatile"</span>
</code></pre>
<a name="H_Reference%20Overloading"></a><h3>Reference Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FReference%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<p>In addition to following the same <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing rules as <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> may be <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed based on whether the <code>this</code> <a href="#BM_(reference)%2Fi">reference</a> is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a> or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a>. To target ...</p>
<ul>
<li><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a>, add an ampersand (&amp;) after the parameter list</li>
<li><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a>, add two ampersands (&amp;&amp;) after the parameter list</li>
</ul>
<p>The benefit of <a href="#BM_(reference)%2Fi">reference</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing is being able to define a version of the function with efficient move semantics when the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is transient.</p>
<pre class="hljs"><code><span class="hljs-comment">// THIS EXAMPLE WAS LIFTED FROM https://docs.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170#ref-qualifiers</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>() {<span class="hljs-comment">/*expensive initialization*/</span>}
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> &amp; </span>{
        std::cout &lt;&lt; <span class="hljs-string">"lvalue\n"</span>;
        <span class="hljs-keyword">return</span> _data;
    }
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> &amp;&amp; </span>{
        std::cout &lt;&lt; <span class="hljs-string">"rvalue\n"</span>;
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(_data);
    }
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; _data;
};


MyClass c {};
<span class="hljs-keyword">auto</span> v {c.<span class="hljs-built_in">get_data</span>()}; <span class="hljs-comment">// get a copy. prints "lvalue".</span>
<span class="hljs-keyword">auto</span> v2 {<span class="hljs-built_in">C</span>().<span class="hljs-built_in">get_data</span>()}; <span class="hljs-comment">// get the original. prints "rvalue"</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The website said <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a>, but does it mean <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">gl-value</a>?</p>
</div>
<a name="H_Functors"></a><h3>Functors</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a></li>
</ul>
</div>
<p>A <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, also called a <a href="#BM_(functor%7Cfunction%20object)%2Fi">function object</a>, is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can invoke as if it were a function because it has an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> for function-call.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};

MyFunctor inst{};
<span class="hljs-built_in">inst</span>(<span class="hljs-number">15</span>);  <span class="hljs-comment">// computes -15 + 5</span>
</code></pre>
<p><a href="#BM_(functor%7Cfunction%20object)%2Fi">Functor</a>s are useful because they allow for state (via <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s) and parameterization (via <a href="#BM_(constructor)%2Fi">constructor</a> arguments) but still retain a function-like syntax.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Unlike normal functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s cannot be assigned to <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s. See section on <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s.</p>
</div>
<a name="H_Friends"></a><h3>Friends</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FFriends)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
</ul>
</div>
<p>A friend is a function or <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that can access the non-public <a href="#BM_%5Cb(member)%2Fi">member</a>s of some other <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that it wasn't declared in.</p>
<p>For friend functions, the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be accessed needs to declare the function's prototype (function declaration) before implementations of a friend function (function definition) can exist. The prototype is included in the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> just like any other <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, but the <code>friend</code> prefix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> is tacked on.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// prototype</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span> </span>{  <span class="hljs-comment">// implementation -- friend of MyClass</span>
    <span class="hljs-keyword">return</span> -(n + obj.x);
}

<span class="hljs-comment">// test</span>
MyClass obj{};
<span class="hljs-type">int</span> t = <span class="hljs-built_in">addAndNegate</span>(obj,<span class="hljs-number">5</span>);
</code></pre>
<p>For friend <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be accessed needs to specify which outside <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is able to access it using <code>friend class</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>;  <span class="hljs-comment">// state that MyFriend can access MyClass's non-public members</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span> </span>{  <span class="hljs-comment">// function in MyFriend accessing non-public members of MyClass</span>
        <span class="hljs-keyword">return</span> -(n + obj.x);
    }
};


<span class="hljs-comment">// test</span>
MyFriend obj_friend{};
MyClass obj{};
<span class="hljs-type">int</span> t = obj_friend.<span class="hljs-built_in">addAndNegate</span>(obj,<span class="hljs-number">5</span>);
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The <code>class</code> in <code>friend class</code> may be omitted if <code>MyFriend</code> was already declared before <code>MyClass</code>. Adding the word <code>class</code> is a <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a> -- it tells the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to just believe that it exists even though it may not have come across it yet.</p>
</div>
<p>Friend functions and friend <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es may also target <a href="#BM_(template)%2Fi">template</a>d types.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, T n)</span></span>;  <span class="hljs-comment">// every addAndNegate(MyClass&amp;, T) will be a friend</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This is how C++ provides its equivalent of Java's <code>Object.toString()</code>. For each <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you want to be able to print as a string, you implement a <a href="#BM_(template)%2Fi">template</a>d friend function of the left-shift <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> (&lt;&lt;) that targets the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <code>ostream</code>, making it usable in something like <code>std::cout</code>.</p>
<pre class="hljs"><code>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> MyClass &amp;obj) {
    os &lt;&lt; obj.x &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> os;
}
</code></pre>
<p>It seems like a convoluted way to do it.</p>
</div>
<a name="H_User-defined%20Literals"></a><h3>User-defined Literals</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FUser-defined%20Literals)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p>C++ provides a way for users to define their own literals through the use of <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing, called <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s. <a href="#BM_(user-defined%20literal)%2Fi">User-defined literal</a>s wrap built-in literals and perform some operation to convert them to either another type or anothe<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>. It's identified by a unique suffix that starts with an underscore (e.g. <code>_km</code>).</p>
<p>The <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> is identified by two quotes followed by the suffix.</p>
<pre class="hljs"><code>Distance <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _km (<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) {
    <span class="hljs-keyword">return</span> Distance {n * <span class="hljs-number">1000.0</span>};
}

Distance <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _mi (<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) {
    <span class="hljs-keyword">return</span> Distance {n * <span class="hljs-number">1609.34</span>};
}

Distance d { <span class="hljs-number">1.2</span>_km + <span class="hljs-number">4.0</span>_mi };
</code></pre>
<p>As stated above, <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s must wrap an existing built-in <a href="#BM_(literal%20type)%2Fi">literal type</a>.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>integral</td>
<td><code>return_type operator"" identifier (unsigned long long int)</code></td>
</tr>
<tr>
<td>floating point</td>
<td><code>return_type operator"" identifier (long double)</code></td>
</tr>
<tr>
<td>character</td>
<td><code>return_type operator"" identifier (char)</code></td>
</tr>
<tr>
<td>wide character</td>
<td><code>return_type operator"" identifier (wchar_t)</code></td>
</tr>
<tr>
<td>utf-8 character</td>
<td><code>return_type operator"" identifier (char8_t)</code></td>
</tr>
<tr>
<td>utf-16 character</td>
<td><code>return_type operator"" identifier (char16_t)</code></td>
</tr>
<tr>
<td>utf-32 character</td>
<td><code>return_type operator"" identifier (char32_t)</code></td>
</tr>
<tr>
<td>character string</td>
<td><code>return_type operator"" identifier (char *, size_t)</code></td>
</tr>
<tr>
<td>wide character string</td>
<td><code>return_type operator"" identifier (wchar_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-8 string</td>
<td><code>return_type operator"" identifier (char8_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-16 string</td>
<td><code>return_type operator"" identifier (char16_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-32 string</td>
<td><code>return_type operator"" identifier (char32_t *, size_t)</code></td>
</tr>
<tr>
<td>raw</td>
<td><code>return_type operator"" identifier (const char *)</code></td>
</tr>
</tbody>
</table>
<p>Note that, for ...</p>
<ul>
<li>numerics, the widest possible C++ type is used for both integral (unsigned long long int) and floating point (long double).</li>
<li>characters, each character type gets its own definition.</li>
<li>strings, each string type gets its own definition.</li>
</ul>
<p>The last definition in the table above, raw, will get a character string of any numeric literal used.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _as_str (<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * n) {
    std::cout &lt;&lt; <span class="hljs-string">"input str: "</span> &lt;&lt; n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-number">123.5e+12</span>_as_str;  <span class="hljs-comment">// outputs "input str: 123.5e+12"</span>
</code></pre>
<p>The standard C++ library makes use of <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s in various places, but its identifiers don't require an underscore (_) prefix.</p>
<ul>
<li>Date-time API (chrono header): <code>std:chrono::duration d  { 2h + 15ms }</code>.</li>
<li>Complex numbers API (complex header): <code>std::complex&lt;double&gt; { (1.0 + 2.0i) * (3.0 + 4.0i) }</code>.</li>
<li>String API (string): <code>std::string str { "hello"s + "world"s }</code>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F">Library Functions/Time/Durations</a></li>
</ul>
</div>
<a name="H_Lambdas"></a><h2>Lambdas</h2>
<p><a name="BM_(Core%20Language%5C%2FLambdas)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F">Core Language/Classes/Functors</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstant)_TOPIC%2F">Core Language/Classes/Constant</a></li>
<li><a href="#BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F">Core Language/Compile-time Evaluation</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FAuto%20Syntax)_TOPIC%2F">Core Language/Templates/Auto Syntax</a></li>
</ul>
</div>
<p><a href="#BM_(lambda)%2Fi">Lambda</a>s are unnamed <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s (not functions) that are expressed in a succinct form. <a href="#BM_(lambda)%2Fi">Lambda</a>s in C++ work similarly to <a href="#BM_(lambda)%2Fi">lambda</a>s in other high-level languages. They capture copies of / <a href="#BM_(reference)%2Fi">reference</a>s to <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope such that they can be used for whatever processing the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> performs.</p>
<p>For example, consider the following <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// define</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> x) {
        <span class="hljs-keyword">this</span>-&gt;x = x;
    };

    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> a + x;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x;
};

<span class="hljs-comment">// instantiate</span>
MyFunction f1{ <span class="hljs-number">5</span> };

<span class="hljs-comment">// invoke</span>
<span class="hljs-built_in">f1</span>(<span class="hljs-number">42</span>);
</code></pre>
<p>The <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> above can be written much more succinctly as a <a href="#BM_(lambda)%2Fi">lambda</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// define and instantiate</span>
<span class="hljs-keyword">auto</span> f2 { [x=<span class="hljs-number">5</span>] (<span class="hljs-type">int</span> a) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> a + x; } };

<span class="hljs-comment">// invoke</span>
<span class="hljs-built_in">f2</span>(<span class="hljs-number">42</span>);
</code></pre>
<p>The general syntax of a <a href="#BM_(lambda)%2Fi">lambda</a> is as follows: <code>[capture-list] (parameter-list) modifiers -&gt; return-type { body }</code>. The subsections below detail this general syntax.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Be aware that, by default, the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a> in the <a href="#BM_(lambda)%2Fi">lambda</a> version is <code>const</code> and will automatically be made into a <code>constexpr</code> if it satisfies all the requirements of <code>constexpr</code>. This is discussed more in the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s subsections.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FBind)_TOPIC%2F">Library Functions/Wrappers/Bind</a></li>
</ul>
</div>
<a name="H_Capture%20List"></a><h3>Capture List</h3>
<p><a name="BM_(Core%20Language%5C%2FLambdas%2FCapture%20List)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<p><code>[capture-list]</code> is a <em>required</em> part of <code>[capture-list] (parameter-list) modifiers -&gt; return-type { body }</code> that defines and sets <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s inside the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>. It's a comma separated list where each element is a list is a variable to capture as a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>.</p>
<p>There are 3 different ways to capture <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</p>
<ul>
<li>
<p><strong>Copy</strong> a variable from the outer scope.</p>
<p>To create a copy of an individual variable into the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, put the variable's name in the capture list.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-comment">// explicitly copy x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f { [x, y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; } };
</code></pre>
<p>One way to avoid listing out individual variable names is to put <code>=</code> as the first element of the capture list. When <code>=</code> is present, missing <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s will automatically get copied as <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-comment">// explicitly copy x and implicitly copy y from outer scope</span>
<span class="hljs-keyword">auto</span> f { [=, x] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; } };
</code></pre>
<p>If used within an enclosing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a> can be captured.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f { [<span class="hljs-keyword">this</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z + <span class="hljs-keyword">this</span>-&gt;x; } };   <span class="hljs-comment">// capture this as a pointer</span>
<span class="hljs-keyword">auto</span> f { [*<span class="hljs-keyword">this</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z + <span class="hljs-keyword">this</span>-&gt;x; } };  <span class="hljs-comment">// capture a COPY OF *this and pass it in as a pointer</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It's mentioned that prior to C++20, automatic copy capturing (<code>[=]</code>) would pull in <code>this</code>. That feature has been deprecated.</p>
</div>
</li>
<li>
<p><strong><a href="#BM_(reference)%2Fi">Reference</a></strong> a variable from the outer scope.</p>
<p>To create <a href="#BM_(reference)%2Fi">reference</a> to an individual variable into the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, put the variable's name in the capture list preceded by an ampersand (&amp;).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-comment">// explicitly reference x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f { [&amp;x, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; } };
</code></pre>
<p>One way to avoid listing out individual variable names is to put <code>&amp;</code> as the first element of the capture list. When <code>&amp;</code> is present, missing <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s will automatically get <a href="#BM_(reference)%2Fi">reference</a>d as <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-comment">// explicitly reference x and implicitly reference y from outer scope</span>
<span class="hljs-keyword">auto</span> f { [&amp;, &amp;x] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; } };
</code></pre>
</li>
<li>
<p><strong>Initialize</strong> a variable using an expression.</p>
<p>When a variable name is followed by <code>=</code> and an expression, the expression is evaluated and captured.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-keyword">auto</span> f { [mod_x=x/<span class="hljs-number">2</span>, mod_y=y/<span class="hljs-number">2</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> mod_x + mod_y + z; } };
</code></pre>
<p>This is especially useful for capturing an <a href="#BM_(object%7Cinstance)%2Fi">object</a> by moving it (as opposed to copying it or referencing it).</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f { [o=std::<span class="hljs-built_in">move</span>(my_obj)] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> o.<span class="hljs-built_in">do_something</span>(z); } };
</code></pre>
</li>
</ul>
<a name="H_Parameter%20List"></a><h3>Parameter List</h3>
<p><a name="BM_(Core%20Language%5C%2FLambdas%2FParameter%20List)_TOPIC%2F"></a><strong></strong></p>
<p><code>(parameter-list)</code> is a <em>required</em> part of <code>[capture-list] (parameter-list) modifiers -&gt; return-type { body }</code> that defines the parameter list of the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 { [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; } };
<span class="hljs-keyword">auto</span> f2 { [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">99</span>) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; } };  <span class="hljs-comment">// default args</span>
<span class="hljs-keyword">auto</span> f3 { [] (<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x + y); } };  <span class="hljs-comment">// templated params (compiler deduces types based on usage)</span>
</code></pre>
<p><a href="#BM_(lambda)%2Fi">Lambda</a> parameter lists are defined similarly to standard function parameter lists. It's common for a <a href="#BM_(lambda)%2Fi">lambda</a>'s parameter list to use <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s via <code>auto</code> as is done in <code>f3</code> of the example above. The reason for using <code>auto</code> is that the <a href="#BM_(lambda)%2Fi">lambda</a> can still work even if you don't know / can't predict the exact types of the arguments passed in (e.g. you know the arguments will be integral types, but you don't know exactly which exact integral types).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>auto</code> is a placeholder for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>, and as such type deduction rules come into play. If you aren't careful, you'll end up with strange or incorrect behaviour. For example, in certain cases the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may decide to create a local copy for an argument that gets passed in where you may be expecting a <a href="#BM_(reference)%2Fi">reference</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction</a></li>
</ul>
</div>
<a name="H_Return%20Type"></a><h3>Return Type</h3>
<p><a name="BM_(Core%20Language%5C%2FReturn%20Type)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction</a></li>
</ul>
</div>
<p><code>return-type</code> is an <em>optional</em> part of <code>[capture-list] (parameter-list) modifiers -&gt; return-type { body }</code> that defines the return type of the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a>. The syntax of using an arrow and defining the type after the parameter list is called the trailing return syntax.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 { [] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> a+b; } };
<span class="hljs-keyword">auto</span> f2 { [] (MyObject* v) -&gt; <span class="hljs-keyword">const</span> MyObject&amp; { <span class="hljs-keyword">return</span> v[<span class="hljs-number">5</span>]; } };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction%2FType%20Cloning%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction/Type Cloning Deduction</a> (different use-case for trailing return type syntax)</li>
</ul>
</div>
<p>When a <a href="#BM_(lambda)%2Fi">lambda</a> doesn't provide a return type, the return type is implicitly <code>auto</code>. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> uses standard <a href="#BM_(template%20parameter)%2Fi">template parameter</a> type deduction rules to determine what the return type should be.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f3 { [] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) { <span class="hljs-keyword">return</span> a+b; } };  <span class="hljs-comment">// return deduced to int</span>
<span class="hljs-keyword">auto</span> f4 { [] (MyObject* v) { <span class="hljs-keyword">return</span> v[<span class="hljs-number">5</span>]; } };  <span class="hljs-comment">// return deduced to MyObject</span>
</code></pre>
<p>In <code>f4</code>, even though <code>v[5]</code> returns a <code>const MyObject &amp;</code>, type deduction rules evaluate it to <code>const MyObject</code> (not a <a href="#BM_(reference)%2Fi">reference</a>). That means <code>f4</code> returns a copy of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> at <code>v[5]</code> rather than a <a href="#BM_(reference)%2Fi">reference</a> to the real thing. Type deduction rules such as the one here may end up causing subtle bugs if you aren't careful.</p>
<p>Another option is to explicitly return <code>decltype(auto)</code>, which copies the exact type being returned.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f5 { [] (MyObject* v) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) { <span class="hljs-keyword">return</span> v[<span class="hljs-number">5</span>]; } };  <span class="hljs-comment">// return deduced to const MyObject&amp;</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>When unsure, it's best to explicitly declare the return type or use <code>decltype(auto)</code>.</p>
</div>
<a name="H_Modifiers"></a><h3>Modifiers</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FLambdas%2FModifiers)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction</a></li>
</ul>
</div>
<p><code>modifiers</code> is an <em>optional</em> part of <code>[capture-list] (parameter-list) modifiers -&gt; return-type { body }</code> that lists the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s of the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a>. Except for the following special cases, <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s work the same way that they do for normal functions.</p>
<ul>
<li>
<p>The <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a> is set to be a <code>constexpr</code> function if it meets the requirements of being a <a href="#BM_(constant%20expression)%2Fi">constant expression</a>. You can force it to be a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> by adding <code>constexpr</code> as one of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 { [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-keyword">constexpr</span> -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; } };  <span class="hljs-comment">// force as constant expression</span>
</code></pre>
</li>
<li>
<p>The <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a> is set to be a <code>const</code> function. You can force this off by adding <code>mutable</code> as one of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f2 { [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; } };    <span class="hljs-comment">// make non-const</span>
</code></pre>
</li>
</ul>
<a name="H_Template%20Parameters"></a><h3>Template Parameters</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FTemplate%20Parameters)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates)_TOPIC%2F">Core Language/Templates</a></li>
</ul>
</div>
<p>A <a href="#BM_(lambda)%2Fi">lambda</a> may have <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s added by injecting <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s in angle brackets between <code>[capture-list]</code> and <code>(parameter-list)</code> of the <a href="#BM_(lambda)%2Fi">lambda</a> declaration <code>[capture-list] (parameter-list) modifiers -&gt; return-type { body }</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 { [] &lt;<span class="hljs-keyword">typename</span> T&gt;(T x, T y) -&gt; T { <span class="hljs-keyword">return</span> x + y; } };
</code></pre>
<p>This is useful in cases where you need to be more explicit with the types of parameters / return types (<code>auto</code> is too loose). The most obvious case is with containers, where you likely want the underlying container type listed.</p>
<pre class="hljs"><code><span class="hljs-comment">// f2 and f3 will do the same thing when passed a std::vector, but f3 is much more explicit.</span>
<span class="hljs-keyword">auto</span> f2 { [] (<span class="hljs-keyword">auto</span>&amp; v) -&gt; <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; { <span class="hljs-keyword">return</span> v[<span class="hljs-number">7</span>]; } };
<span class="hljs-keyword">auto</span> f3 { [] &lt;<span class="hljs-keyword">typename</span> T&gt;(std::vector&lt;T&gt;&amp; v) -&gt; <span class="hljs-keyword">const</span> T&amp; { <span class="hljs-keyword">return</span> v[<span class="hljs-number">7</span>]; } };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s may be used both with <code>auto</code> and with explicit <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s (e.g. <code>T</code>). See the section on <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s to see how to they're applied in both cases.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FConcepts)_TOPIC%2F">Core Language/Templates/Concepts</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F">Library Functions/Containers</a></li>
</ul>
</div>
<a name="H_Templates"></a><h2>Templates</h2>
<p><a name="BM_(Core%20Language%5C%2FTemplates)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p><a href="#BM_(template)%2Fi">Template</a>s are loosely similar to generics in other high-level languages such as Java. A <a href="#BM_(template)%2Fi">template</a> defines a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function where some of the types and code are unknown, called <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. Each <a href="#BM_(template%20parameter)%2Fi">template parameter</a> in a <a href="#BM_(template)%2Fi">template</a> either maps to a ...</p>
<ul>
<li>a type (e.g. <code>int</code>).</li>
<li>an integra<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>5</code>).</li>
<li>floating point value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>5.5f</code>).</li>
<li>an <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>MyEnum::Value</code>).</li>
<li><a href="#BM_(object%7Cinstance)%2Fi">object</a> <a href="#BM_(pointer)%2Fi">pointer</a> type value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>&amp;MyClass::MyStaticField</code>).</li>
<li><a href="#BM_(function%20pointer)%2Fi">function pointer</a> type value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>&amp;MyClass::MyStaticMember</code>).</li>
<li><code>std::nullptr_t</code> value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>nullptr</code>).</li>
</ul>
<p><a href="#BM_(template)%2Fi">Template</a>s are created using the <code>template</code> keyword, where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are a comma separated list sandwiched within angle brackets. When the user makes use of a <a href="#BM_(template)%2Fi">template</a>, its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s get substituted with what the user specified.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
        <span class="hljs-keyword">return</span> (var1 + var2) * N;
    }
};
</code></pre>
<p>As shown above, each <a href="#BM_(template%20parameter)%2Fi">template parameter</a> for a ...</p>
<ul>
<li>type substitution is prefixed with the keyword <code>typename</code>. The keyword <code>class</code> may be used instead of <code>typename</code>. The meaning is exactly the same (<code>typename</code> should be preferred).</li>
<li>value substitution is prefixed with the type name.</li>
</ul>
<p>To use a <a href="#BM_(template)%2Fi">template</a>, use it just as you would a non-<a href="#BM_(template)%2Fi">template</a> but provide substitutions (<a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>). To instantiate a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(template)%2Fi">template</a>, use the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> as if it were a normal <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but immediately after the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> name add in a comma separated list of <a href="#BM_(template%20parameter)%2Fi">template parameter</a> substitutions sandwiched within angle brackets. These substitutions should be in the same order as the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
<pre class="hljs"><code>MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; obj {}; <span class="hljs-comment">// X = float, Y = int, Z = int, N = 2</span>
<span class="hljs-type">float</span> x {obj.<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>Declaring <a href="#BM_(template)%2Fi">template</a>d functions is done in the same manner as <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, and using <a href="#BM_(template)%2Fi">template</a>d functions is done similarly to <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es: Use the function as if it were a normal function but immediately after the function name add in a comma separated list of substitutions sandwiched within angle brackets.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * N;
}

<span class="hljs-comment">// use</span>
<span class="hljs-type">float</span> x {<span class="hljs-built_in">perform</span>&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>When the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are for types only (not values), it's possible to leave out substitutions during usage. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will deduce the types from the argument you pass in and substitute them automatically.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> var1 + var2;
}

<span class="hljs-comment">// use</span>
<span class="hljs-type">float</span> x {<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};  <span class="hljs-comment">// template arguments omitted, deduced by compiler</span>
</code></pre>
<p>It's possible to supply a default substitution for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> by appending it with <code>=</code> followed by the substitution, called <a href="#BM_(default%20template%20argument)%2Fi">default template argument</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y = <span class="hljs-type">long</span>, <span class="hljs-keyword">typename</span> Z = <span class="hljs-type">long</span>&gt;
X <span class="hljs-built_in">perform</span>(Y &amp;var1, Z &amp;var2) {
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>You would think that once a default is supplied, all other <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s after it need a default as well. For whatever reason the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> isn't erroring out when I do this.</p>
</div>
<p>Similarly, it's possible to use <a href="#BM_(template)%2Fi">template</a>s with <a href="#BM_(type%20alias)%2Fi">type alias</a>ing to create shorthand names where only some of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s need to be set, called <a href="#BM_(partial%20template)%2Fi">partial template</a>s.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-keyword">using</span> MyClassPartialTemplate = MyClass&lt;<span class="hljs-type">float</span>, Y, Z, <span class="hljs-number">42</span>&gt;;

<span class="hljs-comment">// use</span>
MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt; x{}; 
MyClassPartialTemplate&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; y{};  <span class="hljs-comment">// same type as previous line</span>
</code></pre>
<p>Normally, C++ code is split into two files: a header file that contains declarations (e.g. function signatures) and a C++ file that contains definitions (e.g. function signatures with their bodies). When accessing C++ code that isn't local, typically only the declarations of that non-local code need to be included. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> binds those non-local declarations to their definitions when it comes time to build the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<p><a href="#BM_(template)%2Fi">Template</a>s work differently from Java generics in that the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates a new code for each unique set of substitutions it sees used (<a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>). Doing so produces more code than if there was only one copy, but also ensures any performance optimizations unique to that specific set of substitutions. Also, because each usage of a <a href="#BM_(template)%2Fi">template</a> may result in newly generated code, that usage typically needs access to both the declaration and definition. The simplest way to handle this is to put the entirety of the <a href="#BM_(template)%2Fi">template</a> (both definition and declaration) into a header, which gets included into the same file as the usage.</p>
<a name="H_Universal%20References"></a><h3>Universal References</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FUniversal%20References)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FConcepts)_TOPIC%2F">Core Language/Templates/Concepts</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<p><a href="#BM_(universal%20reference)%2Fi">Universal reference</a>s allow for collapsing together multiple <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>s where the only differences between <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s are the same parameters being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed as both <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a>s and <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s. In the following non-<a href="#BM_(template)%2Fi">template</a>d code, the only difference between the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s is that one takes a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> and the other takes a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> (and moves it).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; x)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(x);            <span class="hljs-comment">// calls push_back(int &amp;x)</span>
    }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp; x)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(x)); <span class="hljs-comment">// calls push_back(int &amp;&amp;x)</span>
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> val {<span class="hljs-number">5</span>};
    <span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// calls test(int &amp;&amp; x)</span>
    <span class="hljs-built_in">test</span>(val);  <span class="hljs-comment">// calls test(int &amp; x)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>By templating the code above and forcing the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to deduce the parameter type through usage, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> can expand out the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>s on its own.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp; x)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(x)); <span class="hljs-comment">// forward to push_back(int &amp;x) OR push_back(int &amp;&amp;x) based on the reference type</span>
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> val {<span class="hljs-number">5</span>};
    <span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// calls test(int &amp;&amp; x)</span>
    <span class="hljs-built_in">test</span>(val);  <span class="hljs-comment">// calls test(int &amp; x)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>In the example above, the parameter <code>x</code> is a <a href="#BM_(universal%20reference)%2Fi">universal reference</a>. A <a href="#BM_(universal%20reference)%2Fi">universal reference</a> has two ampersands (&amp;&amp;) as if it were a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>, but since the top-level type is a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> (<code>T</code> in this case) it's considered a <a href="#BM_(universal%20reference)%2Fi">universal reference</a>. <code>std::forward&lt;T&gt;()</code> is used to maintain the <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a>-ness / <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>-ness of the argument as it's passed forward into other functions.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Not using <code>std::forward&lt;T&gt;()</code> will force the argument to get moved forward as a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a>. You must use <code>std::forward&lt;T&gt;()</code> to maintain the type of <a href="#BM_(reference)%2Fi">reference</a>.</p>
</div>
<p>For a parameter to be a <a href="#BM_(universal%20reference)%2Fi">universal reference</a>, it must follow the pattern <code>NAME &amp;&amp;</code> where <code>NAME</code> is the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</p>
<ul>
<li>Adding a <code>const</code>, <code>volatile</code>, or modifying it in any other way will make it go back to becoming a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> rather a <a href="#BM_(universal%20reference)%2Fi">universal reference</a>.</li>
<li>Nesting <code>NAME</code> as an argument of another type will make it get interpreted as a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> rather than a <a href="#BM_(universal%20reference)%2Fi">universal reference</a>.</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp;&amp; param)</span> </span>{ ... }      <span class="hljs-comment">// BAD: &amp;&amp; means rvalue reference (because of const)</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyClass&lt;T&gt; &amp;&amp; param)</span> </span>{ ... }  <span class="hljs-comment">// BAD: &amp;&amp; means rvalue reference (because it's wrapped in a concrete type)</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{ ... }            <span class="hljs-comment">// OK: ‚Äú&amp;&amp;‚Äù means universal reference</span>
</code></pre>
<p>More examples of <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s in different contexts:</p>
<pre class="hljs"><code><span class="hljs-comment">// CONTEXT: Multiple universal references of different types.</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp; x, U &amp;&amp; y)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(std::forward&lt;U&gt;(y));
    }
}

<span class="hljs-comment">// CONTEXT: Universal reference of a member function where the class itself is templated.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> UNRELATED_PARAM&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp; x, U &amp;&amp; y)</span> </span>{
        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            vector.<span class="hljs-built_in">push_back</span>(std::forward&lt;U&gt;(y));
        }
    }
    ...
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The reason why <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s work is that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is deducing the correct type for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> based on how its used. If it gets passed a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a>, it'll invoke the <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> version. If it gets passed a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>, it'll invoke the <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> version.</p>
<p>Internally, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> uses a technique called "<a href="#BM_(reference)%2Fi">reference</a> collapsing" to get this to work, which temporarily / internally allows certain unallowable C++ constructs (<a href="#BM_(reference)%2Fi">reference</a>s to <a href="#BM_(reference)%2Fi">reference</a>s are disallowed). See <a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">here</a> for more information.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s can be used to ensure that the underlying type of a <a href="#BM_(universal%20reference)%2Fi">universal reference</a> is correct. In the example above, it's expected that the underlying type is <code>int</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// VERSION 1: Accept only int, int &amp;, or int &amp;&amp;</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> std::same_as&lt;T, <span class="hljs-type">int</span>&gt; || std::same_as&lt;T, <span class="hljs-type">int</span> &amp;&gt; || <span class="hljs-function">std::same_as&lt;T, <span class="hljs-type">int</span> &amp;&amp;&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp; x)</span> </span>{
    ...
}

<span class="hljs-comment">// VERSION 2: Must be the same as int once you strip the reference and const/volatile off</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> std::is_same_v&lt;std::<span class="hljs-type">remove_cv_t</span>&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;, <span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp; x)</span> </span>{
    ...
}
</code></pre>
</div>
<a name="H_Auto%20Syntax"></a><h3>Auto Syntax</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FAuto%20Syntax)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FUniversal%20References)_TOPIC%2F">Core Language/Templates/Universal References</a></li>
</ul>
</div>
<p><code>auto</code> may be used as shorthand for <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. If a parameter has a type of <code>auto</code>, that <code>auto</code> assumes the place of a unique <a href="#BM_(template%20parameter)%2Fi">template parameter</a> (e.g. <code>T</code>).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> p)</span></span>;          <span class="hljs-comment">// template&lt;T&gt; void func(T p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp; p)</span></span>;        <span class="hljs-comment">// template&lt;T&gt; void func(T &amp; p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> * p)</span></span>;        <span class="hljs-comment">// template&lt;T&gt; void func(T * p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; p)</span></span>;  <span class="hljs-comment">// template&lt;T&gt; void func(const T &amp; p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> * p)</span></span>;  <span class="hljs-comment">// template&lt;T&gt; void func(const T * p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp; p)</span></span>;       <span class="hljs-comment">// template&lt;T&gt; void func(T &amp;&amp; p);</span>
</code></pre>
<p>Likewise, if a return type has a type of <code>auto</code> it assumes the place of a unique <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>;          <span class="hljs-comment">// template&lt;T&gt; T func(int p);</span>
</code></pre>
<p><code>auto</code> is typically also used for variable declarations. One important aspect of <code>auto</code> for variable declarations to be aware of: <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> / <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">braced-plus-equals initialization</a> produces an <code>std::initializer_list&lt;T&gt;</code> rather than just <code>T</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;     <span class="hljs-comment">// x is int of 5</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span> <span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;     <span class="hljs-comment">// x is int of 5</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};     <span class="hljs-comment">// x is int of 5</span>
<span class="hljs-type">int</span> x = {<span class="hljs-number">5</span>};   <span class="hljs-comment">// x is int of 5</span>

<span class="hljs-comment">// ... vs ...</span>

<span class="hljs-keyword">auto</span> x = <span class="hljs-number">5</span>;    <span class="hljs-comment">// x is int of 5</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">x</span> <span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;    <span class="hljs-comment">// x is int of 5</span>
<span class="hljs-keyword">auto</span> x {<span class="hljs-number">5</span>};    <span class="hljs-comment">// x is std::initializer_list&lt;int&gt;</span>
<span class="hljs-keyword">auto</span> x = {<span class="hljs-number">5</span>};  <span class="hljs-comment">// x is std::initializer_list&lt;int&gt;</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This seems to mesh with how certain <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es work. For example, to create a <code>std::vector&lt;int&gt;</code>, you can pass in an <code>std::initializer_list&lt;int&gt;</code> via its <a href="#BM_(constructor)%2Fi">constructor</a> to prime it with a set of values. That <code>std::initializer_list&lt;int&gt;</code> is typically created using the curly brace syntax.</p>
<pre class="hljs"><code><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span> <span class="hljs-params">( {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>} )</span></span>;
</code></pre>
<p><strong>However</strong>, when you use <code>auto</code> as the return type of a function OR <code>auto</code> for parameters in a <a href="#BM_(lambda)%2Fi">lambda</a>, the curly-brace to <code>std::initializer&lt;T&gt;</code> conversion discussed below doesn't happen. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will fail to deduce the type if you use supply a list in curly braces.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Later sections discuss <a href="#BM_(template)%2Fi">template</a> deduction and <code>decltype(auto)</code>, both of which are important to know about when using <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. <code>decltype(auto)</code> can be used for variable declarations as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F">Core Language/Templates/Type Cloning</a> (<code>decltype(...)</code> usage)</li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction%2FType%20Cloning%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction/Type Cloning Deduction</a> (<code>decltype(auto)</code> usage)</li>
</ul>
</div>
<a name="H_Type%20Cloning"></a><h3>Type Cloning</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F">Core Language/Classes/Functors</a></li>
<li><a href="#BM_(Core%20Language%5C%2FLambdas)_TOPIC%2F">Core Language/Lambdas</a></li>
</ul>
</div>
<p>To automatically derive the type of a variable something to be passed in as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>, use <code>decltype()</code>. This is useful in scenarios where it's difficult or impossible to determine the exact type for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> (e.g. functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s).</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FUNC_TYPE&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perform</span><span class="hljs-params">(FUNC_TYPE * func)</span> </span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-number">55</span>);
}

<span class="hljs-comment">// use</span>
<span class="hljs-keyword">auto</span> my_lambda = [](<span class="hljs-type">int</span> x) { std::cout &lt;&lt; x; };
<span class="hljs-built_in">perform</span>&lt;<span class="hljs-keyword">decltype</span>(my_lambda)&gt;(my_lambda};
</code></pre>
<p><code>decltype()</code> can take in either an entity (as shown above) or an expression.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> N&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perform</span><span class="hljs-params">(N n)</span> </span>{
    std::cout &lt;&lt; n;
}

<span class="hljs-comment">// use</span>
MyClass myClass{}
<span class="hljs-built_in">perform</span>&lt;<span class="hljs-keyword">decltype</span>(myClass.numVar + <span class="hljs-number">1L</span>)&gt;(my_lambda}; <span class="hljs-comment">// N set to whatever type "myClass.numVar + 1L" evaluates to</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions that, if you're going to use <code>decltype()</code>, don't wrap the expression in brackets. The reason is that <code>decltype()</code>, for whatever reason, will end up interpreting it different than what it is.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { <span class="hljs-number">5</span> };

<span class="hljs-keyword">decltype</span>(x)    <span class="hljs-comment">// will be an int</span>
<span class="hljs-keyword">decltype</span>((x))  <span class="hljs-comment">// will be an int &amp;</span>
</code></pre>
</div>
<a name="H_Type%20Deduction"></a><h3>Type Deduction</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FUniversal%20References)_TOPIC%2F">Core Language/Templates/Universal References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FAuto%20Syntax)_TOPIC%2F">Core Language/Templates/Auto Syntax</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(template)%2Fi">template</a>s allow for <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s to be deduced based on usage.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(T x)</span> </span>{
    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}

<span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);     <span class="hljs-comment">// equivalent to test&lt;int&gt;(5)</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">5ULL</span>);  <span class="hljs-comment">// equivalent to test&lt;unsigned long long&gt;(5ULL)</span>
</code></pre>
<p>The following subsections detail type deduction rules for <a href="#BM_(template)%2Fi">template</a>s as well as edge cases and workarounds.</p>
<a name="H_Deduction%20Rules"></a><h4>Deduction Rules</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction%2FDeduction%20Rules)_TOPIC%2F"></a><strong></strong></p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(T p)</span> </span>{
    <span class="hljs-keyword">return</span> p % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}
</code></pre>
<p>What the type <code>T</code> gets deduced to depends on what <code>p</code> is specified as and what type gets passed into <code>p</code> as an argument.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a { <span class="hljs-number">5</span> };
<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> * aPtr { &amp;a };


<span class="hljs-comment">// Scenario #1: p is just "T" by itself</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">bool</span> <span class="hljs-title">test1</span><span class="hljs-params">(T p)</span> </span>{
    <span class="hljs-keyword">return</span> *p % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}
<span class="hljs-built_in">test1</span>(aPtr);

<span class="hljs-comment">// Scenario #2: p is "T *"</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">bool</span> <span class="hljs-title">test2</span><span class="hljs-params">(T * p)</span> </span>{
    <span class="hljs-keyword">return</span> *p % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}
<span class="hljs-built_in">test2</span>(aPtr);

<span class="hljs-comment">// Scenario #2: p is "const T *"</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">bool</span> <span class="hljs-title">test3</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T * p)</span> </span>{
    <span class="hljs-keyword">return</span> *p % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}
<span class="hljs-built_in">test3</span>(aPtr);
</code></pre>
<p>The idea with C++'s type deduction is that it tries to do the right thing through pattern matching. In the example above, <code>T</code> was deduced to be the correct type in each of the scenarios.</p>
<ul>
<li>In scenario 1, <code>T=const int *</code>.</li>
<li>In scenario 2, <code>T=const int</code>.</li>
<li>In scenario 3, <code>T=int</code>.</li>
</ul>
<p>Pattern matching attempts to deduce <a href="#BM_(template%20parameter)%2Fi">template parameter</a> <code>T</code> based on...</p>
<ul>
<li>how <code>T</code> is used for function parameter <code>p</code>,</li>
<li>what expression <code>e</code> is passed as the argument to <code>p</code>.</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(??? p)</span> </span>{ <span class="hljs-comment">// ??? can be T, T&amp;, const T, const T&amp;, ...</span>
    ...
}

<span class="hljs-built_in">func</span>(e); <span class="hljs-comment">// Given the expression e, func()'s parameter p, what will T be?</span>
</code></pre>
<p>Fo<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a> types, <a href="#BM_(pointer)%2Fi">pointer</a> types, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> types, and <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> types, the rules are as follows:</p>
<ul>
<li>When <code>e</code> and <code>p</code> are both values, <code>const</code> / <code>volatile</code> will never transfer over to <code>T</code> because a copy of <code>e</code> is being passed in.</li>
<li>When <code>e</code> and <code>p</code> are both <a href="#BM_(pointer)%2Fi">pointer</a>s, <code>const</code> / <code>volatile</code> will transfer over to <code>T</code> if not already set on <code>p</code>.</li>
<li>When <code>e</code> and <code>p</code> are both <a href="#BM_(reference)%2Fi">reference</a>s, <code>const</code> / <code>volatile</code> will transfer over to <code>T</code> if not already set on <code>p</code>.</li>
<li>When <code>e</code> is a value but <code>p</code> is a <a href="#BM_(reference)%2Fi">reference</a>, <code>e</code> gets passed into the function as a <a href="#BM_(reference)%2Fi">reference</a> (<code>const</code> / <code>volatile</code> are maintained on <code>e</code>'s <a href="#BM_(reference)%2Fi">reference</a>, see rule where both <code>e</code> and <code>p</code> are <a href="#BM_(reference)%2Fi">reference</a>s).</li>
<li>When <code>e</code> is a <a href="#BM_(reference)%2Fi">reference</a> but <code>p</code> is a value, <code>e</code> gets passed into the function as a copy of the value it <a href="#BM_(reference)%2Fi">reference</a>s (<code>const</code> / <code>volatile</code> are removed from <code>e</code>'s copy, see rule where both <code>e</code> and <code>p</code> are values).</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>p=T</th>
<th>p=const T</th>
<th>p=T&amp;</th>
<th>p=const T&amp;</th>
<th>p=T*</th>
<th>p=const T*</th>
</tr>
</thead>
<tbody>
<tr>
<td>e=int</td>
<td>T=int</td>
<td>T=int</td>
<td>T=int</td>
<td>T=int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>e=const int</td>
<td>T=int</td>
<td>T=int</td>
<td>T=const int</td>
<td>T=int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>e=int&amp;</td>
<td>T=int</td>
<td>T=int</td>
<td>T=int</td>
<td>T=int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>e=const int&amp;</td>
<td>T=int</td>
<td>T=int</td>
<td>T=const int</td>
<td>T=int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>e=int*</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>T=int</td>
<td>T=int</td>
</tr>
<tr>
<td>e=const int*</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>T=const int</td>
<td>T=int</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<ul>
<li><code>volatile</code> not included in above matrix to keep things simple. It behaves just like <code>const</code>.</li>
<li><a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s not included in the matrix to keep things simple. It behaves just like <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a>s.</li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The rules above work for return types exactly the same way that they do for parameter types: <code>e</code> ends up being the expression being returned by the function and <code>p</code> is the function's return type.</p>
</div>
<p>For <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s, the rules are more complicated. <code>p</code> gets reinterpreted based on whether <code>e</code> is a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> or <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>:</p>
<ul>
<li>When <code>e</code> is a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a>, both <code>p</code> and <code>T</code> will be interpreted as <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> to the core type.</li>
<li>When <code>e</code> is a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>, <code>p</code> is interpreted as an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> and <code>T</code> is the <a href="#BM_(reference)%2Fi">reference</a>-less version of <code>p</code>.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>p=T&amp;&amp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>e=int&amp;</td>
<td>T=int&amp; (p interpreted as int&amp;)</td>
</tr>
<tr>
<td>e=const int&amp;</td>
<td>T=const int&amp; (p interpreted as const int&amp;)</td>
</tr>
<tr>
<td>e=int&amp;&amp;</td>
<td>T=int (p interpreted as int&amp;&amp;)</td>
</tr>
<tr>
<td>e=const int&amp;&amp;</td>
<td>T=const i (p interpreted as const int&amp;&amp;)</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>What the above is saying is that, if e ends up being an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>, it uses the basic rules explained just previous to this <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s explainer. Recall that parameters that are <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s borrow the <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> syntax of double ampersand (&amp;&amp;) -- double ampersands are <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s if the type is used in a parameter and left as-is (no <code>const</code>/<code>volatile</code>/etc..).</p>
<p>The types for <code>T</code> and <code>p</code> look invalid in <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> cases but there's some special logic going on under the hood in terms of "<a href="#BM_(reference)%2Fi">reference</a> collapsing" and doing things internally that would be explicitly illegal to do in code. For example, normally, if <code>p=int&amp;</code> then <code>T=int</code>. But that isn't the case with <a href="#BM_(universal%20reference)%2Fi">universal reference</a>s: <code>p=int&amp;</code> (interpreted) but then <code>T=int&amp;</code> as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>A quick-and-dirty way to determine what a type is deduced is to use <code>typeid()</code> in combination with querying type traits.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T p)</span> </span>{  <span class="hljs-comment">// T or T&amp; or const T or const T&amp; or ...</span>
    <span class="hljs-keyword">using</span> P = <span class="hljs-keyword">decltype</span>(p);
    <span class="hljs-keyword">using</span> T_ref_removed = std::remove_reference&lt;T&gt;::type;
    <span class="hljs-keyword">using</span> P_ref_removed = std::remove_reference&lt;P&gt;::type;
    <span class="hljs-keyword">using</span> T_ref_and_cv_removed = std::remove_cv&lt;T_ref_removed&gt;::type;
    <span class="hljs-keyword">using</span> P_ref_and_cv_removed = std::remove_cv&lt;P_ref_removed&gt;::type;
    <span class="hljs-comment">// is_const/is_volatile must have ref removed for test to work: https://en.cppreference.com/w/cpp/types/is_const</span>
    std::cout
        &lt;&lt; <span class="hljs-string">"p: "</span>
        &lt;&lt; (std::is_const&lt;P_ref_removed&gt;::value ? <span class="hljs-string">"[const]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; (std::is_volatile&lt;P_ref_removed&gt;::value ? <span class="hljs-string">"[volatile]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; (std::is_lvalue_reference&lt;P&gt;::value ? <span class="hljs-string">"[&amp;]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; (std::is_rvalue_reference&lt;P&gt;::value ? <span class="hljs-string">"[&amp;&amp;]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; <span class="hljs-built_in">typeid</span>(P_ref_and_cv_removed).<span class="hljs-built_in">name</span>()
        &lt;&lt; <span class="hljs-string">"  /  "</span>
        &lt;&lt; <span class="hljs-string">"T:"</span>
        &lt;&lt; (std::is_const&lt;T_ref_removed&gt;::value ? <span class="hljs-string">"[const]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; (std::is_volatile&lt;T_ref_removed&gt;::value ? <span class="hljs-string">"[volatile]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; (std::is_lvalue_reference&lt;T&gt;::value ? <span class="hljs-string">"[&amp;]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; (std::is_rvalue_reference&lt;T&gt;::value ? <span class="hljs-string">"[&amp;&amp;]"</span> : <span class="hljs-string">""</span>)
        &lt;&lt; <span class="hljs-built_in">typeid</span>(T_ref_and_cv_removed).<span class="hljs-built_in">name</span>()
        &lt;&lt; std::endl;
}
</code></pre>
<p><code>typeid()</code> by itself has a couple of issue:</p>
<ol>
<li>
<p>In certain cases, it won't output specifics of the type (see https://stackoverflow.com/q/37412265). I've tried to work around this by using type traits in the code above.</p>
</li>
<li>
<p>The mains are mangled in G++ and clang (MSVC produces full type names). To de-mangle, you can use a command-line tool (that comes with most Linux g++/clang setups) called "c++-filt". For example, if <code>typeid().name()</code> outputs "PKi", ...</p>
<pre><code>user@localhost$ c++filt -t Pki
int const*
</code></pre>
</li>
</ol>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions a couple of niche cases to do with decaying of types.</p>
<ol>
<li>
<p>When <code>e</code> is a raw array (e.g. <code>e=int[13]</code>) and <code>p</code> is a <a href="#BM_(reference)%2Fi">reference</a> type (e.g. <code>p=T&amp;</code>, <code>p=const T&amp;</code>, <code>p=T&amp;&amp;</code>, ...), <code>p</code> doesn't decay to a <a href="#BM_(pointer)%2Fi">pointer</a> (it doesn't become <code>p=int* &amp;</code>). Instead, an actual <a href="#BM_(reference)%2Fi">reference</a> to the array (including its size) gets passed in, meaning that it's possible to get the array's size via <code>sizeof()</code>. This isn't possible if it decayed to a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<p>The book recommends using <code>std::array</code> instead of relying on this.</p>
</li>
<li>
<p>When <code>e</code> is a function and <code>p</code> is a <a href="#BM_(reference)%2Fi">reference</a> type, <code>p</code> doesn't decay to a <a href="#BM_(function%20pointer)%2Fi">function pointer</a>. It ends up being a <a href="#BM_(reference)%2Fi">reference</a> to the actual function.</p>
<p>The book mentions that, in practice, the non-decaying of functions rarely makes a difference to the code.</p>
</li>
</ol>
</div>
<p>Type deduction for <code>auto</code> works almost exactly the same as <a href="#BM_(template%20parameter)%2Fi">template parameter</a> type deduction. If a parameter type has <code>auto</code>, that <code>auto</code> assumes the place of a unique <a href="#BM_(template%20parameter)%2Fi">template parameter</a> (e.g. <code>T</code>). What <code>auto</code> gets deduced to follows the same rules -- it takes into account the expression passed in as the argument for the parameter and how the parameter is specified (e.g. if it's <code>const</code>, a <a href="#BM_(reference)%2Fi">reference</a>, a <a href="#BM_(pointer)%2Fi">pointer</a>, etc..).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> p)</span></span>;          <span class="hljs-comment">// template&lt;T&gt; void func(T p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp; p)</span></span>;        <span class="hljs-comment">// template&lt;T&gt; void func(T &amp; p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> * p)</span></span>;        <span class="hljs-comment">// template&lt;T&gt; void func(T * p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; p)</span></span>;  <span class="hljs-comment">// template&lt;T&gt; void func(const T &amp; p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> * p)</span></span>;  <span class="hljs-comment">// template&lt;T&gt; void func(const T * p);</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp; p)</span></span>;       <span class="hljs-comment">// template&lt;T&gt; void func(T &amp;&amp; p);</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>;           <span class="hljs-comment">// template&lt;T&gt; T func(int p);</span>
</code></pre>
<p>This <a href="#BM_(extends%3F%7Csubclass)%2Fi">extends</a> to variable declarations that use <code>auto</code>. The rules are essentially the same:</p>
<ul>
<li><code>auto</code> assumes the role of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a></li>
<li>The full type assumes the role of the parameter (e.g. if it's <code>const</code>, a <a href="#BM_(reference)%2Fi">reference</a>, a <a href="#BM_(pointer)%2Fi">pointer</a>, etc..).</li>
<li>The initializing expression assumes the role of the argument being passed into the parameter.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> p = <span class="hljs-number">5</span>;
<span class="hljs-comment">// Imagine p is a parameter in a function and 5 is the argument being passed into it:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// template&lt;T&gt;</span>
<span class="hljs-comment">// void func(const T p) {</span>
<span class="hljs-comment">//     ...</span>
<span class="hljs-comment">// }</span>
<span class="hljs-comment">// func(5);</span>
</code></pre>
<p>The rules are the same even for variables typed as <code>auto &amp;&amp;</code>. When a variable type is <code>auto &amp;&amp;</code>, it's <em>interpreted as a <a href="#BM_(universal%20reference)%2Fi">universal reference</a> rather than a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a></em>. It only becomes a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> if it's set to a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>. Otherwise, it's a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { <span class="hljs-number">22</span> };

<span class="hljs-keyword">auto</span> &amp;&amp; p1 = <span class="hljs-number">52</span>;  <span class="hljs-comment">// p1 is rvalue reference</span>
<span class="hljs-keyword">auto</span> &amp;&amp; p2 = x;   <span class="hljs-comment">// p2 is lvalue reference</span>
</code></pre>
<a name="H_Type%20Cloning%20Deduction"></a><h4>Type Cloning Deduction</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction%2FType%20Cloning%20Deduction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction%2FDeduction%20Rules)_TOPIC%2F">Core Language/Templates/Type Deduction/Deduction Rules</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F">Core Language/Templates/Type Cloning</a></li>
</ul>
</div>
<p>In certain cases, a variable declaration / return statement needs to replicate the exact type of whatever expression is being assigned to it. This is possible with <code>decltype(auto)</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// funcA()'s return type is the exact same as f_ptr()'s return type.</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">funcA</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index);
}

<span class="hljs-comment">// x's type is the exact same as f()'s return type.</span>
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) x = <span class="hljs-built_in">f</span>(a1, a2, a3, a4);
</code></pre>
<p>This is needed because, with normal type deduction rules, the deduction of <code>T</code> changes based on how the overall type is specified (e.g. (e.g. <code>T</code>, <code>const T</code>, <code>T&amp;</code>, <code>T*</code>, etc..) and the type of the expression that gets assigned to it.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See previous section for a refresher on type deduction rules.</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">funcA</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index);
}

<span class="hljs-comment">// What does T get deduced as here? Impossible to know because the signature of "f_ptr()" isn't known beforehand. But,</span>
<span class="hljs-comment">// if "f_ptr(index)" returns a reference, type deduction rules say that T will end up stripping off the reference. So,</span>
<span class="hljs-comment">// for example, if "f_ptr(index)" returns "MyObject &amp;", this function will end up returning a COPY of that object</span>
<span class="hljs-comment">// rather than the reference itself.</span>
</code></pre>
<ul>
<li>
<p>If <code>f_ptr()</code> returns a copy and your return type is <code>T</code>, everything is okay.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index); <span class="hljs-comment">// f_ptr() returns a COPY and you return a COPY</span>
}
</code></pre>
</li>
<li>
<p>If <code>f_ptr()</code> returns a <a href="#BM_(reference)%2Fi">reference</a> and your return type is <code>T&amp;</code>, everything is okay.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
T&amp; <span class="hljs-title">test</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index); <span class="hljs-comment">// f_ptr() returns a REFERENCE and you return a REFERENCE</span>
}
</code></pre>
</li>
<li>
<p>If <code>f_ptr()</code> returns a <a href="#BM_(reference)%2Fi">reference</a> but your return type is <code>T</code>, it's <strong>inefficient code</strong>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
T&amp; <span class="hljs-title">test</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index); <span class="hljs-comment">// f_ptr() returns a REFERENCE and you return a COPY of that reference -- it would have been fine</span>
                         <span class="hljs-comment">// to return just the reference itself</span>
}
</code></pre>
</li>
<li>
<p>If <code>f_ptr()</code> returns a copy but your return type is <code>T&amp;</code>, it's <strong>faulty code</strong>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
T&amp; <span class="hljs-title">test</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index); <span class="hljs-comment">// f_ptr() returns a COPY and you return a REFERENCE to that local copy -- copy is destroyed once</span>
                         <span class="hljs-comment">// this function exits meaning that the reference will be pointing to junk.</span>
}
</code></pre>
</li>
</ul>
<p>If you don't know whether <code>f_ptr()</code> will return a <a href="#BM_(reference)%2Fi">reference</a> or a copy (you just want to mirror back whatever its return type is), use <code>decltype(auto)</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">test</span><span class="hljs-params">(F * f_ptr, <span class="hljs-type">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f_ptr</span>(index); <span class="hljs-comment">// returns the exact type of f_ptr()</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions that, if you're going to use <code>decltype(auto)</code>, don't wrap the expression in brackets. The reason is that <code>decltype()</code>, for whatever reason, will end up interpreting it different than what it is.</p>
<pre class="hljs"><code><span class="hljs-comment">// Example from the book</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> x;        <span class="hljs-comment">// decltype(x) is int, so f1 returns int</span>
}

<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> (x);      <span class="hljs-comment">// decltype((x)) is int&amp;, so f2 returns int&amp;</span>
}
</code></pre>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions that, before <code>decltype(auto)</code>, you needed to use the trailing return type syntax to get similar behaviour when the return type depended on the parameter types.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">(T x)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x + <span class="hljs-number">5</span>)</span> </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;
}
</code></pre>
<p>You can't do something similar with the original return type syntax because the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> doesn't know what's in the parameter list -- it hasn't parsed that part yet.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">decltype</span><span class="hljs-params">(x + <span class="hljs-number">5</span>)</span> <span class="hljs-title">f1</span><span class="hljs-params">(T x)</span> </span>{ <span class="hljs-comment">// THIS WON'T WORK: x used in decltype() before it's encountered in parameter list</span>
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;
}
</code></pre>
</div>
<a name="H_Concepts"></a><h3>Concepts</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FAuto%20Syntax)_TOPIC%2F">Core Language/Templates/Auto Syntax</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This section makes use of the type traits library in the C++ standard libraries. Type traits are <a href="#BM_(template)%2Fi">template</a>s that provide information about types (e.g if a type is signed or unsigned, if it has a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>, etc...). The link below jumps to that section. It's safe to read at this point as it doesn't require any background knowledge other than how to make use of <a href="#BM_(template)%2Fi">template</a>s, which is something you should already be aware of at this point.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FType%20Traits)_TOPIC%2F">Library Functions/Type Traits</a></li>
</ul>
</div>
<p>In certain cases, a set of types substituted in for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s won't produce working code.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y&amp; var1, Z&amp; var2)</span> </span>{
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
<p>In the example above, <code>Y</code> and <code>Z</code> need to be types that support the plus operator (+) on each other (e.g. <code>int</code> and <code>short</code>) and the result must be of type <code>X</code> (or convertible to <code>X</code>). If types substituted for <code>X</code>, <code>Y</code>, and <code>Z</code> don't satisfy those conditions, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> gives back cryptic compilation errors.</p>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s may be used within a <a href="#BM_(template)%2Fi">template</a> to produce more straightforward compilation errors for bad type substitutions: A <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> is a predicate, evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> (not <a href="#BM_(runtime)%2Fi">runtime</a>), that ensures a set of substituted types support specific type traits (e.g. supports plus operator, has a specific <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, has a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>, etc..). The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> gives back easier to understand compilation errors when the predicate fails.</p>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s themselves are <a href="#BM_(template)%2Fi">template</a>s where the <code>concept</code> keyword is used followed by its name and a <a href="#BM_(compile-time)%2Fi">compile-time</a> evaluated expression that returns a <code>bool</code>. For example, the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> below uses the type traits library to ensure that <code>T</code> is both has a <a href="#BM_(default%20constructor)%2Fi">default constructor</a> and a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> DefaultAndCopy = std::is_default_constructible&lt;T&gt;::value &amp;&amp; std::is_copy_constructible&lt;T&gt;::value;
</code></pre>
<p>A <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>'s expression can invoke other <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s. For example, the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> below makes use of the example <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> above and includes an additional type traits check to ensure that <code>T</code> also has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> DefaultAndCopyAndMove = DefaultAndCopy&lt;T&gt; &amp;&amp; std::is_move_constructible&lt;T&gt;::value;
</code></pre>
<p>The C++ standard library includes a set of commonly used <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s. These <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s perform checks similar to the checks provided by the type traits library.</p>
<pre class="hljs"><code><span class="hljs-comment">// equiv to DefaultAndCopyAndMove but written using the concepts library.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> DefaultAndCopyAndMove = std::default_initializable&lt;T&gt; &amp;&amp; std::copy_constructible&lt;T&gt; &amp;&amp; std::move_constructible&lt;T&gt;;
</code></pre>
<p>In cases where neither the type traits library nor the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s library has the check you need, a special <code>requires</code> clause can be used to directly specify exactly what a type needs to support. This <code>requires</code> clause has a parameter list (exactly as if it were a function), and within its body is a list of expressions that <em>must</em> be supported by the types.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
<span class="hljs-keyword">concept</span> MyConcept =
        <span class="hljs-built_in">requires</span>(<span class="hljs-keyword">const</span> T1* t1, <span class="hljs-keyword">const</span> T2&amp; t2) { <span class="hljs-comment">// param list may also contain non-template types like int, float, ...</span>
            { (*t1) + t2 } -&gt; std::same_as&lt;TR&gt;;
            { (*t1) * t2 } -&gt; std::same_as&lt;TR&gt;;
            { std::hash&lt;T1&gt;{}(*t1) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
            { std::hash&lt;T2&gt;{}(t2)  } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
        }
        &amp;&amp; std::is_default_constructible&lt;T1&gt;::value
        &amp;&amp; std::is_default_constructible&lt;T2&gt;::value;
</code></pre>
<p>The <code>requires</code> clause in the example above pretends as if it's a function taking a <a href="#BM_(pointer)%2Fi">pointer</a> to a <code>const</code> (<code>T1</code>) and a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> to a <code>const</code> (<code>T2</code>).</p>
<ul>
<li>When <code>T1</code> is <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>d and either added / multiplied to <code>T2</code>, it must produce a type of <code>TR</code>.</li>
<li>When <code>T1</code> is <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>d and passed to <code>std::hash</code>, it must produce a type that's convertible to <code>size_t</code>.</li>
<li>When <code>T2</code> is passed to <code>std::hash</code>, it must produce a type that's convertible to <code>size_t</code>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Note the syntax. Each statement in the body of <code>requires</code> is an expression that must result in a type that passes its <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> check.</p>
</div>
<p>To apply a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> to a <a href="#BM_(template)%2Fi">template</a>, add a <code>requires</code> just before the body of the <a href="#BM_(template)%2Fi">template</a> with a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> expression. The <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> expression is the exact same as the expressions used to define <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s: It's evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, can <a href="#BM_(reference)%2Fi">reference</a> type traits, can <a href="#BM_(reference)%2Fi">reference</a> other <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s, can have a special parameter list <code>requires</code> clause, and must return a <code>bool</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// templated function perform() using the concept "MyConcept" declared above.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
    <span class="hljs-function"><span class="hljs-keyword">requires</span> MyConcept&lt;T1, T2, TR&gt;
TR <span class="hljs-title">perform</span><span class="hljs-params">(T1 t1, T2 t2)</span> </span>{ <span class="hljs-comment">/* ... implementation ... */</span> }


<span class="hljs-comment">// templated function perform() embedding the rules for that same concept.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
    <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T1* t1, <span class="hljs-keyword">const</span> T2&amp; t2)</span> </span>{
        { (*t1) + t2 } -&gt; std::same_as&lt;TR&gt;;
        { (*t1) * t2 } -&gt; std::same_as&lt;TR&gt;;
        { std::hash&lt;T1&gt;{}(*t1) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
        { std::hash&lt;T2&gt;{}(t2)  } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
    }
    &amp;&amp; std::is_default_constructible&lt;T1&gt;::value
    &amp;&amp; std::is_default_constructible&lt;T2&gt;::value;
<span class="hljs-function">TR <span class="hljs-title">perform</span><span class="hljs-params">(T1 t1, T2 t2)</span> </span>{
    <span class="hljs-comment">/* ... implementation ... */</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The <code>requires requires</code> above is valid. The first <code>requires</code> is saying that this <a href="#BM_(template)%2Fi">template</a> is performing checks, and the second <code>requires</code> is the special parameter list <code>requires</code> clause that lists out what operations <code>T1</code>, <code>T2</code>, and <code>TR</code> must support.</p>
</div>
<p>If a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> only checks a single type, it's possible to use it just by substituting its name in place of the <code>typename</code> / <code>class</code> for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> that requires it (as opposed to using <code>requires</code> shown above).</p>
<pre class="hljs"><code><span class="hljs-comment">// concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> SingleTypeConcept = <span class="hljs-built_in">requires</span>(T a, T b) {
            { a + b } -&gt; std::same_as&lt;T&gt;;
            { a * b } -&gt; std::same_as&lt;T&gt;;
        };

<span class="hljs-comment">// usage of concept</span>
<span class="hljs-keyword">template</span> &lt;SingleTypeConcept X&gt;  <span class="hljs-comment">// this line is updated -- "typename T" replaced with "SingleTypeConcept T"</span>
<span class="hljs-function">X <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(X &amp;var1, X &amp;var2)</span> </span>{
    X x { var1 + var <span class="hljs-number">2</span>};
    <span class="hljs-keyword">return</span> x * var2;
}
</code></pre>
<p>For function <a href="#BM_(template)%2Fi">template</a>s specifically, rather than parameterizing using <code>template</code>, a common shorthand is to use <code>auto</code> for the return type / parameter types being <a href="#BM_(template)%2Fi">template</a>d. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> automatically infers the correct types based on usage. Each <code>auto</code> parameter / return type can have a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> applied to it by placing that <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>'s name just before <code>auto</code>. For example, the usage of <code>SingleTypeConcept</code> in the example above can be rewritten as follows.</p>
<pre class="hljs"><code><span class="hljs-comment">// usage of concept</span>
<span class="hljs-function">SingleTypeConcept <span class="hljs-keyword">auto</span> <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(
    SingleTypeConcept <span class="hljs-keyword">auto</span> &amp;var1,
    SingleTypeConcept <span class="hljs-keyword">auto</span> &amp;var2
)</span> </span>{
    <span class="hljs-keyword">auto</span> x { var1 + var <span class="hljs-number">2</span>};
    <span class="hljs-keyword">return</span> x * var2;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Be careful when making use of <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s like this. When <code>const auto</code> is involved, it'll break compilation.</p>
<pre class="hljs"><code><span class="hljs-function">std::integral <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The above function won't compile because there's something before the <code>const</code>. When a <code>const</code> is the left-most thing, it can't have anything further left of it. You need to move the <code>const</code> after <code>auto</code> (<code>const auto</code> is the exact same as <code>auto const</code>, having <code>const</code> as left-most thing is just a syntactical convenience thing).</p>
<pre class="hljs"><code><span class="hljs-function">std::integral <span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Does this work with <code>decltype(auto)</code> as well?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction%2FType%20Cloning%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction/Type Cloning Deduction</a> (<code>decltype(auto)</code> description)</li>
</ul>
</div>
<a name="H_Ordered%20Type%20Concept"></a><h4>Ordered Type Concept</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FOrdered%20Type%20Concept)_TOPIC%2F"></a><strong></strong></p>
<p>An ordered type is a type that can be compared typically overrides the 6 common relational operators: equals, not equals, less than, less than or equals, greater than, and greater than or equals to. The example <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> below provides a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> that ensures the type provides all of these relational operators.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> Ordering =
    <span class="hljs-built_in">requires</span>(T a, T b) {
        { a == b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
        { a != b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
        { a &lt;= b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
        { a &lt; b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
        { a &gt; b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
        { a &gt;= b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
    };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>You typically won't have to write this out by hand. The C++ standard library has the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s <code>std::three_way_comparable</code> and <code>std::three_way_comparable_with</code>. The former makes sure that a type allows relational comparisons against the same type (same as the example above) while the former allows relational comparisons against different types (e.g. comparing an <code>int</code> against a <code>long</code>).</p>
<p>Both <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s are related to the <a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThree-way%20Comparison%20Overloading)_TOPIC%2F">Core Language/Classes/Three-way Comparison Overloading</a> (<a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a>)</li>
</ul>
</div>
<a name="H_Semi-regular%20Type%20Concept"></a><h4>Semi-regular Type Concept</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FSemi-regular%20Type%20Concept)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F">Core Language/Classes/Copying</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FSpecialization)_TOPIC%2F">Core Language/Templates/Specialization</a></li>
</ul>
</div>
<p>A semi-regular type is a common idea in C++, commonly referred to in documentation on C++ and the C++ standard library. A type is considered semi-regular type if it has a ...</p>
<ul>
<li><a href="#BM_(default%20constructor)%2Fi">default constructor</a></li>
<li><a href="#BM_(copy%20constructor)%2Fi">copy constructor</a></li>
<li><a href="#BM_(move%20constructor)%2Fi">move constructor</a></li>
<li><a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a></li>
<li><a href="#BM_(move%20assignment)%2Fi">move assignment</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a></li>
<li><a href="#BM_(destructor)%2Fi">destructor</a></li>
<li><a href="#BM_(template%20specialization)%2Fi">template specialization</a> / <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> for <code>std::swap(T, T)</code> (is a swappable type)</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> SemiRegular =
    std::is_default_constructible&lt;T&gt;::value &amp;&amp;
    std::is_copy_constructible&lt;T&gt;::value &amp;&amp;
    std::is_copy_assignable&lt;T&gt;::value &amp;&amp;
    std::is_move_constructible&lt;T&gt;::value &amp;&amp;
    std::is_move_assignable&lt;T&gt;::value &amp;&amp;
    std::is_destructible&lt;T&gt;::value &amp;&amp;
    std::is_swappable&lt;T&gt;::value;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This type is built out using functionality provided by the type traits library. Even then, you don't need to use this as the C++ standard library already provides the <code>std::semiregular</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>.</p>
</div>
<a name="H_Regular%20Type%20Concept"></a><h4>Regular Type Concept</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FRegular%20Type%20Concept)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FSemi-regular%20Type%20Concept)_TOPIC%2F">Core Language/Templates/Concepts/Semi-regular Type Concept</a></li>
</ul>
</div>
<p>A regular type is a common idea in C++, commonly referred to in documentation on C++ and the C++ standard library. A type is considered regular type if it supports all the traits of a semi-regular type and it supports both the equality operator (==) and inequality operator (!=).</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> Regular =
    SemiRegular&lt;T&gt; &amp;&amp;
    <span class="hljs-built_in">requires</span>(T a, T b) {
        { a == b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
        { a != b } -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;
    };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>You don't need to use this as the C++ standard library already provides the <code>std::regular</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book and online documentation claims that regular types should behave similarly <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">built-in type</a>s like <code>int</code>.</p>
</div>
<a name="H_Union%20Type%20Concept"></a><h4>Union Type Concept</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FUnion%20Type%20Concept)_TOPIC%2F"></a><strong></strong></p>
<p>One of the most basic use-cases for <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s is to require that a type be one of a set of known types (e.g. require that the type be either <code>short</code>, <code>int</code>, or <code>long</code>). In the example below, a clever use of <a href="#BM_(template)%2Fi">template</a>s is used to test if the two types are equal, then a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> makes use of those <a href="#BM_(template)%2Fi">template</a>s to see if a type is contained in some larger set.</p>
<pre class="hljs"><code><span class="hljs-comment">// templates</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_same</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">false</span>; 
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_same</span>&lt;T, T&gt; { 
   <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">true</span>; 
};


<span class="hljs-comment">// concept for a function whose first parameter's type is an integral type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> integral_check = is_same&lt;T, <span class="hljs-type">short</span>&gt;::value || is_same&lt;T, <span class="hljs-type">int</span>&gt;::value || is_same&lt;T, <span class="hljs-type">long</span>&gt;::value;


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;integral_check T&gt;
<span class="hljs-type">long</span> <span class="hljs-title">square</span><span class="hljs-params">(T num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">square</span>(<span class="hljs-number">2</span>) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">square</span>(<span class="hljs-number">2L</span>) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>In most cases, you shouldn't have to write out <a href="#BM_(template)%2Fi">template</a>s like <code>is_same&lt;&gt;</code> yourself. The C++ standard library provides the <code>type_traits</code> header library which contains <code>std::is_same&lt;&gt;</code> and several other type checks. The C++ standard library also provides a set of pre-built <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s that make use of check that a type has specific type traits. For example, <code>std::is_same&lt;&gt;</code> is exposed as the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> <code>std::same_as&lt;&gt;</code>.</p>
<p>Likewise, the C++ standard library provides a more elaborate version of <code>integral_check&lt;&gt;</code> as <code>std::integral&lt;&gt;</code>.</p>
</div>
<a name="H_Callable%20Type%20Concept"></a><h4>Callable Type Concept</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FCallable%20Type%20Concept)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F">Core Language/Templates/Variadic</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FUnion%20Type%20Concept)_TOPIC%2F">Core Language/Templates/Concepts/Union Type Concept</a></li>
</ul>
</div>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s can be used to specify the requirements for a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>:</p>
<ul>
<li>How many parameters it takes in.</li>
<li>The types allowed for each parameter / the type traits required by each parameter type.</li>
<li>The types allowed for return / traits required by the return type.</li>
</ul>
<p>Up to C++20, the C++ standard library doesn't provide much functionality for verifying the requirements above. The subsections below make clever use of <a href="#BM_(template)%2Fi">template</a>s to design checks for these requirements from scratch.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>These sub-sections come from my question on <a href="https://stackoverflow.com/q/73198589/1196226">stackoverflow</a>. Everything was tested on g++12.1 using C++20 standard. Newer versions of C++ or the g++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> might have better stuff to handle these types of requirements.</p>
</div>
<a name="H_Parameter%20Counts"></a><h5>Parameter Counts</h5>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FCallable%20Types%2FParameter%20Counts)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F">Core Language/Templates/Variadic</a></li>
<li><a href="#BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F">Core Language/Compile-time Evaluation</a></li>
</ul>
</div>
<p>To test a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s parameter count within a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>, <a href="#BM_(template)%2Fi">template</a>s can be used to extract the parameter count. In the example below, the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> checks that a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a> has exactly 1 parameter.</p>
<pre class="hljs"><code><span class="hljs-comment">// template(s) to extract parameter count</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">argCnt</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... As&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">argCnt</span>&lt;<span class="hljs-built_in">R</span>(*)(As...)&gt; { <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> cnt = <span class="hljs-keyword">sizeof</span>...(As); };  <span class="hljs-comment">// needed for std::integral&lt;&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... As&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">argCnt</span>&lt;<span class="hljs-built_in">R</span>(As...)&gt; { <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> cnt = <span class="hljs-keyword">sizeof</span>...(As); };  <span class="hljs-comment">// needed for std::integral&lt;&gt;</span>


<span class="hljs-comment">// concept for a callable object that has exactly 1 parameter</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction = argCnt&lt;Fn&gt;::cnt == <span class="hljs-number">1</span>;


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;MySpecialFunction Fn&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn fn)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square_int</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square_long</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_int) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_long) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Instead of using the <a href="#BM_(template)%2Fi">template</a>s show above, one other solution is to use <a href="https://www.boost.org/doc/libs/1_79_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html">Boost's type traits library</a>: <code>function_traits&lt;my_func&gt;::arity</code>.</p>
</div>
<a name="H_Parameter%20Types"></a><h5>Parameter Types</h5>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FCallable%20Types%2FParameter%20Types)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F">Core Language/Templates/Variadic</a></li>
</ul>
</div>
<p>To test a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s parameter type within a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>, <a href="#BM_(template)%2Fi">template</a>s can be used to extract the parameter type. In the example below, the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> checks that a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s first parameter has a type conforming to the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> <code>std::integral</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// template(s) to extract parameter types</span>
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">typeN</span> { <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> typeN&lt;N<span class="hljs-number">-1U</span>, Ts...&gt;::type; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">typeN</span>&lt;<span class="hljs-number">0U</span>, T0, Ts...&gt; { <span class="hljs-keyword">using</span> type = T0; };

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span>, <span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">argN</span>;

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... As&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">argN</span>&lt;N, <span class="hljs-built_in">R</span>(*)(As...)&gt; { <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> typeN&lt;N, As...&gt;::type; };  <span class="hljs-comment">// needed for std::integral&lt;&gt;</span>

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... As&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">argN</span>&lt;N, <span class="hljs-built_in">R</span>(As...)&gt;  { <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> typeN&lt;N, As...&gt;::type; };  <span class="hljs-comment">// needed for std::is_integeral_v&lt;&gt;</span>


<span class="hljs-comment">// concept for a function whose first parameter's type is an integral type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction = std::integral&lt;<span class="hljs-keyword">typename</span> argN&lt;<span class="hljs-number">0U</span>, Fn&gt;::type&gt;;


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;MySpecialFunction Fn&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn fn)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square_int</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square_long</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_int) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_long) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}


<span class="hljs-comment">// type trait checks using static_assert() -- not necessary</span>
<span class="hljs-built_in">static_assert</span>( std::is_integral_v&lt;<span class="hljs-keyword">typename</span> argN&lt;<span class="hljs-number">0U</span>, <span class="hljs-keyword">decltype</span>(square_int)&gt;::type&gt; );
<span class="hljs-built_in">static_assert</span>( std::is_integral_v&lt;<span class="hljs-keyword">typename</span> argN&lt;<span class="hljs-number">0U</span>, <span class="hljs-keyword">decltype</span>(square_long)&gt;::type&gt; );
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Instead of using the <a href="#BM_(template)%2Fi">template</a>s show above, one other solution is to use <a href="https://www.boost.org/doc/libs/1_79_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html">Boost's type traits library</a>: <code>function_traits&lt;my_func&gt;::argN_type</code></p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Cleverly using <a href="#BM_(template)%2Fi">template</a>s as shown above is the most robust way to check a parameter's type. But, if your requirements aren't overly complex, there may be simpler ways.</p>
<p><strong>SCENARIO 1: Testing for a known concrete types</strong></p>
<p>In this scenario, the requirement is that a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s parameter type be a concrete type that's known beforehand (e.g. <code>int</code>). The <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> for the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a> itself can simply use a parameter list <code>requires</code> clause.</p>
<pre class="hljs"><code><span class="hljs-comment">// concept for a function that takes in a single argument of type int</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> t) {
            { <span class="hljs-built_in">f</span>(t) } -&gt; std::same_as&lt;<span class="hljs-type">int</span>&gt;;
        };
</code></pre>
<p><strong>SCENARIO 2: Testing for a set of known concrete types</strong></p>
<p>In this scenario, the requirement is that a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s parameter be one of a set of concrete types that's known beforehand (e.g. <code>int</code> or <code>long</code>). The <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> for the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a> can be exploded out into several sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s: Each sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> checks that the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s parameter type match a specific concrete type, then those sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s combine to form the full <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// concept that combines the two sub-concepts: checks for a function has a single parameter of type int or long</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction1 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> i) {   <span class="hljs-comment">// sub-concept1: func that has a single parameter of type int</span>
    { <span class="hljs-built_in">f</span>(i) } -&gt; std::same_as&lt;<span class="hljs-keyword">decltype</span>(i)&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction2 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">long</span> l) {  <span class="hljs-comment">// sub-concept2: func that has a single parameter of type long</span>
    { <span class="hljs-built_in">f</span>(l) } -&gt; std::same_as&lt;<span class="hljs-keyword">decltype</span>(l)&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction = MySpecialFunction1&lt;Fn&gt; || MySpecialFunction2&lt;Fn&gt;;  <span class="hljs-comment">// final concept: func that has a single parameter of type int or long</span>


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;MySpecialFunction Fn&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn f)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square_int</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square_long</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_int) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_long) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The problem with exploding out to sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s is that the number of sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s can get very large. For example, if the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a> should have 4 parameters and each of those parameters should be of type <code>int</code>, <code>long</code>, <code>short</code>, or <code>void*</code>, that's 256 different sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s to list out.</p>
<pre class="hljs"><code><span class="hljs-comment">// sub-concepts for function that takes in 4 params:</span>
<span class="hljs-comment">// param1: int|long|short|void*</span>
<span class="hljs-comment">// param2: int|long|short|void*</span>
<span class="hljs-comment">// param2: int|long|short|void*</span>
<span class="hljs-comment">// param3: int|long|short|void*</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 4^4=256 sub-concepts required, not really feasible to code something like this out</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction1 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3, <span class="hljs-type">int</span> p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction2 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3, <span class="hljs-type">long</span> p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction3 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3, <span class="hljs-type">short</span> p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction4 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3, <span class="hljs-type">void</span>* p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction5 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">long</span> p3, <span class="hljs-type">int</span> p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction6 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">long</span> p3, <span class="hljs-type">long</span> p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

...

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction256 = <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">void</span>* p1, <span class="hljs-type">void</span>* p2, <span class="hljs-type">void</span>* p3, <span class="hljs-type">void</span>* p4) {
    { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
};

<span class="hljs-comment">// combine sub-concepts together into final concept</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction =
    MySpecialFunction1&lt;Fn&gt;
    || MySpecialFunction2&lt;Fn&gt;
    || MySpecialFunction3&lt;Fn&gt;
    || MySpecialFunction4&lt;Fn&gt;
    || MySpecialFunction5&lt;Fn&gt;
    || MySpecialFunction6&lt;Fn&gt;
    || ...
    || MySpecialFunction256&lt;Fn&gt;;



<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
    <span class="hljs-keyword">requires</span> MySpecialFunction&lt;Fn&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn fn)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">long</span> num2, <span class="hljs-type">short</span> num3, <span class="hljs-type">long</span> num4)</span> </span>{
    <span class="hljs-keyword">return</span> num1 * num2 * num3 * num4;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(multiply) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>One potential workaround to the sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> explosion problem shown in the example above is to use a parameter list <code>requires</code> clause: Each of the 4 parameter types gets fed into the top-level <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> and requirements are individually tested on each of those <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
<pre class="hljs"><code><span class="hljs-comment">// function that takes in 4 params:</span>
<span class="hljs-comment">// param1: int|long|short|void*</span>
<span class="hljs-comment">// param2: int|long|short|void*</span>
<span class="hljs-comment">// param2: int|long|short|void*</span>
<span class="hljs-comment">// param3: int|long|short|void*</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn, <span class="hljs-keyword">typename</span> P1, <span class="hljs-keyword">typename</span> P2, <span class="hljs-keyword">typename</span> P3, <span class="hljs-keyword">typename</span> P4&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction =
    (std::same_as&lt;P1, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P1, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P1, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P1, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; (std::same_as&lt;P2, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P2, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P2, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P2, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; (std::same_as&lt;P3, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P3, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P3, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P3, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; (std::same_as&lt;P4, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P4, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P4, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P4, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; <span class="hljs-built_in">requires</span>(Fn f, P1 p1, P2 p2, P3 p3, P4 p4) {
        { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
    };
</code></pre>
<p>Doing this removes the sub-<a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> explosion problem, but it introduces a new problem of the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> losing the ability to infer <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s from usage. In the example below, the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> for the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a> is concise, but usages of <code>call()</code> now need to explicitly specify what each <a href="#BM_(template)%2Fi">template</a> argument is because the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is no longer able to infer them on its own.</p>
<pre class="hljs"><code><span class="hljs-comment">// function that takes in 4 params:</span>
<span class="hljs-comment">// param1: int|long|short|void*</span>
<span class="hljs-comment">// param2: int|long|short|void*</span>
<span class="hljs-comment">// param2: int|long|short|void*</span>
<span class="hljs-comment">// param3: int|long|short|void*</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn, <span class="hljs-keyword">typename</span> P1, <span class="hljs-keyword">typename</span> P2, <span class="hljs-keyword">typename</span> P3, <span class="hljs-keyword">typename</span> P4&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction =
    (std::same_as&lt;P1, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P1, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P1, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P1, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; (std::same_as&lt;P2, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P2, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P2, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P2, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; (std::same_as&lt;P3, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P3, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P3, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P3, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; (std::same_as&lt;P4, <span class="hljs-type">int</span>&gt; || std::same_as&lt;P4, <span class="hljs-type">long</span>&gt; || std::same_as&lt;P4, <span class="hljs-type">short</span>&gt; || std::same_as&lt;P4, <span class="hljs-type">void</span>*&gt;)
    &amp;&amp; <span class="hljs-built_in">requires</span>(Fn f, P1 p1, P2 p2, P3 p3, P4 p4) {
        { <span class="hljs-built_in">f</span>(p1, p2, p3, p4) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
    };


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn, <span class="hljs-keyword">typename</span> P1, <span class="hljs-keyword">typename</span> P2, <span class="hljs-keyword">typename</span> P3, <span class="hljs-keyword">typename</span> P4&gt;
    <span class="hljs-keyword">requires</span> MySpecialFunction&lt;Fn, P1, P2, P3, P4&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn fn)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">long</span> num2, <span class="hljs-type">short</span> num3, <span class="hljs-type">long</span> num4)</span> </span>{
    <span class="hljs-keyword">return</span> num1 * num2 * num3 * num4;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// std::cout &lt;&lt; call(multiply) &lt;&lt; std::endl; // &lt;--- WON'T COMPILE because template parameters can't be inferred by the compiler</span>
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>&lt;<span class="hljs-keyword">decltype</span>(multiply), <span class="hljs-type">int</span>, <span class="hljs-type">long</span>, <span class="hljs-type">short</span>, <span class="hljs-type">long</span>&gt;(multiply) &lt;&lt; std::endl; <span class="hljs-comment">// &lt;--- WILL COMPILE because template parameters explicitly listed,</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<a name="H_Return%20Types"></a><h5>Return Types</h5>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FCallable%20Types%2FReturn%20Types)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F">Core Language/Templates/Variadic</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FConcepts%2FCallable%20Types%2FParameter%20Types)_TOPIC%2F">Core Language/Templates/Concepts/Callable Types/Parameter Types</a></li>
</ul>
</div>
<p>To test a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s return type within a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>, <a href="#BM_(template)%2Fi">template</a>s can be used to extract the type. In the example below, the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> checks that a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a> has a return type of integral.</p>
<pre class="hljs"><code><span class="hljs-comment">// template(s) to extract return types</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">returnType</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... As&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">returnType</span>&lt;<span class="hljs-built_in">R</span>(*)(As...)&gt; { <span class="hljs-keyword">using</span> type = R; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... As&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">returnType</span>&lt;<span class="hljs-built_in">R</span>(As...)&gt; { <span class="hljs-keyword">using</span> type = R; };


<span class="hljs-comment">// concept for a function whose return type is an integral type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction =
    std::integral&lt;<span class="hljs-keyword">typename</span> returnType&lt;Fn&gt;::type&gt;;


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;MySpecialFunction Fn&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn fn)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square_int</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square_long</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_int) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_long) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Instead of using the <a href="#BM_(template)%2Fi">template</a>s show above, one other solution is to use <a href="https://www.boost.org/doc/libs/1_79_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html">Boost's type traits library</a>: <code>function_traits&lt;my_func&gt;::result_type</code></p>
<p>Somewhat related as well from the C++ standard library: <code>std::result_of</code> / <code>std::invoke_result</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Cleverly using <a href="#BM_(template)%2Fi">template</a>s as shown above is the most robust way to check a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">callable object</a>'s return type. But, if your requirements aren't overly complex, it may be feasible to use simpler checks such as those discussed in the parameter types section before this section. For example, if the scenario allows for it, a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> check can be reduced to just a set of parameter list <code>requires</code> clauses being logically or'd together.</p>
<pre class="hljs"><code><span class="hljs-comment">// concept for a function whose return type is an integral type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">concept</span> MySpecialFunction =
    <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">int</span> i) {
        { <span class="hljs-built_in">f</span>(i) } -&gt; std::same_as&lt;<span class="hljs-type">int</span>&gt;;
    }
    || <span class="hljs-built_in">requires</span>(Fn f, <span class="hljs-type">long</span> l) {
        { <span class="hljs-built_in">f</span>(l) } -&gt; std::same_as&lt;<span class="hljs-type">long</span>&gt;;
    };


<span class="hljs-comment">// usage</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;MySpecialFunction Fn&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Fn fn)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square_int</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square_long</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> </span>{
    <span class="hljs-keyword">return</span> num * num;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_int) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">call</span>(square_long) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<a name="H1_Variadic"></a><h3>Variadic</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> function is one that takes in a variable number of arguments, sometimes called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s in other languages. A <a href="#BM_(template)%2Fi">template</a> can be made <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> by placing a final <a href="#BM_(template%20parameter)%2Fi">template parameter</a> with <code>...</code> preceding the name, where this <a href="#BM_(template%20parameter)%2Fi">template parameter</a> is referred to as <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a>.</p>
<p>One common use-case for <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a>s is invoking functions where the parameter list isn't known before hand.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function">X <span class="hljs-title">create</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> X {args...};
}
</code></pre>
<p>Another less common use-case is specifying the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to inherit from (multiple inheritance).</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> : R... {
    <span class="hljs-built_in">X</span>(<span class="hljs-keyword">const</span> R&amp;... args) : <span class="hljs-built_in">R</span>(args)... { <span class="hljs-comment">// member initializer list calls constructors of base class</span>
    }
}
</code></pre>
<p>Another less common use-case is to repeatedly apply some operator or function.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T t)</span> </span>{
    <span class="hljs-keyword">return</span> t;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; first, R... rest)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(first) + <span class="hljs-built_in">sum</span>(rest...);
}
</code></pre>
<p>Alternatively, rather than using recursion to exhaustively apply a binary operator, a <a href="#BM_(fold%20expression)%2Fi">fold expression</a> may be applied to the <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a>. A <a href="#BM_(fold%20expression)%2Fi">fold expression</a> applies a binary operator to the contents of a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a> and returns the final result.</p>
<p>The syntax for <a href="#BM_(fold%20expression)%2Fi">fold expression</a>s is <code>...</code> and the <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a>'s name sandwiched in between the operator, all encapsulated within a pair of brackets. Which side of the operator the <code>...</code> appears at defines if the <a href="#BM_(fold%20expression)%2Fi">fold expression</a> will be left <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> or right <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(R... args)</span> </span>{
    R l_ass_res = (... - args);  <span class="hljs-comment">// ((((a-b)-c)-d)-...)</span>
    R r_ass_res = (args - ...);  <span class="hljs-comment">// (...-(w-(x-(y-z))))</span>
    <span class="hljs-keyword">return</span> l_ass_res + r_ass_res;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Just a heads up that, depending on the operator, <a href="#BM_(associativity%7Cassociative)%2Fi">associativity</a> matters. For example <code>((5-4)-3)</code> is not equal to <code>(5-(4-3))</code>.</p>
</div>
<p>To get the size of a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a>, add <code>...</code> after the <code>sizeof</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">calculate_size</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">sizeof</span>...(args);
}
</code></pre>
<p><a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">Parameter pack</a>s are used internally within C++'s implementation of analogues to Python's tuples and zip: <code>std::pair</code>, <code>std::tuple</code>, and <code>std::zip</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Examples adapted from <a href="https://crascit.com/2015/03/21/practical-uses-for-variadic-templates/">here</a>.</p>
</div>
<a name="H_Specialization"></a><h3>Specialization</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FSpecialization)_TOPIC%2F"></a><strong></strong></p>
<p>Given a specific set of substitutions for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s of a <a href="#BM_(template)%2Fi">template</a>, a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is code that overrides the <a href="#BM_(template)%2Fi">template</a> generated code. Oftentimes <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are introduced because they're more memory or computationally efficient than the standard <a href="#BM_(template)%2Fi">template</a> generated code. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>ic example is a <a href="#BM_(template)%2Fi">template</a> that holds on to an array. Most C++ implementations represent a <code>bool</code> as a single byte, however it's more compact to store an array of <code>bool</code>s as a set of bits.</p>
<p>Declare a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> with the <code>template</code> keyword but without any <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s (empty angle brackets). The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function that follows should list out substitutions after its name and the code within it should be real (non-<a href="#BM_(template)%2Fi">template</a>d).</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// template specialization for bool: bitwise or</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-type">bool</span> <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b) {
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
<p><a href="#BM_(template%20specialization)%2Fi">Template specialization</a> doesn't have to substitute all <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. When a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> only provides substitutes for some of its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s, leaving other <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s as-is or partially refined, it's called a <a href="#BM_(partial%20template)%2Fi">partial template</a> specialization.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">R <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
};

<span class="hljs-comment">// template specialization for pointers of unknown type: already return false</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">bool</span>, X*&gt; {
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(X * a, X* b)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><a href="#BM_(partial%20template)%2Fi">Partial template</a> specializations for functions aren't supported (yet?). See <a href="https://stackoverflow.com/a/8061522">here</a>.</p>
</div>
<p>In certain cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is able to deduce the types for a specialization from its usage, meaning explicitly listing substitutions after the name may not be required.</p>
<pre class="hljs"><code><span class="hljs-comment">// first example without explicitly listing out substitutions</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b)</span> </span>{  <span class="hljs-comment">// type removed after name: "sum&lt;bool&gt;" to just "sum"</span>
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
<a name="H_Type%20Aliasing"></a><h3>Type Aliasing</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FType%20Aliasing)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FAliasing)_TOPIC%2F">Core Language/Variables/Aliasing</a></li>
</ul>
</div>
<p>Similar to <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and functions, <a href="#BM_(type%20alias)%2Fi">type alias</a>ing can be <a href="#BM_(template)%2Fi">template</a>d. A <code>template</code> declaration is needed before the the <a href="#BM_(type%20alias)%2Fi">type alias</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> V = std::vector&lt;T&gt;;

<span class="hljs-comment">// usage</span>
V&lt;<span class="hljs-type">int</span>&gt; my_vec { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
</code></pre>
<p>In certain cases, when using a <a href="#BM_(template)%2Fi">template</a>d type within a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(type%20alias)%2Fi">type alias</a>, the keywords <code>typename</code> and <code>template</code> may be required within the <a href="#BM_(type%20alias)%2Fi">type alias</a> declaration itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Option</span> {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">using</span> Vector = std::vector&lt;T&gt;;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> O, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> Vector = <span class="hljs-keyword">typename</span> O::<span class="hljs-keyword">template</span> Vector&lt;T&gt;;

<span class="hljs-comment">// usage</span>
Vector&lt;Option, <span class="hljs-type">int</span>&gt; v { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
</code></pre>
<p>The rules for this are complex, but essentially in certain cases the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> can't decide how to parse a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(type%20alias)%2Fi">type alias</a> and the keywords <code>typename</code> and <code>template</code> act as disambiguation. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will usually generate an error telling you that <code>typename</code> is needed, but may not warn for <code>template</code> and essentially interpret it as something other than what the programmer intended.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>For a full breakdown, see <a href="https://stackoverflow.com/a/613132">here</a>.</p>
</div>
<a name="H_Callable%20Type%20Unpacking"></a><h3>Callable Type Unpacking</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FCallable%20Type%20Unpacking)_TOPIC%2F"></a><strong></strong></p>
<p>A callable (function, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, <a href="#BM_(lambda)%2Fi">lambda</a>)'s type encompasses multiple other types. For example, the following function's type is <code>int(long, short)</code> ...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}
</code></pre>
<p>But that type is composed of 3 other types:</p>
<ul>
<li><code>int</code>, which is the return type.</li>
<li><code>long</code>, which is the first parameter type.</li>
<li><code>short</code>, which is the second parameter type.</li>
</ul>
<p>The subsections below describe how to unpack a callable's type such that you can extract out the types it's composed of. Each callable type has a slightly different way of unpacking types.</p>
<a name="H1_Functions"></a><h4>Functions</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FCallable%20Type%20Unpacking%2FFunctions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F">Core Language/Templates/Type Cloning</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FSpecialization)_TOPIC%2F">Core Language/Templates/Specialization</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F">Core Language/Templates/Variadic</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Aliasing)_TOPIC%2F">Core Language/Templates/Type Aliasing</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F">Core Language/Classes/Functors</a></li>
<li><a href="#BM_(Core%20Language%5C%2FLambdas)_TOPIC%2F">Core Language/Lambdas</a></li>
</ul>
</div>
<p>A <a href="#BM_(template)%2Fi">template</a> can be used to unpack / extract the types that make up a function's declaration. The process works by first creating a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> with a single <a href="#BM_(template%20parameter)%2Fi">template parameter</a> that's left unimplemented.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>;  <span class="hljs-comment">// unimplemented</span>
</code></pre>
<p>When a function type is passed <code>func_types&lt;Fn&gt;</code>'s <a href="#BM_(template%20parameter)%2Fi">template parameter</a>, the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> expects a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> with <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s for the return type and parameter types. This <a href="#BM_(template%20specialization)%2Fi">template specialization</a> provides an implementation for the unimplemented <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, where that implementation is simply a set of <a href="#BM_(type%20alias)%2Fi">type alias</a>es to hold on to the return and parameter types.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> P1, <span class="hljs-keyword">typename</span> P2&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>&lt;<span class="hljs-built_in">R</span>(P1, P2)&gt; {
    <span class="hljs-keyword">using</span> <span class="hljs-type">return_t</span> = R;
    <span class="hljs-keyword">using</span> <span class="hljs-type">param1_t</span> = P1;
    <span class="hljs-keyword">using</span> <span class="hljs-type">param2_t</span> = P2;
};
</code></pre>
<p>When <code>func_types&lt;Fn&gt;</code> is used, <code>Fn</code> needs to be a <em>function type declaration</em>. That function type declaration is typically extracted from an existing function using <code>decltype()</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> types = func_types&lt;<span class="hljs-keyword">decltype</span>(my_func)&gt;;
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">return_t</span>, <span class="hljs-type">int</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;   <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">param1_t</span>, <span class="hljs-type">long</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">param2_t</span>, <span class="hljs-type">short</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl; <span class="hljs-comment">// prints "true"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The <code>func_types</code> <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is specifically for a two parameter function, where the <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> has the function's types nested within as the <a href="#BM_(type%20alias)%2Fi">type alias</a>es. It won't work for 0 parameter functions, or 1 parameter functions, or 3 parameter functions, or etc... A <a href="#BM_(template%20specialization)%2Fi">template specialization</a> will be needed for each of those.</p>
<p>To support a function with an arbitrary number of parameters, a <a href="#BM_(template)%2Fi">template</a> is needed that uses a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a> to represent an arbitrary list of types and recursion to hone in on a specific index within that list.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">recurse_to_type</span> {
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> recurse_to_type&lt;N<span class="hljs-number">-1u</span>, Ts...&gt;::type;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">recurse_to_type</span>&lt;<span class="hljs-number">0u</span>, T0, Ts...&gt; {  <span class="hljs-comment">// template specialization for when N=0</span>
    <span class="hljs-keyword">using</span> type = T0;
};
</code></pre>
<p><code>recurse_to_type&lt;N, T0, Ts&gt;</code> takes in an index <code>N</code>, a starting type <code>T0</code>, and a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a> of remaining types <code>Ts</code>. It recursively pulls the first type out <code>Ts</code> (first type in <code>Ts</code> becomes <code>T0</code> in next recursion) and subtracts <code>N</code> by 1 until it reaches 0, at which point the <a href="#BM_(template%20specialization)%2Fi">template specialization</a> <code>recurse_to_type&lt;0, T0, Ts&gt;</code> sets that first type <code>T0</code> into the <a href="#BM_(type%20alias)%2Fi">type alias</a>.</p>
<p>Pulling out an arbitrary parameter type simply involves using <code>recurse_to_type</code> with the list of parameters (represented as a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a>) and the desired <code>N</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_type</span>;

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_type</span>&lt;N, <span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> recurse_to_type&lt;N, Ps...&gt;::type;
};
</code></pre>
<p>Pulling out the total number of parameters can be done by passing the <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a> to the <code>sizeof</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_cnt</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_cnt</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> std::<span class="hljs-type">size_t</span> cnt { <span class="hljs-keyword">sizeof</span>...(Ps) };  <span class="hljs-comment">// probably should be constexpr</span>
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F">Core Language/Compile-time Evaluation</a> (describes <code>constexpr</code>)</li>
</ul>
</div>
<p>Pulling out a return type is done similarly, but there's no recursion involved as it's always a single type.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ret_type</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ret_type</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">using</span> type = R;
};
</code></pre>
<p>Usage is straight forward for <code>ret_type</code> and <code>param_count</code>. When <code>param_type&lt;N&gt;</code> is used, it needs to target a specific parameter by its index.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> r = ret_type&lt;<span class="hljs-keyword">decltype</span>(my_func)&gt;::type;
    <span class="hljs-keyword">using</span> p0 = param_type&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">decltype</span>(my_func)&gt;::type;
    <span class="hljs-keyword">using</span> p1 = param_type&lt;<span class="hljs-number">1</span>, <span class="hljs-keyword">decltype</span>(my_func)&gt;::type;
    std::cout &lt;&lt; (std::is_same&lt;r, <span class="hljs-type">int</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;    <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;p0, <span class="hljs-type">long</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;p1, <span class="hljs-type">short</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl; <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; param_cnt&lt;<span class="hljs-keyword">decltype</span>(my_func)&gt;::cnt &lt;&lt; std::endl;                   <span class="hljs-comment">// prints "2"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's a much simpler way to do all of this if you're already familiar with <code>std::tuple</code> from the C++ standard library, documented <a href="https://stackoverflow.com/a/24948381">here</a>. Basically, wrap the parameter types within a <code>std::tuple</code>'s type, and then use <code>std::tuple</code>'s type access functions to pull out individual types within that tuple type / number of types nested in that tuple type.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>; <span class="hljs-comment">// unimplemented</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">using</span> <span class="hljs-type">ret_t</span> = R;
    <span class="hljs-keyword">using</span> <span class="hljs-type">params_as_tuple_t</span> = std::tuple&lt;Ps...&gt;;

    <span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> N&gt;
    <span class="hljs-keyword">using</span> <span class="hljs-type">param_t</span> = std::tuple_element&lt;N, <span class="hljs-type">params_as_tuple_t</span>&gt;::type;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> param_cnt { std::tuple_size&lt;<span class="hljs-type">params_as_tuple_t</span>&gt;{} };
};




<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> types = func_types&lt;<span class="hljs-keyword">decltype</span>(my_func)&gt;;
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">ret_t</span>, <span class="hljs-type">int</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;         <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">param_t</span>&lt;<span class="hljs-number">0u</span>&gt;, <span class="hljs-type">long</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">param_t</span>&lt;<span class="hljs-number">1u</span>&gt;, <span class="hljs-type">short</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl; <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; types::param_cnt;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>There's also <a href="https://www.boost.org/doc/libs/1_79_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html">Boost's type traits library</a>, which provides a simple <code>function_traits&lt;&gt;</code> <a href="#BM_(template)%2Fi">template</a> that pulls out all the types and other type related information within a function: <code>function_traits&lt;my_func&gt;::result_type</code>, <code>function_traits&lt;my_func&gt;::argN_type</code>, <code>function_traits&lt;my_func&gt;::arity</code>, etc...</p>
</div>
<a name="H1_Functors"></a><h4>Functors</h4>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FCallable%20Type%20Unpacking%2FFunctors)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FCallable%20Type%20Unpacking%2FFunctions)_TOPIC%2F">Core Language/Templates/Callable Type Unpacking/Functions</a></li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FAuto%20Syntax)_TOPIC%2F">Core Language/Templates/Auto Syntax</a></li>
<li><a href="#BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F">Core Language/Compile-time Evaluation</a></li>
</ul>
</div>
<p>Type extraction for <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s is similar to type extraction for <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s. The main difference is that, with <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, the type extraction is being performed on the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a>  of the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>. As such, ...</p>
<ol>
<li>
<p>the <a href="#BM_(template%20specialization)%2Fi">template specialization</a> for a <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> has to take in an extra type that maps to the actual <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// for function</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_struct</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; { <span class="hljs-comment">/* fill me in  */</span> };

<span class="hljs-comment">// for functor's function call operator</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> O, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_struct</span>&lt;<span class="hljs-built_in">R</span> (O::*)(Ps...)&gt; { <span class="hljs-comment">/* fill me in */</span>  };
</code></pre>
<p>In the example above, the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> takes in the extra <a href="#BM_(template%20parameter)%2Fi">template parameter</a> <code>O</code> and the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> breakdown is <code>R (O::*)(Ps...)</code>, which essentially is mapping <code>O</code> to the type of the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a> with the <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
</li>
<li>
<p>the type being passed to the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> needs to be the type of the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// for function</span>
<span class="hljs-keyword">using</span> types = my_type&lt;<span class="hljs-keyword">decltype</span>(my_func)&gt;;

<span class="hljs-comment">// for functor</span>
<span class="hljs-keyword">using</span> types = my_type&lt;<span class="hljs-keyword">decltype</span>(&amp;my_functor::<span class="hljs-built_in">operator</span>())&gt;;
</code></pre>
<p>In the example above, the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> version is passing the type of that <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a>: <code>decltype(&amp;my_functor::operator())</code>.</p>
</li>
</ol>
<p>The following code adapts the code to extract arbitrary parameters from the previous section to work with <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s as well.</p>
<pre class="hljs"><code><span class="hljs-comment">//</span>
<span class="hljs-comment">// recurse_to_type remains the same as it did before</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">recurse_to_type</span> {
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> recurse_to_type&lt;N<span class="hljs-number">-1u</span>, Ts...&gt;::type;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">recurse_to_type</span>&lt;<span class="hljs-number">0u</span>, T0, Ts...&gt; {  <span class="hljs-comment">// template specialization for when N=0</span>
    <span class="hljs-keyword">using</span> type = T0;
};


<span class="hljs-comment">//</span>
<span class="hljs-comment">// param_type now has a template specialization for functors</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_type</span>;

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt; <span class="hljs-comment">// for function</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_type</span>&lt;N, <span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> recurse_to_type&lt;N, Ps...&gt;::type;
};

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">typename</span> O, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt; <span class="hljs-comment">// for functor</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_type</span>&lt;N, <span class="hljs-built_in">R</span> (O::*)(Ps...)&gt; {
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> recurse_to_type&lt;N, Ps...&gt;::type;
};


<span class="hljs-comment">//</span>
<span class="hljs-comment">// param_cnt now has a template specialization for functors</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_cnt</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt; <span class="hljs-comment">// for function</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_cnt</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">/*constexpr*/</span> std::<span class="hljs-type">size_t</span> cnt { <span class="hljs-keyword">sizeof</span>...(Ps) };
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> O, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt; <span class="hljs-comment">// for functor</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">param_cnt</span>&lt;<span class="hljs-built_in">R</span> (O::*)(Ps...)&gt; {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">/*constexpr*/</span> std::<span class="hljs-type">size_t</span> cnt { <span class="hljs-keyword">sizeof</span>...(Ps) };
};


<span class="hljs-comment">//</span>
<span class="hljs-comment">// ret_type now has a template specialization for functors</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ret_type</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Ps&gt; <span class="hljs-comment">// for function</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ret_type</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">using</span> type = R;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> O, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt; <span class="hljs-comment">// for functor</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ret_type</span>&lt;<span class="hljs-built_in">R</span> (O::*)(Ps...)&gt; {
    <span class="hljs-keyword">using</span> type = R;
};


<span class="hljs-comment">//</span>
<span class="hljs-comment">// usage</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_functor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> functor_func_call_type = <span class="hljs-keyword">decltype</span>(&amp;my_functor::<span class="hljs-built_in">operator</span>());
    <span class="hljs-keyword">using</span> r = ret_type&lt;functor_func_call_type&gt;::type;
    <span class="hljs-keyword">using</span> p0 = param_type&lt;<span class="hljs-number">0</span>, functor_func_call_type&gt;::type;
    <span class="hljs-keyword">using</span> p1 = param_type&lt;<span class="hljs-number">1</span>, functor_func_call_type&gt;::type;
    std::cout &lt;&lt; (std::is_same&lt;r, <span class="hljs-type">int</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;    <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;p0, <span class="hljs-type">long</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;p1, <span class="hljs-type">short</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl; <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; param_cnt&lt;functor_func_call_type&gt;::cnt &lt;&lt; std::endl;                   <span class="hljs-comment">// prints "2"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><a href="#BM_(compile-time)%2Fi">Compile-time</a> expressions can be used to unify the usage of the <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s such that you can pass in a function type or <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> type as the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> (as opposed to passing in the type of the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a>). A phony function can be used to encompass a <a href="#BM_(compile-time)%2Fi">compile-time</a> expression which picks the appropriate <a href="#BM_(template%20specialization)%2Fi">template specialization</a> based on the type traits of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> passed in.</p>
<pre class="hljs"><code><span class="hljs-comment">// this is specifically targeting the ret_type&lt;&gt; template created above, you'd</span>
<span class="hljs-comment">// have one of these functions for param_type&lt;&gt; and param_cnt&lt;&gt; as well.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">unified_ret_type</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> _fake() {
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(!std::is_function&lt;T&gt;::value)</span> </span>{
            <span class="hljs-keyword">return</span> ret_type&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-built_in">operator</span>())&gt; {};
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> ret_type&lt;T&gt; {};
        }
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(unified_ret_type&lt;T&gt;::_fake())::type;
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This code above makes use of the type traits library in the C++ standard libraries. Type traits are <a href="#BM_(template)%2Fi">template</a>s that provide information about types (e.g if a type is signed or unsigned, if it has a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>, etc...). The link below jumps to that section. It's safe to read at this point as it doesn't require any background knowledge other than how to make use of <a href="#BM_(template)%2Fi">template</a>s, which is something you should already be aware of at this point.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FType%20Traits)_TOPIC%2F">Library Functions/Type Traits</a></li>
</ul>
</div>
<p>Then, you simply need to use <code>decltype()</code> to determine what return type an invocation of the above function would return.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> r = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">dummy_function</span>&lt;my_functor&gt;())::type;        <span class="hljs-comment">// pass in my_functor type</span>
<span class="hljs-keyword">using</span> r = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">dummy_function</span>&lt;<span class="hljs-keyword">decltype</span>(my_func)&gt;())::type; <span class="hljs-comment">// pass in my_func's type</span>
<span class="hljs-comment">// RECALL: my_func is an actual function, it's put in decltype() to pull out it's type</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The following adapts the <code>std::tuple</code> approach documented <a href="https://stackoverflow.com/a/24948381">here</a> to work with <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s as well as functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fn&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>; <span class="hljs-comment">// unimplemented</span>

<span class="hljs-comment">// template specialization for functions</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>&lt;<span class="hljs-built_in">R</span>(Ps...)&gt; {
    <span class="hljs-keyword">using</span> <span class="hljs-type">ret_t</span> = R;
    <span class="hljs-keyword">using</span> <span class="hljs-type">params_as_tuple_t</span> = std::tuple&lt;Ps...&gt;;

    <span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> N&gt;
    <span class="hljs-keyword">using</span> <span class="hljs-type">param_t</span> = std::tuple_element&lt;N, <span class="hljs-type">params_as_tuple_t</span>&gt;::type;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> param_cnt { std::tuple_size&lt;<span class="hljs-type">params_as_tuple_t</span>&gt;{} };
};

<span class="hljs-comment">// template specialization for functors</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TObj, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Ps&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">func_types</span>&lt;<span class="hljs-built_in">R</span> (TObj::*)(Ps...)&gt; {
    <span class="hljs-keyword">using</span> <span class="hljs-type">ret_t</span> = R;
    <span class="hljs-keyword">using</span> <span class="hljs-type">params_as_tuple_t</span> = std::tuple&lt;Ps...&gt;;

    <span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> N&gt;
    <span class="hljs-keyword">using</span> <span class="hljs-type">param_t</span> = std::tuple_element&lt;N, <span class="hljs-type">params_as_tuple_t</span>&gt;::type;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> param_cnt { std::tuple_size&lt;<span class="hljs-type">params_as_tuple_t</span>&gt;{} };
};

<span class="hljs-comment">// unify template specializations</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">unified_func_types</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> _fake() {
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(!std::is_function&lt;T&gt;::value)</span> </span>{
            <span class="hljs-keyword">return</span> func_types&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-built_in">operator</span>())&gt; {};
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> func_types&lt;T&gt; {};
        }
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> types = <span class="hljs-keyword">decltype</span>(unified_func_types&lt;T&gt;::_fake());
};




<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_functor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">long</span> lval, <span class="hljs-type">short</span> sval)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// using types = unified_func_types&lt;decltype(my_func)&gt;::types;</span>
    <span class="hljs-keyword">using</span> types = unified_func_types&lt;my_functor&gt;::types;
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">ret_t</span>, <span class="hljs-type">int</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;         <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">param_t</span>&lt;<span class="hljs-number">0u</span>&gt;, <span class="hljs-type">long</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; (std::is_same&lt;types::<span class="hljs-type">param_t</span>&lt;<span class="hljs-number">1u</span>&gt;, <span class="hljs-type">short</span>&gt;::value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl; <span class="hljs-comment">// prints "true"</span>
    std::cout &lt;&lt; types::param_cnt;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<a name="H_Coroutines"></a><h2>Coroutines</h2>
<p><a name="BM_(Core%20Language%5C%2FCoroutines)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a></li>
</ul>
</div>
<p>A coroutine that can suspend its own execution and have it be continued at a later time. Similar to async functions in Javascript, C++ coroutines can work with promise <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (<a href="#BM_(object%7Cinstance)%2Fi">object</a>s that do work asynchronously). A function can be made into a coroutine by using any of the following:</p>
<ul>
<li><code>co_await</code> - suspend execution waiting for a promise to finish.</li>
<li><code>co_yield</code> - suspend execution and optionally return a value.</li>
<li><code>co_return</code> - complete execution and optionally return a value.</li>
</ul>
<p>The return value of a coroutine is a "promise type", a C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that has a specific structure and specific set of functionality that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> calls to determine and control the coroutine's state.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This is deeply convoluted and requires a lot more digging and documentation, possibly in its own section instead of sub-section under the Function header.</p>
</div>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resumable</span> {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span>; <span class="hljs-comment">// forward declaration</span>
    <span class="hljs-built_in">Resumable</span>(std::coroutine_handle&lt;promise_type&gt; coro) : <span class="hljs-built_in">coro</span>(coro) {}
    ~<span class="hljs-built_in">Resumable</span>() {
        coro.<span class="hljs-built_in">destroy</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{ coro.<span class="hljs-built_in">destroy</span>(); }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>{ coro.<span class="hljs-built_in">resume</span>(); }
<span class="hljs-keyword">private</span>:
    std::coroutine_handle&lt;promise_type&gt; coro;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resumable</span>::promise_type {
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Resumable</span>(std::coroutine_handle&lt;Resumable::promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">suspend_never</span>(); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">suspend_never</span>(); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{
        current_value = value;
        <span class="hljs-keyword">return</span> std::suspend_always{};
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>{ }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{ }
    <span class="hljs-type">int</span> current_value;
};

<span class="hljs-function">Resumable <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{
    <span class="hljs-keyword">while</span> (start &lt; end) {
        <span class="hljs-keyword">co_yield</span> start;
        std::cout &lt;&lt; start &lt;&lt; <span class="hljs-string">'\n'</span>;
        start++;
    }
    <span class="hljs-keyword">co_return</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> x {<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)};
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 0</span>
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 1</span>
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 2</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It's said that the coroutine state is kept on the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a>, resulting in C++ coroutines being a performance hog. Maybe it's possible to use a custom allocator to work around performance problems?</p>
</div>
<a name="H_Handler"></a><h3>Handler</h3>
<a name="H_Promise"></a><h3>Promise</h3>
<a name="H_Awaitable"></a><h3>Awaitable</h3>
<p>IN AWAITABLE::await_suspend() IS WHERE YOU LAUNCH SOME ASYNC OPERATION THAT EVENTUALLY CALLS h::resume OT CONTINUE THE COROUTINE</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">switch_to_new_thread</span><span class="hljs-params">(std::jthread&amp; out)</span> </span>{
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">awaitable</span> {
    std::jthread* p_out;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(std::coroutine_handle&lt;&gt; h)</span> </span>{
      std::jthread&amp; out = *p_out;
      <span class="hljs-keyword">if</span> (out.<span class="hljs-built_in">joinable</span>())
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"Output jthread parameter not empty"</span>);
      out = std::<span class="hljs-built_in">jthread</span>([h] { h.<span class="hljs-built_in">resume</span>(); });
      <span class="hljs-comment">// Potential undefined behavior: accessing potentially destroyed *this</span>
      <span class="hljs-comment">// std::cout &lt;&lt; "New thread ID: " &lt;&lt; p_out-&gt;get_id() &lt;&lt; '\n';</span>
      std::cout &lt;&lt; <span class="hljs-string">"New thread ID: "</span> &lt;&lt; out.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// this is OK</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{}
  };
  <span class="hljs-keyword">return</span> awaitable{&amp;out};
}
 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span>{
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> {
    <span class="hljs-function">task <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> {}; }
    <span class="hljs-function">std::suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> {}; }
    <span class="hljs-function">std::suspend_never <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> {}; }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{}
  };
};
 
<span class="hljs-function">task <span class="hljs-title">resuming_on_new_thread</span><span class="hljs-params">(std::jthread&amp; out)</span> </span>{
  std::cout &lt;&lt; <span class="hljs-string">"Coroutine started on thread: "</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
  <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">switch_to_new_thread</span><span class="hljs-params">(out)</span></span>;
  <span class="hljs-comment">// awaiter destroyed here</span>
  std::cout &lt;&lt; <span class="hljs-string">"Coroutine resumed on thread: "</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}
 
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  std::jthread out;
  <span class="hljs-built_in">resuming_on_new_thread</span>(out);
}
</code></pre>
<a name="H_Unions"></a><h2>Unions</h2>
<p><a name="BM_(Core%20Language%5C%2FUnions)_TOPIC%2F"></a><strong></strong></p>
<p>C++ <a href="#BM_(union)%2Fi">union</a>s are a set of variables that point to the same underlying memory. Each <a href="#BM_(union)%2Fi">union</a> takes up only as much memory as its largest <a href="#BM_%5Cb(member)%2Fi">member</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> {
   <span class="hljs-type">char</span> raw[<span class="hljs-number">100</span>];
   <span class="hljs-type">short</span> num_int;
   <span class="hljs-type">double</span> num_dbl;
}

MyUnion x;
<span class="hljs-comment">// set all bytes of raw to 0</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i {<span class="hljs-number">0</span>}; i &lt; <span class="hljs-built_in">sizeof</span>(x.raw); i++) {
   x.raw[i] = <span class="hljs-number">0</span>;
}
<span class="hljs-comment">// since all members of the union start at the same memory location, these</span>
<span class="hljs-comment">// will by likely both be 0 (unless short or double has a byte size of over</span>
<span class="hljs-comment">// 100).</span>
<span class="hljs-type">int</span> x = x.num_in;
<span class="hljs-type">int</span> y = x.num_dbl;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FVariant)_TOPIC%2F">Library Functions/Wrappers/Variant</a> (consider using this instead of <a href="#BM_(union)%2Fi">union</a>s)</li>
</ul>
</div>
<a name="H_Namespaces"></a><h2>Namespaces</h2>
<p><a name="BM_(Core%20Language%5C%2FNamespaces)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p><a href="#BM_(namespace)%2Fi">Namespace</a>s are C++'s way of organizing code into a logical hierarchy / avoiding naming conflicts, similar to packages in Java or Python. Unlike packages, <a href="#BM_(namespace)%2Fi">namespace</a>s don't use the filesystem to define their logical hierarchy. Instead, the hierarchy is specified directly in code using <code>namespace</code> blocks.</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> FirstLevel {
    <span class="hljs-keyword">namespace</span> MiddleLevel {
        <span class="hljs-keyword">namespace</span> LastLevel {
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
                <span class="hljs-type">int</span> count;
                <span class="hljs-type">bool</span> flag;
            };
        }
    }
}
</code></pre>
<p>The nesting in the example above is avoidable via the scope operator (::).</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> FirstLevel::MiddleLevel::LastLevel {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
        <span class="hljs-type">int</span> count;
        <span class="hljs-type">bool</span> flag;
    };
}
</code></pre>
<p>To use the symbols within a <a href="#BM_(namespace)%2Fi">namespace</a>, either include them directly or bring all symbols within the <a href="#BM_(namespace)%2Fi">namespace</a> to the forefront via the <code>using</code> keyword (similar to Java's <code>import</code> or Python's <code>from</code> / <code>import</code>).</p>
<pre class="hljs"><code><span class="hljs-comment">// Use namespace directly.</span>
FirstLevel:MiddleLevel::LastLevel::MyStruct x{};

<span class="hljs-comment">// Bring all symbols within a namespace to the forefront.</span>
<span class="hljs-keyword">using</span> FirstLevel:MiddleLevel::LastLevel;
MyStruct y{};

<span class="hljs-comment">// Bring a single symbol within a namespace to the forefront.</span>
<span class="hljs-keyword">using</span> FirstLevel:MiddleLevel::LastLevel::MyStruct;
MyStruct z{};
</code></pre>
<p>A special type of <a href="#BM_(namespace)%2Fi">namespace</a>, called an <a href="#BM_(unnamed%20namespace)%2Fi">unnamed namespace</a>, limits the visibility of the code to the containing <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>. That means you can't <a href="#BM_(reference)%2Fi">reference</a> an <a href="#BM_(unnamed%20namespace)%2Fi">unnamed namespace</a> in some other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>: It behaves as if you gave the <a href="#BM_(namespace)%2Fi">namespace</a> a unique name and never <a href="#BM_(reference)%2Fi">reference</a>d that <a href="#BM_(namespace)%2Fi">namespace</a> outside of the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// A.h</span>
<span class="hljs-keyword">namespace</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// ... code removed ...</span>
    }
}

<span class="hljs-comment">// B.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span>  <span class="hljs-comment">// help() in A.h won't conflict with the help() here</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ... code removed ...</span>
}
</code></pre>
<a name="H_Linker%20Behaviour"></a><h2>Linker Behaviour</h2>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FObject%20Lifecycle)_TOPIC%2F">Core Language/Object Lifecycle</a></li>
</ul>
</div>
<p><a href="#BM_(specifier%7Cmodifier)%2Fi">Modifier</a>s on a variable or function declaration are used to control how the <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> behaves. Specifically, the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s can ask the <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> to automatically ...</p>
<ul>
<li>merge the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>inline</code>)</li>
<li>find the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>extern</code>)</li>
<li>keep hidden the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>static</code>).</li>
</ul>
<a name="H_Static%20Linkage"></a><h3>Static Linkage</h3>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour%2FStatic%20Linkage)_TOPIC%2F"></a><strong></strong></p>
<p>A static function or variable is one that's only visible to other code in the same <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will make sure that the function doesn't intermingle with other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s.</p>
<p>Static functions/variables have the <code>static</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This is only for non-<a href="#BM_%5Cb(member)%2Fi">member</a>s (not belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<p>The meaning of <code>static</code> changes when the function or variables belongs to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>). When applied on a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, it means that it isn't bound to any <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> -- it can't access <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s belonging to an <a href="#BM_(object%7Cinstance)%2Fi">instance</a>.</p>
</div>
<a name="H_Inline%20Linkage"></a><h3>Inline Linkage</h3>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour%2FInline%20Linkage)_TOPIC%2F"></a><strong></strong></p>
<p>An inline function or variable is one that may be defined in multiple different <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will make sure all <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s use a single <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of that function/variable even though it may have been defined multiple times.</p>
<p>Inline functions/variables have the <code>inline</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">inline</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://stackoverflow.com/a/1759575">this</a>. Typically, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> applies <code>inline</code> automatically based on what it sees, meaning that it isn't something that should be added by the programmer in most cases. The only <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> to that seems to be <a href="#BM_(template)%2Fi">template</a>s? See some of the other answers in the linked stack overflow question.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The original intent of <code>inline</code> was to indicate to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that embedding a copy of the function for an invocation was preferred over an function call. The reason being that in certain cases the code would be faster if it were embedded rather than having it branch into a function call.</p>
</div>
<a name="H_External%20Linkage"></a><h3>External Linkage</h3>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour%2FExternal%20Linkage)_TOPIC%2F"></a><strong></strong></p>
<p>An external function or variable is a one that's usable within the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> but isn't defined. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will sort out where the function is when the time comes.</p>
<p><a href="#BM_(external%20linkage)%2Fi">External linkage</a> functions/variables have the <code>extern</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Sounds similar to <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a> but across different <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s?</p>
</div>
<a name="H_Control%20Flow"></a><h2>Control Flow</h2>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow)_TOPIC%2F"></a><strong></strong></p>
<p>C++ flow control structures are similar to those in other high-level languages (e.g. Java), with the <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> that ...</p>
<ul>
<li>it's possible to have initializer statements in control structures other than for loops.</li>
<li>jumping to arbitrary labels are allowed (goto statements).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>An important caveat about loops in C++ from <a href="https://en.cppreference.com/w/cpp/language/while">cpp</a><a href="#BM_(reference)%2Fi">reference</a>.com:</p>
<blockquote>
<p>As part of the C++ forward progress guarantee, the behavior is undefined if a loop that has no observable behavior (does not make calls to I/O functions, access <a href="#BM_(volatile)%2Fi">volatile</a> <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, or perform atomic or synchronization operations) does not terminate. <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a>s are permitted to remove such loops.</p>
</blockquote>
</div>
<a name="H_If%20Statement"></a><h3>If Statement</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FIf%20Statement)_TOPIC%2F"></a><strong></strong></p>
<p>If statements follow a similar structure to if statements in Java. The only major difference is that an initializer statement is allowed before the condition in the initial <code>if</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()}; r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" div by 5"</span>;
} <span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
}
</code></pre>
<p>In the example above, an initializer statement has been added that sets a variable to a random number. That variable is only accessible inside the different branches of the if statement.</p>
<a name="H_Switch%20Statement"></a><h3>Switch Statement</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FSwitch%20Statement)_TOPIC%2F"></a><strong></strong></p>
<p>Switch statements follow a similar structure to switch statements in Java. The only major difference is that an initializer statement is allowed before the condition.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()}; r % <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
    std::cout &lt;&lt; <span class="hljs-string">"this should never happen"</span>;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>To indicate to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that a fallthrough case is intended behaviour, use the <code>[[fallthrough]]</code> <a href="#BM_(attribute)%2Fi">attribute</a>.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: [[fallthrough]]
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
    std::cout &lt;&lt; <span class="hljs-string">"this should never happen"</span>;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<a name="H_For%20Loop"></a><h3>For Loop</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FFor%20Loop)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li>/<a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li>/<a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p>For loops follow a similar structure to for loop in Java.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i {<span class="hljs-number">0</span>}; i &lt; <span class="hljs-number">10</span>; i++)  {
    std::cout &lt;&lt; i;
}
</code></pre>
<p>Similarly, an analog to Java's for-each loop exists called range-based for loops. The only major difference is that an initializer statement is allowed (optional) before the range declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()}; <span class="hljs-type">int</span> val : array)  {
    std::cout &lt;&lt; (r + val) &lt;&lt; <span class="hljs-string">' '</span>;
}
</code></pre>
<p>For-each loops, sometimes also called range-based for loops, are translated differently based on the type that's being looped over. Specifically, if the type being looped over is an ...</p>
<ul>
<li>
<p>array:</p>
<pre class="hljs"><code><span class="hljs-comment">// FOR-EACH LOOP</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : array)  {
    std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>;
}
<span class="hljs-comment">//</span>
<span class="hljs-comment">// TRANSLATION OF THE ABOVE LOOP AS A STANDARD FOR LOOP</span>
<span class="hljs-comment">//</span>
{
     <span class="hljs-keyword">auto</span> &amp;&amp; __range = array;
     <span class="hljs-keyword">auto</span> __begin = array;
     <span class="hljs-keyword">auto</span> __end = array + std::<span class="hljs-built_in">size</span>(array);
     <span class="hljs-keyword">for</span> ( ; __begin != __end; ++__begin){
         <span class="hljs-type">int</span> val = *__begin;
         std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>;
     }
}
</code></pre>
</li>
<li>
<p>an <a href="#BM_(object%7Cinstance)%2Fi">object</a> that has the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s <code>begin()</code> and <code>end()</code>:</p>
<pre class="hljs"><code><span class="hljs-comment">// FOR-EACH LOOP</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : obj)  {
    std::cout &lt;&lt; (r + val) &lt;&lt; <span class="hljs-string">' '</span>;
}
<span class="hljs-comment">//</span>
<span class="hljs-comment">// TRANSLATION OF THE ABOVE LOOP AS A STANDARD FOR LOOP</span>
<span class="hljs-comment">//</span>
{
     <span class="hljs-keyword">auto</span> &amp;&amp; __range = obj;
     <span class="hljs-keyword">auto</span> __begin = obj.<span class="hljs-built_in">begin</span>();
     <span class="hljs-keyword">auto</span> __end = obj.<span class="hljs-built_in">end</span>();
     <span class="hljs-keyword">for</span> ( ; __begin != __end; ++__begin){
         <span class="hljs-type">int</span> val = *__begin;
         std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>;
     }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FIterators)_TOPIC%2F">Library Functions/Iterators</a> (<a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s supply begin and end <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s)</li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F">Library Functions/Containers</a> (containers are exposed as <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s)</li>
</ul>
</div>
</li>
<li>
<p>an <a href="#BM_(object%7Cinstance)%2Fi">object</a> for which the <em><a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s</em> <code>std::begin(T)</code> and <code>std::end(T)</code> have <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s for:</p>
<pre class="hljs"><code><span class="hljs-comment">// FOR-EACH LOOP</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : obj)  {
    std::cout &lt;&lt; (r + val) &lt;&lt; <span class="hljs-string">' '</span>;
}
<span class="hljs-comment">//</span>
<span class="hljs-comment">// TRANSLATION OF THE ABOVE LOOP AS A STANDARD FOR LOOP</span>
<span class="hljs-comment">//</span>
{
     <span class="hljs-keyword">auto</span> &amp;&amp; __range = obj;
     <span class="hljs-keyword">auto</span> __begin = std::<span class="hljs-built_in">begin</span>(obj);
     <span class="hljs-keyword">auto</span> __end = std::<span class="hljs-built_in">end</span>(obj);
     <span class="hljs-keyword">for</span> ( ; __begin != __end; ++__begin){
         <span class="hljs-type">int</span> val = *__begin;
         std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>;
     }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FRanges)_TOPIC%2F">Library Functions/Ranges</a> (<a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s supply begin and end <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s)</li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F">Library Functions/Containers</a> (containers are exposed as ranges)</li>
</ul>
</div>
</li>
</ul>
<a name="H_While%20Loop"></a><h3>While Loop</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FWhile%20Loop)_TOPIC%2F"></a><strong></strong></p>
<p>While and do-while loops follow a similar structure to their counterparts in Java.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span>};
<span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" "</span>;
    r--;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span>};
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" "</span>;
    r--;
} <span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// semicolon required at the end</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Unlike other control structures, these loops cannot have initializer statements.</p>
</div>
<a name="H_Goto%20Statement"></a><h3>Goto Statement</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FGoto%20Statement)_TOPIC%2F"></a><strong></strong></p>
<p>Unlike most other high-level languages (e.g. Java), C++ allows the use of goto statements. However, note that goto statements are generally considered bad practice and should somehow be refactored to higher-level constructs (e.g. loops, if statements, etc..).</p>
<pre class="hljs"><code>retry:
<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()};
<span class="hljs-keyword">if</span> (r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">goto</span> retry;
}
std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
</code></pre>
<a name="H_Branching%20Likelihood"></a><h3>Branching Likelihood</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FBranching%20Likelihood)_TOPIC%2F"></a><strong></strong></p>
<p>Conditional branching operations in flow control statements may have the <code>[[likely]]</code> and <code>[[unlikely]]</code> <a href="#BM_(attribute)%2Fi">attribute</a>s applied to hint at the likelihood / unlikelihood that of the path execution will take. This allows for better optimization by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (based on your assumptions).</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (exit_code) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    <span class="hljs-comment">// happy path</span>
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    <span class="hljs-comment">// recognized error path</span>
    <span class="hljs-keyword">break</span>;
    [[unlikely]] <span class="hljs-keyword">default</span>:
    <span class="hljs-comment">// unrecognized error path</span>
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_valid</span>(email)) [[likely]] {
    <span class="hljs-comment">// happy path</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// error path</span>
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) [[unlikely]] {
  <span class="hljs-comment">// do something</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I read something online saying you shouldn't use both <code>[[likely]]</code> and <code>[[unlikely]]</code> on the same switch/if/while/etc...</p>
</div>
<a name="H_Attributes"></a><h2>Attributes</h2>
<p><a name="BM_(Core%20Language%5C%2FAttributes)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ <a href="#BM_(attribute)%2Fi">attribute</a>s are similar to annotations in Java, providing information to the user / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> about the code that it's applied to. Unlike Java, C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s are free to pick and choose which <a href="#BM_(attribute)%2Fi">attribute</a>s they support and how they support them. There is no guarantee what action a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will take, if any, when it sees an <a href="#BM_(attribute)%2Fi">attribute</a> (e.g. <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warnings).</p>
<p>An <a href="#BM_(attribute)%2Fi">attribute</a> is applied by nesting it in double square brackets (e.g. <code>[[noreturn]]</code>) and placing it as a <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> on the function.</p>
<pre class="hljs"><code>[[noreturn]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fail</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">throw</span> std::runtime_error { <span class="hljs-string">"Failed"</span> };
}
</code></pre>
<p>Common <a href="#BM_(attribute)%2Fi">attribute</a>s:</p>
<table>
<thead>
<tr>
<th><a href="#BM_(attribute)%2Fi">attribute</a></th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[deprecated("msg")]]</code></td>
<td>Indicates that a function is deprecated. Message is optional.</td>
</tr>
<tr>
<td><code>[[noreturn]]</code></td>
<td>Indicates that a function doesn't return.</td>
</tr>
<tr>
<td><code>[[fallthrough]]</code></td>
<td>Indicates that a switch case was explicitly designed to fall through to the next case (no <code>break</code> / <code>return</code> / etc.. intended).</td>
</tr>
<tr>
<td><code>[[nodiscard]]</code></td>
<td>Indicates that a function's result should be used somehow (produce <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warning).</td>
</tr>
<tr>
<td><code>[[maybe_unused]]</code></td>
<td>Indicates that a function's result doesn't have to be used (avoid compile warning).</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCommon%20Attributes)_TOPIC%2F">Core Language/Variables/Common Attributes</a></li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions%2FCommon%20Attributes)_TOPIC%2F">Core Language/Functions/Common Attributes</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCommon%20Attributes)_TOPIC%2F">Core Language/Classes/Common Attributes</a></li>
</ul>
</div>
<a name="H_Compile-time%20Evaluation"></a><h2>Compile-time Evaluation</h2>
<p><a name="BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FObject%20Lifecycle)_TOPIC%2F">Core Language/Object Lifecycle</a></li>
<li><a href="#BM_(Core%20Language%5C%2FControl%20Flow%2FIf%20Statement)_TOPIC%2F">Core Language/Control Flow/If Statement</a></li>
</ul>
</div>
<p><a href="#BM_(compile-time)%2Fi">Compile-time</a> evaluations allow code to be executed at <a href="#BM_(compile-time)%2Fi">compile-time</a> rather than run-time. For example, rather than hardcoding a magic number, a piece of code can run during compilation that calculates that magic number and automatically hardcodes it in behind the scenes. Calculating a magic number like results in cleaner and more understandable code because the developer can see how the magic number is derived and can even tweak the code that calculates it.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n * n;
}
<span class="hljs-type">int</span> y { <span class="hljs-built_in">sqr</span>(<span class="hljs-number">17</span>) }; <span class="hljs-comment">// compiles exactly the same as initializing y directly to 289</span>
</code></pre>
<p><a href="#BM_(compile-time)%2Fi">Compile-time</a> evaluations are enabled through the following keywords: <code>consteval</code>, <code>constinit</code>, and <code>constexpr</code>.</p>
<ul>
<li>
<p><code>consteval</code> - A function with the <code>consteval</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">specifier</a> is referred to as an <a href="#BM_(immediate%20function)%2Fi">immediate function</a>. An <a href="#BM_(immediate%20function)%2Fi">immediate function</a>'s invocation always gets executed during compilation, where the result of that function is swapped in for its invocation in the compiled code. This is essentially the same as using a <a href="#BM_(compile-time)%2Fi">compile-time</a> constant, but the <a href="#BM_(compile-time)%2Fi">compile-time</a> constant is generated through code.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n * n;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x {<span class="hljs-built_in">sqr</span>(<span class="hljs-number">7</span>)}; <span class="hljs-comment">// during compilation, sqr(7) is replaced with the result of sqr(7)</span>
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<p>A <code>consteval</code> function's body and invocations must only <a href="#BM_(reference)%2Fi">reference</a> other functions and variables that are available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. it can call another <code>consteval</code> function). Similarly, arguments being passed to it during invocation must be available at <a href="#BM_(compile-time)%2Fi">compile-time</a> as well.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n * n;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> divide_val { <span class="hljs-number">2</span> };
    <span class="hljs-type">int</span> x {<span class="hljs-built_in">sqr</span>(<span class="hljs-number">7</span> / divide_val)}; <span class="hljs-comment">// ERROR: even though it looks like it should be, var 'divide_val' is not guaranteed to be known at compile-time</span>
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>constinit</code> - A variable with the <code>constinit</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">specifier</a> is one that has its initializer executed during compilation, where the result of that execution is swapped in for usages of the variable. It works similarly to <code>consteval</code> in that its initializer must only <a href="#BM_(reference)%2Fi">reference</a> other functions and variables that are available at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>+<span class="hljs-number">4</span>/<span class="hljs-number">3</span>};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The difference between a <code>const</code> variable and <code>constinit</code> variable is that the former only guarantees the variable is unmodifiable. It doesn't actually guarantee that the expression within is evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>+<span class="hljs-number">4</span>/<span class="hljs-number">3</span>};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    x = <span class="hljs-number">77</span>; <span class="hljs-comment">// THIS IS OKAY because x is constinit but not const</span>
    std::cout &lt;&lt; x &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>constinit</code> can only be applied to variables with <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static storage duration</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It can also be applied to <a href="#BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi">thread-local storage duration</a>, if you know what that is.</p>
</div>
</li>
<li>
<p><code>constexpr</code> - A function or variable with the <code>constexpr</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">specifier</a>, referred to as <a href="#BM_(constant%20expression)%2Fi">constant expression</a>, acts as if it were a <code>consteval</code> / <code>constinit</code> as long as it only <a href="#BM_(reference)%2Fi">reference</a>s other <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (functions / variables) that are available at <a href="#BM_(compile-time)%2Fi">compile-time</a> and takes in arguments that are available at <a href="#BM_(compile-time)%2Fi">compile-time</a>. Otherwise, it acts as if it were a normal function, meaning nothing gets executed at <a href="#BM_(compile-time)%2Fi">compile-time</a> and the code is compiled as-is.</p>
<pre class="hljs"><code><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>+<span class="hljs-number">4</span>/<span class="hljs-number">3</span>};
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n * n;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sqr_runtime_only</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n * n;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> z {<span class="hljs-built_in">sqr</span>(<span class="hljs-number">7</span>) + x};  <span class="hljs-comment">// z's initializer executed and swapped with constant at compile-time</span>
    std::cout &lt;&lt; z &lt;&lt; std::endl;
    <span class="hljs-type">int</span> a {<span class="hljs-built_in">sqr_runtime_only</span>(<span class="hljs-number">7</span>) + x};  <span class="hljs-comment">// a's initializer executed at run-time</span>
    std::cout &lt;&lt; a &lt;&lt; std::endl;
}
</code></pre>
<p>The keyword <code>constexpr</code> may also be used within an if-else to conditionally compile code. When <code>constexpr</code> appears immediately after <code>if</code>, the conditional expression within is treated similarly to a <code>constexpr</code> variable's initializer. Assuming the conditional expression is evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, the chosen if-else path is the only one that gets compiled. All other paths of the if-else skip compilation.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(y == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span> </span>{
    <span class="hljs-comment">// constant expression y is equivalent to the number of bytes for an int, so compile this block</span>
    ...
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// constant expression y is NOT equivalent to the number of bytes for an int, so compile this block</span>
    ...
}
<span class="hljs-comment">//</span>
<span class="hljs-comment">// What use is a constexpr if-else? Use-cases include ...</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// * omitting parts of a program from compilation (e.g. demonstration software).</span>
<span class="hljs-comment">// * working around compiler-specific / platform-specific inconsistencies (e.g. only include code if `int`'s max value is above some threshold).</span>
<span class="hljs-comment">// * performing specific actions based on the types chosen for template parameters (e.g. include code path 1 if pointer, otherwise code path 2).</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It looks like C++23 may allow <code>consteval</code> for if-else as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's a special function in the C++ standard library called <code>std::is_constant_evaluated()</code> that you can use in a <code>constexpr</code> function to determine if / ensure that the code is being executed at <a href="#BM_(compile-time)%2Fi">compile-time</a> or at run-time. This is useful if you want the code to do something different when evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> vs run-time (e.g. use a look-up table if evaluated at run-time vs do the full calculation if evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</p>
<p>Here's the example from the book...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">double</span> b, <span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">is_constant_evaluated</span>() &amp;&amp; !(b == <span class="hljs-number">0.0</span> &amp;&amp; x &lt; <span class="hljs-number">0</span>)) {       
        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;
        <span class="hljs-type">double</span> r = <span class="hljs-number">1.0</span>, p = x &gt; <span class="hljs-number">0</span> ? b : <span class="hljs-number">1.0</span> / b;
        <span class="hljs-keyword">auto</span> u = <span class="hljs-built_in">unsigned</span>(x &gt; <span class="hljs-number">0</span> ? x : -x);
        <span class="hljs-keyword">while</span> (u != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (u &amp; <span class="hljs-number">1</span>) r *= p;
            u /= <span class="hljs-number">2</span>;
            p *= p;
        }
        <span class="hljs-keyword">return</span> r;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(b, <span class="hljs-built_in">double</span>(x));
    }
}
</code></pre>
<p>Technically, <code>std::is_constant_evaluated()</code> can be used anywhere. If you use it ...</p>
<ul>
<li>in a <code>consteval</code>, it will always evaluate to true</li>
<li>in a <code>constexpr</code>, it may evaluate to true or false depending on where it was called</li>
<li>in a normal run-time evaluated function, it will always evaluate to false</li>
</ul>
</div>
</li>
</ul>
<p>The restrictions on <code>constinit</code> / <code>consteval</code> / <code>constexpr</code> are vast. At a high-level, the only allowed inputs and outputs are <a href="#BM_(literal%20type)%2Fi">literal type</a>s:</p>
<ul>
<li><strong>Scalar</strong>: Floating point types, integral types, <a href="#BM_(pointer)%2Fi">pointer</a> types, <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> types, <code>std::nullptr_t</code>, etc..</li>
<li><strong><a href="#BM_(reference)%2Fi">Reference</a></strong></li>
<li><strong>Array</strong>: Every element must be a literal.</li>
<li><strong><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a></strong>: <a href="#BM_(constructor)%2Fi">Constructor</a> must be a <a href="#BM_(constant%20expression)%2Fi">constant expression</a>. Non-<a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> initializers using <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>, <a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a>, or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> must use <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s. The <a href="#BM_(destructor)%2Fi">destructor</a> must be a trivial <a href="#BM_(destructor)%2Fi">destructor</a> (non-virtual, does nothing, and all base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(destructor)%2Fi">destructor</a>s do nothing).</li>
<li><strong><a href="#BM_(union)%2Fi">Union</a></strong>: Must have at least one non-<a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a> that is a <a href="#BM_(literal%20type)%2Fi">literal type</a>.</li>
</ul>
<p>Also, <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">Exception</a>s handling, <code>static</code> variables, and <code>thread_local</code> variables are not allowed.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The rules here are vast and complicated. The above might not be entirely correct, may be missing some conditions, or may not cover certain aspects. In the type_traits header, there's a function called <code>std::is_literal_type</code> that can be used to test if a type is a <a href="#BM_(literal%20type)%2Fi">literal type</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Type information is queryable at <a href="#BM_(compile-time)%2Fi">compile-time</a> through the type_traits. Information about numeric types is queryable at <a href="#BM_(compile-time)%2Fi">compile-time</a> using numeric_limits, cstdlib, and cfloat headers.</p>
<p>Those are what you would commonly use in <code>if constexpr</code> blocks. They help with building portable software.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>All of this seems to replace the need for C <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros <code>#define</code> / <code>#ifdef</code> / etc...</p>
</div>
<a name="H_Exceptions"></a><h2>Exceptions</h2>
<p><a name="BM_(Core%20Language%5C%2FExceptions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s work similarly to <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s in other languages, except that there is no <code>finally</code> block. The idea behind this is that resources should be bound to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a> (<a href="#BM_(destructor)%2Fi">destructor</a>). As the call stack unwinds and the <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a>s that each function owns are destroyed, the <a href="#BM_(destructor)%2Fi">destructor</a>s of those <a href="#BM_(object%7Cinstance)%2Fi">object</a>s should be cleaning up any resources that would have been cleaned up by the <code>finally</code> block. This concept is referred to as resource acquisition is initialization (<a href="#BM_(RAII%7CCADRe)%2F">RAII</a>).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>What does accordingly mean? For example, wrap the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamically allocated object</a> in a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> where <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> happens in the <a href="#BM_(constructor)%2Fi">constructor</a> / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a> happens in the <a href="#BM_(destructor)%2Fi">destructor</a>. An <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type will clean up properly when the function exits.</p>
</div>
<p>To throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, use the <code>throw</code> keyword followed by the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to throw. Most <a href="#BM_(object%7Cinstance)%2Fi">object</a> types are throwable, but thrown <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are typically limited to types either in or derived from those in the stdexcept header.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">no_negatives_check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> std::runtime_error { <span class="hljs-string">"no negatives"</span> };
    }
}
</code></pre>
<p>Similar to Java and Python, C++ provides a standard set of <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s in stdexcept complete with a hierarchy.</p>
<p><img src="svgbob_0347537f32e15529524b9ab7c34cb1f41f86ec3a.svg" alt="Kroki diagram output"></p>
<p>To catch an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> potentially being thrown, wrap code in a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block. Typical inheritance rules apply when catching an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. For example, catching a <code>std:runtime_error</code> type will also catch anything that <a href="#BM_(extends%3F%7Csubclass)%2Fi">extends</a> from it as well (e.g. <code>std:overflow_error</code>).</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">55</span>);
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// do something</span>
}
</code></pre>
<p>To catch any <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> regardless of type, use <code>...</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-comment">// do something, note the exception object is not accessible here</span>
}
</code></pre>
<p>Multiple catches may exist in the same <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block.</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::range_error &amp;e) {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// do something -- this block will get chosen</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::exception &amp;e) {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-comment">// do something, note the exception object is not accessible here</span>
}
</code></pre>
<a name="H_Structured%20Binding"></a><h2>Structured Binding</h2>
<p><a name="BM_(Core%20Language%5C%2FStructured%20Binding)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p><a href="#BM_(structured%20binding)%2Fi">Structured binding</a> declaration is a C++ language feature similar to Python's unpacking of lists and tuples. Given an array or a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the values contained within are unpackable to individual variables.</p>
<pre class="hljs"><code><span class="hljs-comment">// array example</span>
<span class="hljs-type">int</span> x[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
<span class="hljs-keyword">auto</span> [a, b] = x;  <span class="hljs-comment">// a is a copy of x[0], b is a copy of x[1]</span>
<span class="hljs-keyword">auto</span> &amp;[c, d] = x; <span class="hljs-comment">// c is a REFERENCE to a[0], d is a REFERENCE to a[1]</span>

<span class="hljs-comment">// class example</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;
};
MyStruct y {<span class="hljs-number">5</span>,<span class="hljs-literal">true</span>};
<span class="hljs-keyword">auto</span> [i, j] = y;  <span class="hljs-comment">// i is a copy of y.count, b is a copy of y.flag</span>
<span class="hljs-keyword">auto</span> &amp;[k, l] = y; <span class="hljs-comment">// k is a REFERENCE to y.count, l is a REFERENCE to y.flag</span>
</code></pre>
<a name="H_Expression%20Categories"></a><h2>Expression Categories</h2>
<p><a name="BM_(Core%20Language%5C%2FExpression%20Categories)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">Value categories</a> are a classification of expressions in C++. At their core, these categories are used for determining when <a href="#BM_(object%7Cinstance)%2Fi">object</a>s get <em>moved</em> vs copied, where a move means that the guts of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> are scooped out and transferred to another <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<p><img src="svgbob_636a9684b4155de37000338d0777e9a56174ac26.svg" alt="Kroki diagram output"></p>
<p>This is explicitly categorizing expressions, not <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, variables or types. Each expression is categorized as either an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>, or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>.</p>
<p>A <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is an expression that generates some transient result, where that result is typically either used for assignment or passed into a function invocation by <em>moving</em> it.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a { <span class="hljs-number">0</span> }; <span class="hljs-comment">// move -- 0 is being generated and MOVED into a (the expression 0 is a prvalue)</span>
<span class="hljs-comment">//      ^</span>
<span class="hljs-comment">//      |</span>
<span class="hljs-comment">//   rvalue</span>

<span class="hljs-type">int</span> b { a }; <span class="hljs-comment">// copy -- a already exists and its being COPIED into b (the expression a is NOT a prvalue)</span>
</code></pre>
<p>In essence, the way to think of a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is that it's an expression that meets the following 3 conditions ...</p>
<ol>
<li>
<p>can't have the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator used on it.</p>
<pre class="hljs"><code>MyStruct* a {&amp;<span class="hljs-built_in">MyStruct</span>(<span class="hljs-literal">true</span>)}; <span class="hljs-comment">// error -- right-hand expression is transient, not a var that you can get the address of   </span>
<span class="hljs-type">int</span>* b {&amp;(<span class="hljs-number">5</span>)}                  <span class="hljs-comment">// error -- right-hand expression is a literal, not a var that you can get the address of</span>
<span class="hljs-type">int</span>* c {&amp;<span class="hljs-built_in">get_int</span>()}            <span class="hljs-comment">// error -- right-hand expression is the return val of function, not a var that you can get the address of</span>
</code></pre>
</li>
<li>
<p>can have its guts be scooped out and moved into something else.</p>
<pre class="hljs"><code>x = <span class="hljs-number">55</span> + y;  <span class="hljs-comment">// expression 55 + y is evaluated and the result is MOVED into x (its guts are scooped out and moved into x)</span>
</code></pre>
</li>
<li>
<p>doesn't persist once the expression has been executed.</p>
<pre class="hljs"><code>x = <span class="hljs-number">55</span> + y;  <span class="hljs-comment">// expression 55 + y is a prvalue -- doesn't persist after this line (its not something you can access)</span>
x = c;       <span class="hljs-comment">// expression c is NOT a prvalue -- DOES persist after this line (it IS something you can keep accessing)</span>
</code></pre>
</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The name <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is short for pure right value. It's called that because <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> expressions are usually found on the right side of an assignment.</p>
</div>
<p>An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> is an expression that is the opposite of a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>. An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expression CAN use the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator (opposite of point 1 above), it CANNOT have guts scooped out and moved into something else (opposite of point 2 above), and it DOES persist (opposite of point 3 above). The typical example of an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> is an expression that's solely a variable name or function name.</p>
<pre class="hljs"><code>x = y;  <span class="hljs-comment">// both x and y are lvalue</span>
x = <span class="hljs-number">0</span>;  <span class="hljs-comment">// x is an lvalue while 0 is a prvalue</span>
</code></pre>
<p>The key takeaway with <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>s is that you might be able to <em>copy</em> over its contents to something else, but you can't scoop out its guts and <em>move</em> it over to something different. Doing so would make whatever that <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> points to no longer usable.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The name <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> is short for left value. It's called that because <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expressions are usually found on the left side of an assignment.</p>
</div>
<p>An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> is an expression which can have the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator used on it but also <em>can be moved</em>. The general idea with an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> expression is that the <a href="#BM_(object%7Cinstance)%2Fi">object</a> it represents is nearing the end of its <a href="#BM_(lifetime)%2Fi">lifetime</a> and as such moving its guts is fine. There are a very limited number of cases where this happens or is required.</p>
<pre class="hljs"><code>MyObject a {};
MyObject c { std::<span class="hljs-built_in">move</span>(a) };  <span class="hljs-comment">// std::move returns MyObject &amp;&amp; type, which calls MyObject's move constructor</span>
<span class="hljs-comment">// a is in an invalid state</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The example above is using features that haven't been introduced yet (<code>std::move</code>, <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s, <a href="#BM_(move%20constructor)%2Fi">move constructor</a>). Just ignore it if you don't know those pieces yet. They're explained in other sections.</p>
</div>
<p>This is in contrast to <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expressions, which the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator is usable on but <em>CANNOT be moved</em>. If the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator works on it, regardless of if it's moveable (<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>) or not (<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>), it's called a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">glvalue</a>.</p>
<p><img src="svgbob_2a2d0a00b43ce9677954ebe489b0081560222ce3.svg" alt="Kroki diagram output"></p>
<p>Similarly, if it's an expression that can be <em>moved</em> (gutted), it's called an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> regardless of if the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator can be used on it or not.</p>
<p><img src="svgbob_cfa8451d53907631139a68a6093bf7bd5bf2c0c4.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="http://zhaoyan.website/xinzhi/cpp/html/cppsu32.html">here</a> for what I used to clarify what's going on here.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<a name="H_Modules"></a><h2>Modules</h2>
<p><a name="BM_(Core%20Language%5C%2FModules)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Source is <a href="https://vector-of-bool.github.io/2019/03/10/modules-1.html">this website</a>.</p>
</div>
<p>C++ modules change how C++ source code files interface with each other. Normally, a C++ source / header file would use <code>#include &lt;...&gt;</code> directives to pull in other source code files that it needs access to. Those outside source code files provided things like <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros, function declarations, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> declarations, global variable constants, <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a>s, <a href="#BM_(template)%2Fi">template</a>s, etc...</p>
<p>Instead of dealing with source code files directly, C++ modules allow for independently "compiling" source code files and importing them for use into different source code files, similar to how a Java source code file imports compiled Java <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> files for use. Modules reduce some of the complexities of using header files but certain functionality is also gone. Specifically, before modules go through compilation, <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros and <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives aren't included.</p>
<p>To create a module from a single file, add <code>export module</code> followed by the name of the module in the beginning of the file. Then, prefix <code>export</code> to any function, <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, etc.. that the module should expose.</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>To make use of a module in some other source code, use <code>import</code> followed by the module's name.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> my_module;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
}
</code></pre>
<p>Similar to how non-module C++ source code is broken up into a source file containing definitions and accompanying header file containing declarations, a module may also be broken up into separate definition and declaration files. The declarations go in a file with <code>export module</code> at the top (as shown above) and the definitions go in a file with just <code>module</code>. Declaration files aren't allowed to use <code>export</code> at all.</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;

<span class="hljs-comment">// my_module_impl.cpp</span>
<span class="hljs-keyword">module</span> my_module;  <span class="hljs-comment">// no "export" in module declaration, meaning export not allowed anywhere else in this file</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>Modules may be broken up into several pieces using module partitions, with each piece in its own file, using colons (:).</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module:addition;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
<span class="hljs-keyword">export</span> my_module:multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :addition;        <span class="hljs-comment">// export everything under my_module:addition partition</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :multiplication;  <span class="hljs-comment">// export everything under my_module:multiplication partition</span>
</code></pre>
<p>Module partitions may be made non-exportable as well, similar to the definition / declaration example earlier. The parent would need to re-define anything it wants to explicitly export.</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module:addition;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
my_module:multiplication;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">import</span> :addition;
<span class="hljs-keyword">import</span> :multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;      <span class="hljs-comment">// explicitly export this function (imported from my_module:addition partition)</span>
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>; <span class="hljs-comment">// explicitly export this function (imported from my_module:multiplication partition)</span>
</code></pre>
<p>Note that there can only ever be 1 parent for a partition. All partitions are a part of their parent module, not modules themselves. The parent module must import all of its partitions using either <code>import</code> or <code>export import</code> as shown in the examples above. No module can directly import a partition that doesn't belong to it.</p>
<p>One way to work around these restrictions is to simply make the partitions their own modules. The most common way to do this is to replace the colons (:) in each partition name with a dot (.), making sure to use the full name in the import lines (because the pieces being imported are no longer partitions of the parent module).</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module.addition;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
<span class="hljs-keyword">export</span> my_module.multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> my_module.addition;        <span class="hljs-comment">// export everything under my_module.addition (FULL NAME USED)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> my_module.multiplication;  <span class="hljs-comment">// export everything under my_module.multiplication (FULL NAME USED)</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Last I recall using this, each <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> required a special flag to turn on modules. Just because your code uses modules doesn't mean the internal C++ libraries (e.g. standard <a href="#BM_(template)%2Fi">template</a> library, <code>cstdint</code>, etc..) are going to expose things as modules. You still have to include those using the <code>#include &lt;...&gt;</code> directives (maybe -- I think I remember there being some roundabout way of getting modules to work).</p>
</div>
<a name="H_Preprocessor"></a><h2>Preprocessor</h2>
<p><a name="BM_(Core%20Language%5C%2FPreprocessor)_TOPIC%2F"></a><strong></strong></p>
<p>The <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> is a component of the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>. Before the programming statements in a source code file are compiled, the processor goes over the file looking for <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives. <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">Preprocessor</a> directives either...</p>
<ol>
<li>perform some basic text manipulation.</li>
<li>signal certain things to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (e.g. use a specific feature, turn off a specific feature, etc..).</li>
</ol>
<p>The first case (text manipulation) is primarily what the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> is used for. Unlike normal C++ programming statements, <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives start with the pound sign (#) and shouldn't include a semicolon (;) at the end.</p>
<p>To include one file in another file, use <code>#include</code>. Local files should be wrapped in quotes while files coming from libraries should be wrapped in angled brackets.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>          <span class="hljs-comment">// library header</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span>  <span class="hljs-comment">// local header</span></span>
</code></pre>
<p>To replace strings in a file with another string, use <code>#define</code>.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 500</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-type">int</span> y {INITIAL_VALUE};
</code></pre>
<p>To replace strings in a file with a <em>parameterized replacement</em>, use <code>#define</code> with parenthesis.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADDED_VALUE(x, y) x + y - 15</span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-type">int</span> y {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>To stop replacing a string, use <code>#undef</code>.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 500</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> INITIAL_VALUE</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 8</span>
<span class="hljs-type">int</span> y {INITIAL_VALUE};
</code></pre>
<p>To conditionally include / ignore portions of a file, use an <code>#ifdef</code> / <code>#else</code> / <code>#endif</code> block.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>Similarly, <code>#ifndef</code> may be used to conditionally include / ignore portions of a file (<code>#ifndef</code> -- note the n, if NOT defined).</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>Conditional inclusion <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives come in an alternate form that allows for more flexible conditions: <code>#if</code> / <code>#elif</code> /<code>#else</code> / <code>#endif</code> block.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">1</span>}
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> INITIAL_VALUE &gt; 50</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE - <span class="hljs-number">50</span>}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {INITIAL_VALUE}
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a> / compilation options may be controlled through <code>#pragma</code>s. I've left <code>#pragma</code>s out of the document because they're specific to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> and platform.</p>
</div>
<a name="H_Inconsistent%20Behaviour"></a><h2>Inconsistent Behaviour</h2>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<p>High-level languages are typically very consistent. For example, except for a handful of small things, Java's <a href="#BM_(runtime)%2Fi">runtime</a> and core libraries are consistent across different platforms (e.g. Windows vs Linux), architectures (e.g. ARM vs x86), and <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s (e.g. OpenJDK vs Eclipse <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>). C++ has much less consistency than those other high-level languages because it has to support more platforms and architectures. In addition, having less consistency sometimes allows for more aggressive optimization during compilation.</p>
<p>Inconsistencies comes in three different types:</p>
<ul>
<li>Implementation-defined behaviour: Behaviour varies between implementations, where that behaviour is valid (e.g. no hard crash) and documented.</li>
<li>Unspecified behaviour: Behaviour varies between implementations, where that behaviour is valid (e.g. no hard crash) but <em>not</em> documented.</li>
<li>Undefined behaviour: Behaviour is unrestricted (e.g. maybe hard crash, bad computation, or expected computation) and not documented.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>valid</th>
<th>documented</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implementation-defined behaviour</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Unspecified behaviour</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Undefined behaviour</td>
<td>MAYBE</td>
<td>NO</td>
</tr>
</tbody>
</table>
<a name="H_Implementation-defined%20Behaviour"></a><h3>Implementation-defined Behaviour</h3>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour%2FImplementation-defined%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<p>Implementation-defined behaviour is behaviour that varies between implementations, where that behaviour is valid (e.g. no hard crash) and documented. The obvious example is with numeric data types: <code>short</code>, <code>int</code>, <code>float</code>, etc.. will each have a different minimum and maximum across different platforms:</p>
<ul>
<li><code>short</code> is from <code>SHORT_MIN</code> to <code>SHORT_MAX</code>.</li>
<li><code>int</code> is from <code>INT_MIN</code> to <code>INT_MAX</code>.</li>
<li>...</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Someone posted <a href="http://eel.is/c++draft/impldefindex">this</a> as a comprehensive list of implementation-defined behaviour.</p>
</div>
<a name="H_Unspecified%20Behaviour"></a><h3>Unspecified Behaviour</h3>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour%2FUnspecified%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<p>Unspecified behaviour is behaviour that varies between implementations, where that behaviour is valid (e.g. no hard crash) but <em>not</em> documented. The obvious example is the order in which operands are evaluated in an expression. For example, consider the following statement ...</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-built_in">bird_func</span>() / <span class="hljs-built_in">cow_func</span>()};
</code></pre>
<p>The results of <code>bird_func()</code> and <code>cow_func()</code> may be gotten in any order prior to performing the division. There is no requirement as to which one gets invoked first. The division itself with the correct operands in the correct spots, but which function gets called first is up to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// option1  -- bird_func() evaluated first</span>
<span class="hljs-type">int</span> a {<span class="hljs-built_in">bird_func</span>()};
<span class="hljs-type">int</span> b {<span class="hljs-built_in">cow_func</span>()};
<span class="hljs-type">int</span> x {a / b};

<span class="hljs-comment">// option2  -- cow_func() evaluated first</span>
<span class="hljs-type">int</span> b {<span class="hljs-built_in">cow_func</span>()};
<span class="hljs-type">int</span> a {<span class="hljs-built_in">bird_func</span>()};
<span class="hljs-type">int</span> x {a / b};
</code></pre>
<p>Another example is the memory representation of core types (e.g. integral types). The platform's memory layout could be either big-endian, little-endian, or some other uncommon memory layout.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-comment">// big endian:    00 00 00 05  (e.g. ARM)</span>
<span class="hljs-comment">// little endian: 05 00 00 00  (e.g. x86)</span>
</code></pre>
<p>The above doesn't matter unless you're trying to read raw contents of core types (e.g. for serializing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to disk).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This may not be the case anymore in C++20 because the C++ standard library has <code>std::endian</code>, which tells you the endian-ness of scalar types.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I wasn't able to find a comprehensive list of what the C++ spec considers as unspecified behaviour.</p>
</div>
<a name="H_Undefined%20Behaviour"></a><h3>Undefined Behaviour</h3>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour%2FUndefined%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>According to documentation online: "<a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a>s are not required to diagnose or do anything meaningful when undefined behaviour is present. Correct C++ programs are free of undefined behaviour". Not exactly sure how to fix some scenarios to be "free" of undefined behaviour. Specifically, there are a lot of cases where signed integer overflow (described below) happens, but that's undefined behaviour. I read online that the way to handle these cases is to test at the beginning of the function if overflow is possible and bail out if it is, but there's no built-in C++ mechanism to do that.</p>
<p>The statement and the examples below, were lifted from <a href="https://en.cppreference.com/w/cpp/language/ub">here</a>.</p>
</div>
<p>Undefined behaviour is behaviour that is unrestricted and not documented. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may do anything for code producing undefined behaviour. For example, code producing undefined behaviour could end up ...</p>
<ul>
<li>causing a hard crash.</li>
<li>doing exactly what the author of the source code originally intended for.</li>
<li>doing something different than what the author of the source code originally intended for.</li>
<li>causing the program to not immediately crash, but potentially much later.</li>
</ul>
<p>None of the examples have to be consistent. For example, it could produce a hard crash some of the time and the intended results the rest of the time.</p>
<ul>
<li>
<p>Signed integer overflow</p>
<p>Although signed integers are guaranteed to be two's complement (as of C++20), what happens when a signed integer overflows is still undefined behaviour. In many cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will treat signed integer operations as if overflowing isn't possible. For example, consider the following function ...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x &lt; x + <span class="hljs-number">1</span>;
}
</code></pre>
<p>What may happen: The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s will optimize away the return expression to always return <code>true</code>. Had signed integer overflow NOT been undefined behaviour, the function would return <code>true</code> except in the case where <code>x == INT_MAX</code>: When <code>x == INT_MIN</code>, the expression <code>x + 1</code> would rollover to <code>INT_MIN</code>, leading <code>x &lt; x + 1</code> to evaluate to <code>false</code>.</p>
</li>
<li>
<p>Array out of bounds access</p>
<p>Array out of bounds access typically ends up touching memory past the array's boundaries.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> data[<span class="hljs-number">5</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
data[<span class="hljs-number">65535</span>] {<span class="hljs-number">15</span>};
</code></pre>
<p>What may happen: Out of bounds data access will result in either...</p>
<ul>
<li>the reading/writing of some other <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s memory (e.g. corruption of another <a href="#BM_(object%7Cinstance)%2Fi">object</a>, if writing).</li>
<li>the reading/writing of memory not assigned to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</li>
<li>a crash.</li>
</ul>
</li>
<li>
<p>Uninitialized scalar</p>
<p>Uninitialized scalars are scalars that are read before being written to.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x;
std:cout &lt;&lt; x; <span class="hljs-comment">// what's in x? </span>
</code></pre>
<p>What may happen: Uninitialized scalars contain junk data (e.g. whatever was in the memory before).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Scalar typically means arithmetic type or <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a> type. See <a href="https://stackoverflow.com/a/14822074">this</a>.</p>
</div>
</li>
<li>
<p>Invalid scalar</p>
<p>When a scalar gets reinterpreted as something else (e.g. a byte array) and its contents are manipulated, reading from that original scalar is undefined behaviour.</p>
<pre class="hljs"><code><span class="hljs-comment">// EXAMPLE FROM https://en.cppreference.com/w/cpp/language/ub</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">bool</span> b {<span class="hljs-literal">true</span>};
    <span class="hljs-keyword">unsigned</span> <span class="hljs-type">char</span>* p {<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;b)};
    *p {<span class="hljs-number">10</span>};
    <span class="hljs-comment">// reading from b is now UB</span>
    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span>;
}
</code></pre>
<p>What may happen: modifications on the reinterpretation are treated as if it never happened.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Scalar typically means arithmetic type or <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a> type. See <a href="https://stackoverflow.com/a/14822074">this</a>.</p>
</div>
</li>
<li>
<p>Null <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a></p>
<pre class="hljs"><code><span class="hljs-comment">// EXAMPLE FROM https://en.cppreference.com/w/cpp/language/ub</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>{
    <span class="hljs-type">int</span> x {*p};
    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// Either UB above or this branch is never taken</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span>* p {<span class="hljs-literal">nullptr</span>};
    <span class="hljs-keyword">return</span> *p;        <span class="hljs-comment">// Unconditional UB</span>
}
</code></pre>
<p>What may happen: Trying to read or write to a <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>d <code>nullptr</code> will cause a crash.</p>
</li>
<li>
<p>Side-effect free infinite loops</p>
<p>A side-effect free infinite loop is a loop that goes on forever but doesn't change anything outside of its own scope (e.g. no global variable is changed, nothing is printed to standard out, etc..).</p>
<pre class="hljs"><code><span class="hljs-comment">// EXAMPLE FROM https://en.cppreference.com/w/cpp/language/ub</span>
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (((a*a*a) == ((b*b*b)+(c*c*c)))) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    a++;
    <span class="hljs-keyword">if</span> (a&gt;MAX) { a=<span class="hljs-number">1</span>; b++; }
    <span class="hljs-keyword">if</span> (b&gt;MAX) { b=<span class="hljs-number">1</span>; c++; }
    <span class="hljs-keyword">if</span> (c&gt;MAX) { c=<span class="hljs-number">1</span>;}
}
</code></pre>
<p>What may happen: Side-effect free infinite loops are removed entirely.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I wasn't able to find a comprehensive list of what the C++ spec considers as undefined behaviour. The above examples were taken from <a href="https://en.cppreference.com/w/cpp/language/ub">cpp</a><a href="#BM_(reference)%2Fi">reference</a>.</p>
</div>
<a name="H_Library%20Functions"></a><h1>Library Functions</h1>
<p><a name="BM_(Library%20Functions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language)_TOPIC%2F">Core Language</a></li>
</ul>
</div>
<p>By default, C++ comes packages with the C++ standard library. You can think of this as C++'s equivalent of core Java packages: collection <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es in <code>java.util</code>, thread <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es in <code>java.util.concurrent</code>, IO <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es in <code>java.io</code>, etc... In addition, several third-party C++ libraries exist that provide commonly needed functionality. You can think of these are as C++'s equivalent to common Java libraries: Guava, Apache Commons, etc...</p>
<p>Common third-party C++ libraries:</p>
<ul>
<li><a href="https://www.boost.org/">Boost</a></li>
<li><a href="https://abseil.io/">Absiel</a> (Google)</li>
<li><a href="https://github.com/facebook/folly">Folly</a> (Facebook)</li>
</ul>
<p>The subsections below detail important functionality across the many C++ libraries in existence. If the functionality being documented is for a third party library, it'll be signalled in some way (e.g. <a href="#BM_(namespace)%2Fi">namespace</a> / header files / comments used in sample code will make it apparent).</p>
<a name="H_Type%20Traits"></a><h2>Type Traits</h2>
<p><a name="BM_(Library%20Functions%5C%2FType%20Traits)_TOPIC%2F"></a><strong></strong></p>
<p>The C++ standard library includes a set of <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that detects the traits of a type at <a href="#BM_(compile-time)%2Fi">compile-time</a>. This is useful in cases where <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s need to be restricted.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(T t)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(std::is_integral&lt;T&gt;::value, <span class="hljs-string">"Must be integral"</span>);
    <span class="hljs-keyword">return</span> t + <span class="hljs-number">1</span>;
}

<span class="hljs-built_in">test</span>(<span class="hljs-number">4</span>);     <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">4ULL</span>);  <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">4.09</span>);  <span class="hljs-comment">// FAIL -- 4.09 is a floating point number, not an integral number</span>
</code></pre>
<p>The <code>value</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is <code>true</code> / <code>false</code> depending on if the type passes the check. A shortcut in later versions of C++ is to append <code>_v</code> to the name of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> performing the check rather than explicitly querying the <code>value</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> (e.g. <code>std::is_integral&lt;T&gt;::value</code> vs <code>std::is_integral_v&lt;T&gt;</code>).</p>
<p>List of useful checks:</p>
<ul>
<li><code>std::is_signed</code> - ensures a type is signed.</li>
<li><code>std::is_unsigned</code> - ensures a type is unsigned.</li>
<li><code>std::is_integral</code> - ensures a type is an integer (e.g. <code>short int</code>, <code>int</code>, <code>unsigned long long int</code>, etc..)</li>
<li><code>std::is_pod</code> - ensures a type is a <a href="#BM_(POD)%2F">POD</a>.</li>
<li><code>std::is_fundamental</code> - ensures a type is a <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>.</li>
<li><code>std::is_abstract</code> - ensures a type is an abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (has at least one <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual function</a>).</li>
<li><code>std::is_copy_constructible</code> - ensures type has a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>.</li>
<li><code>std::is_copy_assignable</code> - ensures type has <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a>.</li>
<li><code>std::is_move_constructible</code> - ensures type has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>.</li>
<li><code>std::is_nothrow_move_constructible</code> - ensures type has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a> that never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> (<code>noexcept</code>).</li>
<li><code>std::is_move_assignable</code> - ensures type has <a href="#BM_(move%20assignment)%2Fi">move assignment</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FAliasing)_TOPIC%2F">Core Language/Variables/Aliasing</a> (refresher)</li>
</ul>
</div>
<p>Type traits may also be manipulated at <a href="#BM_(compile-time)%2Fi">compile-time</a> via a set of <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span> </span>{
    <span class="hljs-keyword">using</span> R = std::make_unsigned&lt;T&gt;::type;  <span class="hljs-comment">// R is same type as T but unsigned (if it already isn't)</span>
    R x { t + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>The <code>type</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> contains the name type. A shortcut in later versions of C++ is to append <code>_t</code> to the name of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> doing the manipulation rather than explicitly querying the <code>type</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> (e.g. <code>std::make_unsigned&lt;T&gt;::type</code> vs <code>std::make_unsigned_t&lt;T&gt;</code>).</p>
<p>List of useful conversions:</p>
<ul>
<li><code>std::remove_cv</code> - remove <code>const</code> and / or <code>volatile</code>.</li>
<li><code>std::remove_const</code> - remove <code>const</code>.</li>
<li><code>std::remove_volatile</code> - remove <code>volatile</code>.</li>
<li><code>std::remove_pointer</code> - make into non-<a href="#BM_(pointer)%2Fi">pointer</a> type (removes a <code>*</code> from the type).</li>
<li><code>std::remove_reference</code> - make into non-<a href="#BM_(reference)%2Fi">reference</a> type.</li>
<li><code>std::add_cv</code> - add <code>const</code> and / or <code>volatile</code>.</li>
<li><code>std::add_const</code> - add <code>const</code>.</li>
<li><code>std::add_volatile</code> - add <code>volatile</code>.</li>
<li><code>std::add_pointer</code> - make into <a href="#BM_(pointer)%2Fi">pointer</a> type (adds a <code>*</code> to the type).</li>
<li><code>std::add_lvalue_reference</code> - make into a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> type.</li>
<li><code>std::add_rvalue_reference</code> - make into a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> type.</li>
<li><code>std::make_signed</code> - make into an equivalent version of the same type that's signed.</li>
<li><code>std::make_unsigned</code> - make into an equivalent version of the same type that's unsigned.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Are <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s used to write these checks and transformations? Maybe.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F">Core Language/Compile-time Evaluation</a></li>
</ul>
</div>
<a name="H_Allocators"></a><h2>Allocators</h2>
<p><a name="BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F"></a><strong></strong></p>
<p>Allocators allow for customizing how <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. Some library APIs allow you to provide a custom allocator rather than using the typical <code>new</code>/<code>new[]</code> and <code>delete</code>/<code>delete[]</code> operators. In certain scenarios where performance is important (e.g. gaming, simulations, high-frequency trading, etc..), custom allocators are often used. A custom allocator could increase performance by ...</p>
<ul>
<li>using alternate data structures (e.g. finding free memory to assign to a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> is faster).</li>
<li>using an <a href="#BM_(object%7Cinstance)%2Fi">object</a> pool (e.g. an <a href="#BM_(object%7Cinstance)%2Fi">object</a> put back into the pool and taken out again may not need to be fully re-initialized).</li>
<li>attempting to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> related <a href="#BM_(object%7Cinstance)%2Fi">object</a>s closer together in memory (e.g. less cache misses).</li>
</ul>
<p>By default, libraries that support custom allocators will default to <code>std::allocator</code>, which just wraps the <code>new</code>/<code>new[]</code> and <code>delete</code>/<code>delete[]</code> operators.</p>
<p>To implement a custom allocator, you need to create a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> with a single <a href="#BM_(template%20parameter)%2Fi">template parameter</a> representing the type being <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> must have the following traits...</p>
<ol>
<li>a <a href="#BM_(default%20constructor)%2Fi">default constructor</a>.</li>
<li>a <a href="#BM_(constructor)%2Fi">constructor</a> to "rebind" another allocator (copy).</li>
<li>a nested <a href="#BM_(type%20alias)%2Fi">type alias</a> <code>value_type</code> corresponding to the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</li>
<li>an <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</li>
<li>a <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</li>
<li><a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s for equality inequality.</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocator</span> {
    <span class="hljs-keyword">using</span> value_type = T;  <span class="hljs-comment">// 3</span>

    <span class="hljs-built_in">MyAllocator</span>() <span class="hljs-keyword">noexcept</span>{ }  <span class="hljs-comment">// 1</span>
    
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-built_in">MyAllocator</span>(<span class="hljs-keyword">const</span> MyAllocator&lt;U&gt;&amp;) <span class="hljs-keyword">noexcept</span> { }  <span class="hljs-comment">// 2 (why is this here? https://docs.microsoft.com/en-us/cpp/standard-library/allocator-class?view=msvc-170#allocator)</span>
    
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>{ <span class="hljs-comment">// 4</span>
        <span class="hljs-keyword">auto</span> ret = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(T) * n);
        std::cout &lt;&lt; <span class="hljs-string">"allocated!"</span> &lt;&lt; ret &lt;&lt; <span class="hljs-string">"\n"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(ret);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* p, <span class="hljs-type">size_t</span> n)</span> </span>{ <span class="hljs-comment">//5</span>
        std::cout &lt;&lt; <span class="hljs-string">"deallocated!"</span> &lt;&lt; ret &lt;&lt; <span class="hljs-string">"\n"</span>;
        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MyAllocator&lt;T1&gt;&amp;, <span class="hljs-keyword">const</span> MyAllocator&lt;T2&gt;&amp;) { <span class="hljs-comment">// 6 (why is this here? https://stackoverflow.com/a/30654267)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// always because this class retains no state</span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> MyAllocator&lt;T1&gt;&amp;, <span class="hljs-keyword">const</span> MyAllocator&lt;T2&gt;&amp;) { <span class="hljs-comment">// 6 (why is this here? https://stackoverflow.com/a/30654267)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// always because this class retains no state</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I don't fully understand what the <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> and the <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s are for. The <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> seems to be for cases where you pass in an allocator to some container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (e.g. <code>vector</code>) but that container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> needs to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> more than just the type you're interested in. For example, the allocator may be for creating <code>int</code>s (e.g. <a href="#BM_(template%20parameter)%2Fi">template parameter</a> <code>T</code> = <code>int</code>) but the container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> you're storing those <code>int</code>s may have bookkeeping structures that it wraps each <code>int</code> in (e.g. each <code>int</code> is wrapped as a <code>Node</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> which also contains some extra <a href="#BM_(pointer)%2Fi">pointer</a>s). This <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> "repurposes" the allocator, allowing you to to pass in <code>MyAllocator&lt;int&gt;</code> but have it repurposed to <code>MyAllocator&lt;SomeOtherTypeHere&gt;</code>.</p>
<p>But if you're copying the guts of one allocator into another but both keep on allocating and deallocating, won't they trip up over each other?</p>
<p>I haven't been able to find answers online as to what's going on here. The book just seems to hand wave it away.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Why not just do <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing for the new operator? The answer seems to be that allocators are simpler to deal with and handle wider scenarios (such as the concatenating example in the note above).</p>
</div>
<a name="H_Smart%20Pointers"></a><h2>Smart Pointers</h2>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a> (refresher)</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F">Core Language/Classes/Copying</a> (refresher)</li>
</ul>
</div>
<p><a href="#BM_(smart%20pointer)%2Fi">Smart pointer</a>s are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that wrap <a href="#BM_(pointer)%2Fi">pointer</a>s to dynamically <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. These wrappers provide some level of automated <a href="#BM_(pointer)%2Fi">pointer</a> management / memory management through the use of move semantics, <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>, and <a href="#BM_(RAII%7CCADRe)%2F">RAII</a>.</p>
<p>The subsections below document some common <a href="#BM_(smart%20pointer)%2Fi">smart pointer</a>s and their usages.</p>
<a name="H_Scoped%20Pointer"></a><h3>Scoped Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FScoped%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<p>(non-moveable, non-copyable)</p>
<p>A scoped <a href="#BM_(pointer)%2Fi">pointer</a> wraps a <a href="#BM_(pointer)%2Fi">pointer</a> to an existing <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> / <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a> and invokes <code>delete</code> / <code>delete[]</code> on it once it exits the current scope. It explicitly turns off <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics, meaning that copying a scoped <a href="#BM_(pointer)%2Fi">pointer</a> or moving it isn't allowed.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x == <span class="hljs-number">123L</span>) {
    boost::scoped_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
    x += *ptr; <span class="hljs-comment">// like a real pointer, use indirection operator / member of pointer operator </span>
} <span class="hljs-comment">// ptr destroyed via delete operator at the end of if block (RAII)</span>
</code></pre>
<p>Scoped <a href="#BM_(pointer)%2Fi">pointer</a>s come in two flavours:</p>
<ul>
<li><code>scoped_ptr</code>: <a href="#BM_(pointer)%2Fi">pointer</a> to a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>.</li>
<li><code>scoped_array</code>: <a href="#BM_(pointer)%2Fi">pointer</a> to a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>.</li>
</ul>
<pre class="hljs"><code>boost::scoped_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
boost::scoped_array&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>] {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>} }};
</code></pre>
<p>Although the official move semantics of a scoped <a href="#BM_(pointer)%2Fi">pointer</a> are to deny moves, it does provide a ...</p>
<ul>
<li><code>swap()</code> function that lets you swap the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s between two scoped <a href="#BM_(pointer)%2Fi">pointer</a>s.</li>
<li><code>destroy()</code> function that destroys the current <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> and sets it to the argument passed in, if any.</li>
</ul>
<p>In addition, it's possible to have an unset scoped <a href="#BM_(pointer)%2Fi">pointer</a> (<code>nullptr</code>). An unset scoped <a href="#BM_(pointer)%2Fi">pointer</a> won't attempt to destroy an <a href="#BM_(object%7Cinstance)%2Fi">object</a> when it goes out of scope.</p>
<a name="H_Unique%20Pointer"></a><h3>Unique Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FUnique%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FScoped%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Scoped Pointer</a></li>
</ul>
</div>
<p>(moveable, non-copyable)</p>
<p>A unique <a href="#BM_(pointer)%2Fi">pointer</a> supports all the same features as a scoped <a href="#BM_(pointer)%2Fi">pointer</a>, except that it also supports moving: The ownership of the <a href="#BM_(pointer)%2Fi">pointer</a> that unique <a href="#BM_(pointer)%2Fi">pointer</a> has is transferable to another unique <a href="#BM_(pointer)%2Fi">pointer</a> via move semantics (e.g. assignment operator <a href="#BM_(move%20constructor)%2Fi">move constructor</a>). Like scoped <a href="#BM_(pointer)%2Fi">pointer</a>, a unique <a href="#BM_(pointer)%2Fi">pointer</a> doesn't support copying.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x == <span class="hljs-number">123L</span>) {
    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
    x += *ptr;
    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 { std::<span class="hljs-built_in">move</span>(ptr) };  <span class="hljs-comment">// ALLOWED: move ptr into ptr2 -- ptr is invalid after this point</span>
    x -= *ptr2;
}
</code></pre>
<p>Unlike scoped <a href="#BM_(pointer)%2Fi">pointer</a>s, a unique <a href="#BM_(pointer)%2Fi">pointer</a> uses the same <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> for both <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s and <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s.</p>
<pre class="hljs"><code>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>] {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>} }};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Look at the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s in the example above. It's important that you add <code>[]</code> into the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> when you're dealing with arrays so the destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a> operator (<code>delete[]</code>) gets used. If the destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> operator (<code>delete</code>) is used for an array, it's undefined behaviour. Likewise, don't add <code>[]</code> into the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> if you aren't dealing with arrays.</p>
</div>
<p>In older versions of C++, the <a href="#BM_(template)%2Fi">template</a>d function <code>std::make_unique()</code> was provided to create unique <a href="#BM_(pointer)%2Fi">pointer</a>s because the normal way (shown in the example above) has subtle edge cases that could result in memory leaks. Newer versions of C++ fixed the memory leak problem, so using <code>std::make_unique()</code> isn't necessary but it's still available for backwards compatibility.</p>
<pre class="hljs"><code><span class="hljs-comment">// following two are equivalent</span>
std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>);  <span class="hljs-comment">// make_unique automatically calls new</span>
</code></pre>
<p>Unique <a href="#BM_(pointer)%2Fi">pointer</a>s don't support custom allocators: You pass the <a href="#BM_(pointer)%2Fi">pointer</a> you want to track directly into the <a href="#BM_(constructor)%2Fi">constructor</a> or create it via <code>std::make_unique()</code>. But, unique <a href="#BM_(pointer)%2Fi">pointer</a>s do support taking in a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a> (e.g. function, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, <a href="#BM_(lambda)%2Fi">lambda</a>) to invoke instead of using <code>delete</code> / <code>delete[]</code> on the tracked <a href="#BM_(pointer)%2Fi">pointer</a>. This is useful in cases where the <a href="#BM_(pointer)%2Fi">pointer</a> is being tracked ...</p>
<ul>
<li>wasn't created using <code>new</code> / <code>new[]</code> (e.g. <code>FILE *</code> created using <code>fopen()</code>).</li>
<li>needs to have deletion logged (e.g. print out whenever the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is deleted).</li>
<li>is associated with extra resources that need to be handled in some way on release.</li>
</ul>
<p>For example, a unique <a href="#BM_(pointer)%2Fi">pointer</a> that points to a memory mapped file region shouldn't call <code>delete[]</code> when it goes out of scope because it isn't actually pointing to a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>. Instead, it should invoke the relevant function(s) that release a memory mapped file region.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> custom_deleter = [](<span class="hljs-type">int</span>* x) {
    std::cout &lt;&lt; <span class="hljs-string">"Deleting an int at "</span> &lt;&lt; x;
    <span class="hljs-keyword">delete</span> x;
};
std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(custom_deleter)&gt; ptr{ <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>}, custom_deleter };
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Types have to match -- if the unique pointer is for an "int", the custom deleter should take in an "int *"</span>
</code></pre>
<a name="H_Shared%20Pointer"></a><h3>Shared Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FShared%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FUnique%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Unique Pointer</a></li>
</ul>
</div>
<p>(moveable, copyable)</p>
<p>A shared <a href="#BM_(pointer)%2Fi">pointer</a> tracks the number of copies it has in existence and only destroys the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> it points to once the number of copies reaches 0 (<a href="#BM_(reference)%2Fi">reference</a> counting). The <a href="#BM_(reference)%2Fi">reference</a> count increments when a new copy is made (e.g. <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>) and decrements when a copy is destroyed (e.g. goes out of scope). Moves don't modify the <a href="#BM_(reference)%2Fi">reference</a> count.</p>
<pre class="hljs"><code>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} }; <span class="hljs-comment">// ref count 1</span>
<span class="hljs-keyword">if</span> (x == <span class="hljs-number">123L</span>) {
    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptrCopy { ptr }; <span class="hljs-comment">// ref count 2</span>
    x += *ptrCopy;
} <span class="hljs-comment">// ref count back to 1 because ptrCopy destroyed here</span>
x -= *ptr2;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's a version of shared <a href="#BM_(pointer)%2Fi">pointer</a> in Boost and one in the C++ standard library. The Boost version is legacy.</p>
</div>
<p>The construction of shared <a href="#BM_(pointer)%2Fi">pointer</a>s is similar to the construction of unique <a href="#BM_(pointer)%2Fi">pointer</a>s. You can either call the <a href="#BM_(constructor)%2Fi">constructor</a> directly or you can use the <a href="#BM_(template)%2Fi">template</a>d function <code>std::make_shared()</code>. Where as <code>std::make_unique()</code> was a legacy creation mechanism for unique <a href="#BM_(pointer)%2Fi">pointer</a>s, <code>std::make_shared()</code> is the preferred creation mechanism for shared <a href="#BM_(pointer)%2Fi">pointer</a>s. That's because shared <a href="#BM_(pointer)%2Fi">pointer</a>s require a "control block" that holds onto tracking information (e.g. <a href="#BM_(reference)%2Fi">reference</a> counts), and using <code>std:make_shared()</code> <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>s that control block along with the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> in one single <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> (better performance: one <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> vs two <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a>s).</p>
<pre class="hljs"><code>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>) };  <span class="hljs-comment">// allocates the control block and object together</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>] {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>} }};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book says that sometimes you want to avoid <code>std::make_shared</code> because you might need the control block even if the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> goes away (mentions weak <a href="#BM_(pointer)%2Fi">pointer</a>s). This isn't possible if the control block and the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> are <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d as one, because if they're <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d as one then you can't individually delete them (you can only delete both things at once).</p>
</div>
<p>Like unique <a href="#BM_(pointer)%2Fi">pointer</a>, shared <a href="#BM_(pointer)%2Fi">pointer</a>'s <a href="#BM_(constructor)%2Fi">constructor</a> may take in a custom deleter. In addition, it may also take in a custom allocator. The custom allocator has nothing to do with the underlying <a href="#BM_(pointer)%2Fi">pointer</a> -- it gets used for allocating and deallocating the control block.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> object_deleter = [](<span class="hljs-type">int</span>* x) {
    std::cout &lt;&lt; <span class="hljs-string">"Deleting an int at "</span> &lt;&lt; x;
    <span class="hljs-keyword">delete</span> x;
};
<span class="hljs-keyword">auto</span> control_block_allocator { std::allocator&lt;<span class="hljs-type">void</span>&gt;{}} ;
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr{ <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>}, object_deleter, control_block_allocator };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There are no <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s for the deleter or allocator. You just pass them in as the last two <a href="#BM_(constructor)%2Fi">constructor</a> arguments and it should just work. The book is saying that they were left out for "complicated reason".</p>
</div>
<p>It isn't possible to use a custom allocator with <code>std::make_shared()</code>. It forces the use of <code>new</code> / <code>new[]</code> and <code>delete</code> / <code>delete[]</code> for single combined <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> of the control block and the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>. To perform a single combined <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and use a custom allocator for that <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a>, you need to use <code>std::allocate_shared()</code> instead.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> my_allocator { std::allocator&lt;<span class="hljs-type">void</span>&gt;{}} ;
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr{ std::<span class="hljs-built_in">allocate_shared</span>&lt;<span class="hljs-type">int</span>&gt;(my_allocator, <span class="hljs-number">5</span>) };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There is no <a href="#BM_(template%20parameter)%2Fi">template parameter</a> for the allocator. You just pass it in as the first <a href="#BM_(constructor)%2Fi">constructor</a> argument and it should just work.</p>
<p>There is no custom deleter with <code>std::allocate_shared</code> because the deletion happens via the allocator. Both the control block and the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> are being <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d together.</p>
</div>
<p>In certain cases, a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> may want to return shared <a href="#BM_(pointer)%2Fi">pointer</a>s to itself (a shared <a href="#BM_(pointer)%2Fi">pointer</a> to its <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>). A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can't ...</p>
<ul>
<li>maintain a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a> that's a shared <a href="#BM_(pointer)%2Fi">pointer</a> to itself: That shared <a href="#BM_(pointer)%2Fi">pointer</a>'s <a href="#BM_(reference)%2Fi">reference</a> count would never reach 0 because the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself will always be holding onto a copy of that shared <a href="#BM_(pointer)%2Fi">pointer</a>.</li>
<li>provide a function to generate shared <a href="#BM_(pointer)%2Fi">pointer</a>s to itself: There will be multiple shared <a href="#BM_(pointer)%2Fi">pointer</a>s leading to the same <a href="#BM_(object%7Cinstance)%2Fi">object</a>, meaning that if one of those shared <a href="#BM_(pointer)%2Fi">pointer</a>s were to reach a <a href="#BM_(reference)%2Fi">reference</a> count of 0 it would delete the <a href="#BM_(object%7Cinstance)%2Fi">object</a> while the other shared <a href="#BM_(pointer)%2Fi">pointer</a>s would still think the <a href="#BM_(object%7Cinstance)%2Fi">object</a> still exists (dangling <a href="#BM_(pointer)%2Fi">pointer</a>).</li>
</ul>
<p>To work around these problems, C++ provides the <code>std::enable_shared_from_this</code> base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can inherit from.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; {
    <span class="hljs-function">shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPointer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">// special function provided by the base class</span>
    }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://stackoverflow.com/a/712307">here</a> for more information.</p>
</div>
<a name="H_Weak%20Pointer"></a><h3>Weak Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FWeak%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FShared%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Shared Pointer</a></li>
</ul>
</div>
<p>A weak <a href="#BM_(pointer)%2Fi">pointer</a> is essentially a shared <a href="#BM_(pointer)%2Fi">pointer</a> that doesn't increment or decrement the <a href="#BM_(reference)%2Fi">reference</a> count. At any moment, it can generate an actual shared <a href="#BM_(pointer)%2Fi">pointer</a> via its <code>lock()</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, thereby increasing the <a href="#BM_(reference)%2Fi">reference</a> count.</p>
<pre class="hljs"><code>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp1 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} }; <span class="hljs-comment">// ref count = 1</span>
std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp{ sp };              <span class="hljs-comment">// ref count = 1</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 { wp.<span class="hljs-built_in">lock</span>() };   <span class="hljs-comment">// ref count = 2</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 { wp.<span class="hljs-built_in">lock</span>() };   <span class="hljs-comment">// ref count = 3</span>
</code></pre>
<p>If the shared <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(reference)%2Fi">reference</a> count has already reached 0 when <code>lock()</code> is invoked, the returned shared <a href="#BM_(pointer)%2Fi">pointer</a> will be empty.</p>
<pre class="hljs"><code>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp {};  <span class="hljs-comment">// unset weak pointer</span>
{
    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };  <span class="hljs-comment">// create a new shared pointer</span>
    wp = sp;                                  <span class="hljs-comment">// assign the shared pointer to the weak pointer</span>
} <span class="hljs-comment">// scope ends, shared pointer destroyed (reference count drops from 1 to 0, meaning object is deleted)</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp { wp.<span class="hljs-built_in">lock</span>() };
<span class="hljs-type">bool</span> isEmpty = (sp == std::<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// isEmpty will be true</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's a version of weak <a href="#BM_(pointer)%2Fi">pointer</a> in Boost and one in the C++ standard library. The Boost version is legacy. Each weak <a href="#BM_(pointer)%2Fi">pointer</a> version is tied to the shared <a href="#BM_(pointer)%2Fi">pointer</a> from its library. For example, if you're using the weak <a href="#BM_(pointer)%2Fi">pointer</a> in Boost, you need to use it with the shared <a href="#BM_(pointer)%2Fi">pointer</a> from Boost.</p>
</div>
<p>The typical use-cases for weak <a href="#BM_(pointer)%2Fi">pointer</a>s are ...</p>
<ul>
<li>caching (e.g. only calculate data if weak <a href="#BM_(pointer)%2Fi">pointer</a> is unset).</li>
<li>cyclical <a href="#BM_(reference)%2Fi">reference</a>s (e.g. data structures such as cyclical graphs).</li>
</ul>
<p>For cyclical <a href="#BM_(reference)%2Fi">reference</a>s point above, what it means is that shared <a href="#BM_(pointer)%2Fi">pointer</a>s forming a cycle will never reach a <a href="#BM_(reference)%2Fi">reference</a> count of 0.</p>
<p><img src="svgbob_25474d39768e24b30a0b2722d8a979da4683892a.svg" alt="Kroki diagram output"></p>
<p>In the example above...</p>
<ul>
<li>A has a shared <a href="#BM_(pointer)%2Fi">pointer</a> to C (<a href="#BM_(reference)%2Fi">reference</a> count = 1)</li>
<li>C has a shared <a href="#BM_(pointer)%2Fi">pointer</a> to B (<a href="#BM_(reference)%2Fi">reference</a> count = 1)</li>
<li>B has a shared <a href="#BM_(pointer)%2Fi">pointer</a> to A (<a href="#BM_(reference)%2Fi">reference</a> count = 1)</li>
</ul>
<p>Nothing else holds these shared <a href="#BM_(pointer)%2Fi">pointer</a>s. They all <a href="#BM_(reference)%2Fi">reference</a> each other, meaning that none of the shared <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(reference)%2Fi">reference</a> counts will never reach 0 (memory leak).</p>
<a name="H_Intrusive%20Pointer"></a><h3>Intrusive Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FIntrusive%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FShared%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Shared Pointer</a></li>
</ul>
</div>
<p>An intrusive <a href="#BM_(pointer)%2Fi">pointer</a> invokes the <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> <code>intrusive_ptr_add_ref()</code> on any <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and <code>intrusive_ptr_release()</code> on any <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>. Both functions take in a single argument: a <a href="#BM_(pointer)%2Fi">pointer</a> of the type being <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d.</p>
<pre class="hljs"><code><span class="hljs-type">size_t</span> cnt {};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intrusive_ptr_add_ref</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>{
    cnt++;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intrusive_ptr_release</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>{
    cnt--;
}

boost::intrusive_ptr&lt;<span class="hljs-type">int</span>&gt; a { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>{<span class="hljs-number">5</span>} };     <span class="hljs-comment">// after this, cnt will be 1</span>
{
    boost::intrusive_ptr&lt;<span class="hljs-type">int</span>&gt; b { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>{<span class="hljs-number">6</span>} }; <span class="hljs-comment">// after this, cnt will be 2</span>
    boost::intrusive_ptr&lt;<span class="hljs-type">int</span>&gt; c { a };          <span class="hljs-comment">// after this, cnt will be 3</span>
} <span class="hljs-comment">// at the end of this scope, cnt will be 1 again</span>
</code></pre>
<p>Where as a shared <a href="#BM_(pointer)%2Fi">pointer</a> keeps a count of how many copies of itself are live (<a href="#BM_(reference)%2Fi">reference</a> count), an intrusive <a href="#BM_(pointer)%2Fi">pointer</a> is typically used for keeping count of how many of some specific <em><a href="#BM_(pointer)%2Fi">pointer</a> type</em> are live. In the example above it's tracking <code>int</code>, but you can track more types by simply <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing <code>intrusive_ptr_add_ref()</code> and <code>intrusive_ptr_release()</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions that this is useful in cases where the OS or framework requires some cleanup operation once the last <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of some type goes away (e.g. the old school Windows component <a href="#BM_(object%7Cinstance)%2Fi">object</a> model).</p>
</div>
<a name="H_Wrappers"></a><h2>Wrappers</h2>
<p><a name="BM_(Library%20Functions%5C%2FWrappers)_TOPIC%2F"></a><strong></strong></p>
<p>There are utility <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that wrap one or more other <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, such as optionals or tuples. They either provide some type of extra functionality or provide abstractions that make code easier to handle and reason about.</p>
<p>The subsections below document some common wrappers <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and their usages.</p>
<a name="H_Optional"></a><h3>Optional</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FOptional)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::optional</code> is a wrapper that either holds on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> or is empty (similar to Java or Python's optional <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<pre class="hljs"><code><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;  <span class="hljs-comment">// nullopt = empty optional</span>
    }
    <span class="hljs-keyword">return</span> std::optional&lt;<span class="hljs-type">int</span>&gt; { x * x };
}
</code></pre>
<p>As shown in the example above, the typical usecase for optional is to have a function return an empty optional on failure.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Other strategies for reporting failure are throwing an error and returning an error code along with the <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</div>
<p>In addition to the optional provided by the C++ standard library, Boost provides its own version of optional <code>boost::optional</code> as well as provides an optional-like boolean type called tribool: <code>boost::logic::tribool</code>. A tribool has a third state in addition to true and false, called indeterminate. Boolean operations where one of the operands is a boolean value and the other is indeterminate will always result in false (tribools convert to booleans via implicit conversion).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConversion%20Overloading)_TOPIC%2F">Core Language/Classes/Conversion Overloading</a> (refresher -- tribool <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> implements implicit conversion semantics)</li>
</ul>
</div>
<pre class="hljs"><code>boost::logic::tribool tb { boost::logic::indeterminate };
<span class="hljs-type">bool</span> x {tb == <span class="hljs-literal">true</span>};  <span class="hljs-comment">// false</span>
<span class="hljs-type">bool</span> y {tb == <span class="hljs-literal">false</span>}; <span class="hljs-comment">// false</span>
<span class="hljs-type">bool</span> z {!tb};         <span class="hljs-comment">// false</span>
</code></pre>
<p>The typical usecase for tribool is for operations that take a long time to complete. A tribool may be set as indeterminate while the operation is running, then be set to true (success) or false (failure) once the operation completes.</p>
<a name="H_Tuple"></a><h3>Tuple</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FTuple)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::tuple</code> is a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that holds on to an arbitrary number of elements of arbitrary types. The number of elements and types of elements must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a>, and any code accessing those elements must know which element it's accessing at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>, MyClass&gt; my_tuple{ <span class="hljs-number">1</span>, <span class="hljs-number">500L</span>, MyClass{} };
<span class="hljs-keyword">auto</span>&amp; x { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; y { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; z { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(my_tuple) };
<span class="hljs-comment">// OR you can use structured binding</span>
<span class="hljs-keyword">auto</span>&amp; [x, y, z] = my_tuple;
</code></pre>
<p>Note how the elements are being accessed using <code>std::get()</code>, which requires the index being accessed passed in as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>. Elements your code accesses <em>must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a></em>, meaning you can't evaluate some expression at run-time to determine which index to access like you can with tuples in other high-level languages (e.g. Python).</p>
<p>If all the types in for a tuple are different, the type itself can be passed into <code>std::get()</code>.</p>
<pre class="hljs"><code>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>, MyClass&gt; my_tuple{ <span class="hljs-number">1</span>, <span class="hljs-number">500L</span>, MyClass{} };
<span class="hljs-keyword">auto</span>&amp; x { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; y { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">long</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; z { std::<span class="hljs-built_in">get</span>&lt;MyClass&gt;(my_tuple) };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I guess the way to think about tuples is that they're short-hand for <a href="#BM_(POD)%2F">POD</a>s. Declaring a tuple is like creating a custom <a href="#BM_(POD)%2F">POD</a> where each element of the tuple is a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a> of the <a href="#BM_(POD)%2F">POD</a>.</p>
</div>
<p>Pairs are special cases of tuples where they're restricted to exactly two elements. Accessing the elements in a pair is done through the <code>first</code> and <code>second</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</p>
<pre class="hljs"><code>std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt; my_pair{ <span class="hljs-number">1</span>, <span class="hljs-number">500L</span> };
<span class="hljs-keyword">auto</span>&amp; x {my_pair-&gt;first};
<span class="hljs-keyword">auto</span>&amp; y {my_pair-&gt;second};
<span class="hljs-comment">// OR you can use structured binding</span>
<span class="hljs-keyword">auto</span>&amp; [x, y] = inimitable_duo;
</code></pre>
<p>Boost also provides a version of pair, <code>boost::compressed_pair</code>, except that it's slightly more efficient when either of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s points to an empty <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EmptyClass</span> {};

std::pair&lt;<span class="hljs-type">int</span>, EmptyClass&gt; p {<span class="hljs-number">5</span>, EmptyClass{} };
boost::compressed_pair&lt;<span class="hljs-type">int</span>, EmptyClass&gt; cp {<span class="hljs-number">5</span>, EmptyClass{} };  <span class="hljs-comment">// this one consumes less memory</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's a helper function called <code>std::make_tuple()</code> / <code>std::make_pair()</code> which makes tuples / pairs but has problems when the type is a <a href="#BM_(reference)%2Fi">reference</a>. Be aware of that if you decide to use it. See <a href="https://stackoverflow.com/a/7867662">here</a>.</p>
</div>
<a name="H_Any"></a><h3>Any</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FAny)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::any</code> is a wrapper that can hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of unknown type (a type that isn't known at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</p>
<pre class="hljs"><code>std::any wrapper {};
wrapper.emplace&lt;MyClass&gt; { arg1, arg2 };
<span class="hljs-keyword">auto</span> v1 = std::<span class="hljs-built_in">any_cast</span>&lt;MyClass&gt;(wrapper); <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">auto</span> v2 = std::<span class="hljs-built_in">any_cast</span>&lt;BadType&gt;(wrapper); <span class="hljs-comment">// should throws std::bad_any_cast</span>
</code></pre>
<p>To place an <a href="#BM_(object%7Cinstance)%2Fi">object</a> into the wrapper, use <code>emplace()</code>. This <em>creates</em> a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> and places it into the wrapper, destroying the <a href="#BM_(object%7Cinstance)%2Fi">object</a> previously held. The type of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is passed in as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument while the function arguments are used to initialize that <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. passed directly to <a href="#BM_(constructor)%2Fi">constructor</a>).</p>
<p>Accessing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> within the wrapper is done via <code>std::any_cast()</code>. The function argument is the wrapper itself and the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument is the type of  <a href="#BM_(object%7Cinstance)%2Fi">object</a> <em>you think</em> is being held. If the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is of a different type, the function throws <code>std::bad_any_cast</code> instead of returning the <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The closest Java analog I could think of is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> hierarchy where all Java <a href="#BM_(object%7Cinstance)%2Fi">object</a>s have to derive from <code>java.lang.Object</code>. You can accept a type of <code>Java.lang.Object</code> and cast it at <a href="#BM_(runtime)%2Fi">runtime</a> to the correct type (or one of its ancestors). The C++ any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> provides similar functionality to that.</p>
</div>
<p>Boost also provides a version of this wrapper, <code>boost::any</code>.</p>
<a name="H_Variant"></a><h3>Variant</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FVariant)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li>Library Functions/Wrappers/Any</li>
<li>Library Functions/Wrappers/Tuple</li>
</ul>
</div>
<p><code>std::variant</code> is a type-restricted form of the <code>std::any</code>. Where as with the <code>std::any</code> you can hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of any type, with <code>std::variant</code> you can hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of one of several predefined types.</p>
<pre class="hljs"><code>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, MyClass&gt; wrapper {};  <span class="hljs-comment">// may hold on to either int, float, or MyClass</span>
wrapper.emplace&lt;MyClass&gt; { arg1, arg2 };
<span class="hljs-keyword">auto</span> v1 = std::<span class="hljs-built_in">get</span>&lt;MyClass&gt;(wrapper);     <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">auto</span> v2 = std::<span class="hljs-built_in">get_if</span>&lt;MyClass&gt;(wrapper);  <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">auto</span> v3 = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-type">int</span>&gt;(wrapper);      <span class="hljs-comment">// returns nullptr</span>
<span class="hljs-keyword">auto</span> v4 = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(wrapper);         <span class="hljs-comment">// throws std::bad_variant_exception</span>
<span class="hljs-keyword">auto</span> which_type = wrapper.<span class="hljs-built_in">index</span>();    <span class="hljs-comment">// returns 2</span>
</code></pre>
<p>To determine which of the allowed types is currently held, use <code>index()</code>.</p>
<p>To access data, use <code>std::get()</code> where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument is the type you're interested in (similar to how data access is done in <code>std::tuple</code>). If the variant isn't holding an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the type trying to be extracted, <code>std::get()</code> will throw <code>std::bad_variant_exception</code>. To avoid an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, use <code>std::get_if()</code> -- it will return <code>nullptr</code> rather than throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>.</p>
<p>Unlike <code>std::any</code>, <code>std::variant</code> cannot be left unset (it must hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>). Initially, it creates and holds on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the first type in its allowed types list. That means the first type in its allowed types list must be constructible with empty initializer arguments (e.g. <a href="#BM_(default%20constructor)%2Fi">default constructor</a>). In the example above, the first allowed type is <code>int</code>, meaning that the variant starts off by holding on to an <code>int</code> created using an empty initializer (will have value of 0).</p>
<p>The easiest way to work around this problem is to set the first type to <code>std::monostate</code>. This allows your variant to be unset. Trying to call <code>std::get()</code> on an unset variant throws <code>std::bad_variant_access</code>.</p>
<pre class="hljs"><code>std::variant&lt;std::monostate, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>, MyClass&gt; wrapper {};  <span class="hljs-comment">// may hold on to nothing, int, float, or MyClass</span>
<span class="hljs-keyword">auto</span> which_type = wrapper.<span class="hljs-built_in">index</span>();     <span class="hljs-comment">// returns 0</span>
<span class="hljs-keyword">auto</span> v1 = std::<span class="hljs-built_in">get</span>&lt;MyClass&gt;(wrapper);  <span class="hljs-comment">// throws std::bad_variant_access</span>
</code></pre>
<p>If you have a set of single parameter functions with the same name (<a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>), where those parameters contains all the types in a variant's allowed types list, you can use <code>std::visit()</code> to automatically pull out the <a href="#BM_(object%7Cinstance)%2Fi">object</a> contained in the variant and call the appropriate <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> with that <a href="#BM_(object%7Cinstance)%2Fi">object</a> as the argument.</p>
<pre class="hljs"><code>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; wrapper {};  <span class="hljs-comment">// may hold on to either int, float</span>
<span class="hljs-comment">// call into a generic lambda / functor</span>
<span class="hljs-keyword">auto</span> res1 = std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp; x) { <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> * x; }, wrapper);
<span class="hljs-comment">// call into an overloaded free function (via a generic lambda / functor)</span>
<span class="hljs-keyword">auto</span> res2 = std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span> &amp;x) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">my_function</span>(x); }, wrapper);
<span class="hljs-comment">// call into a specific lambda / functor based on type currently being held</span>
std::<span class="hljs-built_in">visit</span>(
    overloaded {
        [](<span class="hljs-type">int</span>&amp; x) { std::cout &lt;&lt; <span class="hljs-string">"int"</span> &lt;&lt; x; },
        [](<span class="hljs-type">float</span>&amp; x) { std::cout &lt;&lt; <span class="hljs-string">"float"</span> &lt;&lt; x; },
        [](<span class="hljs-keyword">auto</span> &amp;) { std::cout &lt;&lt; <span class="hljs-string">"OTHER"</span>; }
    },
    wrapper
);
</code></pre>
<p>Boost also provides a version of this wrapper, <code>boost::variant</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FUnions)_TOPIC%2F">Core Language/Unions</a> (variants are similar to <a href="#BM_(union)%2Fi">union</a>s but type-safe)</li>
</ul>
</div>
<a name="H_Function"></a><h3>Function</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FFunction)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::function</code> is a standardized wrapper for <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_num</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{
    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;
}
 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrintNum</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
};


std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f1 { print_num };
std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f2 { PrintNum };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers%2FFunction%20Pointer)_TOPIC%2F">Core Language/Variables/Pointers/Function Pointer</a> (refresher)</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F">Core Language/Classes/Functors</a> (refresher)</li>
<li><a href="#BM_(Core%20Language%5C%2FLambdas)_TOPIC%2F">Core Language/Lambdas</a> (refresher)</li>
</ul>
</div>
<p>The typical use-case for <code>std::function</code> is to provide a function with a unified way to accept all <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a>s (e.g. <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s and <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s) as a parameter. The alternative would be to explicitly provide an <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> for each <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a> type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_func_with_42</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; func)</span> </span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-number">42</span>);
}
</code></pre>
<a name="H_Bind"></a><h3>Bind</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FBind)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::bind()</code> takes in a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a> and hardcodes some of its parameters via a new proxy <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_numbers</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">bool</span> print)</span> </span>{
    <span class="hljs-type">int</span> res { i + j };
    <span class="hljs-keyword">if</span> (print) {
        std::cout &lt;&lt; (i + j) &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-keyword">return</span> res;
}


<span class="hljs-keyword">auto</span> add_to_47 = std::<span class="hljs-built_in">bind</span>(
    add_numbers,
    std::placeholders::_1,
    <span class="hljs-number">47</span>,
    std::placeholders::_2
);                  <span class="hljs-comment">// add_to_47() proxies add_numbers(), but hardcodes its 2nd param to 47.</span>
<span class="hljs-built_in">add_to_47</span>(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// prints "50"</span>
</code></pre>
<p>The first parameter of <code>std::bind()</code> is the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a> to proxy, while subsequent parameters define parameter mappings. Specifically, if the argument for a subsequent parameter is ...</p>
<ul>
<li><code>std::placeholders::_N</code>, the proxy <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <code>N</code>th parameter is forwarded to the original <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a>'s parameter at that position (e.g. the 2nd parameter of <code>add_to_47()</code> is mapped to the 3rd parameter of <code>add_numbers()</code>).</li>
<li>something else, that argument is directly passed through to the original <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a>'s parameter at that position (e.g. <code>47</code> is mapped to the 2rd parameter of <code>add_numbers()</code>).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Testing on godbolt, the proxy <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> generated by <code>std::bind</code> requires <em>at least</em> as many parameters as the maximum placeholde<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>. So for example, if you only used <code>std::placeholders::_1</code> and <code>std::placeholders::_5</code>, the proxy <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> still requires that you supply something for 2nd, 3rd, and 4th parameters of the proxy <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> even though they aren't mapped to anything. You can also supply arguments for a 6th, 7th, 8th, 9th, ... parameter, even though they aren't mapped using <code>std::placeholder</code>s, and it'll be fine. You just can't supply less than 5.</p>
</div>
<p>For situations where all hardcoded parameters are at the front (contiguous), <code>std::bind_front()</code> is a more terse alternative. The first parameter of <code>std::bind_front()</code> is the <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a> to proxy, while subsequent parameters list out the hardcoded mappings for parameters 1, 2, 3, etc.. All remaining parameters will implicitly become <code>std::placeholder::_N</code>s that auto-increment from 1.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_numbers</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">bool</span> print)</span> </span>{
    <span class="hljs-type">int</span> res { i + j };
    <span class="hljs-keyword">if</span> (print) {
        std::cout &lt;&lt; (i + j) &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-keyword">return</span> res;
}


<span class="hljs-keyword">auto</span> add_to_47 = std::<span class="hljs-built_in">bind_front</span>(add_numbers, <span class="hljs-number">47</span>); <span class="hljs-comment">// add_to_47() proxies add_numbers(), but hardcodes its 1st param to 47.</span>
<span class="hljs-built_in">add_to_47</span>(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// prints "50"</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Why not just use a <a href="#BM_(lambda)%2Fi">lambda</a> instead of <code>std::bind()</code> / <code>std::bind_front()</code>? Probably because this is more terse. With a <a href="#BM_(lambda)%2Fi">lambda</a>, you likely will need <code>auto &amp;&amp;</code> for each parameter, <code>decltype(auto)</code> for the return, and <code>std::forward</code>s for each argument being pushed into the original <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a>.</p>
</div>
<a name="H_Reference%20Wrapper"></a><h3>Reference Wrapper</h3>
<p><a name="BM_(Library%20Functions%5C%2FWrappers%2FReference%20Wrapper)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li>Library Functions/Containers</li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a> (refresher)</li>
</ul>
</div>
<p><code>std::reference_wrapper</code> is a wrapper that holds a <a href="#BM_(reference)%2Fi">reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>. This is important because, in C++, you can't have a <a href="#BM_(reference)%2Fi">reference</a> to a <a href="#BM_(reference)%2Fi">reference</a> like you can have a <a href="#BM_(pointer)%2Fi">pointer</a> to a <a href="#BM_(pointer)%2Fi">pointer</a>. <a href="#BM_(reference)%2Fi">Reference</a>s, from a usage perspective, are treated as if they're the direct <a href="#BM_(object%7Cinstance)%2Fi">object</a> themselves.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> ** x { ... };                                             <span class="hljs-comment">// OK:  x is a pointer to a pointer to a n integer</span>
<span class="hljs-type">int</span> &amp;&amp; y { ... };                                             <span class="hljs-comment">// BAD: y is an rvalue reference, NOT a reference to a reference</span>
std::reference_wrapper&lt;std::reference_wrapper&lt;<span class="hljs-type">int</span>&gt;&gt; z{ ... }; <span class="hljs-comment">// OK:  z is a reference wrapper to a reference wrapper</span>
</code></pre>
<p>To create a <code>std::reference_wrapper</code>, use <code>std::ref()</code>. To access the value <a href="#BM_(reference)%2Fi">reference</a>d to by a <a href="#BM_(reference)%2Fi">reference</a> wrapper, use <code>get()</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> a { <span class="hljs-number">5</span> };
<span class="hljs-keyword">const</span> std::reference_wrapper&lt;<span class="hljs-keyword">const</span> <span class="hljs-type">int</span>&gt; aWrapped{ std::<span class="hljs-built_in">ref</span>(a) };
<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> b { aWrapped.<span class="hljs-built_in">get</span>() };
<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> c { aWrapped }; <span class="hljs-comment">// This can also work because std::reference_wrapper provides implicit conversion</span>
</code></pre>
<p><code>std::reference_wrapper</code>s are especially useful for containers. Normally, containers won't allow you to store <a href="#BM_(reference)%2Fi">reference</a>s. The only options are to store either full <a href="#BM_(object%7Cinstance)%2Fi">object</a>s or <a href="#BM_(pointer)%2Fi">pointer</a>s to <a href="#BM_(object%7Cinstance)%2Fi">object</a>s.</p>
<pre class="hljs"><code>std::vector&lt;<span class="hljs-type">int</span>&gt; vec2 {};   <span class="hljs-comment">// OK: stores ints</span>
std::vector&lt;<span class="hljs-type">int</span> *&gt; vec2 {}; <span class="hljs-comment">// OK: stores int pointers</span>
std::vector&lt;<span class="hljs-type">int</span> &amp;&gt; vec3 {}; <span class="hljs-comment">// BAD: not allowed</span>
</code></pre>
<p>While storing <a href="#BM_(pointer)%2Fi">pointer</a>s seems like a good alternative to storing <a href="#BM_(reference)%2Fi">reference</a>s, certain container types may not work as expected with <a href="#BM_(pointer)%2Fi">pointer</a>s. For example, unordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers like <code>std::unordered_set</code> will use the default <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s for <code>std::hash</code> and <code>std::equal_to</code>, meaning that the container determines equality by inspecting the <a href="#BM_(pointer)%2Fi">pointer</a> rather than the <a href="#BM_(object%7Cinstance)%2Fi">object</a> it points to.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a {<span class="hljs-number">0</span>}; <span class="hljs-type">int</span> b {<span class="hljs-number">1</span>}; <span class="hljs-type">int</span> c {<span class="hljs-number">1</span>}; <span class="hljs-type">int</span> d {<span class="hljs-number">1</span>}; <span class="hljs-type">int</span> e {<span class="hljs-number">1</span>};

<span class="hljs-comment">// The following outputs 1 0</span>
std::unordered_set&lt;<span class="hljs-type">int</span>&gt; vec2 { a, b, c, d, e };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : vec2) {
    std::cout &lt;&lt; e &lt;&lt; <span class="hljs-string">' '</span>;
}
std::cout &lt;&lt; std::endl;

<span class="hljs-comment">// The following outputs 1 1 1 1 0</span>
std::unordered_set&lt;<span class="hljs-type">int</span> *&gt; vec1 { &amp;a, &amp;b, &amp;c, &amp;d, &amp;e };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : vec1) {
    std::cout &lt;&lt; *e &lt;&lt; <span class="hljs-string">' '</span>;
}
std::cout &lt;&lt; std::endl;
</code></pre>
<p>Using <code>std::reference_wrapper</code> allows for the <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself to be used. The only caveat is that the <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s need to be declared directly in the container type.</p>
<pre class="hljs"><code><span class="hljs-comment">// The following outputs 1 0</span>
std::unordered_set&lt;
    std::reference_wrapper&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-comment">// type to store</span>
    std::hash&lt;<span class="hljs-type">int</span>&gt;,              <span class="hljs-comment">// std::hash specialization to use</span>
    std::equal_to&lt;<span class="hljs-type">int</span>&gt;           <span class="hljs-comment">// std::equal_to specialization to use</span>
&gt; vec3 { a, b, c };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : vec3) {
    std::cout &lt;&lt; e.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">' '</span>;
}
std::cout &lt;&lt; std::endl;

<span class="hljs-comment">// HOW CAN THE ABOVE WORK if the stored type is std::reference_wrapper&lt;int&gt; but hash/equal_to accept only int? Recall that</span>
<span class="hljs-comment">// std::reference_wrapper&lt;int&gt; can implicitly convert to its underlying type. For example, the following is equivalent ...</span>

<span class="hljs-type">int</span> &amp; x { (*vec3.<span class="hljs-built_in">begin</span>()).<span class="hljs-built_in">get</span>() };
<span class="hljs-type">int</span> &amp; y {  *vec3.<span class="hljs-built_in">begin</span>() };  <span class="hljs-comment">// references same object as X</span>

<span class="hljs-comment">// As such, when std::hash&lt;int&gt; / std::equal_to&lt;int&gt; to get invoked, they get passed in a std::reference_wrapper&lt;int&gt; which</span>
<span class="hljs-comment">// implicitly converts to int.</span>
</code></pre>
<p>Common pattern for different container types:</p>
<ul>
<li><code>std::vector&lt;std::reference_type&lt;T&gt;&gt;</code></li>
<li><code>std::unordered_set&lt;std::reference_type&lt;K&gt;, std::hash&lt;K&gt;, std::equal_to&lt;K&gt;&gt;</code></li>
<li><code>std::unordered_map&lt;std::reference_type&lt;K&gt;, V, std::hash&lt;K&gt;, std::equal_to&lt;K&gt;&gt;</code></li>
<li><code>std::ordered_set&lt;std::reference_type&lt;K&gt;, std::less_than&lt;K&gt;&gt;</code></li>
<li><code>std::ordered_map&lt;std::reference_type&lt;K&gt;, V, std::less_than&lt;K&gt;&gt;</code></li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Another option is to go ahead and use <a href="#BM_(pointer)%2Fi">pointer</a>s, but rather than specifying <code>std::hash&lt;K&gt;</code> / <code>std::equal_to&lt;K&gt;</code> / <code>std::less_than&lt;K&gt;</code> in the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s, create custom <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> that access data on the <a href="#BM_(object%7Cinstance)%2Fi">object</a> being pointed to.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">custom_less_functo</span> {
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyObject* &amp; lhs, <span class="hljs-keyword">const</span> MyObject* &amp; rhs)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> lhs-&gt;val1 &lt; rhs-&gt;val1 || lhs-&gt;val2 &lt; rhs-&gt;val2;
    }
}
std::ordered_set&lt;MyObject*, custom_less_functor_for&gt; s { ... }
</code></pre>
</div>
<a name="H_Containers"></a><h2>Containers</h2>
<p><a name="BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FIterators)_TOPIC%2F">Library Functions/Iterators</a></li>
</ul>
</div>
<p>C++'s equivalent of Java collections are commonly referred to as containers. C++ containers come in 3 major types:</p>
<ul>
<li>
<p>Sequence containers - <a href="#BM_(object%7Cinstance)%2Fi">Object</a>s organized in a sequence, where they're (at least) accessible from one end to the other.</p>
<table>
<thead>
<tr>
<th>C++ container</th>
<th>nearest Java equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::array</code></td>
<td>standard Java array</td>
</tr>
<tr>
<td><code>std::vector</code></td>
<td><code>ArrayList</code></td>
</tr>
<tr>
<td><code>std::deque</code></td>
<td><code>Deque</code> (an interface -- the C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is an implementation)</td>
</tr>
<tr>
<td><code>std::list</code></td>
<td><code>LinkedList</code> (doubly-linked list)</td>
</tr>
<tr>
<td><code>std::forward_list</code></td>
<td><code>LinkedList</code> (singly-linked list)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="#BM_(associativity%7Cassociative)%2Fi">Associative</a> containers - <a href="#BM_(object%7Cinstance)%2Fi">Object</a>s organized by key and potentially a value (keys sorted, requiring a comparison function).</p>
<table>
<thead>
<tr>
<th>C++ container</th>
<th>nearest Java equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::set</code></td>
<td><code>TreeSet</code></td>
</tr>
<tr>
<td><code>std::map</code></td>
<td><code>TreeMap</code></td>
</tr>
<tr>
<td><code>std::multiset</code></td>
<td><code>TreeBag</code> (Apache Commons Collections)</td>
</tr>
<tr>
<td><code>std::multimap</code></td>
<td><code>TreeMultimap</code> (Guava)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Unordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers - <a href="#BM_(object%7Cinstance)%2Fi">Object</a>s organized by key and potentially a value (keys unsorted).</p>
<table>
<thead>
<tr>
<th>C++ container</th>
<th>nearest Java equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::unordered_set</code></td>
<td><code>HashSet</code></td>
</tr>
<tr>
<td><code>std::unordered_map</code></td>
<td><code>HashMap</code></td>
</tr>
<tr>
<td><code>std::unordered_multiset</code></td>
<td><code>HashBag</code> (Apache Commons Collections)</td>
</tr>
<tr>
<td><code>std::unordered_multimap</code></td>
<td><code>ArrayListValuedHashMap</code> (Apache Commons Collections)</td>
</tr>
</tbody>
</table>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FControl%20Flow%2FFor%20Loop)_TOPIC%2F">Core Language/Control Flow/For Loop</a> (for-each loop refresher)</li>
</ul>
</div>
<p>Containers support <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s via their <code>begin()</code> and <code>end()</code> functions. Looping over a container using a for-each loop calls those functions, but the order in which containers are iterated over depends on the container. For example ...</p>
<ul>
<li><code>std::vector</code> maintains insertion order.</li>
<li><code>std::map</code> iterates in sort order.</li>
<li><code>std::unordered_map</code> <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s in some unknown order (unordered).</li>
</ul>
<pre class="hljs"><code>std::vector&lt;MyObject&gt; container { <span class="hljs-comment">/* items here */</span> };
<span class="hljs-keyword">for</span> (MyObject &amp;obj : container) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<p>Most (not all) containers allow using user-supplied allocators via <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument.</p>
<pre class="hljs"><code>std::vector&lt;MyObject, CustomAllocator&gt; container { };
</code></pre>
<p>The subsections below detail some of the containers mentioned above. Other major libraries provide more specialized containers (boost, abseil, etc..), but those containers aren't detailed here.</p>
<a name="H_Sequential"></a><h3>Sequential</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FSequential)_TOPIC%2F"></a><strong></strong></p>
<p>Sequential containers organize <a href="#BM_(object%7Cinstance)%2Fi">object</a>s as a sequence, where they're (at least) accessible from one end to the other. The container may or may not be dynamically sized (grow vs shrink) and underlying data structures used by sequential containers aren't the same.</p>
<p>The subsections below detail the various sequential containers that are provided by the C++ standard library.</p>
<a name="H_Array"></a><h4>Array</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FSequential%2FArray)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::array</code> is a container that's more-or-less a wrapper around a normal C++ array. Like normal C++ arrays, it ...</p>
<ul>
<li>is fixed-size, meaning it can't automatically grow or shrink,</li>
<li>allows reads and writes to random positions using its subscript operator.</li>
</ul>
<p>One caveat to this container is that it <em>does not</em> <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> array. That means, just like normal C++ arrays created on the stack, the number of elements must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> my_arr1[<span class="hljs-number">55</span>] {};              <span class="hljs-comment">// int array of size 55</span>
std::array&lt;<span class="hljs-type">int</span>, 55&gt; my_arr2 {};  <span class="hljs-comment">// std::array of ints, with size 55</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : my_arr2) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<p><code>std::array</code> provides <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics. However, because the underlying array is a local <a href="#BM_(object%7Cinstance)%2Fi">object</a>, both moving and copying end up recreating that underlying array. This means that copying and moving may potentially be expensive.</p>
<pre class="hljs"><code>std::array&lt;<span class="hljs-type">int</span>, 55&gt; my_arr3 { std::<span class="hljs-built_in">move</span>(my_arr2) };   <span class="hljs-comment">// move my_arr2 into my_arr3</span>
</code></pre>
<p>To read elements, use the subscript operator ([]) or <code>at()</code>. The main difference between the two is that the latter has bounds checking. Alternatively, ...</p>
<ul>
<li><code>front()</code> may be used as shorthand to get the first element.</li>
<li><code>back()</code> may be used as shorthand to get the last element.</li>
<li><code>std::get()</code> may be used to read a random element so long as the index being read is known at <a href="#BM_(compile-time)%2Fi">compile-time</a> (does bounds checking at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">int</span> w { my_arr2[<span class="hljs-number">20</span>] };
<span class="hljs-type">int</span> x { my_arr2.<span class="hljs-built_in">at</span>(<span class="hljs-number">20</span>) };
<span class="hljs-type">int</span> y { my_arr2.<span class="hljs-built_in">at</span>(<span class="hljs-number">1000</span>) };  <span class="hljs-comment">// throws std::out_of_range</span>
<span class="hljs-type">int</span> z { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">20</span>&gt;(my_arr2) };
<span class="hljs-type">int</span> a { my_arr2.<span class="hljs-built_in">front</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
<span class="hljs-type">int</span> b { my_arr2.<span class="hljs-built_in">back</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FTuple)_TOPIC%2F">Library Functions/Wrappers/Tuple</a> (refresher on <code>std::get()</code>)</li>
</ul>
</div>
<p>To replace elements, use any of the same functions used for reading elements except <code>std::get()</code>. They return a <a href="#BM_(reference)%2Fi">reference</a>, which means assigning something to them will assign into the container.</p>
<pre class="hljs"><code>my_arr2[<span class="hljs-number">20</span>] = <span class="hljs-number">123</span>;
my_arr2.<span class="hljs-built_in">at</span>(<span class="hljs-number">20</span>) = <span class="hljs-number">123</span>;
my_arr2.<span class="hljs-built_in">front</span>() = <span class="hljs-number">123</span>;
my_arr2.<span class="hljs-built_in">back</span>() = <span class="hljs-number">123</span>;

<span class="hljs-keyword">auto</span> &amp; ref = <span class="hljs-built_in">my_arr</span>(<span class="hljs-number">20</span>);
ref = <span class="hljs-number">123</span>;
</code></pre>
<p>To get the size, use <code>size()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> len { my_arr2.<span class="hljs-built_in">size</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>size()</code> and <code>max_size()</code> are equivalent for <code>std::array</code>, but not for other containers that can grow / shrink.</p>
</div>
<p>To gain access to the underlying array being wrapped, use <code>data()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * backing_arr = my_arr2.<span class="hljs-built_in">data</span>();
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> each below are equivalent to the above, but the one above should be preferred</span>
<span class="hljs-comment">//       because the ones below will have undefined behaviour if array length is 0.</span>
<span class="hljs-type">int</span> * backing_arr = &amp;my_arr2[<span class="hljs-number">0</span>];
<span class="hljs-type">int</span> * backing_arr = &amp;my_arr2.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);
<span class="hljs-type">int</span> * backing_arr = &amp;my_arr2.<span class="hljs-built_in">front</span>();
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : my_arr2) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Vector"></a><h4>Vector</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FSequential%2FVector)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential%2FArray)_TOPIC%2F">Library Functions/Containers/Sequential/Array</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>WARNING: The book is saying that there is no hard requirement for a container to return copies vs <a href="#BM_(reference)%2Fi">reference</a>s. Most of the time a container returns <a href="#BM_(reference)%2Fi">reference</a>s, but in special cases it may return a copy of some <a href="#BM_(object%7Cinstance)%2Fi">object</a>. For example, <code>vector&lt;bool&gt;</code> has a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> that returns a proxy <a href="#BM_(object%7Cinstance)%2Fi">object</a> rather than a direct <a href="#BM_(reference)%2Fi">reference</a> (<code>std::vector&lt;bool&gt;::reference</code>).</p>
</div>
<p><code>std::vector</code> is a container that holds on to its elements sequentially and contiguously in memory (array), but it can dynamically size itself (e.g. expand the internal array if not enough room is available to add a new element). It has most of the same functions as <code>std::array</code>, in addition to some others.</p>
<p>To create an <code>std::vector</code> primed with a sequence of values known as <a href="#BM_(compile-time)%2Fi">compile-time</a>, use typical <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<pre class="hljs"><code>std::vector&lt;<span class="hljs-type">int</span>&gt; my_vec1 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
</code></pre>
<p>To create an <code>std::vector</code> without priming it directly to a sequence of values, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">my_vec2</span> <span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// equivalent to initializing to above (8 copies of 5)</span>
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">my_vec3</span> <span class="hljs-params">(c)</span>  <span class="hljs-comment">// copy another container</span>
std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">my_vec4</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>
</span></code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The rules for initialization are complex. In this case, there's a <a href="#BM_(constructor)%2Fi">constructor</a> that takes in an <code>std::initializer_list</code>. That means <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> / <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> will in most cases call that <a href="#BM_(constructor)%2Fi">constructor</a>, where that initializer list gets populated with whatever is in the braces. To avoid that, the easiest thing you can do is fall back to using the legacy way of calling <a href="#BM_(constructor)%2Fi">constructor</a>s (parenthesis).</p>
</div>
<p><code>std::vector</code> provides <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics. Because elements are <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, moving one <code>std::vector</code> into another is fast because it's simply passing off a <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a>. Copying can potentially be expensive.</p>
<pre class="hljs"><code>std::vector&lt;<span class="hljs-type">int</span>&gt; my_vec5 { std::<span class="hljs-built_in">move</span>(my_vec1) };   <span class="hljs-comment">// move my_vec1 into my_vec5</span>
</code></pre>
<p>Similarly, because <code>std::vector</code>'s elements are created as <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, you have the option of supplying a custom allocator.</p>
<pre class="hljs"><code>CustomAllocator allocator {};
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>, CustomAllocator&gt; <span class="hljs-title">my_vec6</span> <span class="hljs-params">(allocator)</span></span>;
</code></pre>
<p>To read elements, the same read functions for <code>std::array</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w { my_vec1[<span class="hljs-number">5</span>] };
<span class="hljs-type">int</span> x { my_vec1.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) };
<span class="hljs-type">int</span> y { my_vec1.<span class="hljs-built_in">at</span>(<span class="hljs-number">1000</span>) };  <span class="hljs-comment">// throws std::out_of_range</span>
<span class="hljs-type">int</span> a { my_vec1.<span class="hljs-built_in">front</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
<span class="hljs-type">int</span> b { my_vec1.<span class="hljs-built_in">back</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Does <code>std::get()</code> work here as well? I don't think so because this is a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>.</p>
</div>
<p>To replace elements, the same write functions for <code>std::array</code> are available here. Those functions are the same functions used for reading elements. They return a <a href="#BM_(reference)%2Fi">reference</a>, which means assigning something to them will assign into the container.</p>
<pre class="hljs"><code>my_vec1[<span class="hljs-number">20</span>] = <span class="hljs-number">123</span>;
my_vec1.<span class="hljs-built_in">at</span>(<span class="hljs-number">20</span>) = <span class="hljs-number">123</span>;
my_vec1.<span class="hljs-built_in">front</span>() = <span class="hljs-number">123</span>;
my_vec1.<span class="hljs-built_in">back</span>() = <span class="hljs-number">123</span>;
</code></pre>
<p>To add elements, the following functions are available:</p>
<ul>
<li><code>insert()</code> will insert an element just behind some <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position (<a href="#BM_(object%7Cinstance)%2Fi">object</a> copied / moved).</li>
<li><code>emplace()</code> will insert an element just behind some <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> <em>by creating it directly</em> (no copying / moving).</li>
<li><code>push_back()</code> will append an element (<a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>)</li>
<li><code>emplace_back()</code> will append an element <em>by creating it directly</em> (no copying / moving).</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 = my_vec1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;
my_vec1.<span class="hljs-built_in">insert</span>(it1, <span class="hljs-number">77</span>); <span class="hljs-comment">// WARNING: it1 invalid after this call</span>
<span class="hljs-keyword">auto</span> it2 = my_vec1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;
my_vec1.<span class="hljs-built_in">emplace</span>(it2, <span class="hljs-number">77</span>); <span class="hljs-comment">// WARNING: it2 invalid after this call</span>
my_vec1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);
my_vec1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">123</span>);
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>emplace()</code> / <code>emplace_back()</code> don't copy or move because you pass in initialization arguments directly into the functions. Internally, they use <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a>s to forward arguments for <a href="#BM_(object%7Cinstance)%2Fi">object</a> creation (e.g. <a href="#BM_(constructor)%2Fi">constructor</a> arguments, initializer list, etc..).</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FAny)_TOPIC%2F">Library Functions/Wrappers/Any</a> (also has an <code>emplace()</code> function)</li>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FVariant)_TOPIC%2F">Library Functions/Wrappers/Variant</a> (also has an <code>emplace()</code> function)</li>
</ul>
</div>
<p>To delete either a single element or a range of elements, use <code>erase()</code> and pass into it either an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> at some position or an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> range.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 {my_vec1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>};
my_vec1.<span class="hljs-built_in">erase</span>(it1); <span class="hljs-comment">// WARNING: it1 invalid after this call</span>

<span class="hljs-keyword">auto</span> it2 {my_vec1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it3 {my_vec1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
my_vec1.<span class="hljs-built_in">erase</span>(it2, it3); <span class="hljs-comment">// WARNING: it2/it3 invalid after this call</span>
</code></pre>
<p>To delete the last element, use <code>pop_back()</code>. It's similar to <code>back()</code> (returns element) but it removes the element as well.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> c { my_vec1.<span class="hljs-built_in">pop_back</span>() }; <span class="hljs-comment">// REMOVES the last </span>
</code></pre>
<p>To delete all elements, use <code>clear()</code>.</p>
<pre class="hljs"><code>my_vec1.<span class="hljs-built_in">clear</span>();
</code></pre>
<p>To delete all elements and re-assign to a list of new elements, use <code>assign()</code>.</p>
<pre class="hljs"><code>my_vec1.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 5 copies of 10</span>
my_vec1.<span class="hljs-built_in">assign</span>({<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>}); <span class="hljs-comment">// 5 copies of 10</span>
my_vec1.<span class="hljs-built_in">assign</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>); <span class="hljs-comment">// starting 5 elements of another container</span>
</code></pre>
<p>To get the number of elements, the same functions for <code>std::array</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { my_vec1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { my_vec1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>Internally, <code>std::vector</code> grows in chunks. For example, if the underlying array has a size of 5 and all of those 5 elements are occupied, when you add in a 6th element the underlying array resizes to have a capacity larger than 6 (e.g. 10). This way, you can continue adding in a few more elements without another resize happening right away (more efficient).</p>
<p>To get the current capacity, use <code>capacity()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">float</span> usage { my_vec1.<span class="hljs-built_in">size</span>() / my_vec2.<span class="hljs-built_in">capacity</span>() };
</code></pre>
<p>If you ...</p>
<ul>
<li>know the capacity you want ahead of time, use <code>reserve()</code>.</li>
<li>want to shrink the capacity to match the number of elements stored, use <code>shrink_to_fit()</code>.</li>
</ul>
<pre class="hljs"><code>my_vec1.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1000</span>);
my_vec1.<span class="hljs-built_in">shrink_to_fit</span>();
</code></pre>
<p>Similar to <code>std::array</code>, you can access the underlying array for an <code>std::vector</code>. However, the returned array may become invalid as soon as you start performing operations on the owning <code>std::vector</code> (e.g. it may get recreated due to shrinkage/growth).</p>
<p>To gain access to the underlying array being wrapped, use <code>data()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * backing_arr = my_vec1.<span class="hljs-built_in">data</span>();
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> each below are equivalent to the above, but the one above should be preferred</span>
<span class="hljs-comment">//       because the ones below will have undefined behaviour if array length is 0.</span>
<span class="hljs-type">int</span> * backing_arr = &amp;my_vec1[<span class="hljs-number">0</span>];
<span class="hljs-type">int</span> * backing_arr = &amp;my_vec1.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);
<span class="hljs-type">int</span> * backing_arr = &amp;my_vec1.<span class="hljs-built_in">front</span>();
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : my_vec1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Deque"></a><h4>Deque</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FSequential%2FDeque)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential%2FVector)_TOPIC%2F">Library Functions/Containers/Sequential/Vector</a></li>
</ul>
</div>
<p><code>std::deque</code> is a container that holds on to its elements sequentially but not contiguously in memory (not an array). It can dynamically size itself (e.g. expand the internal array if not enough room is available to add a new element) just like <code>std::vector</code> and it supports most of the same function as <code>std::vector</code>. The most prominent functions it <em>doesn't</em> support:</p>
<ul>
<li><code>data()</code> because there is no underlying array with this container.</li>
<li><code>capacity()</code>.</li>
<li><code>reserve()</code>.</li>
</ul>
<p>Because of the internal data structure used by this container, the added functions above are efficient.</p>
<p>To create an <code>std::deque</code> primed with a sequence of values known as <a href="#BM_(compile-time)%2Fi">compile-time</a>, use typical <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<pre class="hljs"><code>std::deque&lt;<span class="hljs-type">int</span>&gt; d1 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
</code></pre>
<p>To create an <code>std::deque</code> without priming it directly to a sequence of values, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code><span class="hljs-function">std::deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span> <span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// equivalent to initializing to above (8 copies of 5)</span>
<span class="hljs-function">std::deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d3</span> <span class="hljs-params">(c)</span>  <span class="hljs-comment">// copy another container</span>
std::deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d4</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>
</span></code></pre>
<p><code>std::deque</code> provides <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics. Because elements are <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, moving one <code>std::deque</code> into another is fast because it's simply passing off a <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a>. Copying can potentially be expensive.</p>
<pre class="hljs"><code>std::deque&lt;<span class="hljs-type">int</span>&gt; d5 { std::<span class="hljs-built_in">move</span>(d1) }; <span class="hljs-comment">// move d1 into d5</span>
</code></pre>
<p>Similarly, because <code>std::deque</code>'s elements are created as <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, you have the option of supplying a custom allocator.</p>
<pre class="hljs"><code>CustomAllocator allocator {};
<span class="hljs-function">std::deque&lt;<span class="hljs-type">int</span>, CustomAllocator&gt; <span class="hljs-title">d6</span> <span class="hljs-params">(allocator)</span></span>;
</code></pre>
<p>To read elements, the same read functions for <code>std::vector</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w { d1[<span class="hljs-number">5</span>] };
<span class="hljs-type">int</span> x { d1.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) };
<span class="hljs-type">int</span> y { d1.<span class="hljs-built_in">at</span>(<span class="hljs-number">1000</span>) };  <span class="hljs-comment">// throws std::out_of_range</span>
<span class="hljs-type">int</span> a { d1.<span class="hljs-built_in">front</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
<span class="hljs-type">int</span> b { d1.<span class="hljs-built_in">back</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
</code></pre>
<p>To replace elements, the same write functions for <code>std::vector</code> are available here. Those functions are the same functions used for reading elements. They return a <a href="#BM_(reference)%2Fi">reference</a>, which means assigning something to them will assign into the container.</p>
<pre class="hljs"><code>d1[<span class="hljs-number">20</span>] = <span class="hljs-number">123</span>;
d1.<span class="hljs-built_in">at</span>(<span class="hljs-number">20</span>) = <span class="hljs-number">123</span>;
d1.<span class="hljs-built_in">front</span>() = <span class="hljs-number">123</span>;
d1.<span class="hljs-built_in">back</span>() = <span class="hljs-number">123</span>;
</code></pre>
<p>To add elements, the same add functions for <code>std::vector</code> are available here in addition to...</p>
<ul>
<li><code>emplace_front()</code> - similar to <code>emplace_back()</code> but adds to the front.</li>
<li><code>push_front()</code> - similar to <code>push_back()</code> but adds to the front.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 = d1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;
d1.<span class="hljs-built_in">insert</span>(it1, <span class="hljs-number">77</span>); <span class="hljs-comment">// WARNING: it1 invalid after this call</span>
<span class="hljs-keyword">auto</span> it2 = d1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;
d1.<span class="hljs-built_in">emplace</span>(it2, <span class="hljs-number">77</span>); <span class="hljs-comment">// WARNING: it2 invalid after this call</span>
d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);
d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// similar to push_back, but adds to front</span>
d1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">123</span>);
d1.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// similar to emplace_back, but adds to front</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Recall that "emplace" functions don't copy or move. They're <a href="#BM_(template)%2Fi">template</a>d functions. You pass in <a href="#BM_(object%20initialization)%2Fi">object initialization</a> arguments directly into the functions and it uses a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a> to forward those arguments for <a href="#BM_(object%7Cinstance)%2Fi">object</a> creation directly within the function (e.g. <a href="#BM_(constructor)%2Fi">constructor</a> arguments, initializer list, etc..).</p>
</div>
<p>To delete elements, the same delete functions for <code>std::vector</code> are available here in addition to ...</p>
<ul>
<li><code>pop_front()</code> - similar to  <code>pop_back()</code> but removes from the front.</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// DELETE at ifx</span>
<span class="hljs-keyword">auto</span> it1 {d1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>};
d1.<span class="hljs-built_in">erase</span>(it1); <span class="hljs-comment">// WARNING: it1 invalid after this call</span>
<span class="hljs-comment">// DELETE between idx range</span>
<span class="hljs-keyword">auto</span> it2 {d1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it3 {d1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
d1.<span class="hljs-built_in">erase</span>(it2, it3); <span class="hljs-comment">// WARNING: it2/it3 invalid after this call</span>
<span class="hljs-comment">// DELETE front or back</span>
<span class="hljs-type">int</span> c { d1.<span class="hljs-built_in">pop_back</span>() };
<span class="hljs-type">int</span> d { d1.<span class="hljs-built_in">pop_front</span>() }; <span class="hljs-comment">// similar to pop_back, but removed from the FRONT</span>
<span class="hljs-comment">// DELETE all</span>
d1.<span class="hljs-built_in">clear</span>();
<span class="hljs-comment">// DELETE all and RE-ASSIGN</span>
d1.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 5 copies of 10</span>
d1.<span class="hljs-built_in">assign</span>({<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>}); <span class="hljs-comment">// 5 copies of 10</span>
d1.<span class="hljs-built_in">assign</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>); <span class="hljs-comment">// starting 5 elements of another container</span>
</code></pre>
<p>To get the number of elements, the same functions for <code>std::vector</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { d1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { d1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>To release unused memory that's been reserved by the container, use <code>shrink_to_fit()</code>. The <code>capacity()</code> and <code>reserve()</code> functions found in <code>std::vector</code> are not present in this container.</p>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : d1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_List"></a><h4>List</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FSequential%2FList)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential%2FDeque)_TOPIC%2F">Library Functions/Containers/Sequential/Deque</a></li>
</ul>
</div>
<p><code>std::list</code> is a container that holds on to its elements sequentially. It's implemented as a doubly-linked list, meaning its size is dynamic but it isn't stored contiguously in memory (not an array).</p>
<p><code>std::list</code> supports a similar set of functions as <code>std::deque</code> except for the fact that random element access isn't allowed (the functions for it don't exist -- random access is inefficient with linked lists). You can only access elements by walking either forward or backward. In addition, it provides several built-in helper functions such as sorting and de-duplication.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>List of helper functions is documented near the end.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also <code>std::forward_list</code> which is a singly-linked list. It's functionality is very similar to this <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, but since it only supports walking forward, some of the functions listed here are missing.</p>
</div>
<p>To create a <code>std::list</code> primed with a sequence of values known as <a href="#BM_(compile-time)%2Fi">compile-time</a>, use typical <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<pre class="hljs"><code>std::list&lt;<span class="hljs-type">int</span>&gt; l1 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
</code></pre>
<p>To create a <code>std::list</code> without priming it directly to a sequence of values, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code><span class="hljs-function">std::list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l2</span> <span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// equivalent to initializing to above (8 copies of 5)</span>
<span class="hljs-function">std::list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l3</span> <span class="hljs-params">(c)</span>  <span class="hljs-comment">// copy another container</span>
std::list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l4</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>
</span></code></pre>
<p><code>std::list</code> provides <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics. Because elements are <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, moving one <code>std::list</code> into another is fast because it's simply passing off a <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a>. Copying can potentially be expensive.</p>
<pre class="hljs"><code>std::list&lt;<span class="hljs-type">int</span>&gt; l5 { std::<span class="hljs-built_in">move</span>(l1) }; <span class="hljs-comment">// move l1 into l5</span>
</code></pre>
<p>Similarly, because <code>std::list</code>'s elements are created as <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, you have the option of supplying a custom allocator.</p>
<pre class="hljs"><code>CustomAllocator allocator {};
<span class="hljs-function">std::list&lt;<span class="hljs-type">int</span>, CustomAllocator&gt; <span class="hljs-title">l6</span> <span class="hljs-params">(allocator)</span></span>;
</code></pre>
<p>To read elements, use the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> functions <code>begin()</code> and / or <code>end()</code> to walk the sequence. Alternatively, the <code>front()</code> and <code>back()</code> functions give direct access to the first and last elements respectively.</p>
<pre class="hljs"><code><span class="hljs-comment">// WARNING: undefined behaviour of len is &lt; 3</span>
<span class="hljs-keyword">auto</span> it = l1.<span class="hljs-built_in">begin</span>();
<span class="hljs-type">int</span> a { *it };
it++;
<span class="hljs-type">int</span> b { *it };
it++;
<span class="hljs-type">int</span> c { *it };

<span class="hljs-type">int</span> d { l1.<span class="hljs-built_in">front</span>() }; <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
<span class="hljs-type">int</span> e { l1.<span class="hljs-built_in">back</span>() };  <span class="hljs-comment">// WARNING: undefined behaviour of len is 0</span>
</code></pre>
<p>To replace elements, the same <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> functions <code>begin()</code> and / or <code>end()</code> need to be used to walk the sequence to the point of replacement.</p>
<pre class="hljs"><code><span class="hljs-comment">// WARNING: undefined behaviour of len is &lt; 3</span>
<span class="hljs-keyword">auto</span> it = l1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>;
*it = <span class="hljs-number">55</span>;
</code></pre>
<p>To add elements, the same add functions for <code>std::deque</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 = l1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;
l1.<span class="hljs-built_in">insert</span>(it1, <span class="hljs-number">77</span>);
<span class="hljs-keyword">auto</span> it2 = l1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;
l1.<span class="hljs-built_in">emplace</span>(it2, <span class="hljs-number">77</span>);
l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);
l1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">123</span>);
l1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">123</span>);
l1.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">123</span>);
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I'm getting conflicting information about if an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> is invalid after a write. Right now I'm leaning towards NOT invalid.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Recall that "emplace" functions don't copy or move. They're <a href="#BM_(template)%2Fi">template</a>d functions. You pass in <a href="#BM_(object%20initialization)%2Fi">object initialization</a> arguments directly into the functions and it uses a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a> to forward those arguments for <a href="#BM_(object%7Cinstance)%2Fi">object</a> creation directly within the function (e.g. <a href="#BM_(constructor)%2Fi">constructor</a> arguments, initializer list, etc..).</p>
</div>
<p>To delete elements, the same delete functions for <code>std::deque</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-comment">// DELETE at idx</span>
<span class="hljs-keyword">auto</span> it1 {l1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>};
d1.<span class="hljs-built_in">erase</span>(it1); <span class="hljs-comment">// WARNING: it1 invalid after this call</span>
<span class="hljs-comment">// DELETE between idx range</span>
<span class="hljs-keyword">auto</span> it2 {l1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it3 {l1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it2, it3); <span class="hljs-comment">// WARNING: it2/it3 invalid after this call</span>
<span class="hljs-comment">// DELETE front or back</span>
<span class="hljs-type">int</span> c { l1.<span class="hljs-built_in">pop_back</span>() };
<span class="hljs-type">int</span> d { l1.<span class="hljs-built_in">pop_front</span>() }; <span class="hljs-comment">// similar to pop_back, but removed from the FRONT</span>
<span class="hljs-comment">// DELETE all</span>
l1.<span class="hljs-built_in">clear</span>();
<span class="hljs-comment">// DELETE all and RE-ASSIGN</span>
l1.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 5 copies of 10</span>
l1.<span class="hljs-built_in">assign</span>({<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>}); <span class="hljs-comment">// 5 copies of 10</span>
l1.<span class="hljs-built_in">assign</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>); <span class="hljs-comment">// starting 5 elements of another container</span>
</code></pre>
<p>To get the number of elements, the same functions for <code>std::deque</code> are available here.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { l1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { l1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : l1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<p><code>std::list</code> has several helper functions built-in.</p>
<ul>
<li><code>merge()</code> combines two sorted <code>std::list</code>s into a single sorted <code>std::list</code> and empty them.</li>
<li><code>splice()</code> transfers a range of elements from one <code>std::list</code> to another.</li>
<li><code>remove()</code> searches for and removes all matching elements in a <code>std::list</code>.</li>
<li><code>remove_if()</code> removes all elements in a <code>std::list</code> that matches some predicate.</li>
<li><code>reverse()</code> reverses an <code>std::list</code> (in-place reversal).</li>
<li><code>sort()</code> sorts an <code>std::list</code> based on a comparator (in-place sort).</li>
<li><code>unique()</code> removes consecutive duplicate elements.</li>
</ul>
<a name="H_Ordered%20Associative"></a><h3>Ordered Associative</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative)_TOPIC%2F"></a><strong></strong></p>
<p>Ordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers organize <a href="#BM_(object%7Cinstance)%2Fi">object</a>s by key and potentially a value. Keys are sorted into a specific order, meaning that a comparison function is required. The underlying data structure used by ordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers is a red-black tree.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Unsure if the spec defines if they should be implemented as red-black trees, but from what I've read that's how they're implemented.</p>
</div>
<p>The subsections below detail the various ordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers that are provided by the C++ standard library.</p>
<a name="H_Set"></a><h4>Set</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FSet)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
</ul>
</div>
<p><code>std::set</code> is a container that holds on to <em>unique</em> elements in sorted order, where that order is defined by a comparator.</p>
<p>To create a <code>std::set</code> primed with a sequence of values known as <a href="#BM_(compile-time)%2Fi">compile-time</a>, use typical <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>. Since only unique values are allowed, duplicates will be ignored. By default, the comparator <code>std::less</code> is used which uses the less than operator (&lt;) to compare two <a href="#BM_(object%7Cinstance)%2Fi">object</a>s for priority.</p>
<pre class="hljs"><code>std::set&lt;<span class="hljs-type">int</span>&gt; s1 { <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
</code></pre>
<p>To create a <code>std::set</code> without priming it directly to a sequence of values, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code><span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>

<span class="hljs-comment">// CUSTOM COMPARATOR</span>
<span class="hljs-keyword">auto</span> comparator </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; rhs) -&gt; <span class="hljs-type">bool</span> { <span class="hljs-keyword">return</span> lhs &lt; rhs; };
<span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(comparator)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }, comparator)</span></span>;
<span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::greater)</span>&gt; <span class="hljs-title">s4</span> <span class="hljs-params">({ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }, std::greater)</span></span>;
</code></pre>
<p><code>std::set</code> provides <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics. Because elements are <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, moving one <code>std::set</code> into another is fast because it's simply passing off a <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a>. Copying can potentially be expensive.</p>
<pre class="hljs"><code>std::set&lt;<span class="hljs-type">int</span>&gt; s5 { std::<span class="hljs-built_in">move</span>(s1) }; <span class="hljs-comment">// move s1 into s5</span>
</code></pre>
<p>Similarly, because <code>std::set</code>'s elements are created as <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, you have the option of supplying a custom allocator.</p>
<pre class="hljs"><code>CustomAllocator allocator {};
<span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::less)</span>, CustomAllocator&gt; <span class="hljs-title">s6</span> <span class="hljs-params">(std::less, allocator)</span></span>;
</code></pre>
<p>To check an element exists, the following functions are available:</p>
<ul>
<li><code>find()</code> return an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed at the position of the found element (returns <code>end()</code> <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position if not found).</li>
<li><code>contains()</code> returns bool (true if it exists, false otherwise).</li>
<li><code>count()</code> returns integer (1 if it exists, 0 otherwise).</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>) };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">1</span> };
</code></pre>
<p>To find the first element that is greater than or equal (&gt;=) to some value, use <code>lower_bound()</code>. Similarly, to find the first element that's greater than (&gt;) some value, use <code>upper_bound()</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem 4 if 4 exists, otherwise get iterator to the elem just after 4 (could be s1.end() if no such elem)</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem just after 4 (could be s1.end() if no such elem)</span>
</code></pre>
<p>To add an element, the following functions are available:</p>
<ul>
<li><code>insert()</code> either copies or moves into the container (depending on if the <a href="#BM_(reference)%2Fi">reference</a> passed in is an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>).</li>
<li><code>emplace()</code> adds an element <em>by creating it directly</em> (no copying / moving).</li>
<li><code>emplace_hint()</code> like the above but also takes in an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed to some position as a hint.</li>
</ul>
<pre class="hljs"><code>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>emplace()</code> / <code>emplace_hint()</code> don't copy or move because you pass in initialization arguments directly into the functions. Internally, they use <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a>s to forward arguments for <a href="#BM_(object%7Cinstance)%2Fi">object</a> creation (e.g. <a href="#BM_(constructor)%2Fi">constructor</a> arguments, initializer list, etc..).</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FAny)_TOPIC%2F">Library Functions/Wrappers/Any</a> (also has an <code>emplace()</code> function)</li>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FVariant)_TOPIC%2F">Library Functions/Wrappers/Variant</a> (also has an <code>emplace()</code> function)</li>
</ul>
</div>
<p>To delete an element at some specific <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position, use either <code>extract()</code> or <code>erase()</code>. The difference is that <code>extract()</code> will return the element while <code>erase()</code> won't.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>

<span class="hljs-comment">// DELETE between idx range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
</code></pre>
<p>To delete all elements, use <code>clear()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">clear</span>();
</code></pre>
<p>To get the number of elements, use <code>size()</code>. Similarly, use <code>empty()</code> to check if empty.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Multiset"></a><h4>Multiset</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FMultiset)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FSet)_TOPIC%2F">Library Functions/Containers/Ordered Associative/Set</a></li>
</ul>
</div>
<p><code>std::multiset</code> is a container that, like a <code>std::set</code>, holds on to elements in sorted order where that order is defined by a comparator. Unlike <code>std::set</code>, it can hold on to multiple <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the same element (elements aren't unique). Rather than using the equality operator (==) to find duplicates, <code>std::multiset</code> uses the sorting comparator: two <a href="#BM_(object%7Cinstance)%2Fi">object</a>s a and b are considered equivalent if neither compares less than the other: <code>!comp(a, b) &amp;&amp; !comp(b, a)</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Definition is from cpp<a href="#BM_(reference)%2Fi">reference</a>.</p>
</div>
<p>To create a <code>std::multiset</code>, the same <code>std::set</code> <a href="#BM_(constructor)%2Fi">constructor</a>s apply. The only major difference is that, if you're initializing the values, any duplicate values are kept.</p>
<pre class="hljs"><code><span class="hljs-comment">// prime</span>
std::multiset&lt;<span class="hljs-type">int</span>&gt; s1 { <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };  <span class="hljs-comment">// DUPLICATES RETAINED</span>
<span class="hljs-comment">// copy range</span>
<span class="hljs-function">std::multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>
<span class="hljs-comment">// custom comparator</span>
<span class="hljs-keyword">auto</span> comparator </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; rhs) -&gt; <span class="hljs-type">bool</span> { <span class="hljs-keyword">return</span> lhs &lt; rhs; };
<span class="hljs-function">std::multiset&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(comparator)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }, comparator)</span></span>;
<span class="hljs-function">std::multiset&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::greater)</span>&gt; <span class="hljs-title">s4</span> <span class="hljs-params">({ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }, std::greater)</span></span>;
<span class="hljs-comment">// copy/move</span>
std::multiset&lt;<span class="hljs-type">int</span>&gt; s5 { std::<span class="hljs-built_in">move</span>(s1) };  <span class="hljs-comment">// move s1 into s5</span>
<span class="hljs-comment">// custom allocator</span>
CustomAllocator allocator {};
<span class="hljs-function">std::multiset&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::less)</span>, CustomAllocator&gt; <span class="hljs-title">s6</span> <span class="hljs-params">(std::less, allocator)</span></span>;
</code></pre>
<p>Functions are more or less the same as those in <code>std::set</code>. The only major difference is that <code>count()</code> returns the number of <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s for an element.</p>
<pre class="hljs"><code><span class="hljs-comment">// find</span>
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">1</span>) };
<span class="hljs-comment">// get number of instances</span>
<span class="hljs-type">bool</span> is_two_instances { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">2</span> };
<span class="hljs-comment">// get lower/upper bound</span>
<span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem 4 if 4 exists, otherwise get iterator to the elem just after 4 (could be s1.end() if no such elem)</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem just after 4 (could be s1.end() if no such elem)</span>
<span class="hljs-comment">// add</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
<span class="hljs-comment">// remove</span>
<span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>
<span class="hljs-comment">// remove range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
<span class="hljs-comment">// remove all</span>
s1.<span class="hljs-built_in">clear</span>();
<span class="hljs-comment">// get size</span>
<span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
<span class="hljs-comment">// iterate</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {  <span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Map"></a><h4>Map</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FMap)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FSet)_TOPIC%2F">Library Functions/Containers/Ordered Associative/Set</a></li>
</ul>
</div>
<p><code>std::map</code> is a container similar to <code>std::set</code>, with the major difference being that each element in a <code>std::map</code> has a secondary value associated with it: key to value. Only the key is used for ordering, uniqueness, and lookup. The value just tags along.</p>
<p>To create a <code>std::map</code>, the same <code>std::set</code> <a href="#BM_(constructor)%2Fi">constructor</a>s apply. The only major differences are that ...</p>
<ol>
<li>the type of the value needs to be specified as the second <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</li>
<li>if initializing to a list of key-value pairs, each element of the initializer list must be <code>std::pair&lt;K,V&gt;</code> (<code>K</code> is key type, <code>V</code> is value type).</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// prime</span>
std::map&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s0 {
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// WARNING: this is the 2nd instance of the key 1, which value is inserted for the key is undefined</span>
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
std::map&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s1 {
    { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// WARNING: this is the 2nd instance of the key 1, which value is inserted for the key is undefined</span>
    { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
<span class="hljs-comment">// copy range</span>
<span class="hljs-function">std::map&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 key-value pairs from another container</span>
<span class="hljs-comment">// custom comparator</span>
<span class="hljs-keyword">auto</span> comparator </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; rhs) -&gt; <span class="hljs-type">bool</span> { <span class="hljs-keyword">return</span> lhs &lt; rhs; };
<span class="hljs-function">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(comparator)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> }, { <span class="hljs-number">2</span>, <span class="hljs-number">3.0f</span> }, ... }, comparator)</span></span>;
<span class="hljs-function">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::greater)</span>&gt; <span class="hljs-title">s4</span> <span class="hljs-params">({ { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> }, { <span class="hljs-number">2</span>, <span class="hljs-number">3.0f</span> }, ... }, std::greater)</span></span>;
<span class="hljs-comment">// copy/move</span>
std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; s5 { std::<span class="hljs-built_in">move</span>(s1) }; <span class="hljs-comment">// move s1 into s5</span>
<span class="hljs-comment">// custom allocator</span>
CustomAllocator allocator {};
<span class="hljs-function">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::less)</span>, CustomAllocator&gt; <span class="hljs-title">s6</span> <span class="hljs-params">(std::less, allocator)</span></span>;
</code></pre>
<p>To check an element exists, the following functions are available:</p>
<ul>
<li><code>find()</code> return an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed at the position of the found element (returns <code>end()</code> <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position if not found).</li>
<li><code>contains()</code> returns bool (true if it exists, false otherwise).</li>
<li><code>count()</code> returns integer (0 is false, 1 is true).</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>) };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">1</span> };
</code></pre>
<p><a href="#BM_(dereference%7Cdereferencing)%2Fi">Dereferencing</a> an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> will give back both the key and value as a <code>std::pair&lt;K,V&gt;</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) };
std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; found_pair { *it };
</code></pre>
<p>To find the first key-value pair where the key is greater than or equal (&gt;=) to some other key, use <code>lower_bound()</code>. Similarly, to find the first key-value pair where the key is greater than (&gt;) some other key, use <code>upper_bound()</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem 4 if 4 exists, otherwise get iterator to the elem just after 4 (could be s1.end() if no such elem)</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem just after 4 (could be s1.end() if no such elem)</span>
</code></pre>
<p>To add a key-value pair (not <em>replace</em> an existing value), the following functions are available:</p>
<ul>
<li><code>insert()</code> either copies or moves into the container (depending on if the <a href="#BM_(reference)%2Fi">reference</a> passed in is an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>).</li>
<li><code>emplace()</code> adds an element <em>by creating it directly</em> (no copying / moving).</li>
<li><code>try_emplace()</code> like <code>emplace()</code> but has special move semantics (does not move <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a> <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> arguments if insertion doesn't happen -- see docs for more info).</li>
<li><code>emplace_hint()</code> like <code>emplace()</code> but also takes in an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed to some position as a hint.</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Each func returns a bool (true for insertion, false for already exists) + an iterator to the key-value pair (existing one if not added)</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">insert</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">emplace</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">try_emplace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">try_emplace</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
</code></pre>
<p>To replace a value for an already existing key, <code>insert_or_assign()</code> either copies or moves into the container (depending on if the <a href="#BM_(reference)%2Fi">reference</a> passed in is an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>), replacing it if it already exists.</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> returns a bool (true for insertion, false for assignment) + an iterator to the key-value pair (existing one if not added)</span>
s1.<span class="hljs-built_in">insert_or_assign</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">insert_or_assign</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
</code></pre>
<p>To delete an element at some specific <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position, use either <code>extract()</code> or <code>erase()</code>. The difference is that <code>extract()</code> will return the key-value while <code>erase()</code> won't.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>

<span class="hljs-comment">// DELETE between idx range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
</code></pre>
<p>To delete all elements, use <code>clear()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">clear</span>();
</code></pre>
<p>To get the number of elements, use <code>size()</code>. Similarly, use <code>empty()</code> to check if empty.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Multimap"></a><h4>Multimap</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FMultimap)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FMultiset)_TOPIC%2F">Library Functions/Containers/Ordered Associative/Multiset</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FMap)_TOPIC%2F">Library Functions/Containers/Ordered Associative/Map</a></li>
</ul>
</div>
<p><code>std::multimap</code> is a container that's a combination of <code>std::multiset</code> and <code>std::map</code>. That is, it's a <code>std::map</code> but it allows for many key-value pairs with the same key (keys aren't unique). Similar to <code>std::multiset</code>, <code>std::multimap</code> uses the sorting comparator to find duplicates: two <a href="#BM_(object%7Cinstance)%2Fi">object</a>s a and b are considered equivalent if neither compares less than the other: <code>!comp(a, b) &amp;&amp; !comp(b, a)</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Definition is from cpp<a href="#BM_(reference)%2Fi">reference</a>.</p>
</div>
<p>To create a <code>std::multimap</code>, the same <code>std::map</code> <a href="#BM_(constructor)%2Fi">constructor</a>s apply. The only major difference is that, if you're initializing the values, any duplicate values are kept.</p>
<pre class="hljs"><code><span class="hljs-comment">// prime</span>
std::unordered_multimap&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s0 {
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this is the 2nd instance of the key 1, both key-value pairs are kept</span>
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
std::unordered_multimap&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s1 {
    { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this is the 2nd instance of the key 1, both key-value pairs are kept</span>
    { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
<span class="hljs-comment">// copy range</span>
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 key-value pairs from another container</span>
<span class="hljs-comment">// custom comparator</span>
<span class="hljs-keyword">auto</span> comparator </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; rhs) -&gt; <span class="hljs-type">bool</span> { <span class="hljs-keyword">return</span> lhs &lt; rhs; };
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(comparator)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> }, { <span class="hljs-number">2</span>, <span class="hljs-number">3.0f</span> }, ... }, comparator)</span></span>;
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::greater)</span>&gt; <span class="hljs-title">s4</span> <span class="hljs-params">({ { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> }, { <span class="hljs-number">2</span>, <span class="hljs-number">3.0f</span> }, ... }, std::greater)</span></span>;
<span class="hljs-comment">// copy/move</span>
std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; s5 { std::<span class="hljs-built_in">move</span>(s1) }; <span class="hljs-comment">// move s1 into s5</span>
<span class="hljs-comment">// custom allocator</span>
CustomAllocator allocator {};
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::less)</span>, CustomAllocator&gt; <span class="hljs-title">s6</span> <span class="hljs-params">(std::less, allocator)</span></span>;
</code></pre>
<p>Functions are more or less the same as their <code>std::map</code> counterparts. The only major difference are that...</p>
<ol>
<li><code>count()</code> returns the number of <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s for an element.are available</li>
<li><code>insert_or_assign()</code> is removed because it doesn't make sense to have it (you can have duplicate keys).</li>
<li><code>try_emplace()</code> is removed because it doesn't make sense to have it (you can have duplicate keys).</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// find</span>
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>) };
<span class="hljs-comment">// get</span>
<span class="hljs-keyword">auto</span> it { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) };  <span class="hljs-comment">// WARNING: if there's multiple instances of key, any of them could be returned here</span>
std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; found_pair { *it };
<span class="hljs-comment">// get number of instances</span>
<span class="hljs-type">bool</span> is_two_instances { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">2</span> };
<span class="hljs-comment">// get lower/upper bound</span>
<span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem 4 if 4 exists, otherwise get iterator to the elem just after 4 (could be s1.end() if no such elem)</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">4</span>) }; <span class="hljs-comment">// get iterator to elem just after 4 (could be s1.end() if no such elem)</span>
<span class="hljs-comment">// add</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">insert</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">emplace</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});  <span class="hljs-comment">// iterator should be near to where the value is</span>
<span class="hljs-comment">// remove</span>
<span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>
<span class="hljs-comment">// remove range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
<span class="hljs-comment">// remove all</span>
s1.<span class="hljs-built_in">clear</span>();
<span class="hljs-comment">// get size</span>
<span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
<span class="hljs-comment">// iterate</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Unordered%20Associative"></a><h3>Unordered Associative</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative)_TOPIC%2F"></a><strong></strong></p>
<p>Unordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers organize <a href="#BM_(object%7Cinstance)%2Fi">object</a>s by key and potentially a value. Keys are stored in an unordered fashion. The underlying data structure used by unordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers is a hash table.</p>
<p>By default, unordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers attempt to hash keys by calling <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s of <code>std::hash&lt;T&gt;</code>. Several pre-existing <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are provided by the C++ standard library (e.g. <code>int</code> ,<code>long</code>, <code>std::string</code>, etc..), but custom types need their own specialization to be written by the user.</p>
<p><code>std::hash&lt;T&gt;</code> implementations must be exposed as a <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a> that takes in the type in question and returns a <code>std::size_t</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::hash&lt;MyType&gt; {
    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(S <span class="hljs-keyword">const</span>&amp; s)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        std::<span class="hljs-type">size_t</span> h1 { std::hash&lt;std::string&gt;{} (s.student_name) };
        std::<span class="hljs-type">size_t</span> h2 { std::hash&lt;<span class="hljs-type">int</span>&gt;{} (s.student_age) };
        <span class="hljs-keyword">return</span> h1 ^ h2; <span class="hljs-comment">// see boost::hash_combine</span>
    }
};
</code></pre>
<p>A common point of confusion is what you have to do to use <code>std::hash</code> with a <a href="#BM_(reference)%2Fi">reference</a> type. Note that the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a> in the example above is taking a <a href="#BM_(reference)%2Fi">reference</a>, meaning you always use the non-<a href="#BM_(reference)%2Fi">reference</a> type as the type argument when invoking.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { <span class="hljs-number">55</span> };
<span class="hljs-type">int</span> &amp; xRef { x };
std::<span class="hljs-type">size_t</span> hash1 { std::hash&lt;<span class="hljs-type">int</span>&gt;{} (x) };
std::<span class="hljs-type">size_t</span> hash2 { std::hash&lt;<span class="hljs-type">int</span>&gt;{} (xRef) };
</code></pre>
<p>The subsections below detail the various unordered <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> containers that are provided by the C++ standard library.</p>
<a name="H1_Set"></a><h4>Set</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FSet)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative%2FSet)_TOPIC%2F">Library Functions/Containers/Ordered Associative/Set</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
</ul>
</div>
<p><code>std::unordered_set</code> is a container that's similar to <code>std::set</code>. It holds on to unique elements but does so <em>unordered</em> (whereas <code>std::set</code> has some sort order). It's implemented as a hash table, so rather than having to specify a comparator, you're required to specify a hash function.</p>
<p>Several pre-existing hash functions are provided by the C++ standard library via <code>std::hash&lt;T&gt;</code> (<code>T</code> being the type in question). If the user doesn't supply a hash function directly, the default is to use <code>std::hash&lt;T&gt;</code> with the element type substituted in (compilation will fail if no <code>std::hash&lt;T&gt;</code> implementation for that element type exists). For example, <code>std::hash&lt;int&gt;</code> exists for integers and gets automatically plugged in when the element type of the container is <code>int</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Details on providing a custom <code>std::hash&lt;T&gt;</code> implementation are in the parent section.</p>
</div>
<p>In addition to a hash function, a <code>std::unordered_set</code> may have a custom equivalence function. By default, <code>std::equal_to&lt;T&gt;</code> is used if none is supplied by the user, which uses the equality operator (==).</p>
<p>To create a <code>std::unordered_set</code> primed with a sequence of values known as <a href="#BM_(compile-time)%2Fi">compile-time</a>, use typical <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>. Since only unique values are allowed, duplicates will be ignored.</p>
<pre class="hljs"><code>std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s1 { <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
</code></pre>
<p>To create a <code>std::unordered_set</code> without priming it directly to a sequence of values, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code><span class="hljs-function">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>
</span></code></pre>
<p>To create a <code>std::unordered_set</code> with a custom hash function, that custom hash function can be implemented in one of two ways:</p>
<ul>
<li>a <a href="#BM_(function-like%20object%7Ccallable%20object)%2Fi">function-like object</a> that takes a single parameter of element type and returns the hash code as a <code>size_t</code>.</li>
<li>a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> <code>std::hash&lt;T&gt;</code> for the element type (assuming one wasn't already supplied by the C++ standard library).</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// function-like object</span>
<span class="hljs-keyword">auto</span> hasher = [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; val) -&gt; <span class="hljs-type">size_t</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(val); };
<span class="hljs-function">std::unordered_set&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(hasher)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }, hasher)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I think (not sure) if you create a <code>std::hash&lt;T&gt;</code> implementation for the element type, the <code>std::unordered_set</code> should automatically pick it without having to specify the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> + directly passing it in as an argument (as done above). It should work so long as the implementation is visible (e.g. whatever file its in has been <code>#include</code>-ed) when the container is created.</p>
</div>
<p><code>std::unordered_set</code> provides <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics. Because elements are <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, moving one <code>std::unordered_set</code> into another is fast because it's simply passing off a <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a>. Copying can potentially be expensive.</p>
<pre class="hljs"><code>std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s4 { std::<span class="hljs-built_in">move</span>(s1) }; <span class="hljs-comment">// move s1 into s4</span>
</code></pre>
<p>Similarly, because <code>std::unordered_set</code>'s elements are created as <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s, you have the option of supplying a custom allocator.</p>
<pre class="hljs"><code>CustomAllocator allocator {};
std::unordered_set&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(std::hash&lt;<span class="hljs-type">int</span>&gt;), <span class="hljs-keyword">decltype</span>(std::equal_to&lt;<span class="hljs-type">int</span>&gt;), CustomAllocator&gt; <span class="hljs-built_in">s5</span> (allocator);
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Similar to a Java <code>HashMap</code>, a <code>std::unordered_set</code> has concepts such as bucket count and load factor. It'll automatically add more buckets and rehash once the load factor reaches some point, all of which is tunable if you deem the performance of the defaults as not good. Alternatively, you can always trigger a rehash manually.</p>
<p>Those features aren't discussed here.</p>
</div>
<p><code>std::unordered_set</code> supports most of the same functions as <code>std::set</code> except for those that have to do with sorted ordering. For example, <code>lower_bound()</code> and <code>upper_bound()</code> are missing here because the elements here aren't ordered.</p>
<p>To check if a set contains an element, the following functions are available:</p>
<ul>
<li><code>find()</code> return an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed at the position of the found element (returns <code>end()</code> <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position if not found).</li>
<li><code>contains()</code> returns bool (true if it exists, false otherwise).</li>
<li><code>count()</code> returns integer (1 if it exists, 0 otherwise).</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>) };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">1</span> };
</code></pre>
<p>To add an element, the following functions are available:</p>
<ul>
<li><code>insert()</code> either copies or moves a value into the container (depending on if the <a href="#BM_(reference)%2Fi">reference</a> passed in is an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>).</li>
<li><code>emplace()</code> adds an element <em>by creating it directly</em> (no copying / moving).</li>
<li><code>emplace_hint()</code> like the above but also takes in an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed to some position as a hint.</li>
</ul>
<pre class="hljs"><code>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace_hint</span>(<span class="hljs-number">6</span>, s1.<span class="hljs-built_in">begin</span>());
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>emplace()</code> / <code>emplace_hint()</code> don't copy or move because you pass in initialization arguments directly into the functions. Internally, they use <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a>s to forward arguments for <a href="#BM_(object%7Cinstance)%2Fi">object</a> creation (e.g. <a href="#BM_(constructor)%2Fi">constructor</a> arguments, initializer list, etc..).</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FAny)_TOPIC%2F">Library Functions/Wrappers/Any</a> (also has an <code>emplace()</code> function)</li>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FVariant)_TOPIC%2F">Library Functions/Wrappers/Variant</a> (also has an <code>emplace()</code> function)</li>
</ul>
</div>
<p>To delete an element at some specific <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position, use either <code>extract()</code> or <code>erase()</code>. The difference is that <code>extract()</code> will return the element while <code>erase()</code> won't.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>

<span class="hljs-comment">// DELETE between idx range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
</code></pre>
<p>To delete all elements, use <code>clear()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">clear</span>();
</code></pre>
<p>To get the number of elements, use <code>size()</code>. Similarly, use <code>empty()</code> to check if empty.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H1_Multiset"></a><h4>Multiset</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FMultiset)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FSet)_TOPIC%2F">Library Functions/Containers/Unordered Associative/Set</a></li>
</ul>
</div>
<p><code>std::unordered_multiset</code> is a container that, like a <code>std::unordered_set</code>, holds on to unordered elements. Like <code>std::unordered_set</code>, it requires a hashing function and an equivalence function (same defaults are used if not supplied). Unlike <code>std::unordered_set</code>, it can hold on to multiple <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the same element (elements aren't unique).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Details on providing a custom <code>std::hash&lt;T&gt;</code> implementation are in the parent section.</p>
<p>Details on providing a custom hasher implementation specifically for the container are in the unordered set section.</p>
</div>
<p>To create a <code>std::unordered_multiset</code>, the same <code>std::unordered_set</code> <a href="#BM_(constructor)%2Fi">constructor</a>s apply. The only major difference is that, if you're initializing the values, any duplicate values are kept.</p>
<pre class="hljs"><code><span class="hljs-comment">// prime</span>
std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; s1 { <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };  <span class="hljs-comment">// DUPLICATED RETAINED</span>
<span class="hljs-comment">// copy range</span>
<span class="hljs-function">std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 elems from another container</span>
<span class="hljs-comment">// custom hash function</span>
<span class="hljs-keyword">auto</span> hasher </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; val) -&gt; <span class="hljs-type">size_t</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(val); };
<span class="hljs-function">std::unordered_multiset&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(hasher)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }, hasher)</span></span>;
<span class="hljs-comment">// copy/move</span>
std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; s4 { std::<span class="hljs-built_in">move</span>(s1) };  <span class="hljs-comment">// move s1 into s4</span>
CustomAllocator allocator {};
std::unordered_multiset&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(std::hash&lt;<span class="hljs-type">int</span>&gt;), <span class="hljs-keyword">decltype</span>(std::equal_to&lt;<span class="hljs-type">int</span>&gt;), CustomAllocator&gt; <span class="hljs-built_in">s5</span> (allocator);
</code></pre>
<p>Functions are more or less the same as those in <code>std::unordered_set</code>. The only major difference is that <code>count()</code> returns the number of <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s for an element.</p>
<pre class="hljs"><code><span class="hljs-comment">// find</span>
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">1</span>) };
<span class="hljs-comment">// get number of instances</span>
<span class="hljs-type">bool</span> is_two_instances { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">2</span> };
<span class="hljs-comment">// add</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>);
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
<span class="hljs-comment">// remove</span>
<span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>
<span class="hljs-comment">// remove range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
<span class="hljs-comment">// remove all</span>
s1.<span class="hljs-built_in">clear</span>();
<span class="hljs-comment">// get size</span>
<span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
<span class="hljs-comment">// iterate</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {  <span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H1_Map"></a><h4>Map</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FMap)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FSet)_TOPIC%2F">Library Functions/Containers/Unordered Associative/Set</a></li>
</ul>
</div>
<p><code>std::unordered_map</code> is a container similar to <code>std::unordered_set</code>, with the major difference being that each element in a <code>std::unordered_map</code> has a secondary value associated with it: key to value. Only the key is used for uniqueness and lookup. The value just tags along.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Details on providing a custom <code>std::hash&lt;T&gt;</code> implementation are in the parent section.</p>
<p>Details on providing a custom hasher implementation specifically for the container are in the unordered set section.</p>
</div>
<p>To create a <code>std::unordered_map</code>, the same <code>std::unordered_set</code> <a href="#BM_(constructor)%2Fi">constructor</a>s apply. The only major differences are that ...</p>
<ol>
<li>the type of the value needs to be specified as the second <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</li>
<li>if initializing to a list of key-value pairs, each element of the initializer list must be <code>std::pair&lt;K,V&gt;</code> (<code>K</code> is key type, <code>V</code> is value type).</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// prime</span>
std::unordered_map&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s0 {
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// WARNING: this is the 2nd instance of the key 1, which value is inserted for the key is undefined</span>
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
std::unordered_map&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s1 {
    { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// WARNING: this is the 2nd instance of the key 1, which value is inserted for the key is undefined</span>
    { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
<span class="hljs-comment">// copy range</span>
<span class="hljs-function">std::unordered_map&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 key-value pairs from another container</span>
<span class="hljs-comment">// custom hash function</span>
<span class="hljs-keyword">auto</span> hasher </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; val) -&gt; <span class="hljs-type">size_t</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(val); };
<span class="hljs-function">std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(hasher)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> }, { <span class="hljs-number">2</span>, <span class="hljs-number">3.0f</span> }, ... }, hasher)</span></span>;
<span class="hljs-comment">// copy/move</span>
std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; s5 { std::<span class="hljs-built_in">move</span>(s1) };  <span class="hljs-comment">// move s1 into s5</span>
<span class="hljs-comment">// custom allocator</span>
CustomAllocator allocator {};
<span class="hljs-function">std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::less)</span>, CustomAllocator&gt; <span class="hljs-title">s6</span> <span class="hljs-params">(std::less, allocator)</span></span>;
</code></pre>
<p>To check an element exists, the following functions are available:</p>
<ul>
<li><code>find()</code> return an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed at the position of the found element (returns <code>end()</code> <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position if not found).</li>
<li><code>contains()</code> returns bool (true if it exists, false otherwise).</li>
<li><code>count()</code> returns integer (0 is false, 1 is true).</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>) };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">1</span> };
</code></pre>
<p><a href="#BM_(dereference%7Cdereferencing)%2Fi">Dereferencing</a> an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> will give back both the key and value as a <code>std::pair&lt;K,V&gt;</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) };
std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; found_pair { *it };
</code></pre>
<p>To add a key-value pair (not <em>replace</em> an existing value), the following functions are available:</p>
<ul>
<li><code>insert()</code> either copies or moves into the container (depending on if the <a href="#BM_(reference)%2Fi">reference</a> passed in is an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>).</li>
<li><code>emplace()</code> adds an element <em>by creating it directly</em> (no copying / moving).</li>
<li><code>try_emplace()</code> like <code>emplace()</code> but has special move semantics (does not move <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">template parameter pack</a> <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> arguments if insertion doesn't happen -- see docs for more info).</li>
<li><code>emplace_hint()</code> like <code>emplace()</code> but also takes in an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> primed to some position as a hint.</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Each func returns a bool (true for insertion, false for already exists) + an iterator to the key-value pair (existing one if not added)</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">insert</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">emplace</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">try_emplace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">try_emplace</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
</code></pre>
<p>To replace a value for an already existing key, <code>insert_or_assign()</code> either copies or moves into the container (depending on if the <a href="#BM_(reference)%2Fi">reference</a> passed in is an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>), replacing it if it already exists.</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> returns a bool (true for insertion, false for assignment) + an iterator to the key-value pair (existing one if not added)</span>
s1.<span class="hljs-built_in">insert_or_assign</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">insert_or_assign</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
</code></pre>
<p>To delete an element at some specific <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> position, use either <code>extract()</code> or <code>erase()</code>. The difference is that <code>extract()</code> will return the key-value while <code>erase()</code> won't.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>

<span class="hljs-comment">// DELETE between idx range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
</code></pre>
<p>To delete all elements, use <code>clear()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">clear</span>();
</code></pre>
<p>To get the number of elements, use <code>size()</code>. Similarly, use <code>empty()</code> to check if empty.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
</code></pre>
<p>To iterate over the elements, use <code>being()</code> and <code>end()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// RECALL: for-each loop will implicitly call begin() and end()</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H1_Multimap"></a><h4>Multimap</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FMultimap)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FMultiset)_TOPIC%2F">Library Functions/Containers/Unordered Associative/Multiset</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative%2FMap)_TOPIC%2F">Library Functions/Containers/Unordered Associative/Map</a></li>
</ul>
</div>
<p><code>std::unordered_multimap</code> is a container that's a combination of <code>std::unordered_multiset</code> and <code>std::unordered_map</code>. That is, it's a <code>std::unordered_map</code> but it allows for many key-value pairs with the same key (keys aren't unique). Similar to <code>std::unordered_multiset</code>, <code>std::unordered_multimap</code> requires a hashing function and an equivalence function (same defaults are used if not supplied).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Details on providing a custom <code>std::hash&lt;T&gt;</code> implementation are in the parent section.</p>
<p>Details on providing a custom hasher implementation specifically for the container are in the unordered set section.</p>
</div>
<p>To create a <code>std::multimap</code>, the same <code>std::map</code> <a href="#BM_(constructor)%2Fi">constructor</a>s apply. The only major difference is that, if you're initializing the values, any duplicate values are kept.</p>
<pre class="hljs"><code><span class="hljs-comment">// prime</span>
std::unordered_multimap&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s0 {
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this is the 2nd instance of the key 1, both key-value pairs are kept</span>
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
std::unordered_multimap&lt;<span class="hljs-type">int</span>. <span class="hljs-type">float</span>&gt; s1 {
    { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> },
    { <span class="hljs-number">1</span>, <span class="hljs-number">-99.0f</span> },  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this is the 2nd instance of the key 1, both key-value pairs are kept</span>
    { <span class="hljs-number">2</span>, <span class="hljs-number">-100.0f</span> },
    { <span class="hljs-number">4</span>, <span class="hljs-number">123.0f</span> },
    { <span class="hljs-number">5</span>, <span class="hljs-number">4.0f</span> }
};
<span class="hljs-comment">// copy range</span>
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span> <span class="hljs-params">(c.begin(), c.begin() + <span class="hljs-number">10</span>)</span>  <span class="hljs-comment">// copy first 10 key-value pairs from another container</span>
<span class="hljs-comment">// custom comparator</span>
<span class="hljs-keyword">auto</span> hasher </span>= [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; val) -&gt; <span class="hljs-type">size_t</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(val); };
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(hasher)</span>&gt; <span class="hljs-title">s3</span> <span class="hljs-params">({ { <span class="hljs-number">1</span>, <span class="hljs-number">99.0f</span> }, { <span class="hljs-number">2</span>, <span class="hljs-number">3.0f</span> }, ... }, hasher)</span></span>;
<span class="hljs-comment">// copy/move</span>
std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; s5 { std::<span class="hljs-built_in">move</span>(s1) }; <span class="hljs-comment">// move s1 into s5</span>
<span class="hljs-comment">// custom allocator</span>
CustomAllocator allocator {};
<span class="hljs-function">std::unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(std::less)</span>, CustomAllocator&gt; <span class="hljs-title">s6</span> <span class="hljs-params">(std::less, allocator)</span></span>;
</code></pre>
<p>Functions are more or less the same as their <code>std::unordered_map</code> counterparts. The only major difference are that...</p>
<ol>
<li><code>count()</code> returns the number of <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s for an element.are available</li>
<li><code>insert_or_assign()</code> is removed because it doesn't make sense to have it (you can have duplicate keys).</li>
<li><code>try_emplace()</code> is removed because it doesn't make sense to have it (you can have duplicate keys).</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// find</span>
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != s1.<span class="hljs-built_in">end</span>() };
<span class="hljs-type">bool</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>) };
<span class="hljs-comment">// get</span>
<span class="hljs-keyword">auto</span> it { s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) };  <span class="hljs-comment">// WARNING: if there's multiple instances of key, any of them could be returned here</span>
std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; found_pair { *it };
<span class="hljs-comment">// get number of instances</span>
<span class="hljs-type">bool</span> is_two_instances { s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">2</span> };
<span class="hljs-comment">// add</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">insert</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);
s1.<span class="hljs-built_in">emplace</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>);  <span class="hljs-comment">// iterator should be near to where the value is</span>
s1.<span class="hljs-built_in">emplace_hint</span>(s1.<span class="hljs-built_in">begin</span>(), std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; {<span class="hljs-number">6</span>, <span class="hljs-number">122.0f</span>});  <span class="hljs-comment">// iterator should be near to where the value is</span>
<span class="hljs-comment">// remove</span>
<span class="hljs-keyword">auto</span> it1 { s1.<span class="hljs-built_in">begin</span>() };
<span class="hljs-type">int</span> res { s1.<span class="hljs-built_in">extract</span>(it1) };  <span class="hljs-comment">// WARNING: it1 invalid after this point</span>
<span class="hljs-keyword">auto</span> it2 { s1.<span class="hljs-built_in">begin</span>() };
s1.<span class="hljs-built_in">erase</span>(it2);  <span class="hljs-comment">// WARNING: it2 invalid after this point</span>
<span class="hljs-comment">// remove range</span>
<span class="hljs-keyword">auto</span> it3 {s1.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">auto</span> it4 {s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">10</span>};
l1.<span class="hljs-built_in">erase</span>(it3, it4); <span class="hljs-comment">// WARNING: it3/it4 invalid after this call</span>
<span class="hljs-comment">// remove all</span>
s1.<span class="hljs-built_in">clear</span>();
<span class="hljs-comment">// get size</span>
<span class="hljs-keyword">auto</span> is_empty1 { s1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
<span class="hljs-keyword">auto</span> is_empty2 { s1.<span class="hljs-built_in">empty</span>() };
<span class="hljs-comment">// iterate</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;obj : s1) {
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also ..</p>
<ul>
<li><code>cbegin()</code> / <code>cend()</code> which returns a constant <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (can't change values?).</li>
<li><code>rbegin()</code> / <code>rend()</code> which returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that goes in reverse order.</li>
<li><code>crbegin()</code> / <code>crend()</code> which is a mixture of the above two.</li>
</ul>
</div>
<a name="H_Adapters"></a><h3>Adapters</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FAdapters)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential)_TOPIC%2F">Library Functions/Containers/Sequential</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FOrdered%20Associative)_TOPIC%2F">Library Functions/Containers/Ordered Associative</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FUnordered%20Associative)_TOPIC%2F">Library Functions/Containers/Unordered Associative</a></li>
</ul>
</div>
<p>Container adapters are light-weight wrappers around sequential containers that expose them in a simplified way that matches a common data structure. For example, an <code>std::vector</code> can be wrapped such that it's exposed as a queue. The caller of the queue doesn't have to know what type of sequential container is backing that queue.</p>
<p>The type of sequential container usable by a container adaptor depends on the functions it has. For example, some container adaptors require both <code>front()</code> and <code>back()</code> functions to be supported by the sequential container type.</p>
<a name="H_Stack"></a><h4>Stack</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FAdapters%2FStack)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::stack</code> wraps a sequential container as if it were a stack abstract data type:</p>
<ul>
<li>The only way to write is to append.</li>
<li>The only element that can be read / removed is the last one.</li>
</ul>
<p>To create a <code>std::stack</code>, pass in a <a href="#BM_(reference)%2Fi">reference</a> to the sequential container to wrap: <code>std::vector</code>, <code>std::deque</code>, or <code>std::list</code>. The container will either be copied or moved depending on whether the container <a href="#BM_(reference)%2Fi">reference</a> is an normal <a href="#BM_(reference)%2Fi">reference</a> or an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>. Alternatively, if you pass in no <a href="#BM_(reference)%2Fi">reference</a> at all, an empty container of the type specified will get used.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The sequential container can technically be any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, so long as it supports the expected type traits (e.g. it's expected to have a function called <code>push_back()</code> that has a single parameter of type ...).</p>
</div>
<pre class="hljs"><code><span class="hljs-comment">// create by copying</span>
std::vector&lt;<span class="hljs-type">int</span>&gt; c1 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
std::stack&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(c1)&gt; s1 { c1 };
<span class="hljs-comment">// create by moving</span>
std::deque&lt;<span class="hljs-type">int</span>&gt; c2 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
std::stack&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(c2)&gt; s2 { std::<span class="hljs-built_in">move</span>(c2) };
<span class="hljs-comment">// create into brand new</span>
std::stack&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; s3 {};
std::queue&lt;<span class="hljs-type">int</span>&gt; q4 {};  <span class="hljs-comment">// equivalent to using std::deque&lt;int&gt; as the backing type</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a> (refresher on <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s)</li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F">Core Language/Templates/Type Cloning</a> (refresher on decltype)</li>
</ul>
</div>
<p>To add an item, use <code>push()</code>. Internally, this invokes the wrapped container's <code>push_back()</code> function.</p>
<pre class="hljs"><code>s3.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
s3.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);
s3.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>To read the most recently added item, use <code>top()</code>. Internally, this invokes the wrapped container's <code>back()</code> function.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a { s3.<span class="hljs-built_in">top</span>() };
</code></pre>
<p>To remove the most recently added item, use <code>pop()</code>. Internally, this invokes the wrapped container's <code>pop_back()</code> function.</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> also returns the element removed</span>
s3.<span class="hljs-built_in">pop</span>();
s3.<span class="hljs-built_in">pop</span>();
s3.<span class="hljs-built_in">pop</span>();
</code></pre>
<p>To get the size, use <code>size()</code>. Internally, this invokes the wrapped container function with the same name.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty { s3.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
</code></pre>
<a name="H_Queue"></a><h4>Queue</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FAdapters%2FQueue)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::queue</code> wraps a sequential container as if it were a queue abstract data type:</p>
<ul>
<li>The only way to write is to append.</li>
<li>The only element that can be read / removed is the head.</li>
</ul>
<p>To create a <code>std::queue</code>, pass in a <a href="#BM_(reference)%2Fi">reference</a> to the sequential container to wrap: <code>std::deque</code> or <code>std::list</code>. The container will either be copied or moved depending on whether the container <a href="#BM_(reference)%2Fi">reference</a> is an normal <a href="#BM_(reference)%2Fi">reference</a> or an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>. Alternatively, if you pass in no <a href="#BM_(reference)%2Fi">reference</a> at all, an empty container of the type specified will get used.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The sequential container can technically be any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, so long as it supports the expected type traits (e.g. it's expected to have a function called <code>push_back()</code> that has a single parameter of type ...).</p>
</div>
<pre class="hljs"><code><span class="hljs-comment">// create by copying</span>
std::deque&lt;<span class="hljs-type">int</span>&gt; c1 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
std::queue&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(c1)&gt; q1 { c1 };
<span class="hljs-comment">// create by moving</span>
std::deque&lt;<span class="hljs-type">int</span>&gt; c2 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
std::queue&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(c2)&gt; q2 { std::<span class="hljs-built_in">move</span>(c2) };
<span class="hljs-comment">// create into brand new</span>
std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q3 {};
std::queue&lt;<span class="hljs-type">int</span>&gt; q4 {};  <span class="hljs-comment">// equivalent to using std::deque&lt;int&gt; as the backing type</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a> (refresher on <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s)</li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F">Core Language/Templates/Type Cloning</a> (refresher on decltype)</li>
</ul>
</div>
<p>To add an item, use <code>push()</code>. Internally, this invokes the wrapped container's <code>push_back()</code> function.</p>
<pre class="hljs"><code>q3.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
q3.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);
q3.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>To read the most recently added item, use either <code>front()</code> or <code>back()</code>. Internally, these invoke the wrapped container functions with the same name.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a { q3.<span class="hljs-built_in">front</span>() };
<span class="hljs-type">int</span> b { q3.<span class="hljs-built_in">back</span>() };
</code></pre>
<p>To remove the most recently added item, use <code>pop()</code>. Internally, this invokes the wrapped container's <code>pop_front()</code> function.</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> also returns the element removed</span>
q3.<span class="hljs-built_in">pop</span>();
q3.<span class="hljs-built_in">pop</span>();
q3.<span class="hljs-built_in">pop</span>();
</code></pre>
<p>To get the size, use <code>size()</code>. Internally, this invokes the wrapped container function with the same name.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty { q3.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
</code></pre>
<a name="H_Priority%20Queue"></a><h4>Priority Queue</h4>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FAdapters%2FPriority%20Queue)_TOPIC%2F"></a><strong></strong></p>
<p><code>std::priority_queue</code> wraps a sequential container as if it were a priority queue abstract data type: Regardless of what order elements are added in, the only element that can be read / removed is the element with the highest priority (priority is defined by a comparator).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The sequential container can technically be any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, so long as it supports the expected type traits (e.g. it's expected to have a function called <code>push_back()</code> that has a single parameter of type ...).</p>
</div>
<p>To create a <code>std::priority_queue</code>, pass in a <a href="#BM_(reference)%2Fi">reference</a> to the sequential container to wrap: <code>std::vector</code>, <code>std::deque</code>, or <code>std::list</code>. The container will either be copied or moved depending on whether the container <a href="#BM_(reference)%2Fi">reference</a> is an normal <a href="#BM_(reference)%2Fi">reference</a> or an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>. Alternatively, if you pass in no <a href="#BM_(reference)%2Fi">reference</a> at all, an empty container of the type specified will get used.</p>
<pre class="hljs"><code><span class="hljs-comment">// create by copying</span>
std::vector&lt;<span class="hljs-type">int</span>&gt; c1 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
std::priority_queue&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(c1)&gt; q1 { c1 };
<span class="hljs-comment">// create by moving</span>
std::deque&lt;<span class="hljs-type">int</span>&gt; c2 { <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> };
std::priority_queue&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(c2)&gt; q2 { std::<span class="hljs-built_in">move</span>(c2) };
<span class="hljs-comment">// create into brand new</span>
std::priority_queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q3 {};
std::priority_queue&lt;<span class="hljs-type">int</span>&gt; q4 {};  <span class="hljs-comment">// equivalent to using std::vector&lt;int&gt; as the backing type</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a> (refresher on <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s)</li>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Cloning)_TOPIC%2F">Core Language/Templates/Type Cloning</a> (refresher on decltype)</li>
</ul>
</div>
<p>In the above examples the default comparator of <code>std::less</code> is used, which uses the less than operator (&lt;) to compare two <a href="#BM_(object%7Cinstance)%2Fi">object</a>s for priority. To define a custom comparator, pass in that comparator's type as the 3rd <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument and pass it into the <a href="#BM_(constructor)%2Fi">constructor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> comparator = [] (<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp; rhs) -&gt; <span class="hljs-type">bool</span> { <span class="hljs-keyword">return</span> lhs &lt; rhs; };
std::priority_queue&lt;<span class="hljs-type">int</span>, std::deque&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(comparator)&gt; q5 { comparator };
std::priority_queue&lt;<span class="hljs-type">int</span>, std::deque&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(std::greater&lt;<span class="hljs-type">int</span>&gt;)&gt; q6 { std::greater&lt;<span class="hljs-type">int</span>&gt; };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FLambdas)_TOPIC%2F">Core Language/Lambdas</a> (<a href="#BM_(lambda)%2Fi">lambda</a> refresher)</li>
</ul>
</div>
<p>To add an item, use <code>push()</code>.</p>
<pre class="hljs"><code>q1.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);
q1.<span class="hljs-built_in">push</span>(<span class="hljs-number">100</span>);
q1.<span class="hljs-built_in">push</span>(<span class="hljs-number">-5</span>);
</code></pre>
<p>To read the most high priority element, use <code>top()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a { q1.<span class="hljs-built_in">top</span>() };
</code></pre>
<p>To remove the most high priority element, use <code>pop()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> also returns the element removed</span>
q1.<span class="hljs-built_in">pop</span>();
q1.<span class="hljs-built_in">pop</span>();
q1.<span class="hljs-built_in">pop</span>();
</code></pre>
<p>To get the size, use <code>size()</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> is_empty { s3.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> };
</code></pre>
<a name="H_Iterators"></a><h2>Iterators</h2>
<p><a name="BM_(Library%20Functions%5C%2FIterators)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Iterator</a>s in C++ are similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s in Java. In Java, <a href="#BM_(object%7Cinstance)%2Fi">object</a>s that...</p>
<ul>
<li>produce an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> typically implement the <code>Iterable</code> interface (e.g. <code>ArrayList</code>)</li>
<li>are <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s must implement the <code>Iterator</code> interface.</li>
</ul>
<p>In C++, there is no requirement to <a href="#BM_(extends%3F%7Csubclass)%2Fi">extend</a> from any base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es or interfaces. Instead, any type can act as an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> so long as it supports as set of operators:</p>
<ul>
<li><code>!=</code> - test if the position of one <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> doesn't match the position of another <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (e.g. <code>my_iterator != end_iterator</code>).</li>
<li><code>++</code> - move to the next item (e.g. <code>my_iterator++</code>).</li>
<li><code>*</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>) - access the next item (e.g. <code>int value {*my_iterator}</code>).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Notice that the operators are more or less array / <a href="#BM_(pointer)%2Fi">pointer</a> behaviour. Given something like <code>int *</code> pointing to the beginning of an array, ...</p>
<ul>
<li>incrementing it by 1 (<code>++</code>) moves it to the next element of the array via <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>.</li>
<li><a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> it (<code>*</code>) provides the value at the array element it points to.</li>
<li>testing it using inequality (<code>!=</code>) is a way to check if it hasn't gone past the last array element.</li>
</ul>
<p>An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> is basically a set of operators that walk elements in the same way as you would an array. A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can implement the <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s and behave the same way.</p>
</div>
<p>Similarly, any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can act as an iterable by implementing <code>begin()</code> and <code>end()</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s:</p>
<ul>
<li><code>begin()</code> - returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> pointing to the first item.</li>
<li><code>end()</code> - returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> pointing to <em>past-the-end</em> (just after the last element).</li>
</ul>
<pre class="hljs"><code>MyIterator it {collection.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">while</span> (it != collection.<span class="hljs-built_in">end</span>()) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
    ++iterator;
}
</code></pre>
<p>C++ iterables and <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s can be used together in range-based for loops.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (MyIterator it : collection) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<p>In total, 5 kinds of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s are supported by C++. The kind of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> described above is called an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> and it typically requires an equality <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> (<code>operator ==()</code>) in addition to inequality. <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Input iterator</a>s are the closest thing to a standard Java <code>Iterator</code> -- read-only and forward-only. Other kinds of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s require different <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s.</p>
<ul>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Input iterator</a>, steps forward one element at a time and reads items of the container.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Output iterator</a>, steps forward one element at a time and writes items of the container.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Forward iterator</a>, combination of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> and <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a>.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Bidirectional iterator</a>, <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> with the ability to move back.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Random access iterator</a>, <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> with the ability to jump to different positions.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>input</th>
<th>output</th>
<th>forward</th>
<th>bidirectional</th>
<th>random access</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>++it</code> and <code>it++</code> (move forward)</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>--it</code> and <code>it--</code> (move backward)</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 == it2</code> and<code>it1 != it2</code> (test if at same position)</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &lt; it2</code> (test if before)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &lt;= it2</code> (test if before or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &gt; it2</code> (test if after)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &gt;= it2</code> (test if after or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>x = *it</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and get)</td>
<td>‚úì</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>*it = x</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and set)</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 += n</code> and <code>it1 + n</code> (add integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 -= n</code> and <code>it1 - n</code> (subtract integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it2 - it1</code> (subtract <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s to get positional difference)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 + it2</code> (add <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Note that the adding of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s is listed above but is not supported by any of the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> types. It's there to make it explicit that adding together two <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s isn't a thing.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>If you're dealing with the STL, there's also special <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> implementations that allow insertions rather than setting elements. See <code>insert_iterator</code>, <code>back_insert_iterator</code>, and <code>front_insert_iterator</code>.</p>
</div>
<a name="H1_Concepts"></a><h3>Concepts</h3>
<p><a name="BM_(Library%20Functions%5C%2FIterator%2FConcepts)_TOPIC%2F"></a><strong></strong></p>
<p>Each of the following <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s map to a type of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>.</p>
<ul>
<li><code>std::input_iterator</code> enforces <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> type traits.</li>
<li><code>std::output_iterator</code> enforces <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a> type traits.</li>
<li><code>std::forward_iterator</code> enforces <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> type traits.</li>
<li><code>std::bidirectional_iterator</code> enforces <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> type traits.</li>
<li><code>std::random_access_iterator</code> enforces <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a> type traits.</li>
<li><code>std::contiguous_iterator</code> enforces contiguous <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> type traits.</li>
</ul>
<p>The type traits of each <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> type were described in the parent section.</p>
<table>
<thead>
<tr>
<th></th>
<th>input</th>
<th>output</th>
<th>forward</th>
<th>bidirectional</th>
<th>random access</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>++it</code> and <code>it++</code> (move forward)</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>--it</code> and <code>it--</code> (move backward)</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 == it2</code> and<code>it1 != it2</code> (test if at same position)</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &lt; it2</code> (test if before)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &lt;= it2</code> (test if before or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &gt; it2</code> (test if after)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 &gt;= it2</code> (test if after or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>x = *it</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and get)</td>
<td>‚úì</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>*it = x</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and set)</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 += n</code> and <code>it1 + n</code> (add integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 -= n</code> and <code>it1 - n</code> (subtract integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it2 - it1</code> (subtract <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s to get positional difference)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td><code>it1 + it2</code> (add <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_range</span><span class="hljs-params">(std::random_access_iterator <span class="hljs-keyword">auto</span> &amp;&amp;it)</span> </span>{
    std::cout &lt;&lt; it[<span class="hljs-number">3</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; it[<span class="hljs-number">1</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; it[<span class="hljs-number">2</span>] &lt;&lt; std::endl;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There are a handful of other <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> type traits that build on-top of each other to form a taxonomy of <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s for <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s. For example, at the bottom is ...</p>
<ul>
<li><code>std::incrementable</code> / <code>std::weakly_incrementable</code> - enforces <code>it++</code> and <code>++it</code> type traits.</li>
<li><code>std::input_or_output_iterator</code> - enforces <code>*it</code> type traits and enforces <code>std::weakly_incrementable</code>.</li>
<li>etc..</li>
</ul>
<p>I don't think these are useful enough to document.</p>
</div>
<a name="H_Helpers"></a><h3>Helpers</h3>
<p><a name="BM_(Library%20Functions%5C%2FIterators%2FHelpers)_TOPIC%2F"></a><strong></strong></p>
<p>When writing <em>generic</em> code that makes use of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s, directly using the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> may lead to poor performance. For example, if you want an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> to move up 100 spaces, you can't do <code>it += 100</code> because <code>it</code> may not be a <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a>. The safest thing to do for generic code would be to perform <code>it++</code> 100 times, but that means you miss out any performance gains of doing <code>it += 100</code> if <code>it</code> were a <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a>.</p>
<p>Several helper functions exist to help with examples like the one above. These helper functions choose the most performant way of doing something based on the type traits of the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (e.g. if it's a <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> vs a <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a>).</p>
<ul>
<li>
<p><code>std::advance()</code> - move forward / backward an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> by some amount.</p>
<pre class="hljs"><code>std::<span class="hljs-built_in">advance</span>(it, <span class="hljs-number">100</span>); <span class="hljs-comment">// move forward 100 spaces</span>
std::<span class="hljs-built_in">advance</span>(it, <span class="hljs-number">-100</span>); <span class="hljs-comment">// move backward 100 spaces</span>
</code></pre>
</li>
<li>
<p><code>std::next()</code> - move forward by some amount.</p>
<pre class="hljs"><code>std::<span class="hljs-built_in">next</span>(it); <span class="hljs-comment">// move forward 1 space</span>
std::<span class="hljs-built_in">next</span>(it, <span class="hljs-number">100</span>); <span class="hljs-comment">// move forward 100 spaces</span>
</code></pre>
</li>
<li>
<p><code>std::prev()</code> - move backward by some amount.</p>
<pre class="hljs"><code>std::<span class="hljs-built_in">prev</span>(it); <span class="hljs-comment">// move backward 1 space</span>
std::<span class="hljs-built_in">prev</span>(it, <span class="hljs-number">100</span>); <span class="hljs-comment">// move backward 100 spaces</span>
</code></pre>
</li>
<li>
<p><code>std::distance()</code> - get distance between two <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> d { std::<span class="hljs-built_in">distance</span>(it1, it2) }; <span class="hljs-comment">// it2 should be &gt; than it1</span>
</code></pre>
</li>
<li>
<p><code>std::iter_swap()</code> - given two <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s, swap the elements at their current position.</p>
<pre class="hljs"><code>std::<span class="hljs-built_in">iter_swap</span>(it1, it2);
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> it1 and it2 don't have to point to the same underlying container or</span>
<span class="hljs-comment">// underlying type -- as long as the types are assignable to each other, it'll work.</span>
</code></pre>
</li>
</ul>
<a name="H1_Adapters"></a><h3>Adapters</h3>
<p><a name="BM_(Library%20Functions%5C%2FIterators%2FAdapters)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Iterator</a> adapters are light-weight wrappers that either simplify operations or provide some functionality under the type traits of an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>. For example, an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> exists that can wrap a container as an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>, where writes to that <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> will translate to inserts into the container.</p>
<a name="H_Insert"></a><h4>Insert</h4>
<p><a name="BM_(Library%20Functions%5C%2FIterators%2FAdapters%2FInsert)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F">Library Functions/Containers</a></li>
</ul>
</div>
<p>An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> adaptor that wraps a container and exposes it as an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a>, where writes are translated to inserts on the container. The  It comes in 3 flavours:</p>
<ul>
<li>
<p><code>std::back_insert_iterator</code> - invokes the container's <code>push_back()</code> function.</p>
<pre class="hljs"><code>std::vector&lt;<span class="hljs-type">int</span>&gt; container {};
std::back_insert_iterator it { container };
*it = <span class="hljs-number">1</span>;
it++;
*it = <span class="hljs-number">2</span>;
it++;
*it = <span class="hljs-number">3</span>;
</code></pre>
</li>
<li>
<p><code>std::front_insert_iterator</code> - invokes the container's <code>push_front()</code> function.</p>
<pre class="hljs"><code>std::deque&lt;<span class="hljs-type">int</span>&gt; container {};
std::front_insert_iterator it { container };
*it = <span class="hljs-number">3</span>;
it++;
*it = <span class="hljs-number">2</span>;
it++;
*it = <span class="hljs-number">1</span>;
</code></pre>
</li>
<li>
<p><code>std::insert_iterator</code>- invokes the container's <code>insert()</code> function.</p>
<pre class="hljs"><code>std::deque&lt;<span class="hljs-type">int</span>&gt; container { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
std::insert_iterator it { container, container.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span> }; <span class="hljs-comment">// start inserting at 2 elements down</span>
*it = <span class="hljs-number">100</span>;
it++;
*it = <span class="hljs-number">101</span>;
it++;
*it = <span class="hljs-number">102</span>;
</code></pre>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>According to the book, these adapters ignore the increment operator because it isn't required for what's being done (insertion function calls to the wrapped container). Ignored parts are there because type traits for <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a> require them to be there.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There are helper functions available for creating these. The function names are similar to the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> adapter names: replace the <code>insert_iterator</code> part with <code>inserter</code> (e.g. <code>std::back_inserter()</code>).</p>
</div>
<a name="H_Move"></a><h4>Move</h4>
<p><a name="BM_(Library%20Functions%5C%2FIterators%2FAdapters%2FMove)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F">Core Language/Classes/Copying</a> (refresher)</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a> (refresher)</li>
</ul>
</div>
<p>An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> adaptor that wraps another <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> but modifies the <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> operator such that it returns an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> -- it forcefully moves the element. The typical use case for this is moving items from one container to another (as opposed to copying).</p>
<pre class="hljs"><code>std::vector&lt;MyMovableObject&gt; container1 {};
container1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"morning"</span>);
container1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"midday"</span>);
container1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"evening"</span>);
<span class="hljs-comment">// MOVE each item in container1 to container 2 (move semantics / move constructor)</span>
<span class="hljs-function">std::vector&lt;MyMovableObject&gt; <span class="hljs-title">container2</span><span class="hljs-params">(
    std::move_iterator{ container1.begin() },
    std::move_iterator{ container1.end() }
)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There is a helper function for creating this: <code>std::make_move_iterator()</code>.</p>
</div>
<a name="H_Reverse"></a><h4>Reverse</h4>
<p><a name="BM_(Library%20Functions%5C%2FIterators%2FAdapters%2FReverse)_TOPIC%2F"></a><strong></strong></p>
<p>An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> adaptor that wraps another <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> but exposes it in reverse order -- last element to first element.</p>
<pre class="hljs"><code>std::vector&lt;<span class="hljs-type">int</span>&gt; container1 { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-function">std::vector&lt;MyMovableObject&gt; <span class="hljs-title">container2</span><span class="hljs-params">(
    std::reverse_iterator{ container1.end() },
    std::reverse_iterator{ container1.begin() }
)</span></span>;
</code></pre>
<p>One important thing to note is that the first <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> being wrapped <em>must not be</em> before the 2nd <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> being wrapped. If it were, it'd be undefined behaviour.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (it2 &gt; it1)
<span class="hljs-function">std::vector&lt;MyMovableObject&gt; <span class="hljs-title">container2</span><span class="hljs-params">(  <span class="hljs-comment">// THIS IS UNDEFINED BEHAVIOUR</span>
    std::reverse_iterator{ container1.begin() },
    std::reverse_iterator{ container1.begin() + <span class="hljs-number">2</span> }
)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There is a helper function for creating this: <code>std::make_reverse_iterator()</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Most collections expose <code>rbegin()</code> / <code>rend()</code> functions that automatically give back a reverse <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>.</p>
</div>
<a name="H_Ranges"></a><h2>Ranges</h2>
<p><a name="BM_(Library%20Functions%5C%2FRanges)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F">Library Functions/Containers</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FWrappers%2FTuple)_TOPIC%2F">Library Functions/Wrappers/Tuple</a></li>
</ul>
</div>
<p>The C++ standard library provides an functionality similar to Java streams, called ranges. Like Java streams, ranges enable functional programming in that a range can be fed into a chain of higher-level operations that manipulate the stream of elements within, lazily if possible.</p>
<pre class="hljs"><code><span class="hljs-comment">// The code below prints the numbers 2 and 4. The Java streams equivalent is provided on the right-hand side.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//           C++                                           vs                 JAVA</span>
std::vector&lt;<span class="hljs-type">int</span>&gt; v{ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> };                                  <span class="hljs-comment">// var v = ArrayList&lt;Integer&gt;();</span>
                                                                <span class="hljs-comment">// v.add(0);</span>
                                                                <span class="hljs-comment">// v.add(1);</span>
                                                                <span class="hljs-comment">// v.add(2);</span>
                                                                <span class="hljs-comment">//</span>
<span class="hljs-keyword">auto</span> range {                                                    <span class="hljs-comment">// var range =</span>
    v                                                           <span class="hljs-comment">//          v.stream()</span>
    | std::views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> x) { <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; })        <span class="hljs-comment">//         .map(e -&gt; e * 2)</span>
    | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> x) { <span class="hljs-keyword">return</span> x != <span class="hljs-number">0</span>; })          <span class="hljs-comment">//         .filter(e -&gt; e != 0);</span>
};                                                              <span class="hljs-comment">//</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : range) {                                           <span class="hljs-comment">// range.forEach(e -&gt; { System.out.println(e); } );</span>
    std::cout &lt;&lt; e &lt;&lt; std::endl;                                <span class="hljs-comment">//</span>
}                                                               <span class="hljs-comment">//</span>
</code></pre>
<p>As shown in the example above, ranges work similarly to Java streams. Operations are chained together using the pipe operator (|), where those operations are applied from left-to-right.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><strong>WARNING</strong>: Once <code>v</code> above gets destroyed (e.g. goes out of scope), <code>range</code> becomes invalid. <code>v</code> is <em><a href="#BM_(reference)%2Fi">reference</a>d</em> by <code>range</code>, it isn't <em>copied</em> / <em>moved</em> into <code>range</code>. See the subsection on owning views to workaround this problem.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Unlike Java streams, the current implementation of ranges (C++20) are missing some major functionality:</p>
<ul>
<li>type-erasures (e.g. <code>std::vector&lt;int&gt; {0, 1, 2} | std::views::transform([](int x) { return x * 2; })</code> and <code>std::vector&lt;int&gt; {0, 1, 2} | std::views::filter([](int x) { return x != 0; })</code> don't have the same type)</li>
<li>parallel algorithms (e.g. transform using multiple cores)</li>
<li>actions (e.g. missing things like <code>forEach()</code> in Java streams)</li>
</ul>
</div>
<p>Any <a href="#BM_(object%7Cinstance)%2Fi">object</a> that has a particular set of type traits is a range. Those type traits map closely to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> type traits: A range must have implementation for <code>std::begin(R)</code> and <code>std::end(R)</code> functions, and usage patterns similar to that of the type of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> it maps to:</p>
<ul>
<li>input range has usage patterns similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a>.</li>
<li>output range has usage patterns similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a>.</li>
<li>forward range has usage patterns similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a>.</li>
<li>bidirectional range has usage patterns similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a>.</li>
<li>random access range has usage patterns similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a>.</li>
<li>contiguous range has usage patterns similar to contiguous <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>.</li>
</ul>
<p>One major difference between <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s and ranges is that a range's <code>end()</code> function doesn't necessarily have to return the same type as its <code>begin()</code> function. It can instead return a sentinel type that marks the end of the range. If a range does return the same type for both <code>begin()</code> and <code>end()</code>, it's referred to as a common range. Containers in the C++ standard library are all of common ranges. However, once a container gets piped into an operation, it may end up not being a common range.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <code>std::views::common()</code> below. It wraps a view and makes it so that <code>begin()</code> and <code>end()</code> have a common return type.</p>
</div>
<table>
<thead>
<tr>
<th>container</th>
<th>range type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::unordered_set</code></td>
<td>input range</td>
</tr>
<tr>
<td><code>std::unordered_map</code></td>
<td>input range</td>
</tr>
<tr>
<td><code>std::unordered_multiset</code></td>
<td>input range</td>
</tr>
<tr>
<td><code>std::unordered_multimap</code></td>
<td>input range</td>
</tr>
<tr>
<td><code>std::forward_list</code></td>
<td>input range</td>
</tr>
<tr>
<td><code>std::set</code></td>
<td>output range</td>
</tr>
<tr>
<td><code>std::map</code></td>
<td>output range</td>
</tr>
<tr>
<td><code>std::multiset</code></td>
<td>output range</td>
</tr>
<tr>
<td><code>std::multimap</code></td>
<td>output range</td>
</tr>
<tr>
<td><code>std::list</code></td>
<td>output range</td>
</tr>
<tr>
<td><code>std::deque</code></td>
<td>bidirectional range</td>
</tr>
<tr>
<td><code>std::array</code></td>
<td>contiguous range</td>
</tr>
<tr>
<td><code>std::vector</code></td>
<td>contiguous range</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>std::string</code> and other types of string variants, while not containers, are contiguous ranges.</p>
</div>
<p>When an operation such as transformation or filtering is applied on a range, it's applied through a view. A view is a special type of range that typically doesn't own any data and typically isn't mutable / is state-less. As such, a view typically has constant-time copy, move, and assignment.</p>
<table>
<thead>
<tr>
<th>view</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::views::filter</code></td>
<td><code>v | std::views::filter([](int x) { return x != 0; }</code></td>
<td>keep elements that pass predicate</td>
</tr>
<tr>
<td><code>std::views::transform</code></td>
<td><code>v | std::views::transform([](int x) { return x * 2; }</code></td>
<td>modify elements</td>
</tr>
<tr>
<td><code>std::views::take</code></td>
<td><code>v | std::views::take(5)</code></td>
<td>keep first n elements</td>
</tr>
<tr>
<td><code>std::views::take_while</code></td>
<td><code>v | std::views::take_while([](int x) { return x != 0; }</code></td>
<td>keep elements until predicate fails</td>
</tr>
<tr>
<td><code>std::views::drop</code></td>
<td><code>v | std::views::drop(5)</code></td>
<td>skip first n elements</td>
</tr>
<tr>
<td><code>std::views::drop_while</code></td>
<td><code>v | std::views::drop_while([](int x) { return x == 0; }</code></td>
<td>skip elements until predicate fails</td>
</tr>
<tr>
<td><code>std::views::join</code></td>
<td><code>v | std::views::join</code></td>
<td>flatten a range of ranges (2D) into a range (1D)</td>
</tr>
<tr>
<td><code>std::views::join_with</code></td>
<td><code>v | std::views::join_with(-1)</code></td>
<td>flatten a range of ranges (2D) into a range (1D) with delimiters in between</td>
</tr>
<tr>
<td><code>std::views::split</code></td>
<td><code>v | std::views::split(-1)</code></td>
<td>split a range into a range of ranges using a delimiter</td>
</tr>
<tr>
<td><code>std::views::lazy_split</code></td>
<td><code>v | std::views::lazy_split(-1)</code></td>
<td>split a range into a range of ranges using a delimiter (lazily)</td>
</tr>
<tr>
<td><code>std::views::counted</code></td>
<td><code>std::views::counted(v.begin(), 5)</code></td>
<td>keep a sub-range of a range</td>
</tr>
<tr>
<td><code>std::views::common</code></td>
<td><code>std::views::common(v)</code></td>
<td>convert to a common view (<code>being()</code> and <code>end()</code> have same type)</td>
</tr>
<tr>
<td><code>std::views::reverse</code></td>
<td><code>v | std::views::reverse</code></td>
<td>reverse a view</td>
</tr>
<tr>
<td><code>std::views::elements</code></td>
<td><code>v | std::views::elements&lt;1&gt;</code></td>
<td>transform tuples to their nth item</td>
</tr>
<tr>
<td><code>std::views::keys</code></td>
<td><code>v | std::views::keys</code></td>
<td>transform pairs to their 1st item</td>
</tr>
<tr>
<td><code>std::views::values</code></td>
<td><code>v | std::views::values</code></td>
<td>transform pairs to their 2nd item</td>
</tr>
<tr>
<td><code>std::views::zip</code></td>
<td><code>std::views::zip(v1, v2, v3)</code></td>
<td>zip multiple ranges together (similar to Python's <code>zip()</code>)</td>
</tr>
</tbody>
</table>
<p>In addition to performing operations on another range's elements, a view may originate elements itself.</p>
<table>
<thead>
<tr>
<th>view</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::views::empty</code></td>
<td><code>std::views::empty&lt;int&gt;</code></td>
<td>empty range of some type</td>
</tr>
<tr>
<td><code>std::views::single</code></td>
<td><code>std::views::single&lt;int&gt; { 5 }</code></td>
<td>range of a single element</td>
</tr>
<tr>
<td><code>std::views::iota</code></td>
<td><code>std::views::iota(1, 5)</code></td>
<td>range of incrementing values (bounded)</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The tables above aren't exhaustive.</p>
</div>
<a name="H2_Concepts"></a><h3>Concepts</h3>
<p><a name="BM_(Library%20Functions%5C%2FRanges%2FConcepts)_TOPIC%2F"></a><strong></strong></p>
<p>At it's core, a range must satisfy the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> <code>std::ranges::range</code>, which only asks that the type have an implementation for the functions <code>std::ranges::begin(R)</code> and <code>std::ranges::end(R)</code>. There are two <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> specializations:</p>
<ul>
<li><code>std::ranges::sized_range</code>: A range type that has an implementation for <code>std::ranges::size(R)</code>, which returns the number of elements within the range.</li>
<li><code>std::ranges::borrowed_range</code>: A range type that provides a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> for <code>std::ranges::enable_borrowed_range&lt;R&gt;</code>, which signals that the range type guarantees that the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s it returns aren't bound to the <a href="#BM_(lifetime)%2Fi">lifetime</a> of the range. Borrowed ranges are commonly generate elements on-the-fly.</li>
<li><code>std::ranges::view</code>: A range type with constant-time copy/move/assignment operations and provides a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> for <code>std::enable_view&lt;R&gt;</code>, which signals that the range type is a view. Views are commonly used to transform elements from another range or generate elements on the fly.</li>
</ul>
<p>The following <a href="#BM_(template)%2Fi">template</a>s provide access to the types used by a range.</p>
<ul>
<li><code>std::ranges::iterator_t&lt;R&gt;</code> - <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> type of range <code>R</code></li>
<li><code>std::ranges::sentinel_t&lt;R&gt;</code> - sentinel type of range <code>R</code> (type returned by <code>std::ranges::end(R)</code>, which may be different from the type returned by <code>std::ranges::begin(R)</code>)</li>
<li><code>std::ranges::size_t&lt;R&gt;</code> - type of range <code>R</code>'s size type (type returned by <code>std::ranges::size(R)</code>, if implemented)</li>
<li><code>std::ranges::difference_t&lt;R&gt;</code> - type returned by differencing two <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> types of range <code>R</code> (resolves to <code>std::iter_difference_t&lt;std::ranges::iterator)t&lt;R&gt;&gt;</code>)</li>
<li><code>std::ranges::range_reference_t&lt;R&gt;</code> - type returned by <em><a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a></em> of range <code>R</code> (type returned by <code>*(std::ranges::begin(R)</code>)</li>
<li><code>std::ranges::range_rvalue_reference_t&lt;R&gt;</code> - type returned by <em><a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a></em> of range <code>R</code> but as an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a> <a href="#BM_(reference)%2Fi">reference</a> (type returned by <code>std::move(*(std::ranges::begin(R))</code>)</li>
<li><code>std::ranges::range_value_t&lt;R&gt;</code> - type returned by <em><a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a></em> of range <code>R</code> but with the <a href="#BM_(reference)%2Fi">reference</a>, <code>const</code>, and <code>volatile</code> (e.g. if <code>std::ranges::range_reference_t&lt;R&gt;</code> is <code>const int&amp;</code>, <code>std::ranges::range_value_t&lt;R&gt;</code> is <code>int</code>)</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_range</span><span class="hljs-params">(std::ranges::range <span class="hljs-keyword">auto</span> &amp;&amp;range)</span> </span>{
    <span class="hljs-keyword">using</span> ELEM_REF = std::ranges::<span class="hljs-type">range_reference_t</span>&lt;<span class="hljs-keyword">decltype</span>(range)&gt;;
    <span class="hljs-keyword">for</span> (ELEM_REF v : range) {
        std::cout &lt;&lt; v &lt;&lt; std::endl;
    }
}
</code></pre>
<p>The following <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s detail the features supported by a range's <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> type. These <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> loosely map to the <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> for <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s.</p>
<ul>
<li><code>std::ranges::input_range</code> maps to <code>std::input_iterator</code></li>
<li><code>std::ranges::output_range</code> maps to <code>std::output_iterator</code></li>
<li><code>std::ranges::forward_range</code> maps to <code>std::forward_iterator</code></li>
<li><code>std::ranges::bidirectional_range</code> maps to <code>std::bidirectional_iterator</code></li>
<li><code>std::ranges::random_access_range</code> maps to <code>std::random_access_iterator</code></li>
<li><code>std::ranges::contiguous_range</code> maps to <code>std::contiguous_iterator</code></li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_range</span><span class="hljs-params">(std::ranges::random_access_range <span class="hljs-keyword">auto</span> &amp;&amp;range)</span> </span>{
    <span class="hljs-keyword">auto</span> it { std::ranges::<span class="hljs-built_in">begin</span>(range) };
    std::cout &lt;&lt; it[<span class="hljs-number">3</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; it[<span class="hljs-number">1</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; it[<span class="hljs-number">2</span>] &lt;&lt; std::endl;
}
</code></pre>
<a name="H_Owning%20Views"></a><h3>Owning Views</h3>
<p><a name="BM_(Library%20Functions%5C%2FRanges%2FOwning%20Views)_TOPIC%2F"></a><strong></strong></p>
<p>An owning view moves the range it's operating on into itself rather than <a href="#BM_(reference)%2Fi">reference</a> that range. Doing this avoids the problem of a view referencing a destroyed range, which usually happens when a function returns a view but the range that view is referencing goes out of scope.</p>
<pre class="hljs"><code><span class="hljs-comment">// This function is faulty because the returned view REFERENCES vec but</span>
<span class="hljs-comment">// vec gets destroyed when the function exits. The view references a</span>
<span class="hljs-comment">// destroyed object.</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">faulty_code</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; vec{ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
    <span class="hljs-keyword">return</span> vec
        | std::views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>; })
        | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i != <span class="hljs-number">0</span>; });
}
</code></pre>
<p>To create an owning view, use <code>std::move()</code> on the original range.</p>
<pre class="hljs"><code><span class="hljs-comment">// By using std::move() on the range, the view becomes an owning view.</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">good_code</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; vec{ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(vec)
        | std::views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>; })
        | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i != <span class="hljs-number">0</span>; });
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This started to be supported in version 12 of g++.</p>
</div>
<a name="H_Type-erasure"></a><h3>Type-erasure</h3>
<p><a name="BM_(Library%20Functions%5C%2FRanges%2FType-erasure)_TOPIC%2F"></a><strong></strong></p>
<p>A range's type depends on the type of the underlying container or generator (e.g. <code>std::ordered_set</code>), element type of the range (e.g. <code>int</code>), and the list of view manipulations applied to that range. Each change ends up changing the underlying type of the range.</p>
<pre class="hljs"><code>std::vector&lt;<span class="hljs-type">int</span>&gt; vec{ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };

<span class="hljs-comment">// THE CODE BELOW PRINTS "same!"</span>
<span class="hljs-comment">// ----------------------------</span>
<span class="hljs-comment">// decltype(v1) == decltype(v2) because both use the same underlying container type, element type,</span>
<span class="hljs-comment">// and have the exact same list of views applied WITH the exact same functor object.</span>
<span class="hljs-keyword">auto</span> functor { [](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>; } };
<span class="hljs-keyword">auto</span> v1 { vec | std::views::<span class="hljs-built_in">transform</span>(functor) };
<span class="hljs-keyword">auto</span> v2 { vec | std::views::<span class="hljs-built_in">transform</span>(functor) };
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v1), <span class="hljs-keyword">decltype</span>(v2)&gt;)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"same!"</span>;
} <span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; <span class="hljs-string">"NOT same!"</span>;
}

<span class="hljs-comment">// THE CODE BELOW PRINTS "NOT same!"</span>
<span class="hljs-comment">// ---------------------------------</span>
<span class="hljs-comment">// decltype(v1) != decltype(v2) because although the two types use the same underlying container</span>
<span class="hljs-comment">// type, element type, and have the exact same list of views applied, those views are DIFFERENT the</span>
<span class="hljs-comment">// functor classes each are unique -- they're technically two different classes, each with its own</span>
<span class="hljs-comment">//  unique type. Those unique types are included in the types of v3 and v4 somewhere in a depth of</span>
<span class="hljs-comment">//  template parameter chains.</span>
<span class="hljs-keyword">auto</span> v3 { vec | std::views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>; }) };
<span class="hljs-keyword">auto</span> v4 { vec | std::views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i) { <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>; }) };
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v3), <span class="hljs-keyword">decltype</span>(v4)&gt;)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"same!"</span>;
} <span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; <span class="hljs-string">"NOT same!"</span>;
}
</code></pre>
<p>The lack of type erasures sometimes causes problems when doing certain types of view manipulations. For example, combining together two ranges with the same element type (flattening) via <code>std::views::join</code> isn't possible unless the types of those ranges are exactly the same.</p>
<pre class="hljs"><code>std::ranges::empty_view&lt;<span class="hljs-type">int</span>&gt; y{};
std::ranges::single_view&lt;<span class="hljs-type">int</span>&gt; x{<span class="hljs-number">5</span>};
std::vector combined{ x , y };  <span class="hljs-comment">// x and y of different types, vector's template parameter can't be deduced</span>
<span class="hljs-keyword">auto</span> joined { std::ranges::<span class="hljs-built_in">join_view</span>(combined) };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : joined) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<p>To mitigate this, a third-party library called ranges-v3 provides <code>ranges::any_view&lt;T&gt;</code>. <code>ranges::any_view&lt;T&gt;</code> essentially "erases" the type of a range by wrapping it and unifying it to a specific type. The downside of this wrapping is that it has a performance impact as abstracting away the type information involves extra <a href="#BM_(runtime)%2Fi">runtime</a> code.</p>
<pre class="hljs"><code>std::ranges::empty_view&lt;<span class="hljs-type">int</span>&gt; y{};
std::ranges::single_view&lt;<span class="hljs-type">int</span>&gt; x{<span class="hljs-number">5</span>};
std::vector&lt;ranges::any_view&lt;<span class="hljs-type">int</span>&gt;&gt; combined{
    ranges::any_view&lt;<span class="hljs-type">int</span>&gt; { x },
    ranges::any_view&lt;<span class="hljs-type">int</span>&gt; { y }
};
<span class="hljs-keyword">auto</span> joined { std::ranges::<span class="hljs-built_in">join_view</span>(combined) };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : joined) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<p>One important thing about <code>ranges::any_view&lt;T&gt;</code> is that it takes an optional second <a href="#BM_(template%20parameter)%2Fi">template parameter</a> which defines the capabilities of the range its wrapping. By default, it's set to <code>category::input</code> which supports capabilities of an input range, but it also supports ...</p>
<ul>
<li><code>category::input</code> - satisfies <code>std::ranges::input_range</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a></li>
<li><code>category::forward</code> - satisfies <code>std::ranges::forward_range</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a></li>
<li><code>category::bidirectional</code> - satisfies <code>std::ranges::bidirectional_range</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a></li>
<li><code>category::random_access</code> - satisfies <code>std::ranges::random_access_range</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a></li>
<li><code>category::sized</code> - satisfies <code>std::ranges::sized_ranges</code> <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a></li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There's also <code>category::none</code> and <code>category::mask</code>, not exactly sure what these are for.</p>
</div>
<pre class="hljs"><code>std::ranges::empty_view&lt;<span class="hljs-type">int</span>&gt; y{};
std::ranges::single_view&lt;<span class="hljs-type">int</span>&gt; x{<span class="hljs-number">5</span>};
std::vector&lt;ranges::any_view&lt;<span class="hljs-type">int</span>, ranges::category::input&gt;&gt; combined{
    ranges::any_view&lt;<span class="hljs-type">int</span>, ranges::category::input&gt; { x },
    ranges::any_view&lt;<span class="hljs-type">int</span>, ranges::category::input&gt; { y }
};
<span class="hljs-keyword">auto</span> joined { std::ranges::<span class="hljs-built_in">join_view</span>(combined) };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : joined) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<p>Alternatively, in certain cases <code>std::span&lt;T&gt;</code> also abstracts away type information.</p>
<pre class="hljs"><code>std::ranges::empty_view&lt;<span class="hljs-type">int</span>&gt; y{};
std::ranges::single_view&lt;<span class="hljs-type">int</span>&gt; x{<span class="hljs-number">5</span>};
std::vector&lt;std::span&lt;<span class="hljs-type">int</span>&gt;&gt; combined{
    std::span&lt;<span class="hljs-type">int</span>&gt; { x },
    std::span&lt;<span class="hljs-type">int</span>&gt; { y }
};
<span class="hljs-keyword">auto</span> joined { std::ranges::<span class="hljs-built_in">join_view</span>(combined) };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : joined) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>C++20 / C++23 has nothing in the standard library for this except for <code>std::span&lt;T&gt;</code>, and AFAIK type erasure isn't what it was intended for. You should use ranges-v3. Future versions of C++ might provide something.</p>
</div>
<a name="H_Custom%20Views"></a><h3>Custom Views</h3>
<p><a name="BM_(Library%20Functions%5C%2FRanges%2FCustom%20Views)_TOPIC%2F"></a><strong></strong></p>
<p>To write a custom view, create a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that inherits from <code>std::ranges::view_interface</code> with a <code>begin()</code> function, and an <code>end()</code> function, and either a <a href="#BM_(default%20constructor)%2Fi">default constructor</a> (if generating values) and / or a <a href="#BM_(constructor)%2Fi">constructor</a> that takes in a range (if manipulating values).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FakeGeneratingView</span> : <span class="hljs-keyword">public</span> std::ranges::view_interface&lt;FakeGeneratingView&gt; {
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> &amp;(values[<span class="hljs-number">0</span>]); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> &amp;(values[<span class="hljs-number">3</span>]); }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span>[<span class="hljs-number">3</span>] values = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> };
};


<span class="hljs-comment">// USE THE VIEW</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : FakeGeneratingView{}) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The above example <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is feeding itself as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> to <code>std::ranges::view_interface</code>. This is a common C++ idiom referred to as the curiously recurring <a href="#BM_(template)%2Fi">template</a> pattern (CRTP) which allows for feeding the derived <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> back into a <a href="#BM_(template)%2Fi">template</a>d base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. Something to do with <a href="#BM_(compile-time)%2Fi">compile-time</a> polymorphism.</p>
</div>
<p>The following example is another custom view but this time it takes in an another range and manipulates its values and it supports the pipe operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span>&lt;std::ranges::input_range R&gt; 
    <span class="hljs-keyword">requires</span> std::ranges::view&lt;R&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AddFiveView</span> : <span class="hljs-keyword">public</span> std::ranges::view_interface&lt;AddFiveView&lt;R&gt;&gt; {
    <span class="hljs-built_in">AddFiveView</span>() = <span class="hljs-keyword">delete</span>;
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">AddFiveView</span><span class="hljs-params">(R&amp;&amp; r)</span>:
        i(std::forward&lt;R&gt;(r)),
        _begin(std::begin(i.range)),
        _end(std::end(i.range)) {</span>}
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> _begin; }
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> _end; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">F</span> : <span class="hljs-keyword">decltype</span>([](<span class="hljs-keyword">auto</span> x) { <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>; }) {};
    <span class="hljs-keyword">using</span> R_RES = std::ranges::transform_view&lt;R, F&gt;;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Internal</span> {
        <span class="hljs-built_in">Internal</span>(R&amp;&amp; r) : <span class="hljs-built_in">range</span>(std::forward&lt;R&gt;(r) | std::views::<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">F</span>())) {}
        R_RES range;
    };
    Internal i;  <span class="hljs-comment">// what do I put as the template arg???</span>
    std::ranges::<span class="hljs-type">iterator_t</span>&lt;R_RES&gt; _begin;
    std::ranges::<span class="hljs-type">iterator_t</span>&lt;R_RES&gt; _end; 
};


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AddFiveViewAdaptorClosure</span> {
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">AddFiveViewAdaptorClosure</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-keyword">template</span> &lt;std::ranges::viewable_range R&gt;
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(R&amp;&amp; r)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AddFiveView</span>&lt;R&gt;(std::forward&lt;R&gt;(r));
    }
} ;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AddFiveViewAdaptor</span> {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::ranges::viewable_range R&gt;
    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(R &amp;&amp; r)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AddFiveView</span>(std::forward&lt;R&gt;(r)) ;
    }

    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AddFiveViewAdaptorClosure</span>();
    }   
};

<span class="hljs-keyword">template</span> &lt;std::ranges::viewable_range R&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span> | (R&amp;&amp; r, AddFiveViewAdaptorClosure <span class="hljs-keyword">const</span> &amp; a) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">a</span>(std::forward&lt;R&gt;(r)) ;
}

<span class="hljs-keyword">namespace</span> CustomViews {
    AddFiveViewAdaptorClosure AddFiveView;
}



<span class="hljs-comment">// USE THE VIEW VIA THE PIPE OPERATOR</span>
<span class="hljs-comment">//   Note the use of std::views::all -- this is required for some reason (maybe it normalizes some missing pieces)</span>
std::vector&lt;<span class="hljs-type">int</span>&gt; v{<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v | std::views::all | CustomViews::AddFiveView) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<a name="H_Time"></a><h2>Time</h2>
<p><a name="BM_(Library%20Functions%5C%2FTime)_TOPIC%2F"></a><strong></strong></p>
<p>Similar to Java's <code>java.time</code> package, the C++ standard library offers several <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that represent various time-based constructs. This includes timestamps, durations, calendar representations, timezones, and various helper functions.</p>
<p>The subsections below document some common time-related <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and their usages.</p>
<a name="H_Timestamps"></a><h3>Timestamps</h3>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FTimestamps)_TOPIC%2F"></a><strong></strong></p>
<p>Time points are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that represent some point in type. They're typically created by clocks, which are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that measure time. Each clock has a set of specifics:</p>
<table>
<thead>
<tr>
<th>property</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Epoch</td>
<td>When does it start from? (e.g. since boot, app launch, Jan 1, 1970 00:00:00 UTC, etc..)</td>
</tr>
<tr>
<td>Tick Period</td>
<td>How often does it update? (e.g. once per millisecond)</td>
</tr>
<tr>
<td>Monotonicity</td>
<td>Could it go back in time? (e.g. time returned is before a previous time returned)</td>
</tr>
<tr>
<td>Leap Seconds</td>
<td>Does it include leap seconds?</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Monotonicity is important. In certain cases the clock could go back in time (e.g. inaccurate clocks are a thing, leap seconds, updates from NTP server, etc..).</p>
</div>
<a name="H_Clocks"></a><h4>Clocks</h4>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F"></a><strong></strong></p>
<p>There are multiple types of clock. Each type of clock has the following set of important type traits that you can use to obtain key details about it:</p>
<ul>
<li><code>T::period</code> - Reports tick period of the clock in seconds (<code>std::ratio</code>)</li>
<li><code>T::is_steady</code> - Reports monotonicity of the clock (<code>bool</code>).</li>
<li><code>T::now()</code> - Get the current time (<code>std::chrono::time_point</code>).</li>
</ul>
<pre class="hljs"><code>std::cout &lt;&lt; <span class="hljs-string">"Ticks per Second: "</span> &lt;&lt; std::chrono::system_clock::period::den &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="hljs-string">"Monotonic:        "</span> &lt;&lt; std::chrono::system_clock::is_steady &lt;&lt; std::endl;
std::chrono::time_point&lt;std::chrono::system_clock&gt; time { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<p>Note how the <code>std::chrono::time_point</code> type returned by the clock above is <a href="#BM_(template)%2Fi">template</a>d to the clock's type. The return type of a clock's <code>now()</code> typically won't be able to intermingle with one returned by another type of clock. To do that, you need to use <code>std::chrono::clock_cast&lt;SRC, DST&gt;()</code> first to convert it.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> sys_pt { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> utc_pt { <span class="hljs-built_in">clock_cast</span>&lt;std::chrono::system_clock, std::chrono::utc_clock&gt;(sys_pt) };
</code></pre>
<p>Common types of clock are listed below.</p>
<ul>
<li>
<p><code>std::chrono::system_clock</code></p>
<p>This clock is the system clock (e.g. wrist watch -- it tells you what time it is). Its epoch is whatever the epoch of the system's clock is (e.g. Jan 1, 1970 at midnight on most systems). Leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
</li>
<li>
<p><code>std::chrono::steady_clock</code></p>
<p>This clock is used to measure time intervals (e.g. stopwatch -- measure how long something takes). It's guaranteed to be monotonic, meaning each time you query it for the time it'll be greater than or equal to the result of your last query (e.g. <code>next_time &gt;= prev_time</code>). Epoch is unspecified and leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Would it make sense to include leap seconds here if this is a "stopwatch"? I don't think so, but nothing is mentioned about leap seconds when I look up the docs online.</p>
</div>
</li>
<li>
<p><code>std::chrono::high_resolution_clock</code></p>
<p>This clock is guaranteed to have the shortest possible tick period available (e.g. gaming, real-time systems, etc..). Its epoch and leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Would it make sense to include leap seconds here if this is supposed to be used for high-precision timing? I don't think so, but nothing is mentioned about leap seconds when I look up the docs online.</p>
</div>
</li>
<li>
<p><code>std::chrono::utc_clock</code> (Coordinated Universal Time)</p>
<p>This clock is guaranteed to have an epoch of Jan 1, 1970 at midnight UTC and includes leap seconds.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::utc_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> ls_info { <span class="hljs-built_in">get_leap_second_info</span>(now) };
std::cout &lt;&lt; ls_info.elapsed;       <span class="hljs-comment">// leap seconds elapsed since epoch until time_point</span>
std::cout &lt;&lt; ls_info.is_leap_second <span class="hljs-comment">// did time_point fall on a leap second?</span>
</code></pre>
</li>
<li>
<p><code>std::chrono::tai_clock</code> (International Atomic Time)</p>
<p>This clock is guaranteed to have an epoch of Dec 31, 1957 at 23:59:50 UTC and <em>does not</em> include leap seconds.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::tai_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I'm not sure what the point of this clock is? Is it slowing down time / speeding up time based on the rate of "real" time vs atomic time?</p>
</div>
</li>
<li>
<p><code>std::chrono::gps_clock</code> (Global Positioning System)</p>
<p>This clock is guaranteed to have an epoch of Jan 6, 1980 at midnight UTC and <em>does not</em> include leap seconds.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::gps_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I'm not sure what the point of this clock is? Is it slowing down time / speeding up time based on the rate of "real" time vs gps time? (e.g. GPS time is roughly ~38 microseconds faster per day)</p>
</div>
</li>
<li>
<p><code>std::chrono::file_clock</code></p>
<p>This clock is used for file times (alias for <code>std::filesystem::file_time_type::clock</code>).  Its epoch and leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::gps_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
</li>
</ul>
<p>Boost has a similar set of clocks: <code>boost::chrono::system_clock</code>, <code>boost::chrono::steady_clock</code>, <code>boost::chrono::high_resolution_clock</code>, <code>boost::chrono::process_cpu_clock</code>, etc... But, Boost clocks can't intermingle with clocks from the C++ standard library (e.g. <code>clock_cast()</code> won't work).</p>
<a name="H_Conversions"></a><h4>Conversions</h4>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FConversions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDate%20and%20Time)_TOPIC%2F">Library Functions/Time/Date and Time</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Timezone functionality doesn't seem to be implemented as of clang or GCC as of yet, meaning the code below that uses timezones fails to compile.</p>
</div>
<p>To convert a time point from the system clock to a date and time representation, use <code>std::chrono::floor()</code> to cut out the relevant durations before using them to create the date and time <a href="#BM_(object%7Cinstance)%2Fi">object</a>s...</p>
<pre class="hljs"><code><span class="hljs-comment">// SOURCE: https://stackoverflow.com/a/15958113</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;

<span class="hljs-keyword">auto</span> tp = system_clock::<span class="hljs-built_in">now</span>();
<span class="hljs-keyword">auto</span> tp_rounded = <span class="hljs-built_in">floor</span>&lt;days&gt;(tp);
year_month_day ymd { tp_rounded };
hh_mm_ss time { <span class="hljs-built_in">floor</span>&lt;milliseconds&gt;(tp - tp_rounded) };
</code></pre>
<p>The process is similar for converting a <em>zoned</em> time point (time point associated with a timezone) ..</p>
<pre class="hljs"><code><span class="hljs-comment">// SOURCE: https://stackoverflow.com/a/15958113</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;

<span class="hljs-keyword">auto</span> tp = zoned_time{<span class="hljs-built_in">current_zone</span>(), system_clock::<span class="hljs-built_in">now</span>()}.<span class="hljs-built_in">get_local_time</span>();
<span class="hljs-keyword">auto</span> tp_rounded = <span class="hljs-built_in">floor</span>&lt;days&gt;(tp_rounded);
year_month_day ymd {tp - tp_rounded};
hh_mm_ss time {<span class="hljs-built_in">floor</span>&lt;milliseconds&gt;(tp-dp)};
</code></pre>
<p>To go the other way around (date and time <a href="#BM_(object%7Cinstance)%2Fi">object</a>s to time point), use the <code>std::chrono::local_days</code> / <code>std::chrono::sys_days</code> aliases (they alias <code>std::chrono::time_point</code>).</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;

std::chrono::year_month_day date { January / <span class="hljs-number">27</span>d / <span class="hljs-number">2022</span>y };
std::chrono::hh_mm_ss time { <span class="hljs-number">8</span>h + <span class="hljs-number">30</span>m + <span class="hljs-number">45</span>s };

<span class="hljs-keyword">auto</span> tp = std::chrono::local_days { date } + time;  <span class="hljs-comment">// or use sys_days for system time</span>
</code></pre>
<a name="H_Durations"></a><h3>Durations</h3>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FUser-defined%20Literals)_TOPIC%2F">Core Language/Classes/User-defined Literals</a> (variants are similar to <a href="#BM_(union)%2Fi">union</a>s but type-safe)</li>
</ul>
</div>
<p>A duration is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that represents some amount of time.</p>
<pre class="hljs"><code><span class="hljs-comment">// use helper functions</span>
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">hours</span>(<span class="hljs-number">1</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">minutes</span>(<span class="hljs-number">60</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3600</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">3600000</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">3600000000</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">nanoseconds</span>(<span class="hljs-number">3600000000000</span>) };

<span class="hljs-comment">// use user-defined literals</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals; <span class="hljs-comment">// import the literals</span>
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">1</span>h };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">60</span>m };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600</span>s };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600000</span>ms };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600000000u</span>s };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600000000000</span>ns };
</code></pre>
<p>Subtracting two time points produces the duration in between them.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> before_tp { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> after_tp { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
std::chrono::duration d { after_tp - before_tp };
</code></pre>
<p>Similarly, adding a duration to a time point moves it accordingly.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> before_tp { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">hours</span>(<span class="hljs-number">1</span>) };
<span class="hljs-keyword">auto</span> after_tp { before_tp + hour };  <span class="hljs-comment">// move up by 1 hr</span>
</code></pre>
<p>A duration <a href="#BM_(object%7Cinstance)%2Fi">object</a> has a tick period. For example, <code>std::chrono::hours(1)</code> and <code>std::chrono::minutes(60)</code> both represent exactly 1 hour (equality operator (==) returns true), but the former has a tick period of 1 hour and the latter has a tick period if 1 minute. To get the number of ticks in a duration, use <code>count()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// NOTE if you're calling a method of a user-defined literal, you need a space before the dot</span>
<span class="hljs-keyword">auto</span> x {<span class="hljs-number">3600</span>s .<span class="hljs-built_in">count</span>()}; <span class="hljs-comment">// x will be 3600</span>
<span class="hljs-keyword">auto</span> y {<span class="hljs-number">1</span>h .<span class="hljs-built_in">count</span>()};    <span class="hljs-comment">// y will be 1</span>
<span class="hljs-keyword">auto</span> z {<span class="hljs-number">3600</span>s == <span class="hljs-number">1</span>h};    <span class="hljs-comment">// z will be true</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I've read online that you shouldn't use <code>count()</code> unless absolutely necessary because it breaks a lot of the abstraction / encapsulation that the library does.</p>
</div>
<p><code>std::chrono::duration_cast&lt;DST&gt;</code> may be used to convert one type of duration to another.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> x { std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(<span class="hljs-number">1</span>h) };
<span class="hljs-keyword">auto</span> y { std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(<span class="hljs-number">3600</span>s) };
<span class="hljs-keyword">auto</span> xTicks { x.<span class="hljs-built_in">count</span>() }; <span class="hljs-comment">// xTicks will be 3600</span>
<span class="hljs-keyword">auto</span> yTicks { y.<span class="hljs-built_in">count</span>() }; <span class="hljs-comment">// xTicks will be 1</span>
<span class="hljs-keyword">auto</span> z { std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(<span class="hljs-number">3599</span>s) };
<span class="hljs-keyword">auto</span> zTicks { z.<span class="hljs-built_in">count</span>() }; <span class="hljs-comment">// zTicks will be 0 (ROUNDS DOWN TO 0 -- not enough seconds for 1 hour)</span>
</code></pre>
<a name="H_Date%20and%20Time"></a><h3>Date and Time</h3>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FDate%20and%20Time)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F">Library Functions/Time/Durations</a></li>
</ul>
</div>
<p>Date and time functionality build on durations and time points by providing things like calendar representations, time of day representations (e.g. 12-hour vs 24-hour), timezone conversions, etc..</p>
<p>Calendar <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es represent some exact region (e.g. 5th, 1st, last, etc..) of a specific calendar granularity (day, month, year, weekday).</p>
<table>
<thead>
<tr>
<th></th>
<th>day</th>
<th>day of week</th>
<th>month</th>
<th>year</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::chrono::day</code></td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td>31</td>
</tr>
<tr>
<td><code>std::chrono::weekday</code></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>Tuesday</td>
</tr>
<tr>
<td><code>std::chrono::weekday_indexed</code></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>3rd Tuesday of unknown month</td>
</tr>
<tr>
<td><code>std::chrono::weekday_last</code></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>last weekday of unknown month</td>
</tr>
<tr>
<td><code>std::chrono::month</code></td>
<td></td>
<td></td>
<td>X</td>
<td></td>
<td>January</td>
</tr>
<tr>
<td><code>std::chrono::month_day</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
<td>December 25</td>
</tr>
<tr>
<td><code>std::chrono::month_day_last</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
<td>last day of January</td>
</tr>
<tr>
<td><code>std::chrono::month_weekday</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>3rd Tuesday of January</td>
</tr>
<tr>
<td><code>std::chrono::month_weekday_last</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>last weekday of January</td>
</tr>
<tr>
<td><code>std::chrono::year</code></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month</code></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>January 2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month_day</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>January 26, 2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month_day_last</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>last day of January 2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month_weekday</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>3rd Tuesday of January</td>
</tr>
<tr>
<td><code>std::chrono::year_month_weekday_last</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>last weekday of January 2022</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-comment">// create jan 27 2022 as year_month_day</span>
std::chrono::year y { <span class="hljs-number">2022</span> };
std::chrono::month m { <span class="hljs-number">1</span> };
std::chrono::day d { <span class="hljs-number">27</span> };
std::chrono::year_month_day today { y, m, d };
</code></pre>
<p>Adding or subtracting a duration to a calendar <a href="#BM_(object%7Cinstance)%2Fi">object</a> adjusts it accordingly.</p>
<pre class="hljs"><code>std::chrono::year_month_day today { y, m, d };

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;
today += <span class="hljs-number">5</span>d;  <span class="hljs-comment">// add 5 days to today</span>
</code></pre>
<p>If the calendar <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> captures a full date (e.g. <code>year_month_day</code>, <code>year_month_weekday</code>, etc..), it's convertible to a time point via <code>std::chrono::local_days</code> / <code>std::chrono::sys_days</code>.</p>
<pre class="hljs"><code>std::chrono::year y { <span class="hljs-number">2022</span> };
std::chrono::month m { <span class="hljs-number">1</span> };
std::chrono::day d { <span class="hljs-number">27</span> };
std::chrono::year_month_day today { y, m, d };

std::chrono::local_days today_tp { today };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Which should you use? I'm not sure of the difference. <code>std::chrono::sys_days</code> is shorthand for <code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::days&gt;</code>, which is the time point type for the system clock. <code>std::chrono::local_days</code> expands to the same thing but for the local clock. I'm not sure what local clock actually is. It wasn't listed as one of the clocks.</p>
</div>
<p>Similarly, a time point is convertible to a full date calendar <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> sys_tp { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> sys_tp_rounded { std::chrono::<span class="hljs-built_in">floor</span>&lt;std::chrono::days&gt;(sys_tp) };  <span class="hljs-comment">// round tp down to days</span>
std::chrono::year_month_day ymd{ sys_tp_rounded };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>What type is <code>sys_tp_rounded</code>? It's <code>std::chrono::sys_days</code>, which is shorthand for <code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::days&gt;</code>. The <code>std::chrono::year_month_day</code> <a href="#BM_(constructor)%2Fi">constructor</a> also accepts <code>std::chrono::local_days</code> -- I'm unsure which clock generates that (maybe utc clock?).</p>
</div>
<p>If two calendar <a href="#BM_(object%7Cinstance)%2Fi">object</a>s both capture a full date but are of different types, you can still compare them by first converting them to time points.</p>
<pre class="hljs"><code><span class="hljs-comment">// as year_month_day</span>
std::chrono::year y { <span class="hljs-number">2022</span> };
std::chrono::month m { <span class="hljs-number">1</span> };
std::chrono::day d { <span class="hljs-number">27</span> };
std::chrono::year_month_day today1 { y, m, d };
<span class="hljs-comment">// as year_month_weekday</span>
std::chrono::weekday thurs { <span class="hljs-number">4</span> };
std::chrono::weekday_indexed _4th_thurs { thurs, <span class="hljs-number">4</span> };
std::chrono::year_month_weekday today2 { y, m, _4th_thurs };
<span class="hljs-comment">// convert both to time point</span>
std::chrono::local_days today1_tp {today1};
std::chrono::local_days today2_tp {today2};
<span class="hljs-comment">// compare -- they both represent the same date so they should be equal</span>
<span class="hljs-keyword">auto</span> sameDay { today1_tp == today2_tp }; <span class="hljs-comment">// returns true</span>
</code></pre>
<p>Calendar <a href="#BM_(object%7Cinstance)%2Fi">object</a>s can be created more intuitively via a set of <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s, constants, and <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;

year_month_day today1 { January / <span class="hljs-number">27</span>d / <span class="hljs-number">2022</span>y };
year_month_weekday today2 { <span class="hljs-number">2022</span>y / January / Thursday[<span class="hljs-number">4</span>] };
year_month_weekday_last today3 { <span class="hljs-number">2022</span>y / January / Thursday[last] };
<span class="hljs-comment">// all 3 of the above represent the same date</span>
</code></pre>
<p>The <code>std::chrono::hh_mm_ss</code> <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a container for the time that's elapsed since midnight (also known as time of day).</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> tp { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> tp_rounded { std::chrono::<span class="hljs-built_in">floor</span>&lt;days&gt;(tp) };
std::chrono::year_month_day ymd{ tp_rounded };

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">time_duration</span> <span class="hljs-params">( std::chrono::floor&lt;milliseconds&gt;(tp - tp_rounded) )</span></span>;
std::chrono::hh_mm_ss time{ time_duration };
<span class="hljs-comment">// the variables below are of duration type</span>
<span class="hljs-keyword">auto</span> h { time.<span class="hljs-built_in">hours</span>() };
<span class="hljs-keyword">auto</span> m { time.<span class="hljs-built_in">minutes</span>() };
<span class="hljs-keyword">auto</span> s { time.<span class="hljs-built_in">seconds</span>() };
<span class="hljs-keyword">auto</span> ms { time.<span class="hljs-built_in">subseconds</span>() };
</code></pre>
<p>Several time-related helper functions are provided to deal with 12-hour vs 24-hour time.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> hour_of_day { time.<span class="hljs-built_in">hours</span>() }; <span class="hljs-comment">// using object from example above</span>

<span class="hljs-keyword">auto</span> am { std::chrono::<span class="hljs-built_in">is_am</span>(hour_of_day) };
<span class="hljs-keyword">auto</span> pm { std::chrono::<span class="hljs-built_in">is_pm</span>(hour_of_day) };

<span class="hljs-keyword">auto</span> hour_of_day_12 { std::chrono::<span class="hljs-built_in">make_12</span>(hour_of_day) };        <span class="hljs-comment">// as 12-hour format</span>
<span class="hljs-keyword">auto</span> hour_of_day_24 { std::chrono::<span class="hljs-built_in">make_12</span>(hour_of_day_12, pm) }; <span class="hljs-comment">// back to 24-hour format</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Timezone functionality doesn't seem to be implemented as of clang or GCC as of yet, meaning the code below fails to compile. It does seem to be implemented in MSVC though.</p>
</div>
<p>Timezones are accessible through a timezone database.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> my_tzdb = std::chrono::<span class="hljs-built_in">get_tzdb</span>(); <span class="hljs-comment">// also get_tzdb_list()</span>

<span class="hljs-keyword">const</span> std::chrono::time_zone* la_tz { my_tzdb.<span class="hljs-built_in">locate_zone</span>(<span class="hljs-string">"America/Los_Angeles"</span>) };
<span class="hljs-keyword">const</span> std::chrono::time_zone* local_tz { my_tzdb.<span class="hljs-built_in">current_zone</span>() };
</code></pre>
<p>You can apply a timezone to a time point, then convert it to the appropriate date and time <a href="#BM_(object%7Cinstance)%2Fi">object</a>s.</p>
<pre class="hljs"><code><span class="hljs-comment">// From https://stackoverflow.com/a/15958113</span>
<span class="hljs-keyword">auto</span> tp { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> ztp { std::chrono::zoned_time {local_tz, tp}.<span class="hljs-built_in">get_local_time</span>() };
<span class="hljs-keyword">auto</span> ztp_rounded { std::chrono::<span class="hljs-built_in">floor</span>&lt;days&gt;(ztp) };
std::chrono::year_month_day ymd { tp_rounded };
std::chrono::hh_mm_ss time { std::chrono::<span class="hljs-built_in">floor</span>&lt;milliseconds&gt;(ztp - ztp_rounded) };
</code></pre>
<p>Similarly, you can construct a zoned time point from date and time details.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;

std::chrono::year_month_day date { January / <span class="hljs-number">27</span>d / <span class="hljs-number">2022</span>y };
std::chrono::hh_mm_ss time { <span class="hljs-number">8</span>h + <span class="hljs-number">30</span>m + <span class="hljs-number">45</span>s };

<span class="hljs-keyword">auto</span> tp { std::chrono::local_days { date } + time };  <span class="hljs-comment">// or use sys_days for system time</span>
</code></pre>
<a name="H_Numbers"></a><h2>Numbers</h2>
<p><a name="BM_(Library%20Functions%5C%2FNumbers)_TOPIC%2F"></a><strong></strong></p>
<p>Both the C++ standard library and third-party libraries (e.g. Boost) provide several pieces of functionality that make working with numbers easier: Math constants and functions, random number generation, bounds-checked numeric type casting, etc..</p>
<p>The subsections below document some common number-related <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and their usages.</p>
<a name="H_Random%20Numbers"></a><h3>Random Numbers</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FRandom%20Numbers)_TOPIC%2F"></a><strong></strong></p>
<p>There are several options for random number generation. For ...</p>
<ul>
<li>non-cryptographic scenarios, use <code>std::mt19937_64</code>, an implementation of Mersenne Twister.</li>
<li>cryptographic scenarios, use <code>std::random_device</code>, which tries to use an unpredictable hardware source (but may not).</li>
</ul>
<p>The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, where each invocation generates a random integral.</p>
<pre class="hljs"><code>std::mt19937_64 mt_rand{ <span class="hljs-number">12345</span> };  <span class="hljs-comment">// seed value of 12345</span>
std::cout &lt;&lt; <span class="hljs-built_in">mt_rand</span>() &lt;&lt; std::endl;

std::random_device secure_rand {}; <span class="hljs-comment">// doesn't take a seed</span>
std::cout &lt;&lt; <span class="hljs-built_in">secure_rand</span>() &lt;&lt; std::endl;
</code></pre>
<p>To have a random number generator return a distribution other than a normal distribution, you can use one of the distribution wrappers.</p>
<pre class="hljs"><code>std::mt19937_64 rng{ <span class="hljs-number">12345</span> };
std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; uniform_dist{ <span class="hljs-number">0</span>, <span class="hljs-number">10</span> };
<span class="hljs-keyword">auto</span> value { <span class="hljs-built_in">uniform_dist</span>(rng) };
</code></pre>
<ul>
<li><code>std::uniform_int_distribution</code></li>
<li><code>std::uniform_real_distribution</code> (like the above but for floating point types)</li>
<li><code>std::normal_distribution</code> (a tweaked normal distribution)</li>
<li>etc..</li>
</ul>
<p>Boost provides a set of distributions as well.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Are there friendly wrappers here? What if I want the random number generator to give me a float, bool, or an alphanumeric string instead of an int?</p>
</div>
<a name="H_Numeric%20Type%20Information"></a><h3>Numeric Type Information</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FNumeric%20Type%20Information)_TOPIC%2F"></a><strong></strong></p>
<p>Recall that C++'s numeric types are wishy-washy (e.g. there is no guarantee as to how large an <code>int</code> is, just that it must be greater than or equal to <code>short</code>). The <code>std::numeric_limits</code> <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> allows you to get <a href="#BM_(compile-time)%2Fi">compile-time</a> information about a numeric type, such as signed-ness, min, max, etc..</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> a { std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::is_integer };      <span class="hljs-comment">// false</span>
<span class="hljs-keyword">auto</span> b { std::numeric_limits&lt;<span class="hljs-type">uint16_t</span>&gt;::is_integer };   <span class="hljs-comment">// true</span>
<span class="hljs-keyword">auto</span> c { std::numeric_limits&lt;<span class="hljs-type">uint16_t</span>&gt;::has_infinity }; <span class="hljs-comment">// false</span>
</code></pre>
<ul>
<li><code>std::numeric_limits&lt;T&gt;::is_signed</code> - if the type is signed</li>
<li><code>std::numeric_limits&lt;T&gt;::is_integer</code> - if the type is an integral</li>
<li><code>std::numeric_limits&lt;T&gt;::has_infinity</code> - if the type supports infinity (e.g. floats do)</li>
<li><code>std::numeric_limits&lt;T&gt;::has_quiet_NaN</code> - if the type can be set to not-a-number (e.g. IEEE floats can be set to not a number)</li>
<li><code>std::numeric_limits&lt;T&gt;::round_style</code> - rounding mode for a type</li>
<li><code>std::numeric_limits&lt;T&gt;::is_iec559</code> - if the type is an IEEE float.</li>
<li><code>std::numeric_limits&lt;T&gt;::lowest()</code> - maximum negative value.</li>
<li><code>std::numeric_limits&lt;T&gt;::max()</code> - maximum value.</li>
<li><code>std::numeric_limits&lt;T&gt;::min()</code> - smallest representable value (different from <code>::lowest()</code>).</li>
<li><code>std::numeric_limits&lt;T&gt;::quiet_NaN()</code> - get a not-a-numbe<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>.</li>
<li>etc..</li>
</ul>
<p>Boost's Integer library also provides additional functionality for determining information about numerics (e.g. which one is the fastest for the platform you're on).</p>
<a name="H_Numeric%20Type%20Casting"></a><h3>Numeric Type Casting</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FNumeric%20Type%20Casting)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li>(<a href="#BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion%2FNamed%20Conversions)_TOPIC%2F">Core Language/Variables/Explicit Conversion/Named Conversions</a> (refresher)</li>
</ul>
</div>
<p>Typically, the <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion function</a> <code>static_cast</code> is used for converting from one numeric type to another (e.g. <code>double</code> to <code>int</code>). In most cases, <code>static_cast</code> is fine to use, however  certain scenarios require a more customizable form of conversion (e.g. don't allow overflow). More customizable forms of numeric conversions are possible via the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <code>boost::numeric::converter</code>.</p>
<p>To use <code>boost::numeric::converter</code>, two <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are required:</p>
<ol>
<li><code>T</code> - (REQUIRED) output numeric type for the conversion.</li>
<li><code>S</code> - (REQUIRED) input numeric type for the conversion.</li>
</ol>
<p>Either use its <code>convert()</code> function or invoke the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> directly (it's a <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>) to perform a conversion.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { boost::numeric::converter&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">convert</span>(<span class="hljs-number">1.234</span>) };
<span class="hljs-type">int</span> y { boost::numeric::<span class="hljs-built_in">converter</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;(<span class="hljs-number">1.234</span>) };  <span class="hljs-comment">// same thing as above</span>
</code></pre>
<p>Several other optional <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s control how the numeric conversion happens. For example, what to do on overflow (e.g. throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>), how to round a float (e.g. round down), etc.. The most important thing to remember is that the default overflow configuration is to throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> -- either <code>boost::numeric::positive_overflow</code> or <code>boost::numeric::negative_overflow</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://www.boost.org/doc/libs/1_33_1/libs/numeric/conversion/doc/converter.html">here</a> for all <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
</div>
<p>If the default conversion options are desirable, then an analog to <code>static_cast</code> called <code>boost::numeric_cast</code> may be used instead of <code>boost::numeric::converter</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> z { boost::<span class="hljs-built_in">numeric_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1.234</span>) };  <span class="hljs-comment">// same thing as the examples above</span>
</code></pre>
<a name="H_Numeric%20String%20Conversion"></a><h3>Numeric String Conversion</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FNumeric%20String%20Conversion)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F">Library Functions/Strings/String</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FFormatter)_TOPIC%2F">Library Functions/Strings/Formatter</a></li>
</ul>
</div>
<p>The appropriate way to convert to string is <code>std::formatter</code>. For quick-and-dirty conversions of numeric <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">built-in type</a>s to <code>std::string</code> / <code>std::wstring</code>, use <code>std::to_string()</code> / <code>std::to_wstring()</code>. Other string types such as <code>std::u8string</code> aren't supported.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">10</span>) }; <span class="hljs-comment">// int</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">10U</span>) }; <span class="hljs-comment">// unsigned int </span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">10L</span>) }; <span class="hljs-comment">// long</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">10UL</span>) }; <span class="hljs-comment">// unsigned long</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">10LL</span>) }; <span class="hljs-comment">// long long</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">10ULL</span>) }; <span class="hljs-comment">// unsigned long long</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">1.0f</span>) }; <span class="hljs-comment">// float</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">1.0</span>) }; <span class="hljs-comment">// double</span>
<span class="hljs-keyword">auto</span> s { std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">1.0L</span>) }; <span class="hljs-comment">// long double</span>
</code></pre>
<p>For quick-and-dirty conversions of <code>std::string</code> / <code>std::wstring</code> to built-in numeric types, use any of the <code>std::sto*()</code> functions. For integer types, it also takes in a base (defaults to base 10).</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stoi</span>(my_string) }; <span class="hljs-comment">// int</span>
<span class="hljs-comment">// THERE IS NO sto*() FOR unsigned int -- use stoul() and cast to an unsigned int</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stol</span>(my_string) }; <span class="hljs-comment">// long</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stoul</span>(my_string) }; <span class="hljs-comment">// unsigned long</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stoll</span>(my_string) }; <span class="hljs-comment">// long long</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stoull</span>(my_string) }; <span class="hljs-comment">// unsigned long long</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stof</span>(my_string) }; <span class="hljs-comment">// float</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stod</span>(my_string) }; <span class="hljs-comment">// double</span>
<span class="hljs-keyword">auto</span> num { std::<span class="hljs-built_in">stold</span>(my_string) }; <span class="hljs-comment">// long double</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There is no equivalent or <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s for string specializations like <code>std::u8string</code>? How is someone supposed to convert those? The answer seems to be to use a third-party library (ICU might provide some functionality for this). It seems as if the C++20 standard still doesn't have full support for text encoding. Third-party libraries are required.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>sto*()</code> functions also take in a <a href="#BM_(pointer)%2Fi">pointer</a> as a parameter, when finished, will be set to the <a href="#BM_(pointer)%2Fi">pointer</a> of the input string's <code>c_str()</code> just after the number. By default this parameter is set to <code>std::nullptr</code>, which means don't set it.</p>
</div>
<a name="H_Math"></a><h3>Math</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FMath)_TOPIC%2F"></a><strong></strong></p>
<p>Several common math functions are provided directly within the C++ standard library.</p>
<table>
<thead>
<tr>
<th>function(s)</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::midpoint(a, b)</code></td>
<td>equivalent to <code>(a + (b-a)/2)</code>, which is the midpoint between two points</td>
</tr>
<tr>
<td><code>std::lerp(a, b, t)</code></td>
<td>equivalent to <code>(a + t*(b-a))</code>, which is the linear interpolation between two points</td>
</tr>
<tr>
<td><code>std::abs(x)</code></td>
<td>absolute value</td>
</tr>
<tr>
<td><code>std::min(x)</code></td>
<td>minimum/maximum of two values</td>
</tr>
<tr>
<td><code>std::max(x)</code></td>
<td>minimum/maximum of two values</td>
</tr>
<tr>
<td><code>std::isfinite(x)</code></td>
<td>check if finite / infinite (e.g. floating point infinite)</td>
</tr>
<tr>
<td><code>std::isinf(x)</code></td>
<td>check if finite / infinite (e.g. floating point infinite)</td>
</tr>
<tr>
<td><code>std::pow(x,y)</code></td>
<td>power of (x to the power of y)</td>
</tr>
<tr>
<td><code>std::sqrt(x)</code></td>
<td>square root</td>
</tr>
<tr>
<td><code>std::cbrt(x)</code></td>
<td>cube root</td>
</tr>
<tr>
<td><code>std::sin(x)</code></td>
<td>trigonometry functions</td>
</tr>
<tr>
<td><code>std::cos(x)</code></td>
<td>trigonometry functions</td>
</tr>
<tr>
<td><code>std::tan(x)</code></td>
<td>trigonometry functions</td>
</tr>
<tr>
<td><code>std::asin(x)</code></td>
<td>trigonometry functions</td>
</tr>
<tr>
<td><code>std::acos(x)</code></td>
<td>trigonometry functions</td>
</tr>
<tr>
<td><code>std::sinh(x)</code></td>
<td>hyperbolic functions</td>
</tr>
<tr>
<td><code>std::cosh(x)</code></td>
<td>hyperbolic functions</td>
</tr>
<tr>
<td><code>std::tanh(x)</code></td>
<td>hyperbolic functions</td>
</tr>
<tr>
<td><code>std::asinh(x)</code></td>
<td>hyperbolic functions</td>
</tr>
<tr>
<td><code>std::acosh(x)</code></td>
<td>hyperbolic functions</td>
</tr>
<tr>
<td><code>std::atanh(x)</code></td>
<td>hyperbolic functions</td>
</tr>
<tr>
<td><code>std::ceil(x)</code></td>
<td>rounding function</td>
</tr>
<tr>
<td><code>std::floor(x)</code></td>
<td>rounding function</td>
</tr>
<tr>
<td><code>std::round(x)</code></td>
<td>rounding function</td>
</tr>
<tr>
<td><code>std::div(x, y)</code></td>
<td>divides and gives both the quotient AND remainder</td>
</tr>
<tr>
<td><code>std::fmod(x, y)</code></td>
<td>modulo for floating point</td>
</tr>
<tr>
<td><code>std::remainder(x, y)</code></td>
<td>signed remainder of x div y (<a href="https://stackoverflow.com/a/13683709">different from modulo for non-positive values</a>)</td>
</tr>
<tr>
<td><code>std::log(x)</code></td>
<td>logarithm functions</td>
</tr>
<tr>
<td><code>std::log10(x)</code></td>
<td>logarithm functions</td>
</tr>
<tr>
<td><code>std::log2(x)</code></td>
<td>logarithm functions</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Built-in functions like <code>std::midpoint()</code> are preferred over rolling it by hand because they properly formulate things to work around integer overflow issues.</p>
</div>
<p>The C++ standard library also provides several math constants.</p>
<table>
<thead>
<tr>
<th>constant</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::numbers::pi</code></td>
<td>archimedes's constant</td>
</tr>
<tr>
<td><code>std::numbers::e</code></td>
<td>euler's constant</td>
</tr>
<tr>
<td><code>std::numbers::degree</code></td>
<td>number of radians per degree</td>
</tr>
<tr>
<td><code>std::numbers::radian</code></td>
<td>number of degrees per radian</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The functions / constants listed above the useful ones. There are more. There are constants in <code>boost::math::double_constants</code> as well.</p>
</div>
<p>By default, the type of these constants are <code>double</code>. However, they can be re-targeted to either <code>float</code>, <code>double</code>, or <code>long double</code> via their <a href="#BM_(template)%2Fi">template</a>d <code>*_v</code> variants (e.g. <code>std::numbers::pi&lt;long double&gt;</code>).</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::numbers::pi &lt;&lt; std::endl;
std::cout &lt;&lt; std::numbers::pi_v&lt;<span class="hljs-type">double</span>&gt; &lt;&lt; std::endl;
std::cout &lt;&lt; std::numbers::pi_v&lt;<span class="hljs-type">float</span>&gt; &lt;&lt; std::endl;
</code></pre>
<p>In addition, there's support for complex numbers via <code>std::complex</code>, which implements various common complex number operations via <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing and <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
<pre class="hljs"><code>std::complex&lt;<span class="hljs-type">double</span>&gt; a{<span class="hljs-number">1.0</span>, <span class="hljs-number">33.71</span>};
<span class="hljs-keyword">auto</span> aReal { std::<span class="hljs-built_in">real</span>(a) };      <span class="hljs-comment">// get real part</span>
<span class="hljs-keyword">auto</span> aImaginary { std::<span class="hljs-built_in">imag</span>(a)} ; <span class="hljs-comment">// get imaginary part</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This seems like such a niche thing that I don't think it's worth fleshing it out.</p>
</div>
<a name="H_Bit%20Manipulation"></a><h3>Bit Manipulation</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FBit%20Manipulation)_TOPIC%2F"></a><strong></strong></p>
<p>The C++ standard library provides several functions to aid with bit manipulation tasks.</p>
<p>To determine the endian-ness of the platform (e.g. x86 is little-endian while ARM is big-endian), use <code>std::endian</code>.</p>
<ul>
<li><code>std::endian::little</code> - constant for little-endian</li>
<li><code>std::endian::big</code> - constant for big-endian</li>
<li><code>std::endian::native</code> - the endian-ness of the current platform.</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::endian::native == std::endian::little)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"little"</span> &lt;&lt; std::endl;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::endian::native == std::endian::big) {
    std::cout &lt;&lt; <span class="hljs-string">"big"</span> &lt;&lt; std::endl;
} <span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; <span class="hljs-string">"mixed (some types are little while others are big)"</span> &lt;&lt; std::endl;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The book mentions that the <code>std::endian</code> system covers all possible edge cases, such as the case where some type are big-endian but others are little-endian (tested for in the example above). The other edge case it mentions is where all types are exactly 1 byte in size, in which case the platform has no endian-ness (<code>std::endian::little == std::endian::native == std::endian::big</code>).</p>
</div>
<p>The following bit-manipulation operations all require an unsigned integer type as input (e.g. <code>unsigned short</code>, <code>unsigned int</code>, etc..). The recommended way to cast to an unsigned integer is <code>std::bit_cast&lt;DST_TYPE&gt;(v)</code>, which is similar to a <code>reinterpret_cast</code> except it has certain benefits (e.g. can be used inside of <code>constexpr</code> / <code>consteval</code> / <code>constinit</code>).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The following uses left-most/right-most bit instead of most-significant/least-significant bit .</p>
</div>
<ul>
<li>
<p><code>std::has_single_bit(v)</code> - Check if <code>v</code> only a single bit is 1 (<code>v</code> is power of 2).</p>
<pre class="hljs"><code>std::cout &lt;&lt; (std::<span class="hljs-built_in">has_single_bit</span>(<span class="hljs-number">2u</span>) ? <span class="hljs-string">"yes"</span> : <span class="hljs-string">"no"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "yes"</span>
std::cout &lt;&lt; (std::<span class="hljs-built_in">has_single_bit</span>(<span class="hljs-number">3u</span>) ? <span class="hljs-string">"yes"</span> : <span class="hljs-string">"no"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "no"</span>
</code></pre>
</li>
<li>
<p><code>std::bit_floor(v)</code> - Return <code>v</code> with all bits set to 0 other than left-most 1. (get largest power of 2 that's &lt;= <code>v</code>).</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">bit_floor</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">bit_floor</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "4"</span>
</code></pre>
</li>
<li>
<p><code>std::bit_ceil(v)</code> - Return <code>v</code> if <code>std::has_single_bit(v) == true</code>, otherwise return <code>std::bit_floor(v &lt;&lt; 1)</code> (get smallest power of 2 that's &gt;= <code>v</code>).</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">bit_ceil</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "4"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">bit_ceil</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "4"</span>
</code></pre>
</li>
<li>
<p><code>std::bit_width(v)</code> - Return minimum number of bits needed to store <code>v</code> (calculate <code>1+log2(v)</code>).</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">bit_width</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">bit_width</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "3"</span>
</code></pre>
</li>
<li>
<p><code>std::rotl(v, s)</code> - Return <code>v</code> rotated left by <code>s</code>.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">rotl</span>(<span class="hljs-number">3u</span>, <span class="hljs-number">1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "6"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">rotl</span>(<span class="hljs-number">4u</span>, <span class="hljs-number">1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "8"</span>
</code></pre>
</li>
<li>
<p><code>std::rotr(v, s)</code> - Return <code>v</code> rotated right by <code>s</code>.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">rotr</span>(<span class="hljs-number">3u</span>, <span class="hljs-number">1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2147483649"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">rotr</span>(<span class="hljs-number">4u</span>, <span class="hljs-number">1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2"</span>
</code></pre>
</li>
<li>
<p><code>std::countl_zero(v)</code> - Count number of consecutive 0s from the left-most position.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">countl_zero</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "30"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">countl_zero</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "29"</span>
</code></pre>
</li>
<li>
<p><code>std::countl_one(v)</code> - Count number of consecutive 1s from the left-most position.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">countl_one</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "0"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">countl_one</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "0"</span>
</code></pre>
</li>
<li>
<p><code>std::countr_zero(v)</code> - Count number of consecutive 0s from the right-most position.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">countr_zero</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "0"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">countr_zero</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2"</span>
</code></pre>
</li>
<li>
<p><code>std::countr_one(v)</code> - Count number of consecutive 1s from the right-most position.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">countr_one</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">countr_one</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "0"</span>
</code></pre>
</li>
<li>
<p><code>std::popcount(v)</code> - Count the total number of 1s.</p>
<pre class="hljs"><code>std::cout &lt;&lt; std::<span class="hljs-built_in">popcount</span>(<span class="hljs-number">3u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "2"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">popcount</span>(<span class="hljs-number">4u</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// "1"</span>
</code></pre>
</li>
</ul>
<a name="H_Bitset"></a><h3>Bitset</h3>
<p><a name="BM_(Library%20Functions%5C%2FNumbers%2FBitset)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential%2FArray)_TOPIC%2F">Library Functions/Containers/Sequential/Array</a></li>
</ul>
</div>
<p><code>std::bitset</code> is a pseudo-container that wraps a fixed-size sequence of bits. It's similar to an <code>std::array&lt;bool, N&gt;</code> or <code>bool [N]</code>, but optimized for space and provides functions more appropriate for working with bits.</p>
<p>To create a <code>std::bitset</code> from an integral type, set the number of bits to capture as the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>. The <a href="#BM_(constructor)%2Fi">constructor</a> can optionally take in the integra<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> to initialize to (if not present, all sets initialized to 0).</p>
<pre class="hljs"><code>std::bitset&lt;4&gt; b1 {};  <span class="hljs-comment">// 4 bits, 0000</span>
std::bitset&lt;4&gt; b2 {<span class="hljs-number">0b1011</span>}; <span class="hljs-comment">// 4 bits, 1011</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FIntegral)_TOPIC%2F">Core Language/Variables/Core Types/Integral</a> (refresher on 0b prefix for integral literals specified as binary)</li>
</ul>
</div>
<p>To create a <code>std::bitset</code> that's potentially larger than the largest available integral type, pass in an <code>std::string</code> of ones and zeros. Alternatively, you can use a custom character for the both ones and zeros by passing those characters into the <a href="#BM_(constructor)%2Fi">constructor</a>.</p>
<pre class="hljs"><code>std::string str3 { <span class="hljs-string">"1011"</span> };
std::bitset&lt;4&gt; b3 { str3 };
std::string str4 { <span class="hljs-string">"TFTT"</span> };
std::bitset&lt;4&gt; b4 { str4, <span class="hljs-number">0</span>, str4.<span class="hljs-built_in">size</span>(), <span class="hljs-string">'T'</span>, <span class="hljs-string">'F'</span> };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>When working with <code>std::bitset</code>'s functions, bits are represented as a bool type. The value false is for 0 / true is for 1.</p>
</div>
<p><a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">Operator overload</a>s are available for all bitwise operators and their assignment operator equivalents.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> b5 { b1 &amp; b2 };  <span class="hljs-comment">//AND</span>
<span class="hljs-keyword">auto</span> b6 { b1 | b2 };  <span class="hljs-comment">// OR</span>
<span class="hljs-keyword">auto</span> b7 { b1 ^ b2 };  <span class="hljs-comment">// XOR</span>
<span class="hljs-keyword">auto</span> b8 { ~b1 }; <span class="hljs-comment">// NOT</span>
<span class="hljs-keyword">auto</span> b9 { b1 &lt;&lt; <span class="hljs-number">2</span> };  <span class="hljs-comment">// shift-left</span>
<span class="hljs-keyword">auto</span> b10 { b1 &gt;&gt; <span class="hljs-number">2</span> };  <span class="hljs-comment">// shift-right</span>
b1 &amp;= b2;
b1 |= b2;
b1 ^= b2;
b1 &lt;&lt;= <span class="hljs-number">2</span>;
b1 &gt;&gt;= <span class="hljs-number">2</span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>I'm assuming if you're going to be using bitwise operators, the <code>set::bitset</code>s must be of the same size.</p>
</div>
<p>To read an individual bit as a bool, use either the subscript operator ([]) or <code>test()</code>. The difference is that <code>test()</code> provides bounds checking.</p>
<pre class="hljs"><code><span class="hljs-type">bool</span> a = b1[<span class="hljs-number">1</span>];
<span class="hljs-type">bool</span> b = b1.<span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);
<span class="hljs-type">bool</span> c = b1.<span class="hljs-built_in">test</span>(<span class="hljs-number">999</span>);  <span class="hljs-comment">// throws std::out_of_range</span>
</code></pre>
<p>To replace an individual bit as a bool, use either the subscript operator ([]) or <code>set()</code>. The difference is that <code>set()</code> provides bounds checking.</p>
<pre class="hljs"><code>b1[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;
b1.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)
b1.<span class="hljs-built_in">set</span>(<span class="hljs-number">999</span>, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// throws std::out_of_range</span>
</code></pre>
<p>To set a single bit to 0, use <code>reset()</code>.</p>
<pre class="hljs"><code>b1.<span class="hljs-built_in">reset</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>To set all bits to 1, use <code>set()</code> without any arguments. Similarly, to set all bits to 0, use <code>reset()</code> without any arguments.</p>
<pre class="hljs"><code>b1.<span class="hljs-built_in">set</span>();  <span class="hljs-comment">// sets all bits to true</span>
b1.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// sets all bits to false</span>
</code></pre>
<p>To flip a single bit, use <code>flip()</code>. Don't specify an argument to flip all bits.</p>
<pre class="hljs"><code>b1.<span class="hljs-built_in">flip</span>(<span class="hljs-number">1</span>);
b1.<span class="hljs-built_in">flip</span>(); <span class="hljs-comment">// flips all bits</span>
</code></pre>
<p>To get the number of times 1 occurs in the sequence, use <code>count()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> d { b1.<span class="hljs-built_in">count</span>() };
</code></pre>
<p>To test the sequence if ...</p>
<ul>
<li>all bits are set to 1, use <code>all()</code>.</li>
<li>all bits are set to 0, use <code>none()</code>.</li>
<li>at least a single bit is set to 1, use <code>any()</code>.</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">bool</span> e { b1.<span class="hljs-built_in">all</span>() };
<span class="hljs-type">bool</span> f { b1.<span class="hljs-built_in">none</span>() };
<span class="hljs-type">bool</span> g { b1.<span class="hljs-built_in">any</span>() };
</code></pre>
<p>To get the size, use <code>size()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> len { b1.<span class="hljs-built_in">size</span>() };
</code></pre>
<a name="H_Safe%20Integer%20Comparison"></a><h3>Safe Integer Comparison</h3>
<p>Comparing signed and unsigned integral types may lead to unexpected results. This happens because the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> performs an implicit cast to get the two operands of the comparison to have matching types. In the example below, <code>neg &lt; pos</code> implicitly converts <code>neg</code> to <code>pos</code>'s type (<code>int</code> to <code>unsigned int</code>) so that the comparison operation can take place, meaning <code>neg</code>'s value of <code>-1</code> gets converted to <code>UINT_MAX</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> neg { <span class="hljs-number">-1</span> };
<span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span> pos { <span class="hljs-number">1</span> };
std::cout &lt;&lt; (neg &lt; pos ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// outputs "false"</span>
std::cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span>&gt;(neg) &lt;&lt; std::endl;  <span class="hljs-comment">// outputs "4294967295"</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Why does it change to <code>UINT_MAX</code>? Because of twos complement number system used by integers. Out of scope to describe in this document.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FIntegral)_TOPIC%2F">Core Language/Variables/Core Types/Integral</a> (refresher on <code>*_MIN</code>/<code>*_MAX</code> constants)</li>
</ul>
</div>
<p>To provide proper comparisons between signed and unsigned types, the C++ standard library provides several functions:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::cmp_equal</code></td>
<td><code>==</code></td>
</tr>
<tr>
<td><code>std::cmp_not_equal</code></td>
<td><code>!=</code></td>
</tr>
<tr>
<td><code>std::cmp_less</code></td>
<td><code>&lt;</code></td>
</tr>
<tr>
<td><code>std::cmp_less_equal</code></td>
<td><code>&lt;=</code></td>
</tr>
<tr>
<td><code>std::cmp_greater</code></td>
<td><code>&gt;</code></td>
</tr>
<tr>
<td><code>std::cmp_greater_equal</code></td>
<td><code>&gt;=</code></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-type">int</span> neg { <span class="hljs-number">-1</span> };
<span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span> pos { <span class="hljs-number">1</span> };
std::cout &lt;&lt; (neg &lt; pos ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;                <span class="hljs-comment">// outputs "false"</span>
std::cout &lt;&lt; (std::<span class="hljs-built_in">cmp_less</span>(neg, pos) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// outputs "true"</span>
</code></pre>
<a name="H_Strings"></a><h2>Strings</h2>
<p><a name="BM_(Library%20Functions%5C%2FStrings)_TOPIC%2F"></a><strong></strong></p>
<p>In addition to null-terminated character strings (e.g. <code>const char * = "hello world"</code>), the C++ standard library provides a higher-level character string abstractions. These higher-level abstractions provide more type safety, protect against common problems like buffer overflows, and generally make working with strings easier.</p>
<p>The subsections below document some common number-related <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and their usages.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>As of C++20, there is very little support for things like locale and character encodings. If you need need that type of functionality, check out the ICU library.</p>
</div>
<a name="H_String"></a><h3>String</h3>
<p><a name="BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential%2FVector)_TOPIC%2F">Library Functions/Containers/Sequential/Vector</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FCharacter%20String)_TOPIC%2F">Core Language/Variables/Core Types/Character String</a> (refresher on C-style character strings)</li>
</ul>
</div>
<p><code>std::basic_string</code> is used as a wrapper for representing character strings. It's different from null-terminated character strings in that strings are resizable and manipulatable similarly to how they are in other high-level languages (e.g. Java or Python). Unlike other high-level languages, a C++ string <em>is not immutable</em> (it's characters can change).</p>
<p>A <code>std::basic_string</code> supports all of the same functionality as a <code>std::vector</code> in addition to more. It takes 3 <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s:</p>
<ol>
<li><code>CharT</code> - type of character.</li>
<li><code>Traits</code> - type supporting a specific set of <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s and <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s for working with <code>CharT</code> (defaults to <code>std::char_traits&lt;CharT&gt;</code>).</li>
<li><code>Allocator</code> - type of custom allocator (defaults to <code>std::allocator&lt;CharT&gt;</code>).</li>
</ol>
<p>Several <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are provided out-of-the-box for <code>std::basic_string</code>, one for each character type. In almost all cases, you'll want to use these <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s rather than than using <code>std::basic_string</code>. The most common case for using <code>std::basic_string</code> directly is the need for a custom allocator, which isn't possible with <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s.</p>
<table>
<thead>
<tr>
<th><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a></th>
<th>character type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::string</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wstring</code></td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td><code>std::u8string</code></td>
<td><code>char8_t</code></td>
</tr>
<tr>
<td><code>std::u16string</code></td>
<td><code>char16_t</code></td>
</tr>
<tr>
<td><code>std::u32string</code></td>
<td><code>char32_t</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The text and examples below use <code>std::string</code>, but they should work for the other <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s as well. Make sure to use the correct literal for raw character string types (e.g. <code>u8"example"</code> for <code>char_8t</code>).</p>
</div>
<p>To create a <code>std::string</code> primed with a sequence of characters known as <a href="#BM_(compile-time)%2Fi">compile-time</a>, use typical <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<pre class="hljs"><code>std::string s1 { <span class="hljs-string">'h'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span> };
</code></pre>
<p>To create a <code>std::string</code> without priming it directly to a sequence of characters, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code><span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>; <span class="hljs-comment">// create from null-terminated string</span>
<span class="hljs-function">std::string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// create from first 2 chars of null-terminated string</span>
<span class="hljs-function">std::string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>)</span></span>; <span class="hljs-comment">// create by repeating a 10 times</span>
<span class="hljs-function">std::string <span class="hljs-title">s5</span><span class="hljs-params">(s1)</span></span>;  <span class="hljs-comment">// create by copying s1</span>
<span class="hljs-function">std::string <span class="hljs-title">s6</span><span class="hljs-params">(s1, <span class="hljs-number">3</span>)</span></span>;  <span class="hljs-comment">// create by copying substring of s1 from index 3 until end</span>
<span class="hljs-function">std::string <span class="hljs-title">s7</span><span class="hljs-params">(s1, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// create by copying 2 char long substring of s1 starting at index 3</span>
<span class="hljs-function">std::string <span class="hljs-title">s8</span><span class="hljs-params">(s1.begin() + <span class="hljs-number">3</span>, s1.begin() + <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// create by copying substring of s1 from index 3 to 5</span>
<span class="hljs-function">std::string <span class="hljs-title">s9</span><span class="hljs-params">(std::move(s1))</span></span>; <span class="hljs-comment">// create by moving s1 into s5</span>
</code></pre>
<p>To append to a string, use either the addition operator (+) the assignment addition operator (+=), <code>push_back()</code>, or <code>append()</code>.</p>
<pre class="hljs"><code>std::string s10 { s1 + s2 };
std::string s11 { s1 + <span class="hljs-string">"boop"</span> };
std::string s12 { s1 };
s12 += s2;
s12.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">'x'</span>);  <span class="hljs-comment">// single character only</span>
s12.<span class="hljs-built_in">append</span>({ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> }); <span class="hljs-comment">// append compile-time list</span>
s12.<span class="hljs-built_in">append</span>(<span class="hljs-string">"xyz"</span>); <span class="hljs-comment">// append null-terminated string</span>
s12.<span class="hljs-built_in">append</span>(s1); <span class="hljs-comment">// append s1</span>
s12.<span class="hljs-built_in">append</span>(s1, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// append 2 char substring of s1 starting at index 3</span>
s12.<span class="hljs-built_in">append</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>);  <span class="hljs-comment">// append substring of s1 from index 3 to 5</span>
s12.<span class="hljs-built_in">append</span>(<span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>); <span class="hljs-comment">// append a 10 times</span>
</code></pre>
<p>To insert at a specific position of a string, use <code>insert()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'X'</span>); <span class="hljs-comment">// insert X 5 times at index 3</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"xyz"</span>); <span class="hljs-comment">// insert "xyz" at index 3</span>
s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>, s2); <span class="hljs-comment">// insert s2 at index 3</span>
s1.<span class="hljs-built_in">insert</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'X'</span>); <span class="hljs-comment">// insert X 5 times at iterator position</span>
s1.<span class="hljs-built_in">insert</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, <span class="hljs-string">"xyz"</span>); <span class="hljs-comment">// insert "xyz" at iterator position</span>
s1.<span class="hljs-built_in">insert</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, s2); <span class="hljs-comment">// insert s2 at iterator position</span>
</code></pre>
<p>To see if a string has a specific prefix or suffix with a string, use <code>starts_with()</code> and <code>ends_with()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">starts_with</span>(<span class="hljs-string">'h'</span>);
s1.<span class="hljs-built_in">starts_with</span>(<span class="hljs-string">"he"</span>);
s1.<span class="hljs-built_in">ends_with</span>(s2);
</code></pre>
<p>To see if a string contains a specific substring, use <code>contains()</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> found { s1.<span class="hljs-built_in">contains</span>(<span class="hljs-string">"ell"</span>) };
<span class="hljs-keyword">auto</span> found { s1.<span class="hljs-built_in">contains</span>(s2) };
</code></pre>
<p>To find the position of a substring within a string, use <code>find()</code> or <code>rfind()</code>. The latter finds in reverse (from end to beginning). If the substring wasn't found, <code>std::string::npos</code> is returned.</p>
<pre class="hljs"><code><span class="hljs-comment">// find</span>
<span class="hljs-keyword">auto</span> pos1 { s1.<span class="hljs-built_in">find</span>(<span class="hljs-string">"llo"</span>) };  <span class="hljs-comment">// find index within s1 going FORWARD from index 0, or npos if not found</span>
<span class="hljs-keyword">auto</span> pos2 { s1.<span class="hljs-built_in">find</span>(<span class="hljs-string">"llo"</span>, <span class="hljs-number">2</span>) };  <span class="hljs-comment">// find index within s1 going FORWARD from index 2, or npos if not found</span>
<span class="hljs-keyword">auto</span> pos3 { s1.<span class="hljs-built_in">find</span>(<span class="hljs-string">'l'</span>, <span class="hljs-number">2</span>) };  <span class="hljs-comment">// find index within s1 going FORWARD from index 2, or npos if not found</span>
<span class="hljs-comment">// rfind</span>
<span class="hljs-keyword">auto</span> pos4 { s1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">"llo"</span>) };  <span class="hljs-comment">// find index within s1 going BACKWARD from last index, or npos if not found</span>
<span class="hljs-keyword">auto</span> pos5 { s1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">"llo"</span>, <span class="hljs-number">5</span>) };  <span class="hljs-comment">// find index within s1 going BACKWARD from index 5, or npos if not found</span>
<span class="hljs-keyword">auto</span> pos6 { s1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">'l'</span>, <span class="hljs-number">5</span>) };  <span class="hljs-comment">// find index within s1 going BACKWARD from index 5, or npos if not found</span>
</code></pre>
<p>To get a substring of a string, use <code>substr()</code>.</p>
<pre class="hljs"><code>std::string s13 { s1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>) }; <span class="hljs-comment">// create by copying 2 char long substring of s1 starting at index 3</span>
<span class="hljs-function">std::string <span class="hljs-title">s14</span><span class="hljs-params">(s1, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// equivalent to the substr() above</span>
</code></pre>
<p>To delete a specific position or range of a string, use either <code>pop_back()</code>, <code>clear()</code>, or <code>erase()</code>.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// remove element from end</span>
s1.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// reset to empty string</span>
s1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// remove 3 characters starting from index 1</span>
s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>); <span class="hljs-comment">// remove characters at index 1 to 5</span>
s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>); <span class="hljs-comment">// remove character at index 1</span>
</code></pre>
<p>To replace a part of the string, use <code>replace()</code>, which takes in some position / range and another string to replace it with.</p>
<pre class="hljs"><code>s1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"hello"</span>); <span class="hljs-comment">// replace 2 char substring of s1 starting at index 3 with hello</span>
s1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// replace 2 char substring of s1 starting at index 3 with 2 char substring at index 3 of "hello"</span>
s1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>); <span class="hljs-comment">// replace 2 char substring of s1 starting at index 3 with a 10 times</span>
s1.<span class="hljs-built_in">replace</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, <span class="hljs-string">"hello"</span>); <span class="hljs-comment">// replace characters at index 1 to 5 with hello</span>
s1.<span class="hljs-built_in">replace</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, {<span class="hljs-string">'h'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>}); <span class="hljs-comment">// replace characters at index 1 to 5 with hello</span>
s1.<span class="hljs-built_in">replace</span>(s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, s1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>); <span class="hljs-comment">// replace characters at index 1 to 5 with a 10 times</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Need more elaborate string algorithms? Check out Boost's string functions.</p>
</div>
<p>To get the number of characters in a <code>std::string</code>, use either <code>size()</code>, <code>length()</code>, or <code>empty()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">bool</span> empty { s1.<span class="hljs-built_in">empty</span>() }; <span class="hljs-comment">// check if empty</span>
<span class="hljs-keyword">auto</span> len { s1.<span class="hljs-built_in">size</span>() };
<span class="hljs-keyword">auto</span> len { s1.<span class="hljs-built_in">length</span>() }; <span class="hljs-comment">// equivalent to size()</span>
</code></pre>
<p>To test if two strings have the exact same sequence of characters, use the equality operator (==) and inequality operator (!=).</p>
<pre class="hljs"><code><span class="hljs-type">bool</span> equal { s1 == s2 };
<span class="hljs-type">bool</span> not_equal { s1 != s2 };
</code></pre>
<p>To test if a string is lexicographically less than the other, use the greater than operator (&gt;) or less than operators (&lt;).</p>
<pre class="hljs"><code><span class="hljs-type">bool</span> less_than { s1 &lt; s2 };
<span class="hljs-type">bool</span> greater_than { s1 &gt; s2 };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Don't depend on this to sort alphabetically because it isn't portable. Lexicographically doesn't mean alphabetical, it just means that it compares by the symbol (character in this case). The comparisons depend on the encoding of the string. According to the book, for US-ASCII (most common), it means <code>A &lt; Z &lt; a &lt; z</code>.</p>
</div>
<p>To access individual characters within a <code>std::string</code>, use either the subscript operator ([]), <code>at()</code>, <code>front()</code>, and <code>back()</code>. The behaviour of these functions is similar to their <code>std::vector</code> equivalents.</p>
<pre class="hljs"><code><span class="hljs-comment">// WARNING: first() and last() have undefined behaviour if size is 0.</span>
<span class="hljs-type">char</span> first_char { s1.<span class="hljs-built_in">first</span>(); }
<span class="hljs-type">char</span> last_char { s1.<span class="hljs-built_in">last</span>(); }

<span class="hljs-comment">// WARNING: at() does bounds checking while the subscript operator does not.</span>
<span class="hljs-type">char</span> x { s1.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) };
<span class="hljs-type">char</span> w { s1[<span class="hljs-number">2</span>] };
<span class="hljs-type">char</span> y { s1.<span class="hljs-built_in">at</span>(<span class="hljs-number">1000</span>) }; <span class="hljs-comment">// throws std::out_of_range</span>
<span class="hljs-type">char</span> z { s1[<span class="hljs-number">1000</span>] };    <span class="hljs-comment">// out of bounds -- undefined behaviour</span>
</code></pre>
<p>To access individual characters within <code>std::string</code> via a <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a>, use the typical <code>begin()</code> and <code>end()</code> functions (and their variants).</p>
<ul>
<li><code>begin()</code> / <code>end()</code></li>
<li><code>cbegin()</code> / <code>cend()</code> - returns characters as <code>const</code></li>
<li><code>rbegin()</code> / <code>rend()</code> - returns characters in reverse</li>
<li><code>crbegin()</code> / <code>crend()</code> - returns characters in reverse and as <code>const</code></li>
</ul>
<p>To access the underlying character data of a <code>std::string</code>, use either <code>data()</code> or <code>c_str()</code>. Both return a null-terminated string, but the latter is <code>const</code>.</p>
<pre class="hljs"><code><span class="hljs-type">char</span> * data1 { s1.<span class="hljs-built_in">data</span>() };
<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * data2 { s1.<span class="hljs-built_in">c_str</span>() };
</code></pre>
<a name="H_String%20View"></a><h3>String View</h3>
<p><a name="BM_(Library%20Functions%5C%2FStrings%2FString%20View)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F">Library Functions/Strings/String</a></li>
</ul>
</div>
<p><code>std::basic_string_view</code> is a wrapper around a <code>std::basic_string</code> that represents some range of characters within the string. Similar to <code>std::basic_string</code>, <code>std::basic_string_view</code> has several out-of-the-box <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s for each character type.</p>
<table>
<thead>
<tr>
<th><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a></th>
<th>character type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::string_view</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wstring_view</code></td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td><code>std::u8string_view</code></td>
<td><code>char8_t</code></td>
</tr>
<tr>
<td><code>std::u16string_view</code></td>
<td><code>char16_t</code></td>
</tr>
<tr>
<td><code>std::u32string_view</code></td>
<td><code>char32_t</code></td>
</tr>
</tbody>
</table>
<p><code>std::basic_string_view</code> works by holding on to the underlying string as a <a href="#BM_(pointer)%2Fi">pointer</a>, meaning that it's efficient but unsafe. Specifically, it has the <em>potential for a memory leak</em>: If the underlying string gets destroyed, the view pointing to it will be pointing at bad data.</p>
<p><code>std::basic_string_view</code> (and its specializations) support most of the same functions as <code>std::basic_string</code> (and its specializations).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The text and examples below use <code>std::string_view</code>, but they should work for the other <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s as well.</p>
</div>
<pre class="hljs"><code>std::string_view sv1 { s1, <span class="hljs-number">4</span> };  <span class="hljs-comment">// view of first 4 characters of s1</span>
std::string_view sv2 { s1 };  <span class="hljs-comment">// view of s1</span>
std::string_view sv3 {};  <span class="hljs-comment">// view of an empty string</span>
std::string_view sv4 { <span class="hljs-string">"hello"</span> };  <span class="hljs-comment">// view of the constant C-string hello</span>
</code></pre>
<a name="H_Formatter"></a><h3>Formatter</h3>
<p><a name="BM_(Library%20Functions%5C%2FStrings%2FFormatter)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F">Library Functions/Strings/String</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString%20View)_TOPIC%2F">Library Functions/Strings/String View</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FTime)_TOPIC%2F">Library Functions/Time</a> (briefly mentioned below)</li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This is from a C++ library called fmt which formats strings (similar to Python format strings). It's been included into the C++ standard library as of C++20, which is the version this section <a href="#BM_(reference)%2Fi">reference</a>s.</p>
</div>
<p><code>std::format</code> is a string formatting <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that provides functionality very similar to Python's string formatting. Unlike older formatting systems like <code>sprintf()</code>, it's ...</p>
<ul>
<li>type-safe in that doesn't require you to know the type of <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s beforehand.</li>
<li>safe in that it avoids buffer overflows by using C++ strings (<code>std::string</code>) rather than null-terminated character strings (<code>char *</code>).</li>
<li><a href="#BM_(extends%3F%7Csubclass)%2Fi">extend</a>able in that it's easy to support custom types for the formatter.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Much of this functionality is also available in C++ IO streams, but this is vastly simpler to use.</p>
</div>
<pre class="hljs"><code>std::format(<span class="hljs-string">"Hello {}, it's {} degrees outside."</span>, <span class="hljs-string">"steven"</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// Hello steven, it's 42 degrees outside</span>
std::format(<span class="hljs-string">"Here's a number: {0}. Here's that same number again: {0}."</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// Here's a number: 42. Here's that same number again: 42.</span>
std::format(<span class="hljs-string">"{0:x&gt;10} {0:x&lt;10}"</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// xxxxxxxx42 42xxxxxxxx</span>
</code></pre>
<p>The formatting of a parameter is controlled by what's inside of the curly brackets for that parameter. At a minimum, it's is empty (e.g. 1st example above). If it should target a specific argument, it needs to take in the index of that parameter (e.g. 2nd example above). Then, any output options for a specific parameter are specified by inserting a colon followed by those options (e.g. 3rd example above).</p>
<p>Examples of the most common formatting options are provided below.</p>
<ul>
<li>
<p>Padding and alignment</p>
<pre class="hljs"><code>std::format(<span class="hljs-string">"{:10}"</span>, <span class="hljs-number">42</span>);   <span class="hljs-comment">// "        42"</span>
std::format(<span class="hljs-string">"{:&lt;10}"</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// "42        "</span>
std::format(<span class="hljs-string">"{:&gt;10}"</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// "        42"</span>
std::format(<span class="hljs-string">"{:^10}"</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// "    42    "</span>
std::format(<span class="hljs-string">"{:x^10}"</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// "xxxx42xxxx"</span>
</code></pre>
</li>
<li>
<p>Number signs (e.g. should plus sign be put on a positive integer)</p>
<pre class="hljs"><code>std::format(<span class="hljs-string">"{0:},{0:+},{0:-},{0: }"</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// "1,+1,1, 1"</span>
std::format(<span class="hljs-string">"{0:},{0:+},{0:-},{0: }"</span>, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// "-1,-1,-1,-1"</span>
</code></pre>
</li>
<li>
<p>Number precision (e.g. where to truncate floating point)</p>
<pre class="hljs"><code>std::format(<span class="hljs-string">"{:.5f}"</span>, <span class="hljs-number">3.14</span>);      <span class="hljs-comment">// "3.14000"</span>
std::format(<span class="hljs-string">"{:0&gt;10.5f}"</span>, <span class="hljs-number">3.14</span>);  <span class="hljs-comment">// "0003.14000"</span>
</code></pre>
</li>
<li>
<p>Numeric encoding (e.g. decimal, hex, octal)</p>
<pre class="hljs"><code>std::format(<span class="hljs-string">"{:d}"</span>, <span class="hljs-number">10</span>);     <span class="hljs-comment">// "10"</span>
std::format(<span class="hljs-string">"{:x}"</span>, <span class="hljs-number">10</span>);     <span class="hljs-comment">// "a"</span>
std::format(<span class="hljs-string">"{:#x}"</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">// "0xa"</span>
std::format(<span class="hljs-string">"{:#X}"</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">// "0xA"</span>
std::format(<span class="hljs-string">"{:#04X}"</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// "0x0A"</span>
std::format(<span class="hljs-string">"{:o}"</span>, <span class="hljs-number">10</span>);     <span class="hljs-comment">// "12"</span>
std::format(<span class="hljs-string">"{:#o}"</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">// "012"</span>
std::format(<span class="hljs-string">"{:b}"</span>, <span class="hljs-number">10</span>);     <span class="hljs-comment">// "1010"</span>
std::format(<span class="hljs-string">"{:#b}"</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">// "0b1010"</span>
</code></pre>
</li>
</ul>
<p><code>std::format</code> provides support for many common parameter types: numbers (e.g. integral and floating point), <a href="#BM_(pointer)%2Fi">pointer</a>s, single characters, character strings (e.g. null-terminated strings, C++ strings, and C++ string views), dates, times, durations, timezones, etc.. To add support for a new type, that type needs a <code>std:formatter</code> <a href="#BM_(template%20specialization)%2Fi">template specialization</a> (note the "er" at the end -- formatter, not format).</p>
<p>The simplest approach to implement a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> for a custom type is to inherit from an existing <a href="#BM_(template%20specialization)%2Fi">template specialization</a>. Formatting options are typically ignored in this case.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::formatter&lt;Person&gt; : std::formatter&lt;std::string&gt; {
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">format</span><span class="hljs-params">(Person s, format_context&amp; ctx)</span> </span>{
        <span class="hljs-keyword">return</span> format_to(ctx.<span class="hljs-built_in">out</span>(), <span class="hljs-string">"{} {}"</span>, s.firstName, s.lastName);
    }
};

Person p { <span class="hljs-string">"steve"</span>, <span class="hljs-string">"smith"</span> };
std::format(<span class="hljs-string">"Hello {}, the temperature today is {}!"</span>, p, <span class="hljs-number">42</span>);
</code></pre>
<p>To support formatting options, an extra function needs to be implemented (<code>parse()</code>) which sets <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s based on the options it sees.</p>
<pre class="hljs"><code><span class="hljs-comment">// For a better example, see https://www.modernescpp.com/index.php/extend-std-format-in-c-20-for-user-defined-types</span>
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::formatter&lt;Person&gt; {
    <span class="hljs-type">int</span> space_count;

    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">parse</span><span class="hljs-params">(format_parse_context&amp; ctx)</span> </span>{
        std::string val {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it { <span class="hljs-built_in">begin</span>(ctx) }; it != <span class="hljs-built_in">end</span>(ctx); ++it) {
            <span class="hljs-type">char</span> c { *it };
            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'}'</span>) {
                space_count = std::<span class="hljs-built_in">stoi</span>(val);
                <span class="hljs-keyword">return</span> it;
            } <span class="hljs-keyword">else</span> {
                val += c;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">end</span>(ctx);
    }

    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">format</span><span class="hljs-params">(Person s, format_context&amp; ctx)</span> </span>{
        <span class="hljs-function">std::string <span class="hljs-title">spacer</span><span class="hljs-params">(space_count, <span class="hljs-string">' '</span>)</span></span>;
        <span class="hljs-keyword">return</span> format_to(ctx.<span class="hljs-built_in">out</span>(), <span class="hljs-string">"{}{}{}"</span>, s.firstName, spacer, s.lastName);
    }
};

Person p { <span class="hljs-string">"steve"</span>, <span class="hljs-string">"smith"</span> };
std::format(<span class="hljs-string">"Hello {:1}, the temperature today is {}!"</span>, p, <span class="hljs-number">42</span>);
</code></pre>
<a name="H_Regular%20Expressions"></a><h3>Regular Expressions</h3>
<p><a name="BM_(Library%20Functions%5C%2FStrings%2FRegular%20Expressions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F">Library Functions/Strings/String</a></li>
</ul>
</div>
<p><code>std::basic_regex</code> is a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> for regular expression functionality. Similar to <code>std::basic_string</code>, <code>std::basic_regex</code> has several out-of-the-box <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s for specific character types (not all character types).</p>
<table>
<thead>
<tr>
<th><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a></th>
<th>character type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::regex</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wregex</code></td>
<td><code>wchar_t</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>What about other character types (e.g. <code>char8_t</code>)? Not supported because encoding support in C++ is not really there as of C++20. So what encoding is used here? Platform-specific maybe? or ASCII? It's probably stated somewhere but I have yet to find out what it is. On most major platforms, it's probably safe to assume that basic printable ASCII characters are there encoded as they would be in ASCII.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The text and examples below use <code>std::regex</code>, but they should work for the other <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s as well.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FCharacter%20String)_TOPIC%2F">Core Language/Variables/Core Types/Character String</a> (refresher on raw string literals)</li>
</ul>
</div>
<p>To create a <code>std::regex</code>, prime it with a specific regex pattern and optionally regex flags. Unless the pattern string is presented as an initializer list argument, you can't use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>. You must use parenthesis.</p>
<pre class="hljs"><code>std::regex pattern1 { <span class="hljs-string">'\\'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'+'</span> };  <span class="hljs-comment">// initializer list of pattern.</span>
<span class="hljs-function">std::regex <span class="hljs-title">pattern2</span><span class="hljs-params">(R<span class="hljs-string">"|\d+|"</span>)</span></span>;
<span class="hljs-function">std::regex <span class="hljs-title">pattern3</span><span class="hljs-params">(R<span class="hljs-string">"|\d+|"</span>, std::regex_constants::ECMAScript)</span></span>;  <span class="hljs-comment">// equivalent to above</span>
<span class="hljs-function">std::regex <span class="hljs-title">pattern4</span><span class="hljs-params">(R<span class="hljs-string">"|\d+|"</span>, std::regex_constants::ECMAScript | std::regex_constants::icase)</span></span>;
</code></pre>
<p>To get the regex flags, use <code>flags()</code>. To get the number of groups (sub-expressions), use <code>mark_count()</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> flags { pattern1.<span class="hljs-built_in">flags</span>() };
<span class="hljs-keyword">auto</span> group_count { pattern1.<span class="hljs-built_in">mark_count</span>() };
</code></pre>
<p>To search a string for a pattern, use either <code>std::regex_match()</code> or <code>std::regex_search()</code>. Both have the same set of parameters, but the former requires the entire string to match the pattern while the latter searches the string for a substring that matches the pattern. Parameter number ...</p>
<ol>
<li>(required) is the string being searched.
<ul>
<li>can be <code>std::string</code>.</li>
<li>can be <code>const char *</code>.</li>
<li>can be range between <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> positions.</li>
</ul>
</li>
<li>(optional) is a <a href="#BM_(reference)%2Fi">reference</a> to <code>std::match_results</code> where match results go (<a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).
<ul>
<li>if parameter 1 is of type <code>std::string</code>, use <a href="#BM_(template%20specialization)%2Fi">template specialization</a> <code>std::smatch</code>.</li>
<li>if parameter 1 is of type <code>std::wstring</code>, use <a href="#BM_(template%20specialization)%2Fi">template specialization</a> <code>std::wmatch</code>.</li>
<li>if parameter 1 is of type <code>const char *</code>, use <a href="#BM_(template%20specialization)%2Fi">template specialization</a> <code>std::cmatch</code>.</li>
<li>if parameter 1 is of type <code>const wchar_t *</code>, use <a href="#BM_(template%20specialization)%2Fi">template specialization</a> <code>std::wcmatch</code>.</li>
</ul>
</li>
<li>(required) is the pattern to search for.</li>
<li>(optional) is the match flags (optional -- this specifies matching behaviour such as how you should treat EOL)</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>There are lots more specializations for parameter 2. See <a href="https://en.cppreference.com/w/cpp/regex/match_results">here</a> for more information.</p>
</div>
<pre class="hljs"><code>std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello steven"</span>);
<span class="hljs-function">std::regex <span class="hljs-title">pattern5</span><span class="hljs-params">(R<span class="hljs-string">"|hello (.*+)|"</span>)</span></span>;
std::smatch result;
<span class="hljs-type">bool</span> matched { std::<span class="hljs-built_in">regex_match</span>(s1, result, pattern5, std::regex_constants::match_default) };
<span class="hljs-comment">// matched contains true if the pattern matched the string</span>
<span class="hljs-comment">// result contains information about the match (e.g. what parts of the string matched which sub-expressions) -- see cppreference for more info</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>If using <code>std::regex_search()</code>, you can continue searching the string by extracting the end position of the search from the match result and running the search again from that position.</p>
</div>
<p>To search a string for a pattern and replace it, use <code>std::replace()</code>. Similar to <code>std::regex_match()</code> and <code>std::regex_search()</code>, this also has a flag argument (same type and default) that defines how replacement happens (e.g. <code>$1</code> to replace with capture group 1).</p>
<pre class="hljs"><code><span class="hljs-function">std::regex <span class="hljs-title">pattern6</span><span class="hljs-params">(R<span class="hljs-string">"|hello (.*+)|"</span>)</span></span>;
std::string res = std::<span class="hljs-built_in">regex_replace</span>(<span class="hljs-string">"hello steven"</span>, pattern6, <span class="hljs-string">"goodbye $1"</span>);
<span class="hljs-comment">// res should be "goodbye steven"</span>
</code></pre>
<a name="H_Streams"></a><h2>Streams</h2>
<p><a name="BM_(Library%20Functions%5C%2FStreams)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FSequential%2FArray)_TOPIC%2F">Library Functions/Containers/Sequential/Array</a></li>
</ul>
</div>
<p>Similar to Java's <code>InputStream</code> and <code>OutputStream</code> interfaces (and surrounding utilities and packages), the C++ standard library offers several stream <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and interfaces. Similar to <code>std::basic_string</code>, a set of <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are provided for streams.</p>
<ul>
<li><code>std::basic_ostream</code> is the equivalent of Java's <code>OutputStream</code>.</li>
<li><code>std::basic_istream</code> is the equivalent of Java's <code>InputStream</code>.</li>
<li><code>std::basic_iostream</code> is a combination of the above two.</li>
</ul>
<p>Each of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es above requires two <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s: element type of the stream (e.g. is it streaming <code>char</code>s, <code>int</code>s, a custom type, etc..) and a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that describes the element type's traits (e.g. similar to the <code>std::basic_string</code>'s character traits type). <a href="#BM_(template%20specialization)%2Fi">Template specialization</a>s are provided for some commonly used element types (e.g. <code>char</code> and <code>wchar_t</code>).</p>
<table>
<thead>
<tr>
<th>base stream type</th>
<th>element type</th>
<th>specialized stream type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::basic_ostream</code></td>
<td><code>char</code></td>
<td><code>std::istream</code></td>
</tr>
<tr>
<td><code>std::basic_istream</code></td>
<td><code>char</code></td>
<td><code>std::ostream</code></td>
</tr>
<tr>
<td><code>std::basic_iostream</code></td>
<td><code>char</code></td>
<td><code>std::iostream</code></td>
</tr>
<tr>
<td><code>std::basic_ostream</code></td>
<td><code>wchar_t</code></td>
<td><code>std::wistream</code></td>
</tr>
<tr>
<td><code>std::basic_istream</code></td>
<td><code>wchar_t</code></td>
<td><code>std::wostream</code></td>
</tr>
<tr>
<td><code>std::basic_iostream</code></td>
<td><code>wchar_t</code></td>
<td><code>std::wiostream</code></td>
</tr>
</tbody>
</table>
<p>You typically won't need to implement your own stream types. The C++ standard library provides stream implementations for common use-cases such as reading/writing to the console and files. The subsections below document these implementations, while the remainder of this section discusses the stream API.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The rest of this section talks about the general functionality of streams using <code>std::cout</code> for an output stream / <code>std::cin</code> for an input stream. These are for writing to / reading from the console, which is documented further in one of the subsections. For now just assume they exist.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a> (refresher)</li>
</ul>
</div>
<p>To read and write text, <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s are provided called formatted operations: The left-shift operator (&lt;&lt;) is for writing while the right-shift operator (&gt;&gt;) is for reading. Each <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> takes in the type to write/read and returns a <a href="#BM_(reference)%2Fi">reference</a> back to the stream itself, allowing for chaining.</p>
<pre class="hljs"><code>std::cout &lt;&lt; <span class="hljs-number">5</span> &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; <span class="hljs-string">"hello world"</span>;
<span class="hljs-type">int</span> x {};
<span class="hljs-type">int</span> y {};
std::cin &gt;&gt; x &gt;&gt; y;
</code></pre>
<p>By default, the C++ standard library provides <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s for most <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">built-in type</a>s (e.g. <code>int</code>, <code>long</code>, etc.. ) as well as some higher-level types within the C++ standard library strings (e.g. <code>std::string</code>, <code>std::complex</code>, etc..). To provide support for custom types, simply <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> the operators for that type.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyType</span> {
    <span class="hljs-type">int</span> intValue;
    <span class="hljs-type">long</span> longValue;
}
std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; s, <span class="hljs-keyword">const</span> MyType&amp; val) {
    <span class="hljs-keyword">return</span> s &lt;&lt; val.intValue &lt;&lt; val.longValue;
}
std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; s, MyType&amp; val) {
    s &gt;&gt; val.intValue;
    s &gt;&gt; val.longValue;
    <span class="hljs-keyword">return</span> s;
}
</code></pre>
<p>Special <a href="#BM_(object%7Cinstance)%2Fi">object</a>s called manipulators may be used to to modify how a stream interprets formatted operations.</p>
<ul>
<li><code>std::ws</code> skips over all whitespace in the input.</li>
<li><code>std::flush</code> flushes any buffered output.</li>
<li><code>std::ends</code> writes a null byte (e.g. 0).</li>
<li><code>std::endl</code> writes a newline character and flushes.</li>
<li><code>std::boolalpha</code> tells the stream to write/read booleans as text rather than 0/1.</li>
<li><code>std::noboolalpha</code> tells the stream to write/read booleans as 0/1 rather than text.</li>
<li><code>std::oct</code> tells the stream to write/read integrals as octal.</li>
<li><code>std::dec</code> tells the stream to write/read integrals as decimal.</li>
<li><code>std::hex</code> tells the stream to write/read integrals as hexidecimal.</li>
<li><code>std::setprecision(p)</code> tells the stream to write/read floating point at a specific precision.</li>
<li><code>std::fixed</code> tells the stream to write/read floating point in fixed notation.</li>
<li><code>std::scientific</code> tells the stream to write/read floating point in scientific notation.</li>
</ul>
<pre class="hljs"><code>std::cin &gt;&gt; std::ws &gt;&gt; x;  <span class="hljs-comment">// skip over whitespace and read into variable</span>

std::cout &lt;&lt; <span class="hljs-string">"hello"</span> &lt;&lt; std::flush; <span class="hljs-comment">// writes string and forces buffer to flush</span>
std::cout &lt;&lt; <span class="hljs-string">"hello"</span> &lt;&lt; std::ends;  <span class="hljs-comment">// writes string followed by null character</span>
std::cout &lt;&lt; <span class="hljs-string">"hello"</span> &lt;&lt; std::endl;  <span class="hljs-comment">// writes string followed by new-line character AND forces buffer to flush</span>

std::cout &lt;&lt; std::boolalpha &lt;&lt; <span class="hljs-literal">true</span>;   <span class="hljs-comment">// writes true</span>
std::cout &lt;&lt; std::noboolalpha &lt;&lt; <span class="hljs-literal">true</span>; <span class="hljs-comment">// writes 1</span>
std::cin &gt;&gt; std::boolalpha &gt;&gt; b_var;   <span class="hljs-comment">// reads true/false into boolean variable</span>
std::cin &gt;&gt; std::noboolalpha &gt;&gt; b_var; <span class="hljs-comment">// writes 0/1 into boolean variable</span>

std::cout &lt;&lt; std::oct &lt;&lt; <span class="hljs-number">10</span> &lt;&lt; st::dec &lt;&lt; <span class="hljs-number">10</span> &lt;&lt; std::hex &lt;&lt; <span class="hljs-number">10</span>;            <span class="hljs-comment">// writes 10 as octal, decimal, and hex</span>
std::cin &gt;&gt; std::oct &gt;&gt; i_var1 &gt;&gt; st::dec &gt;&gt; i_var2 &gt;&gt; std::hex &gt;&gt; i_var3; <span class="hljs-comment">// reads integral as octal, decimal, and hex</span>

std::cout &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// writes 3.14</span>
std::cout &lt;&lt; std::fixed &lt;&lt; <span class="hljs-number">0.1</span>;               <span class="hljs-comment">// writes 0.100000</span>
std::cout &lt;&lt; std::scientific &lt;&lt; <span class="hljs-number">0.1</span>;          <span class="hljs-comment">// writes 1.000000e-01</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FImplicit%20Conversion)_TOPIC%2F">Core Language/Variables/Implicit Conversion</a> (refresher)</li>
</ul>
</div>
<p>At any point, a stream may end or enter into a bad state. A set of <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s can be used to query the state.</p>
<ul>
<li><code>good()</code> returns true if the stream is in a good state.</li>
<li><code>eof()</code> returns true if the stream has ended.</li>
<li><code>fail()</code> returns true if the last operation failed (but the stream may still be usable).</li>
<li><code>bad()</code> returns true if the stream is in an unrecoverable state.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>At any point, you can call <code>clear()</code> to reset the state to good. Why would you ever want to do this?</p>
</div>
<p>In addition, <code>exceptions()</code> can be used to make the stream throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> if it enters into one (or more) of the states listed above.</p>
<pre class="hljs"><code>std::cin.<span class="hljs-built_in">exceptions</span>(std::istream::badbit | std::istream::failbit); <span class="hljs-comment">// exception if bad/fail, but not good/eof</span>
</code></pre>
<p>Streams provide an <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> for <code>bool</code> that gives back the result of <code>good()</code>, allowing for shorthand testing of the stream state.</p>
<pre class="hljs"><code><span class="hljs-comment">// keep reading characters until the stream breaks or eof</span>
<span class="hljs-keyword">while</span> (std::cin) {
    <span class="hljs-type">char</span> ch {};
    std::cin &gt;&gt; ch;
    <span class="hljs-built_in">process</span>(ch);
}
</code></pre>
<p>To read non-text data, a set of <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s referred to as unformatted operations are available.</p>
<p>To read non-text data, use <code>get()</code>, <code>peek()</code>, <code>getline()</code>, <code>read()</code>, <code>readsome()</code>, and <code>ignore()</code>. <code>gcount()</code> may be used to determine exactly how many characters were read in one of these functions (e.g. may have terminated early because it hit end-of-file or a new-line character).</p>
<pre class="hljs"><code><span class="hljs-type">char</span> ch {};
std:array&lt;<span class="hljs-type">char</span>, 100&gt; arr {};

ch = std::cin.<span class="hljs-built_in">peek</span>(); <span class="hljs-comment">// read single character WITHOUT moving forward in  the stream</span>
ch = std::cin.<span class="hljs-built_in">get</span>();  <span class="hljs-comment">// read single character</span>
std::cin.<span class="hljs-built_in">get</span>(ch);     <span class="hljs-comment">// read single character</span>
std::cin.<span class="hljs-built_in">get</span>(arr, <span class="hljs-number">100</span>);           <span class="hljs-comment">// read 100 characters OR until \n (\n included in arr)</span>
std::cin.<span class="hljs-built_in">get</span>(arr, <span class="hljs-number">100</span>, <span class="hljs-string">';'</span>);      <span class="hljs-comment">// read 100 characters OR until ;  (; included in arr)</span>
std::cin.<span class="hljs-built_in">getline</span>(arr, <span class="hljs-number">100</span>);       <span class="hljs-comment">// read 100 characters OR until \n (\n DISCARDED)</span>
std::cin.<span class="hljs-built_in">getline</span>(arr, <span class="hljs-number">100</span>, <span class="hljs-string">';'</span>);  <span class="hljs-comment">// read 100 characters OR until ;  (; DISCARDED)</span>
std::cin.<span class="hljs-built_in">read</span>(arr, <span class="hljs-number">100</span>);          <span class="hljs-comment">// read 100 characters</span>
std::cin.<span class="hljs-built_in">readsome</span>(arr, <span class="hljs-number">100</span>);      <span class="hljs-comment">// read 100 characters or however many are "immediately available"</span>
std::cin.<span class="hljs-built_in">ignore</span>();        <span class="hljs-comment">// skip single char</span>
std::cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">5</span>);       <span class="hljs-comment">// skip 5 chars</span>
std::cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">5</span>, <span class="hljs-string">'\n'</span>); <span class="hljs-comment">// skip up to 5 chars, stopping if \n is encountered (stops AFTER skipping \n)</span>

<span class="hljs-keyword">auto</span> count { std::cin.<span class="hljs-built_in">gcount</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p><code>readsome()</code> is a little more dicey in that how it works is implementation specific.</p>
</div>
<p>To write non-text data, use <code>put()</code> and <code>write()</code>. For buffered streams, the buffer may be explicitly flushed by <code>flush()</code>.</p>
<pre class="hljs"><code>std::cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">'x'</span>);         <span class="hljs-comment">// write single character</span>
std::cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">"hello"</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// write 5 characters</span>
std::cout.<span class="hljs-built_in">flush</span>();
</code></pre>
<p>To get and move the position of the underlying stream, use <code>tell*()</code> and <code>seek*()</code> respectively. The suffix depends on the type of stream:</p>
<ul>
<li>input streams use <code>tellg()</code> / <code>seekg()</code></li>
<li>output streams use <code>tellp()</code> / <code>seekp()</code></li>
<li>input output streams use <code>tell()</code> / <code>seek()</code></li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not supported on all stream types</span>
<span class="hljs-keyword">auto</span> pos { std::cin.<span class="hljs-built_in">tellg</span>() };
</code></pre>
<a name="H1_String"></a><h3>String</h3>
<p><a name="BM_(Library%20Functions%5C%2FStreams%2FString)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F">Library Functions/Strings/String</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString%20View)_TOPIC%2F">Library Functions/Strings/String View</a></li>
</ul>
</div>
<p>String streams are equivalent to Java's <code>ByteArrayInputStream</code> / <code>StringReader</code> and <code>ByteArrayOutputStream</code> / <code>StringWriter</code>. The underlying types for string streams are ...</p>
<ul>
<li><code>std::basic_istringstream</code> for input string stream.</li>
<li><code>std::basic_ostringstream</code> for output string stream.</li>
<li><code>std::basic_stringstream</code> for both input and output string stream.</li>
</ul>
<p>The above types are <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s specify element type, element traits, and a custom allocator. The following <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are provided out-of the box...</p>
<table>
<thead>
<tr>
<th>type</th>
<th>element type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::ostringstream</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wostringstream</code></td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td><code>std::istringstream</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wistringstream</code></td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td><code>std::stringstream</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wstringstream</code></td>
<td><code>wchar_t</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The text and examples below use <code>std::ostringstream</code> / <code>std::istringstream</code>, but they should work for the other <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s as well. Make sure to use the correct literal for raw character string types (e.g. <code>u8"example"</code> for <code>char_8t</code>).</p>
</div>
<p>For output string streams, in addition to all of the normal output stream functionality, ...</p>
<ul>
<li><code>str()</code> returns a copy of the internal buffer as a <code>std::string</code>.</li>
<li><code>view()</code> returns a view to the internal buffer as a <code>std::string_view</code>.</li>
</ul>
<pre class="hljs"><code>std::ostringstream out {};
out &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">"hello!"</span> &lt;&lt; std::endl;
std::string output { out.<span class="hljs-built_in">str</span>() };
std::string_view view { out.<span class="hljs-built_in">view</span>() };
</code></pre>
<p>Input string streams have the same two <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s, but they're hardly used because the main point of input string streams is to parse data out of the stream.</p>
<pre class="hljs"><code>std::istringstream in { <span class="hljs-string">"1 9.555555"</span> };
<span class="hljs-type">int</span> x;
<span class="hljs-type">double</span> y;
in &gt;&gt; x &gt;&gt; y;
</code></pre>
<a name="H_File"></a><h3>File</h3>
<p><a name="BM_(Library%20Functions%5C%2FStreams%2FFile)_TOPIC%2F"></a><strong></strong></p>
<p>File streams are equivalent to Java's <code>FileInputStream</code> and <code>FileOutputStream</code>. The underlying types for string stream are ...</p>
<ul>
<li><code>std::basic_ifstream</code> for input string streams.</li>
<li><code>std::basic_ofstream</code> for output string streams.</li>
<li><code>std::basic_fstream</code> for both input and output string stream.</li>
</ul>
<p>The above types are <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s specify element type, element traits, and a custom allocator. The following <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are provided out-of the box...</p>
<table>
<thead>
<tr>
<th>type</th>
<th>element type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::ofstream</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wofstream</code></td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td><code>std::ifstream</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>std::wifstream</code></td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td><code>std::fstream</code></td>
<td><code>char</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The text and examples below use <code>std::ofstream</code> / <code>std::ifstream</code>, but they should work for the other <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s as well. Make sure to use the correct literal for raw character string types (e.g. <code>u8"example"</code> for <code>char_8t</code>).</p>
</div>
<p>To access a file, either pass that file's path to the <a href="#BM_(constructor)%2Fi">constructor</a> or to <code>open()</code> along with the set of file access flags. Those flags are ...</p>
<ul>
<li><code>std::ios::in</code> - file must exist.</li>
<li><code>std::ios::out</code> - file created if it doesn't exist.</li>
<li><code>std::ios::app</code> - file created if it doesn't exist AND writes go to the end of the file.</li>
<li><code>std::ios::trunc</code> - file contents discarded.</li>
<li><code>std::ios::binary</code> - if set, no implicit text manipulations are performed on the file (e.g. replacing <code>\n</code> with <code>\r\n</code> or vice-versa).</li>
</ul>
<pre class="hljs"><code>std::fstream f1 { <span class="hljs-string">"/path/to/file.txt"</span>, std::ios::in | std::ios::trunc }; <span class="hljs-comment">// file must exist AND truncate it</span>
std::fstream f2 {};
f2.<span class="hljs-built_in">open</span>(<span class="hljs-string">"/path/to/file.txt"</span>, std::ios::in | std::ios::trunc); <span class="hljs-comment">// same open operation as f1</span>
</code></pre>
<p>To close a file, use <code>close()</code> or call the stream <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(destructor)%2Fi">destructor</a> by destroying it.</p>
<pre class="hljs"><code>f1.<span class="hljs-built_in">close</span>();
</code></pre>
<p>To check if the stream has a file open, use <code>is_open()</code>.</p>
<pre class="hljs"><code><span class="hljs-type">bool</span> open { f1.<span class="hljs-built_in">is_open</span>() };
</code></pre>
<p>To read and write, the standard stream mechanisms are available: formatted operations and unformatted operations.</p>
<pre class="hljs"><code><span class="hljs-comment">// write</span>
f1 &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">"hello!"</span> &lt;&lt; std::endl; <span class="hljs-comment">// write</span>
<span class="hljs-comment">// read</span>
<span class="hljs-type">int</span> x;
<span class="hljs-type">double</span> y;
f1 &gt;&gt; x &gt;&gt; y;
</code></pre>
<p>To get and set the position, the standard stream mechanisms are available: <code>seek*()</code> and <code>tell*()</code></p>
<pre class="hljs"><code>f1.<span class="hljs-built_in">seek</span>(<span class="hljs-number">500</span>);
<span class="hljs-keyword">auto</span> pos { f1.<span class="hljs-built_in">tell</span>() };
</code></pre>
<p>To handle IO errors, the standard stream mechanisms are available: <code>exceptions()</code> to throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s or explicitly check flags (e.g. invoke <code>good()</code>).</p>
<pre class="hljs"><code>f1.<span class="hljs-built_in">exceptions</span>(std::istream::badbit | std::istream::failbit); <span class="hljs-comment">// exception if bad/fail, but not good/eof</span>
</code></pre>
<a name="H_Global"></a><h3>Global</h3>
<p><a name="BM_(Library%20Functions%5C%2FStreams%2FGlobal)_TOPIC%2F"></a><strong></strong></p>
<p>For console access, global streams provides access to standard input, standard output, and standard error. Global streams are presented to the user as global variables.</p>
<table>
<thead>
<tr>
<th>channel</th>
<th>element type</th>
<th>global variable</th>
</tr>
</thead>
<tbody>
<tr>
<td>standard in</td>
<td><code>char</code></td>
<td><code>std::cin</code></td>
</tr>
<tr>
<td>standard out</td>
<td><code>char</code></td>
<td><code>std::cout</code></td>
</tr>
<tr>
<td>standard error</td>
<td><code>char</code></td>
<td><code>std::cerr</code></td>
</tr>
<tr>
<td>standard in</td>
<td><code>wchar_t</code></td>
<td><code>std::wcin</code></td>
</tr>
<tr>
<td>standard out</td>
<td><code>wchar_t</code></td>
<td><code>std::wcout</code></td>
</tr>
<tr>
<td>standard error</td>
<td><code>wchar_t</code></td>
<td><code>std::wcerr</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>The text and examples below use <code>std::cout</code> / <code>std::cin</code> / <code>std::cerr</code>, but they should work for the other <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s as well. Make sure to use the correct literal for raw character string types (e.g. <code>u8"example"</code> for <code>char_8t</code>).</p>
</div>
<p>To read and write, the standard stream mechanisms are available: formatted operations and unformatted operations.</p>
<pre class="hljs"><code><span class="hljs-comment">// write</span>
std::cout &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">"hello!"</span> &lt;&lt; std::endl; <span class="hljs-comment">// write</span>
<span class="hljs-comment">// read</span>
<span class="hljs-type">int</span> x;
<span class="hljs-type">double</span> y;
std::cin &gt;&gt; x &gt;&gt; y;
</code></pre>
<p>To handle IO errors, the standard stream mechanisms are available: <code>exceptions()</code> to throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s or explicitly check flags (e.g. invoke <code>good()</code>).</p>
<pre class="hljs"><code>std::cin.<span class="hljs-built_in">exceptions</span>(std::istream::badbit | std::istream::failbit); <span class="hljs-comment">// exception if bad/fail, but not good/eof</span>
</code></pre>
<a name="H_Span"></a><h2>Span</h2>
<p><a name="BM_(Library%20Functions%5C%2FSpan)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString)_TOPIC%2F">Library Functions/Strings/String</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FStrings%2FString%20View)_TOPIC%2F">Library Functions/Strings/String View</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FRanges)_TOPIC%2F">Library Functions/Ranges</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F">Library Functions/Containers</a></li>
</ul>
</div>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<p>TODO: fill me in</p>
<a name="H_Debug%20Utilities"></a><h2>Debug Utilities</h2>
<p><a name="BM_(Library%20Functions%5C%2FDebug%20Utilities)_TOPIC%2F"></a><strong></strong></p>
<p>The C++ standard library provides functionality to assist with debugging. The subsections below detail some of the most common ones.</p>
<a name="H_Source%20Location"></a><h3>Source Location</h3>
<p><a name="BM_(Library%20Functions%5C%2FDebug%20Utilities%2FSource%20Location)_TOPIC%2F"></a><strong></strong></p>
<p>The function <code>std::source_location::current()</code> determines where in the source code the program is executing. The function generates a <code>std::source_location</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> which specifies which source file and where in that file the invocation took place. The <code>std::source_location</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> provides the following <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s:</p>
<ul>
<li><code>file_name()</code> returns which source file in which the invocation took place.</li>
<li><code>line()</code>  returns which source line in which the invocation took place.</li>
<li><code>column()</code> returns the index within the source line in which the invocation took place.</li>
<li><code>function()</code> returns the name of the function in which the invocation took place.</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">//</span>
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> log() works because the default for the location parameter is generated by the caller.</span>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(std::string_view message, <span class="hljs-keyword">const</span> std::source_location&amp; location = std::source_location::current())</span> </span>{
    std::cout &lt;&lt; location.<span class="hljs-built_in">file_name</span>() &lt;&lt; <span class="hljs-string">':'</span> &lt;&lt; location.<span class="hljs-built_in">line</span>() &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; message;
}
 
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">log</span>(<span class="hljs-string">"Hello world!"</span>);  <span class="hljs-comment">// prints "info:main.cpp:19 Hello world!"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>It seems like this is replacing standard C++ <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros like <code>__FILE__</code> and <code>__LINE__</code>.</p>
</div>
<a name="H_Object%20Address"></a><h3>Object Address</h3>
<p><a name="BM_(Library%20Functions%5C%2FDebug%20Utilities%2FObject%20Address)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚Ü©PREREQUISITES‚Ü©</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers)_TOPIC%2F">Library Functions/Smart Pointers</a></li>
</ul>
</div>
<p>In certain scenarios, it isn't easily possible to get access to the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> an <a href="#BM_(object%7Cinstance)%2Fi">object</a>. The C++ standard library provides two functions that help with this.</p>
<ul>
<li>
<p><code>std::addressof()</code> forcefully returns the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> an <a href="#BM_(object%7Cinstance)%2Fi">object</a>. This is useful in cases where the <a href="#BM_(object%7Cinstance)%2Fi">object</a> could have an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> for the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator (&amp;) that returns something other than the <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s actual address.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x;
std::cout &lt;&lt; std::<span class="hljs-built_in">addressof</span>(x) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "0x7ffc0504312c"</span>
</code></pre>
</li>
<li>
<p><code>std::to_address()</code> converts a <a href="#BM_(pointer)%2Fi">pointer</a>-like <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. a raw <a href="#BM_(pointer)%2Fi">pointer</a> or a <a href="#BM_(smart%20pointer)%2Fi">smart pointer</a>) to a raw <a href="#BM_(pointer)%2Fi">pointer</a>. This is useful because it abstracts out accessing the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, even if that <a href="#BM_(object%7Cinstance)%2Fi">object</a> is wrapped in something like a <a href="#BM_(smart%20pointer)%2Fi">smart pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { <span class="hljs-number">5</span> };
<span class="hljs-type">int</span> *xRawPtr { &amp;x };
<span class="hljs-keyword">auto</span> custom_deleter = [](<span class="hljs-type">int</span>* x) { <span class="hljs-comment">/* do nothing */</span> };
std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(custom_deleter)&gt; xSmartPtr{ &amp;x, custom_deleter };

std::cout &lt;&lt; std::<span class="hljs-built_in">to_address</span>(&amp;x) &lt;&lt; std::endl;         <span class="hljs-comment">// prints "0x7ffc36e943b4"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">to_address</span>(xRawPtr) &lt;&lt; std::endl;    <span class="hljs-comment">// prints "0x7ffc36e943b4"</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">to_address</span>(xSmartPtr) &lt;&lt; std::endl;  <span class="hljs-comment">// prints "0x7ffc36e943b4"</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://stackoverflow.com/a/56494186">here</a> for discussion on specific use-cases.</p>
</div>
</li>
</ul>
<a name="H_Compile-time%20Evaluation%20Test"></a><h3>Compile-time Evaluation Test</h3>
<p><a name="BM_(Library%20Functions%5C%2FDebug%20Utilities%2FCompile-time%20Evaluation%20Test)_TOPIC%2F"></a><strong></strong></p>
<p>The function <code>std::is_constant_evaluated()</code> can be invoked inside of a <code>constexpr</code> function to determine whether it's being invoked at <a href="#BM_(compile-time)%2Fi">compile-time</a> or run-time. One of the typical use-cases of <code>constexpr</code> functions is to increase performance by forcefully evaluating things at <a href="#BM_(compile-time)%2Fi">compile-time</a> when possible. As such, when debugging performance issues, <code>std::is_constant_evaluated()</code> can be used to ensure that the correct path is being taken for an invocation.</p>
<p>Here's the example from the book...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">double</span> b, <span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">static_assert</span> <span class="hljs-title">std::is_constant_evaluated</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(b, <span class="hljs-built_in">double</span>(x));
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>üîçSEE ALSOüîç</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FCompile-time%20Evaluation)_TOPIC%2F">Core Language/Compile-time Evaluation</a> (refresher)</li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>Technically, <code>std::is_constant_evaluated()</code> can be used anywhere. If you use it ...</p>
<ul>
<li>in a <code>consteval</code>, it will always evaluate to true</li>
<li>in a <code>constexpr</code>, it may evaluate to true or false depending on where it was called</li>
<li>in a normal run-time evaluated function, it will always evaluate to false</li>
</ul>
</div>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(preprocessor%7Ctranslation%20unit)%2Fi"></a><strong>preprocessor</strong> - A tool that takes in a C++ source file and performs basic manipulation on it to produce what's called a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</p>
</li>
<li>
<p><a name="BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi"></a><strong>compiler</strong> - A tool that takes in a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> to produce an intermediary format called an <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>.</p>
</li>
<li>
<p><a name="BM_(linker%7Cexecutable)%2Fi"></a><strong>linker</strong> - A tool that takes multiple <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s to produce an <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>. <a href="#BM_(linker%7Cexecutable)%2Fi">Linker</a>s are also responsible for finding libraries used by the program and integrating them into the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
</li>
<li>
<p><a name="BM_(enumeration%7Cenum)%2Fi"></a><strong>enumeration</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> that can be set to one of a set of possibilities.</p>
<pre class="hljs"><code><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MyEnum</span> {
   OptionA,
   OptionB,
   OptionC
};

MyEnum x {MyEnum::OptionC};
</code></pre>
</li>
<li>
<p><a name="BM_(class%7C%5Cbstruct)%2Fi"></a><strong>class</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> that pairs together data and the functions that operate on that data.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">long</span> y) {
        <span class="hljs-keyword">this</span>-&gt;x = x;
        <span class="hljs-keyword">this</span>-&gt;y = y;
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;x += z;
        <span class="hljs-keyword">return</span> y + z;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">long</span> y;
}
</code></pre>
</li>
<li>
<p><a name="BM_(union)%2Fi"></a><strong>union</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> where all <a href="#BM_%5Cb(member)%2Fi">member</a>s share the same memory location (different representations of the same data).</p>
<pre class="hljs"><code><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> {
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">long</span> y;
}
</code></pre>
</li>
<li>
<p><a name="BM_(plain-old-data%20class%7Cplain-old%20data%20class%7Cplain%20old%20data%20class%7Cplain-old-data%20structure%7Cplain-old%20data%20structure%7Cplain%20old%20data%20structure%7Cplain-old-data%20struct%7Cplain-old%20data%20struct%7Cplain%20old%20data%20struct)%2Fi"></a><strong>plain-old-data class</strong> <a name="BM_(POD)%2F"></a><strong></strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that contains only data, not functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Podo</span> {
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">long</span> y;
}
</code></pre>
</li>
<li>
<p><a name="BM_%5Cb(member)%2Fi"></a><strong>member</strong> - Data or function belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(method%7C%5Cbmember%20function)%2Fi"></a><strong>member function</strong> - Function belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> that is a function).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    ...
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x + y; }
};
</code></pre>
</li>
<li>
<p><a name="BM_(free%20function%7Cnon-member%20function)%2Fi"></a><strong>free function</strong> - Function not belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> -x; }
</code></pre>
</li>
<li>
<p><a name="BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi"></a><strong>field</strong> - Variable belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> that is a variable).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-type">int</span> x;
};
</code></pre>
</li>
<li>
<p><a name="BM_(class%20invariant)%2Fi"></a><strong>class invariant</strong> - When using some <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <a href="#BM_(class%20invariant)%2Fi">class invariant</a> is a feature of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that is always true (never varies). For example, if a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is used to hold on to an IP and port combination, and it ensures that the port can never be 0, that's a <a href="#BM_(class%20invariant)%2Fi">class invariant</a>.</p>
</li>
<li>
<p><a name="BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi"></a><strong>fundamental type</strong> - C++ type that's built into the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> itself rather than being declared through code. Examples include <code>void</code>, <code>bool</code>, <code>int</code>, <code>char</code>, etc..</p>
</li>
<li>
<p><a name="BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi"></a><strong>user-defined type</strong> - A type that's defined by a user, typically derived from existing types. Examples include <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>s, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, <a href="#BM_(union)%2Fi">union</a>s, etc..</p>
</li>
<li>
<p><a name="BM_(object%20initialization)%2Fi"></a><strong>object initialization</strong> - The process by which a C++ program initializes an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. an <code>int</code>, array of <code>int</code>s, <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type, etc..).</p>
</li>
<li>
<p><a name="BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi"></a><strong>braced initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where braces are used to set values (e.g. <code>int x {1}</code>, <code>MyStruct x{ 1, true }</code>, etc..). <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> is often the least error-prone form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a>, where other forms may introduce ambiguity.</p>
<pre class="hljs"><code>MyStruct x{<span class="hljs-built_in">int</span>(a), <span class="hljs-built_in">int</span>(b)};  <span class="hljs-comment">// call the constructor taking in two ints</span>
<span class="hljs-function">MyStruct <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-type">int</span>(a), <span class="hljs-type">int</span>(b))</span></span>;  <span class="hljs-comment">// possibly interpreted as function declaration -- equiv to MyStruct(int a, int b)</span>

<span class="hljs-type">float</span> a{<span class="hljs-number">1</span>}, b{<span class="hljs-number">2</span>};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span> <span class="hljs-params">(a/b)</span></span>; <span class="hljs-comment">// no compiler warning generated about narrowing (why? -- book doesn't say)</span>
<span class="hljs-type">int</span> b {a/b}; <span class="hljs-comment">// compiler warning generated about narrowing</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>This is also called <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">uniform initialization</a>.</p>
</div>
</li>
<li>
<p><a name="BM_(equals%3F%20initialization)%2Fi"></a><strong>equals initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where the equals sign is used (e.g. <code>int x = 5</code>).</p>
</li>
<li>
<p><a name="BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi"></a><strong>braces-plus-equals initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where both the equals sign and braces are used for initialization (e.g. <code>MyStruct x = { 1, true }</code>). This is mostly equivalent to <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See <a href="https://stackoverflow.com/a/20733537">here</a>. Even though there's an equal sign (=), there is no <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> / move semantics.</p>
</div>
</li>
<li>
<p><a name="BM_(constructor)%2Fi"></a><strong>constructor</strong> - A function used for initializing an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> : MyParent {
    ...
    <span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some setup here</span>
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(destructor)%2Fi"></a><strong>destructor</strong> - A function used for cleanup when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is destroyed.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> : MyParent {
    ...
    ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
<p>See also: <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>.</p>
</li>
<li>
<p><a name="BM_(default%20constructor)%2Fi"></a><strong>default constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> that has in no parameters.</p>
</li>
<li>
<p><a name="BM_(pointer)%2Fi"></a><strong>pointer</strong> - A data type used to point to a different piece of memory (e.g. <code>int yPtr { &amp;y }</code>).</p>
</li>
<li>
<p><a name="BM_(reference)%2Fi"></a><strong>reference</strong> - A data type used to point to a different piece of memory, but in a more sanitized / less confusing manner (e.g. <code>int &amp;yRef { y };</code>).</p>
</li>
<li>
<p><a name="BM_(sizeof)%2Fi"></a><strong>sizeof</strong> - A unary operator that returns the size of a type or <a href="#BM_(object%7Cinstance)%2Fi">object</a> (known at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">size_t</span> x_size {<span class="hljs-keyword">sizeof</span> x};
</code></pre>
</li>
<li>
<p><a name="BM_(address%5B%5C-%5Cs%5Dof)%2Fi"></a><strong>address-of (&amp;)</strong> - A unary operator used to obtain the memory <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (<a href="#BM_(pointer)%2Fi">pointer</a>) (e.g. <code>int *ptr {&amp;x}</code>).</p>
</li>
<li>
<p><a name="BM_(dereference%7Cdereferencing)%2Fi"></a><strong>dereference (*)</strong> - A unary operator used to obtain the <a href="#BM_(object%7Cinstance)%2Fi">object</a> at some memory address (e.g. <code>int x {*ptr}</code>).</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi"></a><strong>member-of-pointer (-&gt;)</strong> - An operator that <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>s a <a href="#BM_(pointer)%2Fi">pointer</a> and accesses a <a href="#BM_%5Cb(member)%2Fi">member</a> of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to (e.g. <code>ptr-&gt;x</code>).</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi"></a><strong>member-of-object (.)</strong> - An operator that accesses a <a href="#BM_%5Cb(member)%2Fi">member</a> of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> to (e.g. <code>obj.x</code>).</p>
</li>
<li>
<p><a name="BM_(pointer%20arithmetic)%2Fi"></a><strong>pointer arithmetic</strong> - Adding or subtracting integer types to a <a href="#BM_(pointer)%2Fi">pointer</a> will move that <a href="#BM_(pointer)%2Fi">pointer</a> by the number of bytes that makes up its underlying type (e.g. <code>uint32_t *ptrB = ptrA + 1</code> will set <code>ptrB</code> to 4 bytes ahead of ptrA).</p>
</li>
<li>
<p><a name="BM_(reseat)%2Fi"></a><strong>reseating</strong> - The concept of a variable that points to something updating to point to something else. <a href="#BM_(pointer)%2Fi">Pointer</a>s can be <a href="#BM_(reseat)%2Fi">reseat</a>ed, but <a href="#BM_(reference)%2Fi">reference</a>s cannot.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *p {&amp;x};
<span class="hljs-type">int</span> y {<span class="hljs-number">7</span>};
p = &amp;y; <span class="hljs-comment">// reseat p</span>
</code></pre>
</li>
<li>
<p><a name="BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi"></a><strong>member initializer list</strong> - A comma separated list of <a href="#BM_(object%20initialization)%2Fi">object initialization</a>s for the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> appearing just before a <a href="#BM_(constructor)%2Fi">constructor</a>'s body.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-built_in">MyStruct</span>(): count{<span class="hljs-number">0</span>}, flag{<span class="hljs-literal">false</span>} {
    }
}
</code></pre>
</li>
<li>
<p><a name="BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi"></a><strong>default member initialization</strong> - The <a href="#BM_(object%20initialization)%2Fi">object initialization</a> of a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> directly where that <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is declared.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-type">int</span> my_var {<span class="hljs-number">5</span>};
};
</code></pre>
</li>
<li>
<p><a name="BM_(object%7Cinstance)%2Fi"></a><strong>object</strong> - A region of memory that has a type and a value (e.g. <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, an integer, a <a href="#BM_(pointer)%2Fi">pointer</a> to an integer, etc..).</p>
</li>
<li>
<p><a name="BM_(allocation%7Callocate)%2Fi"></a><strong>allocation</strong> - The act of reserving memory for an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(deallocation%7Cdeallocate)%2Fi"></a><strong>deallocation</strong> - The act of releasing the memory used by an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(storage%20duration)%2Fi"></a><strong>storage duration</strong> - The duration between an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>.</p>
</li>
<li>
<p><a name="BM_(lifetime)%2Fi"></a><strong>lifetime</strong> - The duration between when an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(constructor)%2Fi">constructor</a> <em>completes</em> (meaning the <a href="#BM_(constructor)%2Fi">constructor</a> finishes) and when its <a href="#BM_(destructor)%2Fi">destructor</a> is <em>invoked</em> (meaning when the <a href="#BM_(destructor)%2Fi">destructor</a> starts).</p>
</li>
<li>
<p><a name="BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi"></a><strong>automatic object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's declared within an enclosing code block. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the block and finish at the end of the block.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-type">int</span> automatic_object {x + <span class="hljs-number">5</span>};
    <span class="hljs-keyword">return</span> automatic_object;
}
</code></pre>
</li>
<li>
<p><a name="BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi"></a><strong>static object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's declared using <code>static</code> or <code>extern</code>. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the program and finish at the end of the program.</p>
</li>
<li>
<p><a name="BM_(local%20static%20object%7Clocal%20static%20variable%7Clocal%20static%20storage%20duration)%2Fi"></a><strong>local static object</strong> - A <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static object</a> but declared at function scope. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the first invocation of the function and finish at the end of the program.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> local_static_object {<span class="hljs-number">0</span>};
    local_static_object++;
    <span class="hljs-keyword">return</span> local_static_object;
}
</code></pre>
</li>
<li>
<p><a name="BM_(static%20field%7Cstatic%20member)%2Fi"></a><strong>static member</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's a <a href="#BM_%5Cb(member)%2Fi">member</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but bound globally rather than on an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. A <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> is essentially a <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static object</a> that's accessible through the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself (not an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>). Similarly, a static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is essentially a global function that's accessed through the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (not an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> my_var {<span class="hljs-number">5</span>};
};
</code></pre>
</li>
<li>
<p><a name="BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi"></a><strong>thread local object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> where each thread has access to its own copy. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the thread and finish when the thread ends.</p>
</li>
<li>
<p><a name="BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi"></a><strong>dynamically allocated object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d at the user's behest, meaning that it's <a href="#BM_(storage%20duration)%2Fi">storage duration</a> is also controlled by the user.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * x { <span class="hljs-keyword">new</span> x {<span class="hljs-number">5</span>} };
<span class="hljs-keyword">delete</span> x;
</code></pre>
</li>
<li>
<p><a name="BM_(internal%20linkage)%2Fi"></a><strong>internal linkage</strong> - A variable only visible to the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's in.</p>
</li>
<li>
<p><a name="BM_(external%20linkage)%2Fi"></a><strong>external linkage</strong> - A variable visible to the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s that it's in as well as other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s.</p>
</li>
<li>
<p><a name="BM_(scope%20resolution)%2Fi"></a><strong>scope resolution (::)</strong> - An operator that's used to access <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a>s (e.g. <code>MyStruct::static_func()</code>).</p>
</li>
<li>
<p><a name="BM_(extends%3F%7Csubclass)%2Fi"></a><strong>extend</strong> - Another way of expressing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inheritance (e.g. B <a href="#BM_(extends%3F%7Csubclass)%2Fi">extends</a> A is equivalent to saying B is a child of A).</p>
</li>
<li>
<p><a name="BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi"></a><strong>exception</strong> - An <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> operation accepts an <a href="#BM_(object%7Cinstance)%2Fi">object</a> and unwinds the call stack until reaching a special region specifically intended to stop the unwinding for <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of that type, called a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block. <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">Exception</a>s are a way for code to signal that something unexpected / <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>al happened.</p>
</li>
<li>
<p><a name="BM_(structured%20binding)%2Fi"></a><strong>structured binding</strong> - A language feature that allows for unpacking an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s / array's elements into a set of variables (e.g. <code>auto [x, y] { two_elem_array }</code>).</p>
</li>
<li>
<p><a name="BM_(copy%20semantics)%2Fi"></a><strong>copy semantics</strong> - The rules used for making copies of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of some type. A copy, once made, should be equivalent to its source. A modification on the copy shouldn't modify the source as well.</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi"></a><strong>member-wise copy</strong> - The default <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> for <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es. Each individual <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is copied.</p>
</li>
<li>
<p><a name="BM_(copy%20constructor)%2Fi"></a><strong>copy constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> with a single parameter that takes in a <a href="#BM_(reference)%2Fi">reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type (e.g. <code>T(const T &amp;) { ... }</code>). A <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is used to specify the <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> for that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(copy%20assignment)%2Fi"></a><strong>copy assignment</strong> - An assignment <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> that copies one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another (e.g. <code>x = y</code>). <a href="#BM_(copy%20assignment)%2Fi">Copy assignment</a> requires that resources in the destination <a href="#BM_(object%7Cinstance)%2Fi">object</a> be cleaned up prior to performing the copy.</p>
</li>
<li>
<p><a name="BM_(RAII%7CCADRe)%2F"></a><strong>RAII</strong> - Short for resource acquisition is initialization, the concept that the life cycle of some resource (e.g. open file, database <a href="#BM_(object%7Cinstance)%2Fi">object</a>, etc..) is bound to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a> via it's <a href="#BM_(constructor)%2Fi">constructor</a> and <a href="#BM_(destructor)%2Fi">destructor</a>.</p>
<p>Sometimes also referred to as <a href="#BM_(constructor)%2Fi">constructor</a> acquires <a href="#BM_(destructor)%2Fi">destructor</a> releases (<a href="#BM_(RAII%7CCADRe)%2F">CADRe</a>).</p>
</li>
<li>
<p><a name="BM_(moved%5B%5C-%5Cs%5Dfrom%20object%7Cmoved%5B%5C-%5Cs%5Dfrom%20state)%2Fi"></a><strong>moved-from object</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is moved to another <a href="#BM_(object%7Cinstance)%2Fi">object</a>, that <a href="#BM_(object%7Cinstance)%2Fi">object</a> enters a special state where the only possible operation allowed on it is either destruction or re-assignment.</p>
</li>
<li>
<p><a name="BM_(move%20constructor)%2Fi"></a><strong>move constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> with a single parameter that takes in an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type (e.g. <code>T(T &amp;&amp;) { ... }</code>). A <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is used to specify the move semantics for that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(move%20assignment)%2Fi"></a><strong>move assignment</strong> - An assignment <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> that moves one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another (e.g. <code>x = y</code>).</p>
</li>
<li>
<p><a name="BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi"></a><strong>value categories</strong> - A classification hierarchy for C++ expressions. Any C++ expression falls into one of the following categories: <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>, or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>.</p>
<p>The intent of this hierarchy is to enable the <em>moving</em> of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. In this case, moving doesn't mean copying. It means gutting out the contents of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> and moving it into another <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<p><img src="svgbob_98c47b0782577adc03415029a6512cbe5425620a.svg" alt="Kroki diagram output"></p>
<ul>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> - An expression that, once evaluated, is a transient / temporary <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code>(x + <span class="hljs-number">51</span>) / n    <span class="hljs-comment">// this is a prvalue      (the result is temporary, needing to go somewhere)</span>
x               <span class="hljs-comment">// this is NOT a prvalue  (the result of x is just x -- it's an exist object)</span>
</code></pre>
</li>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> - An expression that, once evaluated, is an addressable <a href="#BM_(object%7Cinstance)%2Fi">object</a> (NOT transient / NOT temporary / the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator is usable on it).</p>
<pre class="hljs"><code>(x + <span class="hljs-number">51</span>) / n    <span class="hljs-comment">// this is NOT an lvalue (the result is temporary, needing to go somewhere)</span>
x               <span class="hljs-comment">// this is a lvalue      (the result of x is just x -- it's an exist object)</span>
</code></pre>
</li>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> - An expression that, similar to <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, is an addressable <a href="#BM_(object%7Cinstance)%2Fi">object</a>. But, unlike <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is marked as being near the end of its <a href="#BM_(lifetime)%2Fi">lifetime</a>.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>‚ö†Ô∏èNOTEÔ∏èÔ∏èÔ∏è‚ö†Ô∏è</strong></p>
<p>See the expression categories for more information.</p>
</div>
</li>
<li>
<p><a name="BM_(variable%20length%20array)%2Fi"></a><strong>variable length array</strong> <a name="BM_(VLA)%2F"></a><strong></strong> - A feature of C99 that allows for declaring an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a> array whose length is determined at <a href="#BM_(runtime)%2Fi">runtime</a> (non-constant length). This feature is not available in C++ because C++ provides higher-level abstractions for collections of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s in its STL (speculation).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-type">int</span> x[] = <span class="hljs-type">int</span>[n];  <span class="hljs-comment">// okay in C99, but not in C++</span>
}
</code></pre>
</li>
<li>
<p><a name="BM_(rvalue%20reference)%2Fi"></a><strong>rvalue reference</strong> - A data type that's more-or-less the same as a <a href="#BM_(reference)%2Fi">reference</a> but conveys to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that the data it's pointing to is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> (e.g. <code>MyType &amp;&amp;rref { y }</code>).</p>
</li>
<li>
<p><a name="BM_(virtual%20method%7Cvirtual%20function)%2Fi"></a><strong>virtual method</strong> - A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in a base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that is overridable by any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that inherits from that base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x + <span class="hljs-keyword">this</span>-&gt;y;
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi"></a><strong>pure virtual method</strong> - A <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> that requires an implementation (no implementation has been provided by the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that declares it). For a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be instantiable, it cannot have any <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s (similar to an abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> in Java).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    ...
};
</code></pre>
</li>
<li>
<p><a name="BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi"></a><strong>pure virtual class</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that only contains <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() {};  <span class="hljs-comment">// also okay to do   "virtual ~MyParent() = default"</span>
};
</code></pre>
</li>
<li>
<p><a name="BM_(virtual%20destructor)%2Fi"></a><strong>virtual destructor</strong> - A <a href="#BM_(destructor)%2Fi">destructor</a> that's a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> : MyParent {
    ...
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(vtable)%2Fi"></a><strong>vtable</strong> - A table of <a href="#BM_(pointer)%2Fi">pointer</a>s to <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a>s, generated by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>. When a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a> gets invoked (<a href="#BM_(runtime)%2Fi">runtime</a>) <a href="#BM_(vtable)%2Fi">vtable</a>s are used to determine which <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> implementation to use.</p>
</li>
<li>
<p><a name="BM_(template)%2Fi"></a><strong>template</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function where parts of the code are intended for substitution (by other code). At <a href="#BM_(compile-time)%2Fi">compile-time</a>, a user supplies a set of substitutions for each usage of a <a href="#BM_(template)%2Fi">template</a>, customizing it for the specific use-case that user is dealing with.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">add</span><span class="hljs-params">(Y y, Z z)</span> </span>{
    <span class="hljs-keyword">return</span> y + z;
}
</code></pre>
</li>
<li>
<p><a name="BM_(template%20parameter)%2Fi"></a><strong>template parameter</strong> - An identifier within the <a href="#BM_(template)%2Fi">template</a>. At compile time, any time a <a href="#BM_(template)%2Fi">template</a> is used its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are substituted with code that the usage supplies.</p>
<p>A <a href="#BM_(template%20parameter)%2Fi">template parameter</a> may be used multiple times throughout the <a href="#BM_(template)%2Fi">template</a>. At <a href="#BM_(compile-time)%2Fi">compile-time</a>, each usage is substituted with the same piece of code.</p>
<pre class="hljs"><code><span class="hljs-comment">// X, Y, Z, and N are template parameters</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
        <span class="hljs-keyword">return</span> (var1 + var2) * N;
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(template%20instantiation)%2Fi"></a><strong>template instantiation</strong> - The process of substituting the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s in a <a href="#BM_(template)%2Fi">template</a> with real code.</p>
<pre class="hljs"><code>MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; obj {}; <span class="hljs-comment">// X = float, Y = int, Z = int, N = 2</span>
<span class="hljs-type">float</span> x { obj.<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) };
</code></pre>
</li>
<li>
<p><a name="BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi"></a><strong>named conversion</strong> - A set of language features / functions used for converting types (casting): <code>const_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>, and <code>narrow_cast</code>.</p>
</li>
<li>
<p><a name="BM_(concept)_TEMPLATE%2Fi"></a><strong>concept</strong> - A <a href="#BM_(compile-time)%2Fi">compile-time</a> check to ensure that the type substituted for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> matches a set of requirements (e.g. the type supports certain operators).</p>
<pre class="hljs"><code><span class="hljs-comment">// concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
<span class="hljs-keyword">concept</span> MyConcept = std::is_default_constructible&lt;T1&gt;::value
        &amp;&amp; std::is_default_constructible&lt;T2&gt;::value
        &amp;&amp; <span class="hljs-built_in">requires</span>(T1 a, T2 b) {
            { a + b } -&gt; std::same_as&lt;TR&gt;;
            { a * b } -&gt; std::same_as&lt;TR&gt;;
        };

<span class="hljs-comment">// usage of concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-function"><span class="hljs-keyword">requires</span> MyConcept&lt;T1, T2, T1&gt;
T1 <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(T1 &amp;var1, T2 &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
</li>
<li>
<p><a name="BM_(compile-time)%2Fi"></a><strong>compile-time</strong> - Used in <a href="#BM_(reference)%2Fi">reference</a> to something that happens during the compilation process.</p>
</li>
<li>
<p><a name="BM_(runtime)%2Fi"></a><strong>runtime</strong> - Used in <a href="#BM_(reference)%2Fi">reference</a> to something that happens when the compiled program is running.</p>
</li>
<li>
<p><a name="BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi"></a><strong>zero-arg</strong> - Short for zero argument. A function with zero parameters.</p>
</li>
<li>
<p><a name="BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi"></a><strong>parameter pack</strong> - In the context of <a href="#BM_(template)%2Fi">template</a>s, a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a> is a single <a href="#BM_(template%20parameter)%2Fi">template parameter</a> declaration that can take in zero or more substitutions (<a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function">X <span class="hljs-title">create</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> X {args...};
}
</code></pre>
</li>
<li>
<p><a name="BM_(variadic%7Cvararg)%2Fi"></a><strong>variadic</strong> - A function that takes in a variable number of arguments, sometimes also called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-type">float</span> sum {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        sum += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">return</span> sum /= n;
}
</code></pre>
</li>
<li>
<p><a name="BM_(template%20specialization)%2Fi"></a><strong>template specialization</strong> - Given a specific substitutions set substitutions for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s of a <a href="#BM_(template)%2Fi">template</a>, a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is code that overrides the <a href="#BM_(template)%2Fi">template</a> generated code. Oftentimes <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are introduced because they're more memory or computationally efficient than the standard <a href="#BM_(template)%2Fi">template</a> generated code.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// template specialization for bool: bitwise or</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-type">bool</span> <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b) {
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
</li>
<li>
<p><a name="BM_(partial%20template%20specialization%20%7C%20template%20partial%20specialization)%2Fi"></a><strong>partial template specialization</strong> - A <a href="#BM_(template%20specialization)%2Fi">template specialization</a> where not all of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s have been removed.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">R <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
};

<span class="hljs-comment">// template specialization for pointers of unknown type: already return false</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">bool</span>, X*&gt; {
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(X * a, X* b)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(partial%20template)%2Fi"></a><strong>partial template</strong> - A <a href="#BM_(template)%2Fi">template</a> with some of its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s set (not all).</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-keyword">using</span> MyClassPartialTemplate = MyClass&lt;<span class="hljs-type">float</span>, Y, Z, <span class="hljs-number">42</span>&gt;;

<span class="hljs-comment">// use</span>
MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt; x{}; 
MyClassPartialTemplate&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; y{};  <span class="hljs-comment">// same type as previous line</span>
</code></pre>
</li>
<li>
<p><a name="BM_(default%20template%20argument)%2Fi"></a><strong>default template argument</strong> - The default substitute in use for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y = <span class="hljs-type">long</span>, <span class="hljs-keyword">typename</span> Z = <span class="hljs-type">long</span>&gt;
X <span class="hljs-built_in">perform</span>(Y &amp;var1, Z &amp;var2) {
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
</li>
<li>
<p><a name="BM_(heap%7Cfree%20store)%2Fi"></a><strong>heap</strong> - An implementation-specific block of memory used for <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s. Also called the <a href="#BM_(heap%7Cfree%20store)%2Fi">free store</a>.</p>
</li>
<li>
<p><a name="BM_(implicit%20type%20conversion)%2Fi"></a><strong>implicit type conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is converted automatically, without code explicitly changing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to a different type (e.g. <code>long x {1}</code> implicitly converts the <code>int</code> literal in the initializer to the <code>long</code> type).</p>
</li>
<li>
<p><a name="BM_(explicit%20type%20conversion)%2Fi"></a><strong>explicit type conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is explicitly converted to another type: casting and <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>s.</p>
</li>
<li>
<p><a name="BM_(promotion%20rule)%2Fi"></a><strong>promotion rule</strong> - An <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> that may occur when an operator's operands are of differing integral and floating point types. For example, adding an integral type with a smaller integral type will cause the result to be of the same type as the larger type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">long</span> y {<span class="hljs-number">5L</span>};
<span class="hljs-keyword">auto</span> z {x + y};  <span class="hljs-comment">// z will be long</span>
</code></pre>
</li>
<li>
<p><a name="BM_(narrowing%20conversion)%2Fi"></a><strong>narrowing conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is truncated to a lesser type (e.g. <code>int</code> to <code>short</code>).</p>
<p><a href="#BM_(narrowing%20conversion)%2Fi">Narrowing conversion</a>s may be implicit during <a href="#BM_(object%20initialization)%2Fi">object initialization</a>. To erroneous cases of narrowing, use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> to force the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning.</p>
</li>
<li>
<p><a name="BM_(constant%20expression)%2Fi"></a><strong>constant expression</strong> - A function that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, such that at run-time any invocation of it simply returns the result computed at <a href="#BM_(compile-time)%2Fi">compile-time</a>. <a href="#BM_(constant%20expression)%2Fi">Constant expression</a>s are represented as functions prefixed with <code>constexpr</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span>;
}
</code></pre>
</li>
<li>
<p><a name="BM_(immediate%20function)%2Fi"></a><strong>immediate function</strong> - A function that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> and must produce a <a href="#BM_(compile-time)%2Fi">compile-time</a> constant. <a href="#BM_(immediate%20function)%2Fi">Immediate function</a>s expressions are represented as functions prefixed with <code>consteval</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span>;
}
</code></pre>
</li>
<li>
<p><a name="BM_(literal%20type)%2Fi"></a><strong>literal type</strong> - A type that's usable in a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> (for parameters and return), meaning that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of this type can have a value that's knowable at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>nullptr</code>).</p>
</li>
<li>
<p><a name="BM_(volatile)%2Fi"></a><strong>volatile</strong> - A <a href="#BM_(volatile)%2Fi">volatile</a> variable's usage in code is immune to <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> optimizations such as operation re-ordering and removal. Mutations and accesses, no matter how irrelevant they may seem, are kept in-place and in-order by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
x = <span class="hljs-number">5</span>;
x = <span class="hljs-number">6</span>;
x = <span class="hljs-number">7</span>;
</code></pre>
</li>
<li>
<p><a name="BM_(type%20alias)%2Fi"></a><strong>type alias</strong> - A synonym (different name) for an existing type.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> BasicGraph = DirectedGraph::Graph&lt;std::string, std::map&lt;std::string, std::string&gt;, std::string, std::map&lt;std::string, std::string&gt;&gt;;

<span class="hljs-function">BasicGraph <span class="hljs-title">removeLimbs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BasicGraph &amp;g)</span></span>;
</code></pre>
</li>
<li>
<p><a name="BM_(attribute)%2Fi"></a><strong>attribute</strong> - A tag applied to code that provides information to the user / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> about whatever it is that it's applied to. Similar to Java annotations.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) [[likely]] {
    <span class="hljs-keyword">return</span> x + y;
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">report_error</span>();
}
</code></pre>
</li>
<li>
<p><a name="BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi"></a><strong>iterator</strong> - A type used to access elements within some sequence (e.g. array, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> representing a list, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> representing an infinite stream of <code>int</code>s, etc..). An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> requires a specific set of operators to be implemented, where those operators function similar to accessing memory using <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> / arrays.</p>
<pre class="hljs"><code>MyIterator it {collection.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">while</span> (it != collection.<span class="hljs-built_in">end</span>()) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
    ++iterator;
}
</code></pre>
<p>Five types of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s exist:</p>
<ul>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that can only move forward in the sequence one element at a time and can only read elements of the sequence.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that can only move forward in the sequence one element at a time and can only write elements of the sequence.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that combines the functionality of both <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> and <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a>.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that has the same functionality as <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> but also allows for moving backward in the sequence one element at a time, meaning it
can move forward as well as backward.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that has the same functionality as <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> but also allows randomly jumping to different elements within the sequence.</li>
</ul>
</li>
<li>
<p><a name="BM_(specifier%7Cmodifier)%2Fi"></a><strong>modifier</strong> - Optional marker that alters a function. With functions, a <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> may be required to go either before the return type (prefix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>) or after the parameter list (suffix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>).</p>
<pre class="hljs"><code><span class="hljs-comment">//                  modifier here</span>
<span class="hljs-comment">//                    vvvvvvvv</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">noexcept</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}
</code></pre>
<p><a href="#BM_(specifier%7Cmodifier)%2Fi">Modifier</a>s are also sometimes referred to as <a href="#BM_(specifier%7Cmodifier)%2Fi">specifier</a>s.</p>
</li>
<li>
<p><a name="BM_(fold%20expression)%2Fi"></a><strong>fold expression</strong> - Exhaustively applies a binary operator to the contents of a <a href="#BM_(parameter%20pack%7Ctemplate%20parameter%20pack)%2Fi">parameter pack</a> and returns the final result.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(R... args)</span> </span>{
    R l_ass_res {... - args};  <span class="hljs-comment">// ((((a-b)-c)-d)-...)</span>
    R r_ass_res {args - ...};  <span class="hljs-comment">// (...-(w-(x-(y-z))))</span>
    <span class="hljs-keyword">return</span> l_ass_res + r_ass_res;
}
</code></pre>
</li>
<li>
<p><a name="BM_(associativity%7Cassociative)%2Fi"></a><strong>associativity</strong> - In the context of binary operators, <a href="#BM_(associativity%7Cassociative)%2Fi">associativity</a> refers to the order in which an expression with a chain of the same binary operator is evaluated. The term ...</p>
<ul>
<li>
<p>left <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> means that the chain is evaluated left-to-right (left-most first, right-most last).</p>
<pre class="hljs"><code>a ? b ? c ? d == (((a ? b) ? c) ? d)
</code></pre>
</li>
<li>
<p>right <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> means that the chain is evaluated right-to-left (right-most first, left-most last).</p>
<pre class="hljs"><code>a ? b ? c ? d == (a ? (b ? (c ? d)))
</code></pre>
</li>
</ul>
</li>
<li>
<p><a name="BM_(function%20pointer)%2Fi"></a><strong>function pointer</strong> - A <a href="#BM_(pointer)%2Fi">pointer</a> to a function.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-built_in">int</span> (*p)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {add};
<span class="hljs-built_in">p</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// invoke</span>
</code></pre>
</li>
<li>
<p><a name="BM_(functor%7Cfunction%20object)%2Fi"></a><strong>functor</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can invoke as if it were a function because it has an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> for the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};
</code></pre>
</li>
<li>
<p><a name="BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi"></a><strong>function call operator</strong> - The operator used for making function calls (parenthesis), may be <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ed on <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to turn them into <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
</code></pre>
</li>
<li>
<p><a name="BM_(lambda)%2Fi"></a><strong>lambda</strong> - Shorthand expression for an unnamed <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> -z; };
</code></pre>
</li>
<li>
<p><a name="BM_(closure)%2Fi"></a><strong>closure</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> / <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of a <a href="#BM_(lambda)%2Fi">lambda</a>.</p>
</li>
<li>
<p><a name="BM_(named%20capture)%2Fi"></a><strong>named capture</strong> - Pulling in <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope into a <a href="#BM_(lambda)%2Fi">lambda</a> by explicitly listing their names in the capture clause, adding <code>&amp;</code> before each name if wanting to pull it in by <a href="#BM_(reference)%2Fi">reference</a> rather than by copy.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [&amp;x, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; }; <span class="hljs-comment">// x and y from outer scope</span>
</code></pre>
</li>
<li>
<p><a name="BM_(default%20capture)%2Fi"></a><strong>default capture</strong> - Pulling in <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope into a <a href="#BM_(lambda)%2Fi">lambda</a> automatically (based on their usage) but putting either an <code>=</code> (for copying into <a href="#BM_(lambda)%2Fi">lambda</a>) or <code>&amp;</code> (for referencing into <a href="#BM_(lambda)%2Fi">lambda</a>) in the capture clause.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [=] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };
</code></pre>
</li>
<li>
<p><a name="BM_(init%20capture%7Cinitializer%20capture)%2Fi"></a><strong>init capture</strong> - An initializer expression used as a <a href="#BM_(lambda)%2Fi">lambda</a> <a href="#BM_(named%20capture)%2Fi">named capture</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [new_x=x/<span class="hljs-number">2</span>, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> new_x + y + z; };
</code></pre>
</li>
<li>
<p><a name="BM_(function-like%20object%7Ccallable%20object)%2Fi"></a><strong>callable object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that can be invoked: a function, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, or <a href="#BM_(lambda)%2Fi">lambda</a>.</p>
</li>
<li>
<p><a name="BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi"></a><strong>function overload</strong> - A function that has the same name as another function within the same scope.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0.0</span>; }
</code></pre>
</li>
<li>
<p><a name="BM_(operator%20overload%7Coverloaded%20operator)%2Fi"></a><strong>operator overload</strong> - A function that gets invoked when a certain operator is used with some specific <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. The function can be either a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> or a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the operator is intended for.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; } <span class="hljs-comment">// function call operator</span>
   ...
};
</code></pre>
</li>
<li>
<p><a name="BM_(forward%20declaration)%2Fi"></a><strong>forward declaration</strong> - To use a function, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, variable, etc.. within some C++ code, only its declaration is needed, not its definition (implementation). The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will ensure that the usage points to the implementation when the time comes.</p>
<p>The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> needs this to handle cyclical <a href="#BM_(reference)%2Fi">reference</a>s. It can also significantly reduce build times.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span>; <span class="hljs-comment">// forward declaration of MyClassA</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassB</span>; <span class="hljs-comment">// forward declaration of MyClassB</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClassA &amp;objA, MyClassB &amp;objB)</span></span>; <span class="hljs-comment">// forward declaration of a function</span>


<span class="hljs-comment">// implement myFunction, using MyClassA and MyClassB before implementation is defined</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClassA &amp;objA, MyClassB &amp;objB)</span> </span>{
    ...
}
<span class="hljs-comment">// implement MyClassA, using MyClassB before implementation is defined</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span> {
    ...
<span class="hljs-keyword">private</span>:
    MyClassB objB;
}
<span class="hljs-comment">// implement MyClassB</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span> {
    ...
<span class="hljs-keyword">private</span>:
    MyClassA objA;
}
</code></pre>
</li>
<li>
<p><a name="BM_(user-defined%20literal)%2Fi"></a><strong>user-defined literal</strong> - A literal suffix defined by a user, where when that suffix is applied to some literal, some computation is performed.</p>
<pre class="hljs"><code>Distance d {<span class="hljs-number">42.0</span>_km};  <span class="hljs-comment">// the suffix _km converts the literal 42.0 to an instance of the Distance type</span>
</code></pre>
</li>
<li>
<p><a name="BM_(module%20unit)%2Fi"></a><strong>module unit</strong> - A <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> that contains a module declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> MyModule;  <span class="hljs-comment">// module declaration</span>

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
</li>
<li>
<p><a name="BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi"></a><strong>three-way comparison operator</strong> - Given two <a href="#BM_(object%7Cinstance)%2Fi">object</a>s <code>a</code> and <code>b</code>, the three-way comparison operator determines if <code>a &lt; b</code>, <code>a == b</code>, or <code>a &gt; b</code>.</p>
<p>The symbol for the operator is an equal-sign sandwiched between angle brackets: <code>a &lt;=&gt; b</code>. This operator is sometimes called the <a href="#BM_(three%20way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a> because it's said that the symbol for the operator looks like a spaceship.</p>
</li>
<li>
<p><a name="BM_(smart%20pointer)%2Fi"></a><strong>smart pointer</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that wraps a <a href="#BM_(pointer)%2Fi">pointer</a> to a dynamically <a href="#BM_(object%7Cinstance)%2Fi">object</a>. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> provides some level of automated <a href="#BM_(pointer)%2Fi">pointer</a> management / memory management through the use of move semantics, <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>, and <a href="#BM_(RAII%7CCADRe)%2F">RAII</a>.</p>
</li>
<li>
<p><a name="BM_(namespace)%2Fi"></a><strong>namespace</strong> - C++'s mechanism of organizing code into a logical hierarchy / avoiding naming conflicts, similar to packages in Java or Python.</p>
</li>
<li>
<p><a name="BM_(unnamed%20namespace)%2Fi"></a><strong>unnamed namespace</strong> - A special <a href="#BM_(namespace)%2Fi">namespace</a> that limits the visibility of the code to the containing <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>, meaning that code can't be <a href="#BM_(reference)%2Fi">reference</a>d at all outside of the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</p>
</li>
<li>
<p><a name="BM_(universal%20reference)%2Fi"></a><strong>universal reference</strong> - A function <a href="#BM_(template)%2Fi">template</a> that automatically creates <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s based on whether the argument passed in for a parameter is a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> <a href="#BM_(reference)%2Fi">reference</a> or a <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// TEMPLATE where the parameter x is a universal reference</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp; x)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(x));  <span class="hljs-comment">// forward based on the reference type</span>
    }
}


<span class="hljs-comment">// When the type is an it, the above template expands to the following two overloads ...</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; x)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(x);            <span class="hljs-comment">// calls push_back(int &amp;x) / push_back(int x)</span>
    }
}  
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp; x)</span> </span>{
    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        vector.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(x)); <span class="hljs-comment">// calls push_back(int &amp;&amp;x)</span>
    }
}
</code></pre>
</li>
<li>
<p><a name="BM_(special%20member%20function)%2Fi"></a><strong>special member function</strong> - A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> which, if invoked but not explicitly implemented, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will automatically generate a default implementation for. Each of the following is considered a <a href="#BM_(special%20member%20function)%2Fi">special member function</a>: <a href="#BM_(default%20constructor)%2Fi">default constructor</a>, <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>, <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> operator, <a href="#BM_(move%20assignment)%2Fi">move assignment</a> operator, and <a href="#BM_(destructor)%2Fi">destructor</a>.</p>
</li>
</ul>
<p>


</p>
<p>
</p>
<p></p>

        </body></html>