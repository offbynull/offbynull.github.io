<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>C++</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href=".temp_githib_css/github-markdown.css" rel="stylesheet"><link href=".temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><p></p>
<div class="toc">
<ul>
<li><a href="#H_TODOs">TODOs</a></li>
<li><a href="#H_How%20to%20Read">How to Read</a></li>
<li><a href="#H_Essentials">Essentials</a></li>
<ul>
<li><a href="#H_Language%20Basics">Language Basics</a></li>
<li><a href="#H_Compilation%20Basics">Compilation Basics</a></li>
<li><a href="#H_Header%20Files">Header Files</a></li>
<li><a href="#H_Development%20Environment">Development Environment</a></li>
</ul>
<li><a href="#H_Core%20Language">Core Language</a></li>
<ul>
<li><a href="#H_Operators">Operators</a></li>
<li><a href="#H_Variables">Variables</a></li>
<ul>
<li><a href="#H_Core%20Types">Core Types</a></li>
<ul>
<li><a href="#H_Integral">Integral</a></li>
<li><a href="#H_Floating%20Point">Floating Point</a></li>
<li><a href="#H_Character%20String">Character String</a></li>
<li><a href="#H_Void">Void</a></li>
</ul>
<li><a href="#H_Arrays">Arrays</a></li>
<li><a href="#H_Pointers">Pointers</a></li>
<ul>
<li><a href="#H_Pointer%20Arithmetic">Pointer Arithmetic</a></li>
<li><a href="#H_Void%20Pointer">Void Pointer</a></li>
<li><a href="#H_Function%20Pointer">Function Pointer</a></li>
</ul>
<li><a href="#H_References">References</a></li>
<li><a href="#H_Rvalue%20References">Rvalue References</a></li>
<li><a href="#H_Size">Size</a></li>
<li><a href="#H_Aliasing">Aliasing</a></li>
<li><a href="#H_Constant">Constant</a></li>
<li><a href="#H_Volatile">Volatile</a></li>
<li><a href="#H_Type%20Deduction">Type Deduction</a></li>
<li><a href="#H_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Implicit%20Conversion">Implicit Conversion</a></li>
<li><a href="#H_Explicit%20Conversion">Explicit Conversion</a></li>
<ul>
<li><a href="#H_Named%20Conversions">Named Conversions</a></li>
<li><a href="#H_C-style%20Casts">C-style Casts</a></li>
</ul>
</ul>
<li><a href="#H_Object%20Lifecycle">Object Lifecycle</a></li>
<ul>
<li><a href="#H_Static%20Objects">Static Objects</a></li>
<li><a href="#H_Dynamic%20Objects">Dynamic Objects</a></li>
</ul>
<li><a href="#H_Functions">Functions</a></li>
<ul>
<li><a href="#H_Overloading">Overloading</a></li>
<li><a href="#H_Argument%20Matching">Argument Matching</a></li>
<li><a href="#H1_Type%20Deduction">Type Deduction</a></li>
<li><a href="#H_Main%20Function">Main Function</a></li>
<li><a href="#H_Variadic">Variadic</a></li>
<li><a href="#H_No%20Exception">No Exception</a></li>
<li><a href="#H1_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Coroutines">Coroutines</a></li>
</ul>
<li><a href="#H_Enumerations">Enumerations</a></li>
<li><a href="#H_Classes">Classes</a></li>
<ul>
<li><a href="#H_This%20Pointer">This Pointer</a></li>
<li><a href="#H1_Constant">Constant</a></li>
<li><a href="#H1_Volatile">Volatile</a></li>
<li><a href="#H2_Common%20Attributes">Common Attributes</a></li>
<li><a href="#H_Static">Static</a></li>
<li><a href="#H_Construction">Construction</a></li>
<li><a href="#H_Destruction">Destruction</a></li>
<li><a href="#H_Copying">Copying</a></li>
<li><a href="#H_Moving">Moving</a></li>
<li><a href="#H_Inheritance">Inheritance</a></li>
<li><a href="#H_Interfaces">Interfaces</a></li>
<li><a href="#H_Operator%20Overloading">Operator Overloading</a></li>
<li><a href="#H_Three-way%20Comparison%20Overloading">Three-way Comparison Overloading</a></li>
<li><a href="#H_Conversion%20Overloading">Conversion Overloading</a></li>
<li><a href="#H_Const%20%2F%20Volatile%20Overloading">Const / Volatile Overloading</a></li>
<li><a href="#H_Reference%20Overloading">Reference Overloading</a></li>
<li><a href="#H_Functors">Functors</a></li>
<li><a href="#H_Lambdas">Lambdas</a></li>
<li><a href="#H_Friends">Friends</a></li>
<li><a href="#H_User-defined%20Literals">User-defined Literals</a></li>
</ul>
<li><a href="#H_Templates">Templates</a></li>
<ul>
<li><a href="#H2_Type%20Deduction">Type Deduction</a></li>
<li><a href="#H_Concepts">Concepts</a></li>
<li><a href="#H1_Variadic">Variadic</a></li>
<li><a href="#H_Specialization">Specialization</a></li>
</ul>
<li><a href="#H_Unions">Unions</a></li>
<li><a href="#H_Namespaces">Namespaces</a></li>
<li><a href="#H_Linker%20Behaviour">Linker Behaviour</a></li>
<ul>
<li><a href="#H_Static%20Linkage">Static Linkage</a></li>
<li><a href="#H_Inline%20Linkage">Inline Linkage</a></li>
<li><a href="#H_External%20Linkage">External Linkage</a></li>
</ul>
<li><a href="#H_Control%20Flow">Control Flow</a></li>
<ul>
<li><a href="#H_If%20Statement">If Statement</a></li>
<li><a href="#H_Switch%20Statement">Switch Statement</a></li>
<li><a href="#H_For%20Loop">For Loop</a></li>
<li><a href="#H_While%20Loop">While Loop</a></li>
<li><a href="#H_Goto%20Statement">Goto Statement</a></li>
<li><a href="#H_Branching%20Likelihood">Branching Likelihood</a></li>
</ul>
<li><a href="#H_Attributes">Attributes</a></li>
<li><a href="#H_Constant%20Expressions">Constant Expressions</a></li>
<li><a href="#H_Exceptions">Exceptions</a></li>
<li><a href="#H_Structured%20Binding">Structured Binding</a></li>
<li><a href="#H_Expression%20Categories">Expression Categories</a></li>
<li><a href="#H_Iterators">Iterators</a></li>
<li><a href="#H_Modules">Modules</a></li>
<li><a href="#H_Preprocessor">Preprocessor</a></li>
<li><a href="#H_Inconsistent%20Behaviour">Inconsistent Behaviour</a></li>
<ul>
<li><a href="#H_Implementation-defined%20Behaviour">Implementation-defined Behaviour</a></li>
<li><a href="#H_Unspecified%20Behaviour">Unspecified Behaviour</a></li>
<li><a href="#H_Undefined%20Behaviour">Undefined Behaviour</a></li>
</ul>
</ul>
<li><a href="#H_Library%20Functions">Library Functions</a></li>
<ul>
<li><a href="#H_Allocators">Allocators</a></li>
<li><a href="#H_Smart%20Pointers">Smart Pointers</a></li>
<ul>
<li><a href="#H_Scoped%20Pointer">Scoped Pointer</a></li>
<li><a href="#H_Unique%20Pointer">Unique Pointer</a></li>
<li><a href="#H_Shared%20Pointer">Shared Pointer</a></li>
<li><a href="#H_Weak%20Pointer">Weak Pointer</a></li>
<li><a href="#H_Intrusive%20Pointer">Intrusive Pointer</a></li>
</ul>
<li><a href="#H_Containers">Containers</a></li>
<ul>
<li><a href="#H_Optional">Optional</a></li>
<li><a href="#H_Tuple">Tuple</a></li>
<li><a href="#H_Any">Any</a></li>
<li><a href="#H_Variant">Variant</a></li>
</ul>
<li><a href="#H_Time">Time</a></li>
<ul>
<li><a href="#H_Timestamps">Timestamps</a></li>
<ul>
<li><a href="#H_Clocks">Clocks</a></li>
<li><a href="#H_Conversions">Conversions</a></li>
</ul>
<li><a href="#H_Durations">Durations</a></li>
<li><a href="#H_Date%20and%20Time">Date and Time</a></li>
</ul>
<li><a href="#H_Random%20Numbers">Random Numbers</a></li>
<li><a href="#H_Numeric%20Limits">Numeric Limits</a></li>
<li><a href="#H_Numeric%20Conversions">Numeric Conversions</a></li>
</ul>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_TODOs"></a><h1>TODOs</h1>
<p>TODO: ch 9 at std::function / std::callable</p>
<p>TODO: C++20 coroutines section needs to be fleshed out better (no good source for this)</p>
<p>TODO: add section on equals/hashcode/tostring equivalents
-- operator== <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>
-- std::hash <a href="#BM_(template)%2Fi">template</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>: https://en.cpp<a href="#BM_(reference)%2Fi">reference</a>.com/w/cpp/utility/hash
-- friend function to ostringstream</p>
<p>TODO: streams</p>
<p>TODO: add terminology for declarations and definitions + add more example code into terminology</p>
<p>TODO: std::visit and <code>overloaded { }</code> -- add in a section for these, then go back and fix the std::variant section (and any other sections that can make use of it like std::vector) to refer to it (MOVE THE PIECES OUT OF STD::VARIANT SECTION INTO THE STD::VISIT -- USE SEEALSO TO <a href="#BM_(reference)%2Fi">REFERENCE</a> IT) -- https://dev.to/tmr232/that-<a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed-trick-<a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing-<a href="#BM_(lambda)%2Fi">lambda</a>s-in-c17   /     https://dzone.com/articles/two-lines-of-code-and-three-c17-features-the-overl</p>
<p>TODO: figure out C++20 date time functionality</p>
<p>TODO: unnamed namespaces  (https://en.cpp<a href="#BM_(reference)%2Fi">reference</a>.com/w/cpp/language/namespace)</p>
<p>TODO: std::formatter (INCLUDING the c++20 changes for std::format) https://en.cpp<a href="#BM_(reference)%2Fi">reference</a>.com/w/cpp/utility/format/formatter</p>
<a name="H_How%20to%20Read"></a><h1>How to Read</h1>
<p>This document is broken down into sections and sub-sections. To understand a specific section, you need to understand all of its parent sections as well as any prerequisites that it lists. For example, if section <code>Fruits/Apples/Granny Smith</code> has prerequisites <code>Vegetables/Peas</code> and <code>Fish</code> listed, you'll need to have read ...</p>
<ul>
<li><code>Fruits</code> (just that section, not its sub-sections)</li>
<li><code>Fruits/Apples</code> (just that section, not its sub-sections)</li>
<li><code>Vegetables/Peas</code> (that section and including ALL of its sub-sections)</li>
<li><code>Fish</code> (that section including ALL of its sub-sections)</li>
</ul>
<p>This is essentially a tree where each section is a node. To understand a node, you need to understand ...</p>
<ol>
<li>its ancestor nodes <strong>not including</strong> the children of those ancestors (these are the parent sections).</li>
<li>any nodes it links to <strong>as well as</strong> their descendants (these are the sections listed as prerequisites).</li>
</ol>
<a name="H_Essentials"></a><h1>Essentials</h1>
<p><a name="BM_(Essentials)_TOPIC%2F"></a><strong></strong></p>
<p>The following document is my attempt at charting out the various pieces of the modern C++ landscape, focusing on the 80% of features that get used most of the time rather than the 20% of highly esoteric / confusing features. It isn't comprehensive and some of the information may not be entirely correct / may be missing large portions.</p>
<p>The key points of similarity to remember:</p>
<ol>
<li>Scope in C++ is similar to Java/C# (e.g. function scope, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> scope, etc...). Variables, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, etc.. come into and leave out of scopes in similar ways.</li>
<li>Compound statements in C++ are similar Java/C#. They create a scope, and things declared in that scope are gone once the scope is exited.</li>
<li>Control flow statements in C++ are similar to Java/C#. All the basics are there: for loops, for-each loops, while loops, if-else, switch, etc...</li>
<li>Data can exist on the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a> or stack similar to Java/C#.</li>
</ol>
<p>The key point of dissimilarity to remember:</p>
<ol>
<li><strong>C++ does not come with a garbage collector</strong>. You are responsible for releasing memory, although the C++ standard library has a lot of pieces to help with this.</li>
<li>C++ has a lot of legacy baggage and many edge cases. Compared to Java/C#, the language is powerful but also deeply convoluted with many foot-guns and esoteric syntax / semantics.</li>
<li>C++ has a lot of ambiguous behaviour. Compared to Java/C#, the language specifically carves out pieces of the spec and leaves it as platform-specific behaviour, undefined behaviour, etc.. so that <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s have more room to optimize code.</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FInconsistent%20Behaviour)_TOPIC%2F">Core Language/Inconsistent Behaviour</a></li>
</ul>
</div>
<a name="H_Language%20Basics"></a><h2>Language Basics</h2>
<p><a name="BM_(Essentials%5C%2FLanguage%20Basics)_TOPIC%2F"></a><strong></strong></p>
<p>The following are a base set of language constructs required for understanding the rest of the document.</p>
<ol>
<li>
<p>The general purpose integral type is <code>int</code>.</p>
</li>
<li>
<p>Variables use the format <code>modifiers type name initializer</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// parenthesis</span>
<span class="hljs-type">int</span> c {<span class="hljs-number">0</span>}; <span class="hljs-comment">// curly braces</span>
</code></pre>
<p>C++ provides a bewildering number of ways to initialize a variable, each with its own set of edge cases. For best results, stick to the curly braces.</p>
</li>
<li>
<p>Functions use the format <code>modifiers return-type name(param-type1 arg-name1, param-type2 arg-name2, ...) modifiers { body }</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> x + a;
}
</code></pre>
<p>C++ functions don't necessarily have to be <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s (<a href="#BM_%5Cb(member)%2Fi">member</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
</li>
<li>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a>es use either <code>struct</code> or <code>class</code>.</p>
<p><code>struct</code> makes all <a href="#BM_%5Cb(member)%2Fi">member</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> public by default, while <code>class</code> makes them all private by default. <a href="#BM_%5Cb(member)%2Fi">Member</a>s need to be grouped together by visibility, where a visibility (e.g. <code>private</code>) is a label within the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
      <span class="hljs-keyword">return</span> x + a;
   }
<span class="hljs-keyword">private</span>: <span class="hljs-comment">// everything under this label is private</span>
   <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};
</code></pre>
</li>
<li>
<p>Source code often comes in pairs: A header file usually contains declarations (e.g. just the function's signature / prototype) while a C++ file usually contains definitions (e.g. the function implementation).</p>
<pre class="hljs"><code><span class="hljs-comment">// MyCode.hpp (header file w/ declarations)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-comment">// MyCode.cpp (source file w/ definitions)</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyCode.hpp"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> x + a;
}
</code></pre>
<p>This isn't required. Source files may contain declarations and / or header files may contain definitions, but the split is typically done for a variety of reasons: faster compile times, sharing the same <a href="#BM_(object%7Cinstance)%2Fi">object</a> across multiple source files, compiling when there are cyclical <a href="#BM_(reference)%2Fi">reference</a>s, etc..</p>
</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The above points aren't entirely correct or complete. They're generalizations that help set up a base for the explanations in the rest of the document.</p>
</div>
<p>The following is an example C++ program that prints "hello world" to stdout.</p>
<pre class="hljs"><code><span class="hljs-comment">// hello.cpp file</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"hello world\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The ...</p>
<ul>
<li><code>#include &lt;iostream&gt;</code> pulls in a library that lets you interface with stdout, stderr, and stdin.</li>
<li><code>int main() { ... }</code> is the entry point of the program.</li>
<li><code>std:cout &lt;&lt; ...</code> is what prints to stdout.</li>
<li><code>return 0</code> returns from the <code>main()</code> function, ending the program with an exit code of 0.</li>
</ul>
<p>Pretty much any modern C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will compile the above code. The output below uses the GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to compile the example, then runs the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<pre><code>$ g++ hello.cpp
$ ./a.out
hello world
</code></pre>
<a name="H_Compilation%20Basics"></a><h2>Compilation Basics</h2>
<p><a name="BM_(Essentials%5C%2FCompilation%20Basics)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Essentials%5C%2FLanguage%20Basics)_TOPIC%2F">Essentials/Language Basics</a></li>
</ul>
</div>
<p>Several C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s exist, the most popular of which are the GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> and LLVM clang. C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s generally follow the same set of steps to go from C++ code to an <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<ol>
<li>C++ source files get fed into a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> to generate <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s. A <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> is the C++ source file after going through modifications based on <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specifics, platform specifics, libraries used, compile options / library options, etc..</li>
<li><a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">Translation unit</a> files get fed into a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s. An <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a> is the intermediary compiled form of each individual <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</li>
<li><a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Object file</a>s get fed into a <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> to generate the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>. All <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s come together and linkages between them are made to form the final <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</li>
</ol>
<p><img src="svgbob_80c99337d0ee9d0afb6fdd8cc113d933be8d1ce9.svg" alt="Kroki diagram output"></p>
<p>The C++ language has a lot of legacy baggage, edge cases, and ambiguous behaviour. Regardless of the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> chosen, at least some of the following warning options should be enabled:</p>
<ul>
<li><code>-Wall</code> - Warns about questionable but easily avoidable constructs.</li>
<li><code>-Wextra</code> - Warns about other questionable constructs not covered by <code>-Wall</code>.</li>
<li><code>-Wpedantic</code> - Warns about ISO conformance.</li>
<li><code>-Weverything</code> - Turns on all warnings.</li>
</ul>
<p>Most <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s support some or all of the flags above.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A good online tool to try things in is <a href="https://cppinsights.io/">cppinsights</a>, which breaks down C++ code and allows you some visibility into what the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is doing / what the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> sees.</p>
</div>
<a name="H_Header%20Files"></a><h2>Header Files</h2>
<p><a name="BM_(Essentials%5C%2FHeader%20Files)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Essentials%5C%2FLanguage%20Basics)_TOPIC%2F">Essentials/Language Basics</a></li>
<li><a href="#BM_(Essentials%5C%2FCompilation%20Basics)_TOPIC%2F">Essentials/Compilation Basics</a></li>
</ul>
</div>
<p>For each source code file that gets compiled, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> needs to know that the entities (variables, functions, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, etc..) accessed within that file actually exist. The scope at which the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> keeps track of these entities is per source code file. For example, imagine a source code file that defines a function named <code>myFunction</code> (definition). There are 5 other source code files that call <code>myFunction</code> at some point. Each of those 5 other files is required to tell the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> what <code>myFunction</code> is (declaration) before it can invoke it.</p>
<p>One way to handle this scenario is to put <code>myFunction</code>'s declaration in each source code file that calls it.</p>
<pre class="hljs"><code><span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;
</code></pre>
<p>The problem with doing this is that ...</p>
<ol>
<li>you're duplicating something 5 times, meaning you need to update 5 different places should anything change with the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</li>
<li>you need a declaration for more than just <code>myFunction</code> (e.g. <code>myFunction</code> requires <code>OtherClass</code>, which may require even more entities).</li>
<li>as a result of 1 and 2, source code file sizes explode and quickly become unmanageable.</li>
</ol>
<p>The preferred way to handle this scenario is to put <code>myFunction</code>'s declaration into a header file. Then, any file that needs to know about <code>myFunction</code> can use the <code>#include</code> directive.,,</p>
<pre class="hljs"><code><span class="hljs-comment">// MyFunction.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span></span>
<span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-comment">// UsageFile1.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"MyFunction.hpp"</span></span>
<span class="hljs-built_in">myFunction</span>(<span class="hljs-number">44</span>);
</code></pre>
<p>If an entity is declared once already by an <code>#include</code>, it shouldn't be declared again.  For example, imagine that the file <code>Main.cpp</code> includes <code>ParentA.hpp</code> and <code>ParentB.hpp</code>. Both <code>ParentA.hpp</code> and <code>ParentB.hpp</code> then go on to include <code>Child.hpp</code>....</p>
<p><img src="svgbob_b33513cc90f4ec659ecb36587de9b266289fe213.svg" alt="Kroki diagram output"></p>
<p>The problem the above example scenario creates is that <code>Child.hpp</code> gets <code>#include</code>'d twice, meaning that everything in it is declared twice. To mitigate this problem, an include guard is typically provided in each header file.</p>
<pre class="hljs"><code><span class="hljs-comment">// MyFunction.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_FUNCTION_H <span class="hljs-comment">// include guard</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_FUNCTION_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span></span>
<span class="hljs-function">OtherClass <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>#ifdef</code>, <code>#define</code>, and <code>#endif</code> are <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros that aren't covered here. Look them up online if you need to.</p>
</div>
<p>You may notice that sometimes <code>#include</code> puts quotes around the files and sometimes angle brackets. Use quotes when the files are in the same directory structure, angle brackets when the files are coming from some external library.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>          <span class="hljs-comment">// library header</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span>  <span class="hljs-comment">// local header</span></span>
</code></pre>
<a name="H_Development%20Environment"></a><h2>Development Environment</h2>
<p><a name="BM_(Essentials%5C%2FDevelopment%20Environment)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Essentials%5C%2FCompilation%20Basics)_TOPIC%2F">Essentials/Compilation Basics</a></li>
</ul>
</div>
<p>There are many different <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s, IDEs, build systems, and dependency managers for C++.</p>
<p>Common <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s:</p>
<ul>
<li>GNU C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a></li>
<li>LLVM Clang</li>
<li>Microsoft Visual C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a></li>
</ul>
<p>Common IDEs:</p>
<ul>
<li>Visual Studio Code (open-source, multi-platform), commonly referred to as vscode</li>
<li>Visual Studio C++ (proprietary, Windows only)</li>
<li>CLion (proprietary, multi-platform)</li>
<li>KDevelop  (open-source, multi-platform)</li>
</ul>
<p>Common build systems:</p>
<ul>
<li>Make</li>
<li>Automake / Autoconf / Autotools</li>
<li>CMake</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>CMake isn't a build system itself, but a tool that generates the configuration needed for build systems. The idea is that, since C++ code can be compiled on many different platforms and build systems, this high-level tool can be used to generate the configuration for those build systems. For example, building on Linux is commonly done using Make while on Windows it's commonly done through Microsoft Visual Studio IDE project files. CMake can configure both using the same CMake script.</p>
</div>
<p>Common dependency managers:</p>
<ul>
<li>Conan</li>
<li>Vcpkg</li>
<li>Spack</li>
</ul>
<p>Of the tools above, the best mixture I've found so far is to use ...</p>
<ol>
<li>LLVM Clang as the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (installable via apt -- <code>apt install clang-12</code>)</li>
<li>Visual Studio Code as the editor (installable via snap -- <code>snap install --classic code</code>)</li>
<li>CMake as the build system  (installable via apt -- <code>apt install cmake</code>)</li>
<li>Conan as the dependency manager (install deb file from website)</li>
<li>C++ extension pack for vscode (install via extension section of vscode)</li>
<li>LLVM clangd extension for vscode (install via extension section of vscode)</li>
<li>C-Mantic extension for vscode (install via extension section of vscode)</li>
</ol>
<p>There are basic guides / tutorials for each of these tools available online. With the C++ extensions (5, 6, and 7), vscode (3) works similar to a professional IDE. It will parse a CMake configuration (3) to figure out how the code should be built as well as to provide C++ intellisense / auto-complete / formatting / debugging / etc.. support. Conan (4) integrates with CMake, so intellisense and builds through vscode automatically include the libraries.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Make sure to turn off the C++ extension's intellisense support or else it'll interfere with clangd's superior intellisense support. You can do this by adding the following to your <code>.vscode/settings.json file</code>...</p>
<pre class="hljs"><code><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"C_Cpp.intelliSenseEngine"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Disabled"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"C_Cpp.autocomplete"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Disabled"</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// So you don't get autocomplete from both extensions.</span>
    <span class="hljs-attr">"C_Cpp.errorSquiggles"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Disabled"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// So you don't get error squiggles from both extensions (clangd's seem to be more reliable anyway).</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Make sure that you don't have other C++ extensions installed. I'd initially installed a Makefile plugin into vscode that was tripping up the CMake plugin and breaking my intellisense.</p>
</div>
<p>Assuming you have all the software above installed, <a href="my_cpp_template.tar.xz">this cookie cutter template</a> can be used to set up a simple project structure that you can open directly in vscode. The <a href="#BM_(template)%2Fi">template</a> primes the project by ...</p>
<ol>
<li>creating a main source folder (<code>src/main</code>).</li>
<li>creating a test source folder (<code>src/test</code>).</li>
<li>setting Conan to download POCO C++ Libraries and Google Test.</li>
<li>setting CMake and Conan to use LLVM Clang 12.</li>
<li>setting CMake to build using C++20.</li>
<li>setting CMake to integrate with Conan.</li>
<li>setting CMake to recursive glob compile.</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I keep reading that globs aren't recommended in CMake. If you don't use globs, you'll have to go in and manually add in each source file into the CMake configuration.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that ...</p>
<ul>
<li>vscode will automatically reconfigure CMake on any change to the configuration file.</li>
<li>vscode will build your code when you hit F7.</li>
</ul>
<p>Conan changes ARE NOT automatically picked up. You need to re-run conan (from <code>./build</code> -- see the cookie cutter <a href="#BM_(template)%2Fi">template</a> post hook) to pick up any library changes.</p>
</div>
<a name="H_Core%20Language"></a><h1>Core Language</h1>
<p><a name="BM_(Core%20Language)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Essentials)_TOPIC%2F">Essentials</a></li>
</ul>
</div>
<p>The following subsection loosely details core C++ language features. It isn't comprehensive and some of the information may not be entirely correct / may be missing large portions.</p>
<a name="H_Operators"></a><h2>Operators</h2>
<p><a name="BM_(Core%20Language%5C%2FOperators)_TOPIC%2F"></a><strong></strong></p>
<p>The following is a list of operators available in C++. Some operators are obvious, while others are explained in other sections.</p>
<p><strong>Bitwise Logical Operators</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitwise AND         (<code>&amp;</code>)</td>
<td><code>0b1011 &amp; 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise OR          (<code>|</code>)</td>
<td><code>0b1011 | 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise XOR         (<code>^</code>)</td>
<td><code>0b1011 ^ 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise NOT         (<code>~</code>)</td>
<td><code>~0b1011</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise left-shift  (<code>&lt;&lt;</code>)</td>
<td><code>0b1011 &lt;&lt; 2</code></td>
<td></td>
</tr>
<tr>
<td>Bitwise right-shift (<code>&gt;&gt;</code>)</td>
<td><code>0b1011 &gt;&gt; 2</code></td>
<td>Results on signed may be different than unsigned.</td>
</tr>
</tbody>
</table>
<p><strong>Boolean Logical Operators</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logical AND (<code>&amp;&amp;</code>)</td>
<td><code>true &amp;&amp; true</code></td>
<td></td>
</tr>
<tr>
<td>Logical OR  (<code>||</code>)</td>
<td><code>true || false</code></td>
<td></td>
</tr>
<tr>
<td>Logical NOT (<code>!</code>)</td>
<td><code>!true</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Arithmetic Operators</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unary Plus      (<code>+</code>)</td>
<td><code>+10</code></td>
<td></td>
</tr>
<tr>
<td>Unary Minus     (<code>-</code>)</td>
<td><code>-10</code></td>
<td></td>
</tr>
<tr>
<td>Addition        (<code>+</code>)</td>
<td><code>1 + 2</code></td>
<td></td>
</tr>
<tr>
<td>Subtraction     (<code>-</code>)</td>
<td><code>2 - 1</code></td>
<td></td>
</tr>
<tr>
<td>Multiplication  (<code>*</code>)</td>
<td><code>2 * 3</code></td>
<td></td>
</tr>
<tr>
<td>Division        (<code>/</code>)</td>
<td><code>6 / 2</code></td>
<td></td>
</tr>
<tr>
<td>Modulo          (<code>%</code>)</td>
<td><code>6 % 4</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>There are implicit rules for how <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>s get promoted. The general rule of thumb is that the result of the operator is promoted to the operand with the "greater" type. For example, if an <code>int</code> is added to a <code>float</code>, the result will be a <code>float</code>.</p>
<p>These rules are similar to those in other languages (e.g. Java and Python).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If confused, use type deduction via the <code>auto</code> keyword: <code>auto x {5 + y}</code>, then check to see what the type of <code>y</code> is in the IDE or using <code>typeid</code>.</p>
</div>
<p><strong>Assignment Operators</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Assignment                     (<code>=</code>)</td>
<td><code>x = 5</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise AND         (<code>&amp;=</code>)</td>
<td><code>x &amp;= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise OR          (<code>|=</code>)</td>
<td><code>x |= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise XOR         (<code>^=</code>)</td>
<td><code>x ^= 0b0110</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise left-shift  (<code>&lt;&lt;=</code>)</td>
<td><code>x &lt;&lt;= 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Bitwise right-shift (<code>&gt;&gt;=</code>)</td>
<td><code>x &gt;&gt;= 2</code></td>
<td>Result  on signed may be different than unsigned.</td>
</tr>
<tr>
<td>Assignment Addition            (<code>+=</code>)</td>
<td><code>x += 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Subtraction         (<code>-=</code>)</td>
<td><code>x -= 1</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Multiplication      (<code>*=</code>)</td>
<td><code>x *= 3</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Division            (<code>/=</code>)</td>
<td><code>x /= 2</code></td>
<td></td>
</tr>
<tr>
<td>Assignment Modulo              (<code>%=</code>)</td>
<td><code>x %= 4</code></td>
<td></td>
</tr>
<tr>
<td>Increment                      (<code>++</code>)</td>
<td><code>x++</code></td>
<td>Applicable BEFORE or AFTER the operand: <code>++x</code> returns the value AFTER modification, <code>x++</code> returns the value BEFORE modification.</td>
</tr>
<tr>
<td>Decrement                      (<code>--</code>)</td>
<td><code>x--</code></td>
<td>Applicable BEFORE or AFTER the operand: <code>--x</code> returns the value AFTER modification, <code>x--</code> returns the value BEFORE modification.</td>
</tr>
</tbody>
</table>
<p>All assignment operators work similar to those in Java except for the increment and decrement operators. Due to the confusion it causes, Java disallows the increment / decrement from returning a value, meaning that it can't be used in an expression. Not so in C++. In addition to modifying the variable passed as the operand, in C++ these operators also return a result, meaning that it's okay to increment / decrement operator within some larger expression.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> y {(x++) + <span class="hljs-number">2</span>};
<span class="hljs-comment">// at this point, x is 4, y is 5</span>
<span class="hljs-type">int</span> a {<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> b {(++a) + <span class="hljs-number">2</span>};
<span class="hljs-comment">// at this point, a is 4, b is 6</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You probably shouldn't do this because it gets confusing. Also, incrementing/decrementing the same variable more than once in the same expression isn't defined behaviour: The order of  incrementing/decrementing can change based on whatever the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> thinks is best, meaning that the results won't be consistent across different platforms / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> options / etc...</p>
</div>
<p><strong>Comparison Operator</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equal To                 (<code>==</code>)</td>
<td><code>5 == 7</code></td>
<td></td>
</tr>
<tr>
<td>Not Equal To             (<code>!=</code>)</td>
<td><code>5 != 7</code></td>
<td></td>
</tr>
<tr>
<td>Less Than                (<code>&lt;</code>)</td>
<td><code>5 &lt; 7</code></td>
<td></td>
</tr>
<tr>
<td>Less Than Or Equal To    (<code>&lt;=</code>)</td>
<td><code>5 &lt;= 7</code></td>
<td></td>
</tr>
<tr>
<td>Greater Than             (<code>&gt;</code>)</td>
<td><code>5 &gt; 7</code></td>
<td></td>
</tr>
<tr>
<td>Greater Than Or Equal To (<code>&gt;=</code>)</td>
<td><code>5 &gt;= 7</code></td>
<td></td>
</tr>
<tr>
<td>Three-way Comparison     (<code>&lt;=&gt;</code>)</td>
<td><code>5 &lt;=&gt; 7</code></td>
<td>Returns a special ordering type, not boolean (discussed in <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a> section).</td>
</tr>
</tbody>
</table>
<p>In addition, the ternary conditional operator is a pseudo operator that takes in 3 operands similar to those found in other high-level languages: <code>CONDITION ? EXPRESSION_IF_TRUE : EXPRESSION_IF_FALSE</code>. It's essentially a shorthand if-else block.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {n % <span class="hljs-number">7</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">1000</span> : <span class="hljs-number">-1000</span>};
<span class="hljs-comment">// equiv to...</span>
<span class="hljs-keyword">if</span> (n % <span class="hljs-number">7</span> == <span class="hljs-number">1</span>) {
    x = <span class="hljs-number">1000</span>;
} <span class="hljs-keyword">else</span> {
    x = <span class="hljs-number">-1000</span>;
}
</code></pre>
<p><strong><a href="#BM_%5Cb(member)%2Fi">Member</a> Access Operators</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Subscript         (<code>[]</code>)</td>
<td><code>x[0]</code></td>
<td></td>
</tr>
<tr>
<td>Indirection       (<code>*</code>)</td>
<td><code>*x</code></td>
<td>Doesn't conflict with arithmetic multiplication operator because this is a unary operator.</td>
</tr>
<tr>
<td><a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">Address Of</a>        (<code>&amp;</code>)</td>
<td><code>&amp;x</code></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi">Member Of Object</a>  (<code>.</code>)</td>
<td><code>x.member</code></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">Member Of Pointer</a> (<code>-&gt;</code>)</td>
<td><code>x-&gt;member</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>These operators are used in scenarios that deal with accessing the <a href="#BM_%5Cb(member)%2Fi">member</a>s of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. element in an array, <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) or dealing with memory addresses / <a href="#BM_(pointer)%2Fi">pointer</a>s. The subscript and and <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi">member of object</a> operators are similar to their counterparts in other high-level languages (e.g. Java, Python, C#, etc..). The others are unique to languages with support for lower-level programming like C++. Their usage is detailed in other sections.</p>
<p><strong><a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a> Operators</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a>       (<code>new</code>)</td>
<td><code>new int</code></td>
<td></td>
</tr>
<tr>
<td>Create <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Array</a>      (<code>new[]</code>)</td>
<td><code>new int[50]</code></td>
<td></td>
</tr>
<tr>
<td>Destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Object</a>   (<code>delete</code>)</td>
<td><code>delete x</code></td>
<td></td>
</tr>
<tr>
<td>Destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">Dynamic Array</a>  (<code>delete[]</code>)</td>
<td><code>delete[] x</code></td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you already know about <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s and arrays and <a href="#BM_(constructor)%2Fi">constructor</a>s/<a href="#BM_(destructor)%2Fi">destructor</a>s, make sure you delete an array using <code>delete[]</code>. It makes sure to call the <a href="#BM_(destructor)%2Fi">destructor</a> for each element of the array.</p>
</div>
<p><strong>Size Operator</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Example</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size (<code>sizeof</code>)</td>
<td><code>sizeof x]</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>This operator gets the size of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> in bytes. Note that an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s byte size may not be indicative of the da may include padding required by the platform (e.g. an <a href="#BM_(object%7Cinstance)%2Fi">object</a> requiring 5 bytes may get expanded to 8 bytes because the platform requires 8 byte boundary alignments).</p>
<p><strong>Other Operators</strong></p>
<p>C++ provides a set of other operators such as the ...</p>
<ul>
<li>comma operator (<code>,</code>).</li>
<li><a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function call operator</a> (<code>()</code>).</li>
<li>conversion operator (e.g. casting).</li>
<li><a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a> operator (e.g. <code>_</code>)</li>
</ul>
<p>While it isn't worth going into them in detail here, the reason the language explicitly lists them as operators is because they're <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>-able (e.g. <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing). <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">Overload</a>ing these operators is heavily discouraged since doing so causes confusion.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions the comma operator specifically. It doesn't look like this is used for much and the book recommends against using it for anything (e.g. <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing) due to the confusion it causes. This gives off similar vibes to Python's tuple syntax, where you can pass an unenclosed tuple as a subscript to something. When I was learning Python, that also came off as very confusing.</p>
<pre class="hljs"><code>x = obj[<span class="hljs-string">'column name'</span>, <span class="hljs-number">100</span>]
</code></pre>
</div>
<a name="H_Variables"></a><h2>Variables</h2>
<p><a name="BM_(Core%20Language%5C%2FVariables)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FOperators)_TOPIC%2F">Core Language/Operators</a>: Just basic ones like comparison and arithmetic.</li>
</ul>
</div>
<p>C++ variable declarations have the following form: <code>modifiers type name initializer</code>.</p>
<ul>
<li>
<p><strong>type</strong> (required) - Type of variable.</p>
</li>
<li>
<p><strong>name</strong>: (required) - Name of variable.</p>
</li>
<li>
<p><strong>initializer</strong>: (optional) - Initia<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> to assign (<a href="#BM_(object%20initialization)%2Fi">object initialization</a>).</p>
<p>There are multiple ways to initialize a variable, each with their own advantages and disadvantages.</p>
<ul>
<li><a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> / <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">uniform initialization</a>: braces used for initialization (e.g. <code>int x {a + b}</code>).</li>
<li><a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a>: equals sign used for initialization (e.g. <code>int x = 5</code>).</li>
<li><a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a>: equals sign and braces used for initialization (e.g. <code>int x = { a + b }</code>).</li>
<li>etc..</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The above is an over-simplification. The ways to initialize are vast and complex. See <a href="https://en.cppreference.com/w/cpp/language/initialization">here</a> for a full accounting and <a href="https://youtu.be/7DTlWPgX6zs">here</a> for an hour long talk about the edge cases.</p>
<p>It seems like the safest bet is to always use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">brace initialization</a> where possible. Just use the braces as if they were parentheses or braces in Java (specific to the context). The others have surprising behaviour (e.g. they won't warn about <a href="#BM_(narrowing%20conversion)%2Fi">narrowing conversion</a>s).</p>
</div>
</li>
<li>
<p><strong><a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a variable.</p>
<p>(e.g. <code>const</code>, <code>volatile</code>, <code>constexpr</code>, <code>inline</code>, ...)</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-type">int</span> a;     <span class="hljs-comment">// no initializer -- garbage possibly contained at memory location</span>
<span class="hljs-type">int</span> b {};  <span class="hljs-comment">// empty initializer -- zeros out the memory for the int</span>
<span class="hljs-type">int</span> c {<span class="hljs-number">0</span>}; <span class="hljs-comment">// assign to constant 0</span>
<span class="hljs-type">int</span> d {c}; <span class="hljs-comment">// assign to value in c</span>
</code></pre>
<p>In C++, variables that are <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s (assigned to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) are called <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s. This section deals with non-<a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s (e.g. scoped somewhere other than a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> -- global, inside a function, etc..).</p>
<a name="H_Core%20Types"></a><h3>Core Types</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FOperators)_TOPIC%2F">Core Language/Operators</a> (just the basics like comparison and arithmetic)</li>
</ul>
</div>
<p>The following sections list out core C++ types and their analogs. These include numeric types, character types, and string types.</p>
<a name="H_Integral"></a><h4>Integral</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FIntegral)_TOPIC%2F"></a><strong></strong></p>
<p>C++'s core integer types are as follows...</p>
<ol>
<li><code>short int</code></li>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ol>
<p>The above integer types come in two forms: signed and unsigned. The range of ...</p>
<ul>
<li>unsigned integers start at 0 and end at a positive integer.</li>
<li>signed integers start at a negative integer and positive integer.</li>
</ul>
<p>By default, the integer types above are signed (speculation). Signed-ness can be explicitly stated by prefixing either <code>signed</code> or <code>unsigned</code> to the type, but if the type is signed the prefix is usually omitted.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short int</code>     / <code>signed short int</code></td>
<td><code>unsigned short int</code></td>
</tr>
<tr>
<td><code>int</code>           / <code>signed int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>long int</code>      / <code>signed long int</code></td>
<td><code>unsigned long int</code></td>
</tr>
<tr>
<td><code>long long int</code> / <code>signed long long int</code></td>
<td><code>unsigned long long int</code></td>
</tr>
</tbody>
</table>
<p>Integer types <code>char int</code>, <code>short int</code>, <code>long int</code>, and <code>long long int</code> can optionally omit the <code>int</code> keyword.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short</code>     / <code>signed short</code></td>
<td><code>unsigned short</code></td>
</tr>
<tr>
<td><code>int</code>       / <code>signed int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>long</code>      / <code>signed long</code></td>
<td><code>unsigned long</code></td>
</tr>
<tr>
<td><code>long long</code> / <code>signed long long</code></td>
<td><code>unsigned long long</code></td>
</tr>
</tbody>
</table>
<p>The only guarantees for core integer types are that ...</p>
<ul>
<li>each integer type tier must be able to cover the same range as the tier before it (e.g. range of <code>short</code> &gt;= range of <code>int</code>).</li>
<li>unsigned integer types start at 0.</li>
<li>unsigned integer types overflow behaviour is to wrap to 0.</li>
</ul>
<p>All other specifics are platform-dependent. Specifically, ...</p>
<ul>
<li>range is undefined.</li>
<li>bit length is undefined (e.g. 8, 16, etc..).</li>
<li>endian-ness is undefined (e.g. big-endian vs little-endian).</li>
<li>encoding scheme of <em>signed</em> types is two's complement (as of C++20), but underflow/overflow behaviour of <em>signed</em> types is undefined (e.g. crash, stay at boundary, wrap back around, etc..).</li>
</ul>
<p>Integer ranges, although platform-specific, are queryable in the climits header.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>min</th>
<th>max</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed short</code></td>
<td><code>SHRT_MIN</code></td>
<td><code>SHRT_MAX</code></td>
</tr>
<tr>
<td><code>signed int</code></td>
<td><code>INT_MIN</code></td>
<td><code>INT_MAX</code></td>
</tr>
<tr>
<td><code>signed long</code></td>
<td><code>LONG_MIN</code></td>
<td><code>LONG_MAX</code></td>
</tr>
<tr>
<td><code>signed long long</code></td>
<td><code>LLONG_MIN</code></td>
<td><code>LLONG_MAX</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td><code>0</code></td>
<td><code>USHRT_MAX</code></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td><code>0</code></td>
<td><code>UINT_MAX</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td><code>0</code></td>
<td><code>ULONG_MAX</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td><code>0</code></td>
<td><code>ULLONG_MAX</code></td>
</tr>
</tbody>
</table>
<p>By default, literals are represented using base10. Literals may be presented in different bases via the prefix.</p>
<table>
<thead>
<tr>
<th>base</th>
<th>literal prefix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 (binary)</td>
<td>0b</td>
<td><code>0b1111</code></td>
</tr>
<tr>
<td>8 (octal)</td>
<td>0</td>
<td><code>016</code></td>
</tr>
<tr>
<td>10 (decimal)</td>
<td></td>
<td><code>15</code></td>
</tr>
<tr>
<td>16 (hex)</td>
<td>0x</td>
<td><code>0xF</code></td>
</tr>
</tbody>
</table>
<p>Integer literals are targeted to specific integer types by their suffix.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>literal suffix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed short</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>signed int</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>signed long</code></td>
<td>L</td>
<td><code>2L</code></td>
</tr>
<tr>
<td><code>signed long long</code></td>
<td>LL</td>
<td><code>2LL</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>U</td>
<td><code>2U</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>UL</td>
<td><code>2UL</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td>ULL</td>
<td><code>2ULL</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Notice that <code>int</code>, <code>short</code>, and <code>unsigned short</code> don't have explicit suffixes. If no suffix is present, it's an int (speculation). To get it to a short, the easiest way is to cast it: <code>(short) 2</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits header. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<p>Integer types with standardized bit lengths are defined in the cstdlib header.</p>
<table>
<thead>
<tr>
<th>signed</th>
<th>unsigned</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>intmax_t</code></td>
<td><code>uintmax_t</code></td>
<td>widest possible bit length</td>
</tr>
<tr>
<td><code>int8_t</code></td>
<td><code>uint8_t</code></td>
<td>exactly 8 bits</td>
</tr>
<tr>
<td><code>int16_t</code></td>
<td><code>uint16_t</code></td>
<td>exactly 16 bits</td>
</tr>
<tr>
<td><code>int32_t</code></td>
<td><code>uint32_t</code></td>
<td>exactly 32 bits</td>
</tr>
<tr>
<td><code>int64_t</code></td>
<td><code>uint64_t</code></td>
<td>exactly 64 bits</td>
</tr>
<tr>
<td><code>int_least8_t</code></td>
<td><code>uint_least8_t</code></td>
<td>8 bits  or greater</td>
</tr>
<tr>
<td><code>int_least16_t</code></td>
<td><code>uint_least16_t</code></td>
<td>16 bits or greater</td>
</tr>
<tr>
<td><code>int_least32_t</code></td>
<td><code>uint_least32_t</code></td>
<td>32 bits or greater</td>
</tr>
<tr>
<td><code>int_least64_t</code></td>
<td><code>uint_least64_t</code></td>
<td>64 bits or greater</td>
</tr>
<tr>
<td><code>int_fast8_t</code></td>
<td><code>uint_fast8_t</code></td>
<td>8 bits  or greater</td>
</tr>
<tr>
<td><code>int_fast16_t</code></td>
<td><code>uint_fast16_t</code></td>
<td>16 bits or greater</td>
</tr>
<tr>
<td><code>int_fast32_t</code></td>
<td><code>uint_fast32_t</code></td>
<td>32 bits or greater</td>
</tr>
<tr>
<td><code>int_fast64_t</code></td>
<td><code>uint_fast64_t</code></td>
<td>64 bits or greater</td>
</tr>
<tr>
<td><code>intptr_t</code></td>
<td><code>uintptr_t</code></td>
<td>wide enough to hold a void *</td>
</tr>
<tr>
<td></td>
<td><code>size_t</code></td>
<td>wide enough to hold the maximum number of bytes of something in memory</td>
</tr>
</tbody>
</table>
<p>The minimum and maximum extents of each type are defined in <code>{TYPE}_MIN</code> and <code>{TYPE}_MAX</code>, where <code>{TYPE}</code> doesn't include the <code>_t</code> suffix. For example the maximum value an <code>uint64_t</code> can be is <code>UINT64_MAX</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not all types guaranteed to be present (e.g. 64-bit types may be missing if the platform can't support it). Unsigned types don't have a minimum extent defined because a minimum of any unsigned integer type is always 0 (e.g. uint64_t can't go any lower than 0).</p>
</div>
<p>To expand any integer <strong>literal</strong> to a ...</p>
<ul>
<li><code>intmax_t</code>, use the macro <code>INTMAX_C(...)</code>.</li>
<li><code>uintmax_t</code>, use the macro <code>UINTMAX_C(...)</code>.</li>
<li><code>int{N}_t</code>, use the macro <code>INT{N}_C(...)</code> (where <code>{N}</code> is the bit length).</li>
<li><code>uint{N}_t</code>, use the macro <code>UINT{N}_C(...)</code> (where <code>{N}</code> is the bit length).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There is no macro <code>SIZE_C(...)</code> for <code>size_t</code>. Best to just assign a `size_t to one of the other types's literals and hope the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warns about any <a href="#BM_(narrowing%20conversion)%2Fi">narrowing conversion</a>s that might happen.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What's the point of the above? You don't know what internal integer type each standardized type maps to. For example, <code>uint64_t</code> may map to <code>unsigned long long</code>, which means when you want to assign a literal to a variable of that type you need to add a <code>ULL</code> suffix...</p>
<p><code>uint64_t test {9999999999999999999ULL}</code></p>
<p>The macros above make it so that you don't need to know the underlying mapping...</p>
<p><code>uint64_t test {UINT64_C(9999999999999999999)}</code></p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<a name="H_Floating%20Point"></a><h4>Floating Point</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FFloating%20Point)_TOPIC%2F"></a><strong></strong></p>
<p>C++'s core floating point types are as follows...</p>
<table>
<thead>
<tr>
<th>type</th>
<th>description</th>
<th>literal suffix</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td>single precision</td>
<td><code>f</code></td>
<td><code>123.0f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>double precision</td>
<td></td>
<td><code>123.0</code></td>
</tr>
<tr>
<td><code>long double</code></td>
<td><a href="#BM_(extends%3F%7Csubclass)%2Fi">extend</a>ed precision</td>
<td><code>L</code></td>
<td><code>123.0L</code></td>
</tr>
</tbody>
</table>
<p>The specifics of each type are platform-dependent. The only guarantee is that each type has to hold at least the same range as the type before it (e.g. <code>double</code>'s range should cover <code>float</code>'s range). Other than that, ...</p>
<ul>
<li>rounding mode is undefined.</li>
<li>exponent bit length is undefined.</li>
<li>mantissa bit length is undefined.</li>
<li>subnormal number support is undefined.</li>
</ul>
<p>Floating point characteristics, although platform-specific, are queryable in the cfloat header.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>min</th>
<th>max</th>
<th>min exponent</th>
<th>max exponent</th>
<th>mantissa digits</th>
<th>radix</th>
<th>epsilon</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td><code>FLT_MIN</code></td>
<td><code>FLT_MAX</code></td>
<td><code>FLT_MIN_EXP</code></td>
<td><code>FLT_MAX_EXP</code></td>
<td><code>FLT_MANT_DIG</code></td>
<td><code>FLT_RADIX</code></td>
<td><code>FLT_EPSILON</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>DBL_MIN</code></td>
<td><code>DBL_MAX</code></td>
<td><code>DBL_MIN_EXP</code></td>
<td><code>DBL_MAX_EXP</code></td>
<td><code>DBL_MANT_DIG</code></td>
<td><code>DBL_RADIX</code></td>
<td><code>DBL_EPSILON</code></td>
</tr>
<tr>
<td><code>long double</code></td>
<td><code>LDBL_MIN</code></td>
<td><code>LDBL_MAX</code></td>
<td><code>LDBL_MIN_EXP</code></td>
<td><code>LDBL_MAX_EXP</code></td>
<td><code>LDBL_MANT_DIG</code></td>
<td><code>LDBL_RADIX</code></td>
<td><code>LDBL_EPSILON</code></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Mantissa digits is the number of digits (of the base specified in radix) that the floating point type uses (speculation).</p>
<p>Epsilon is the difference between 1 and the floating point number just before 1.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(sizeof)%2Fi">sizeof</a> operator should NOT be used to infer limits / characteristics of a floating point type. For example, a <code>sizeof(long double)</code> 16 doesn't necessarily mean that the type is a quadruple precision float (128-bit). Rather, it's likely that the floating point type has less precision but the platform requires padding.</p>
</div>
<p>The rounding behaviour of all floating point types is queryable via <code>FLT_ROUNDS</code>, where a ...</p>
<ul>
<li>-1 means undetermined.</li>
<li>0 means toward zero.</li>
<li>1 means toward whichever is nearest.</li>
<li>2 means toward positive infinity.</li>
<li>3 means toward negative infinity.</li>
</ul>
<p>The floating point evaluation behaviour is queryable via <code>FLT_EVAL_METHOD</code>, where a ...</p>
<ul>
<li>-1 means undetermined.</li>
<li>0 means evaluate just to the range and precision of the type.</li>
<li>1 means evaluate float and double as double, and long double as long double.</li>
<li>2 means evaluate all as long double</li>
<li>negative value other than -1 means platform-specific behavior.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unsure about the last point. How's the last point any different than -1?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I see online that <code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code>, and <code>DECIMAL_DIG</code> define the number of "decimal digits" that can be converted to floating point and back without a loss in precision. I'm assuming that just means the max number of digits that can be represented in a float where exp is 1?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also <code>std::numeric_limits</code> in the limits header. This seems to also provide platform-specific definitions that are queryable via functions..</p>
</div>
<a name="H_Character%20String"></a><h4>Character String</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FCharacter%20String)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FIntegral)_TOPIC%2F">Core Language/Variables/Core Types/Integral</a></li>
</ul>
</div>
<p>Core C++ strings are represented as an array of characters, where that array ends with a null character to signify its end. This is in contrast to other major platforms that typically structure strings a size integer along with the array (no null terminator).</p>
<p>Individual characters all map to integer types, where literals are defined by wrapping the character in single quotes. Even though they're integers, the signed-ness of each of the types below isn't guaranteed.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>bits</th>
<th>literal prefix</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>&gt;= 8</td>
<td></td>
<td><code>'T'</code></td>
<td>&gt;= 8-bit wide character (smallest unit of memory -- 1 byte)</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>16</td>
<td><code>u</code></td>
<td><code>u'T'</code></td>
<td>16-bit wide character (e.g. UTF-16)</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>32</td>
<td><code>U</code></td>
<td><code>U'T'</code></td>
<td>32-bit wide character (e.g. UTF-32)</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td></td>
<td><code>L</code></td>
<td><code>L'T'</code></td>
<td>at least as wide as <code>char</code></td>
</tr>
</tbody>
</table>
<p>Note that <code>char</code> and <code>wchar_t</code> don't have predefined bit lengths. They are platform-dependent. The bit length for...</p>
<ul>
<li><code>char</code> is defined in <code>CHAR_BIT</code> of climits and must be at least 8 bits.</li>
<li><code>wchar_t</code> must be equal to or greater than that of <code>char</code>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>char</code> literals can also be integers, but the signed-ness of the <code>char</code> type isn't defined by default (speculation). It can specifically be made to be signed / unsigned by prefixing it as such: <code>signed char</code> / <code>unsigned char</code>.</p>
</div>
<p>Strings literals are wrapped in double quotes instead of single quotes, where they get transformed into an array terminated by a null character.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>literal prefix</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char *</code></td>
<td></td>
<td><code>"hello"</code></td>
<td>unknown encoding (platform specific?)</td>
</tr>
<tr>
<td><code>wchar_t *</code></td>
<td><code>L</code></td>
<td><code>L"hello"</code></td>
<td>unknown encoding (platform specific?)</td>
</tr>
<tr>
<td><code>char16_t *</code></td>
<td><code>u</code></td>
<td><code>u"hello"</code></td>
<td>encoded as UTF-16</td>
</tr>
<tr>
<td><code>char32_t *</code></td>
<td><code>U</code></td>
<td><code>U"hello"</code></td>
<td>encoded as UTF-32</td>
</tr>
<tr>
<td><code>char8_t *</code></td>
<td><code>u8</code></td>
<td><code>u8"hello"</code></td>
<td>encoded as UTF-8</td>
</tr>
</tbody>
</table>
<p>Typically escaping rules apply to string literals. Unescaped string literals are allowed by adding an <code>R</code> at the end of the literal prefix, which make it so that the ...</p>
<ol>
<li>starting quote requires a custom delimiter immediately after it.</li>
<li>finishing quote requires a custom delimited immediately before it.</li>
</ol>
<p>These delimiter characters are characters that aren't encountered in the contents of the string itself. For example, in <code>u8R"|hello|"</code>, the delimiter is <code>|</code> and isn't included in the resulting UTF-8 string.</p>
<a name="H_Void"></a><h4>Void</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCore%20Types%2FVoid)_TOPIC%2F"></a><strong></strong></p>
<p><code>void</code> is a type that represents an empty set of values. Since it can't hold a value, C++ won't allow you to declare an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type void. However, you can use it to declare that a function ...</p>
<ul>
<li>returns no value (<code>void</code> return).</li>
<li>accepts no arguments (<code>void</code> parameter list).</li>
</ul>
<a name="H_Arrays"></a><h3>Arrays</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a>: Just the main section, not any of the subsections.</li>
</ul>
</div>
<p>C++ allows for the creation of arrays of constant length (size of the array must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a>). Elements of an array are guaranteed to be contiguous in memory (speculation).</p>
<ul>
<li><code>int x[100]</code> - Creates an array of 100 ints where those 100 ints are junk values (data previously at that memory location is not zeroed out).</li>
<li><code>int x[] { 5, 5, 5 }</code> - Creates an array of 3 ints where each of those ints have been initialized to 5 (<a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>).</li>
<li><code>int x[] = { 5, 5, 5 }</code> - Equivalent to above (assignment does not do any extra work).</li>
<li><code>int x[3] {}</code> - Creates an array of 3 ints where each of those ints are 0 (memory zeroed out -- <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>).</li>
<li><code>int x[3] = {}</code> - Equivalent to above (assignment does not do any extra work).</li>
<li><code>int x[n]</code> - Disallowed by C++ if n isn't a constant. These types of arrays are allowed in C (called <a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>s / <a href="#BM_(VLA)%2F">VLA</a>), but not in C++ because C++ has collection <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that allow for sizes not known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</li>
</ul>
<p>Accessing arrays is done similarly to how it is in most other languages, by subscripting (e.g. <code>x[0] = 5</code>). The only difference is that array access isn't bounds-checked and array length information isn't automatically maintained at run-time. For example, if an array has 100 elements, C++ won't stop you from trying to access element 250 -- out-of-bounds array access is undefined behaviour.</p>
<p>One way to think of an array is as a <a href="#BM_(pointer)%2Fi">pointer</a> to a contiguous block of elements of the array type. In fact, if an array type gets used where it isn't expected, that array type automatically decays to a <a href="#BM_(pointer)%2Fi">pointer</a> type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *x)</span> </span>{
   <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
   <span class="hljs-type">int</span> y { <span class="hljs-built_in">test</span>(x) };
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>My understanding is that arrays are typically passed to functions as <a href="#BM_(pointer)%2Fi">pointer</a>s + array length. This is because the array length information is only available at <a href="#BM_(compile-time)%2Fi">compile-time</a>, meaning that if you have a function that takes in an array, how would it know the size of the array it's working with when it runs (it isn't the one who declared it). It looks like a function parameter can be an array type of fixed size, but apparently that doesn't mean anything? The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> doesn't enforce that a caller use an array of that fixed size, and using <a href="#BM_(sizeof)%2Fi">sizeof</a> on the array will produce a warning saying that it's decaying into a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> x[<span class="hljs-number">10</span>])</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(x); <span class="hljs-comment">// compiler warning that this is returning sizeof(int *)</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
   <span class="hljs-type">size_t</span> y { <span class="hljs-built_in">test</span>(x) }; <span class="hljs-comment">// compiler doesn't complain that test() expects int[10] but this is int[3]</span>
   cout &lt;&lt; y;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p>Be careful when using the <code>sizeof</code> operator on an array. If the type is the original array type, <code>sizeof</code> will return the number of bytes taken up by the elements of that array (known at <a href="#BM_(compile-time)%2Fi">compile-time</a>). However, if the type has decayed to a <a href="#BM_(pointer)%2Fi">pointer</a> type, <code>sizeof</code> will return the number of bytes to hold on to a <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[<span class="hljs-number">3</span>];
<span class="hljs-type">int</span> *y {x};  <span class="hljs-comment">// equiv to setting to &amp;(x[0]);</span>
cout &lt;&lt; <span class="hljs-keyword">sizeof</span> x;  <span class="hljs-comment">// should be the size of 3 ints</span>
cout &lt;&lt; <span class="hljs-keyword">sizeof</span> y;  <span class="hljs-comment">// should be the size of a pointer</span>
</code></pre>
<p>Similarly, range-based for loops won't work if the type has decayed to a <a href="#BM_(pointer)%2Fi">pointer</a> type because the array size of that <a href="#BM_(pointer)%2Fi">pointer</a> isn't known at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> *y {x};
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i {<span class="hljs-number">0</span>}; i &lt; <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// OK</span>
   cout &lt;&lt; y[i] &lt;&lt; endl;
}
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : x) { <span class="hljs-comment">// OK</span>
   cout &lt;&lt; v &lt;&lt; endl;
}
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : y) { <span class="hljs-comment">// ERROR</span>
   cout &lt;&lt; v &lt;&lt; endl;
}
</code></pre>
<p>You may be tempted to use <code>sizeof(array) / sizeof(type)</code> to determine the number of elements within an array. It's a better idea to use <code>std::size(array)</code> instead (found in the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> header) because it should have logic to workaround and platform-specific behaviours that might cause inconsistent results / unexpected behaviour (speculation).</p>
<a name="H_Pointers"></a><h3>Pointers</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
</ul>
</div>
<p>C++ provides types that <a href="#BM_(reference)%2Fi">reference</a> a memory address, called <a href="#BM_(pointer)%2Fi">pointer</a>s. Variables of these types can point to different memory addresses / <a href="#BM_(object%7Cinstance)%2Fi">object</a>s.</p>
<p>Adding an asterisk (*) to the end of any type makes it a <a href="#BM_(pointer)%2Fi">pointer</a> type (e.g. <code>int *</code> is a type that can contain a <a href="#BM_(pointer)%2Fi">pointer</a> to an <code>int</code>). A <a href="#BM_(pointer)%2Fi">pointer</a> to any <a href="#BM_(object%7Cinstance)%2Fi">object</a> can be retrieved using the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> unary operator (&amp;). Similarly, the value in any <a href="#BM_(pointer)%2Fi">pointer</a> can be retrieved using the <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> unary operator (*).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *x { &amp;w }; <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> *y { &amp;w }; <span class="hljs-comment">// y points to w</span>
<span class="hljs-type">int</span> z { *x };   <span class="hljs-comment">// z is a copy of whatever x points to, which is w, which means it gets set to 5</span>
*x = <span class="hljs-number">7</span>;        <span class="hljs-comment">// w is set to 5 through x</span>

<span class="hljs-type">int</span> **a { &amp;x }; <span class="hljs-comment">// a points to x, which points to w (a pointer to a pointer to an int)</span>
</code></pre>
<p>As shown in the example above, it's perfectly valid to use the <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> operator on the left-side of the equals. It defines where the result of the right side should go.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *x { &amp;w };  <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> **y { &amp;x }; <span class="hljs-comment">// y point to x, which points to w</span>

**y = <span class="hljs-number">7</span>;        <span class="hljs-comment">// y dereferenced twice and set to 7 -- w should now be 7 </span>
</code></pre>
<p>The notation is confusing because asterisk (*) has different meanings. In the context of a ...</p>
<ul>
<li>type declaration, an asterisk means that the type is a "<a href="#BM_(pointer)%2Fi">pointer</a> to" some other type.</li>
<li>unary operator in an expression, an asterisk means the <a href="#BM_(object%7Cinstance)%2Fi">object</a> being pointed to should be accessed.</li>
<li>binary operator in an expression, an asterisk means multiplication.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See also: <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator.</p>
</div>
<p>In addition, a <a href="#BM_(pointer)%2Fi">pointer</a> can optionally be set to nothing via the <code>nullptr</code> literal. <code>nullptr</code> is actually of type <code>std::nullptr_t</code>, but the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will implicit conversion to/from other <a href="#BM_(pointer)%2Fi">pointer</a> types when required.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> *y { <span class="hljs-literal">nullptr</span> }; <span class="hljs-comment">// implicit conversion</span>
<span class="hljs-keyword">if</span> (y == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// report error</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It seems like there's some implicit conversions to boolean that are possible with <a href="#BM_(pointer)%2Fi">pointer</a>s. If whatever the <a href="#BM_(pointer)%2Fi">pointer</a> is going to expect a boolean, it's implicitly converted to <code>ptr != nullptr</code>? So in if / while/ for conditions, you can just use the <a href="#BM_(pointer)%2Fi">pointer</a> as is without explicitly writing out a condition?</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>How is this different than the NULL macro? I guess because it's a distance type, you can have a <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> that takes in param of type <code>std::nullptr_t</code>? But why would you ever want to do that?</p>
</div>
<a name="H_Pointer%20Arithmetic"></a><h4>Pointer Arithmetic</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers%2FPointer%20Arithmetic)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<p>Certain arithmetic operators are allowed on <a href="#BM_(pointer)%2Fi">pointer</a>s, called <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>. Adding or subtracting integer types on a <a href="#BM_(pointer)%2Fi">pointer</a> will move that <a href="#BM_(pointer)%2Fi">pointer</a> by the number of bytes that makes up its underlying type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> []x = {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-type">int</span> *ptrA { &amp;(x[<span class="hljs-number">1</span>]) };  <span class="hljs-comment">// points to idx 1 of x (5)</span>
<span class="hljs-type">int</span> *ptrB { ptrA + <span class="hljs-number">1</span> }; <span class="hljs-comment">// points to idx 2 of x (7)</span>
</code></pre>
<p>This is similar to array access via the subscript operator. In fact, both arrays and <a href="#BM_(pointer)%2Fi">pointer</a>s can be accessed in the same way using the subscript operator and <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">int</span> *y {x};
*(y+<span class="hljs-number">1</span>) = <span class="hljs-number">99</span>;  <span class="hljs-comment">// equivalent to x[1] = 99</span>
x[<span class="hljs-number">2</span>] = <span class="hljs-number">101</span>;   <span class="hljs-comment">// equivalent to *(y+2) = 101;</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>An array guarantees that its elements appear contiguously and in order within memory (I think?), so if the <a href="#BM_(pointer)%2Fi">pointer</a> is from a decayed array, using <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> to access its elements is perfectly fine.</p>
</div>
<a name="H_Void%20Pointer"></a><h4>Void Pointer</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers%2FVoid%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(pointer)%2Fi">pointer</a> to the void type means that the type being pointed to is unknown. Since the type is unknown, <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a void <a href="#BM_(pointer)%2Fi">pointer</a> isn't possible. In other words, it isn't possible to read or write to the data pointed to by a void * because the underlying type is void / unknown.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">void</span> *y { x };
*y = <span class="hljs-number">2</span>; <span class="hljs-comment">// fails</span>
</code></pre>
<p>Since the underlying type of the <a href="#BM_(pointer)%2Fi">pointer</a> is unknown, <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> isn't allowed either.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-type">void</span> *y { x };
y = y + <span class="hljs-number">2</span>; <span class="hljs-comment">// fails</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you have a <code>void *</code> and you want to do raw memory manipulation at that address, use a <code>std::byte *</code> instead. Why not just use <code>char *</code> instead? Is a <code>char</code> guaranteed to be 1 byte (I think it is)? According to <a href="https://stackoverflow.com/a/46151026">this</a>, it's because certain assumptions about <code>char</code>s may not hold with bytes? I don't know. Just remember <code>std::byte *</code> if you're working with raw data.</p>
</div>
<a name="H_Function%20Pointer"></a><h4>Function Pointer</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FPointers%2FFunction%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know what a function is / how to define one.</li>
</ul>
</div>
<p>A <a href="#BM_(pointer)%2Fi">pointer</a> to a function means the type being pointed to is a function with some specific structure. All functions have a type associated with them, defined by their return type, parameter type, and owning <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> if the function is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// type is: int (int, int)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>To declare a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> to a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> or a static <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, write out the function type (return type and parameter list without names) but place the <a href="#BM_(pointer)%2Fi">pointer</a> name preceded by an asterisk (*) <em>wrapped in parenthesis</em> where the function name would be. Invoke it just like you would any other function.</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {}; <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a * b;
}

func_ptr = &amp;add;  <span class="hljs-comment">// point func_ptr to address of add()</span>
<span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// invoke</span>
</code></pre>
<p>To declare a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> to a non-static <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>), the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type needs to be included before the asterisk (*) using the scoped resolution operator (::).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (MyClass::*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {}; <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)  in or inherited from MyClass</span>

MyClass x {};

func_ptr { &amp;MyClass::multiply }; <span class="hljs-comment">// point to:  int MyClass::multiply(int, int)</span>
(x.*func_ptr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);             <span class="hljs-comment">// provide x as the MyClass instance when invoking</span>
</code></pre>
<p>Unlike normal functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s cannot be assigned to raw <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s. A <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s equivalent of a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> is a <a href="#BM_(pointer)%2Fi">pointer</a> to the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> (MyFunctor::*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {};  <span class="hljs-comment">// unset pointer to a function of structure  int (int, int)  in or inherited from MyClass</span>

MyFunctor x {};

func_ptr { &amp;MyFunctor::<span class="hljs-built_in">operator</span>() };
(x.*func_ptr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// provide x as the MyClass instance when invoking</span>
</code></pre>
<p>Alternatively, to support both functions and <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, the parameter expecting a <a href="#BM_(function%20pointer)%2Fi">function pointer</a> should be changed to the <code>std::function</code> or the code doing the invocation should be changed to use the <code>std::invoke</code> wrapper. These wrappers abstract away the differences between <a href="#BM_(pointer)%2Fi">pointer</a>s to functions and <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s.</p>
<a name="H_References"></a><h3>References</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>C++ provides a more sanitized version of <a href="#BM_(pointer)%2Fi">pointer</a>s called <a href="#BM_(reference)%2Fi">reference</a>s. A <a href="#BM_(reference)%2Fi">reference</a> type is declared by adding an ampersand (&amp;) after the type rather than an asterisk (*), and it implicitly takes the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> whatever is passed into it when it's created.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> w {<span class="hljs-number">5</span>};

<span class="hljs-type">int</span> *x { &amp;w }; <span class="hljs-comment">// x points to w</span>
<span class="hljs-type">int</span> &amp;y { w };  <span class="hljs-comment">// y references to w (note address-of operator not used here)</span>
</code></pre>
<p>The main difference between <a href="#BM_(pointer)%2Fi">pointer</a> types and <a href="#BM_(reference)%2Fi">reference</a> types is that a <a href="#BM_(reference)%2Fi">reference</a> type doesn't need to explicitly <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> to access the <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to. The <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to by the <a href="#BM_(reference)%2Fi">reference</a> type is accessed as if it were the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself.</p>
<pre class="hljs"><code>*x = <span class="hljs-number">10</span>;       <span class="hljs-comment">// x explicitly dereferenced to w and set to 10</span>
y = <span class="hljs-number">15</span>;        <span class="hljs-comment">// y implicitly dereferenced to w and set to 15</span>
</code></pre>
<p>As shown in the example above, assignment to a <a href="#BM_(reference)%2Fi">reference</a> type is assignment on the underlying <a href="#BM_(object%7Cinstance)%2Fi">object</a> being <a href="#BM_(reference)%2Fi">reference</a>d. As such, having the <a href="#BM_(reference)%2Fi">reference</a> type point to a different <a href="#BM_(object%7Cinstance)%2Fi">object</a> isn't possible (<a href="#BM_(reseat)%2Fi">reseat</a>ing).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>One way to think of this is that it's implicitly <code>const</code> -- the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't let you explicitly set a <a href="#BM_(reference)%2Fi">reference</a> to be <code>const</code>.</p>
</div>
<p>Similarly, it's not possible to have a <a href="#BM_(reference)%2Fi">reference</a> to a <a href="#BM_(reference)%2Fi">reference</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> &amp;&amp;z { y }; <span class="hljs-comment">// this isn't a thing -- fail</span>
</code></pre>
<a name="H_Rvalue%20References"></a><h3>Rvalue References</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FExpression%20Categories)_TOPIC%2F">Core Language/Expression Categories</a></li>
</ul>
</div>
<p>An <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> is similar to a <a href="#BM_(reference)%2Fi">reference</a> except that it tells the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that it's working with an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a>. <a href="#BM_(rvalue%20reference)%2Fi">Rvalue reference</a>s are declared by adding two ampersands (&amp;&amp;) after the type rather than just one. It's initialized using the <code>std::move()</code> function within the utility header, which casts its input into an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>.</p>
<p><a href="#BM_(rvalue%20reference)%2Fi">Rvalue reference</a>s are typically used for moving <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (not copying, but actually moving the guts of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another). This is typically done through something called a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, which will be explained further on.</p>
<pre class="hljs"><code>MyObject a {};
MyObject &amp;&amp;b { std::<span class="hljs-built_in">move</span>(a) }; <span class="hljs-comment">// get rvalue reference</span>
MyObject c {b};                <span class="hljs-comment">// move a into c (gut it into c) via the move constructor</span>
<span class="hljs-comment">// b is in an invalid state</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Once an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is moved, it's in an invalid state. The only two reliable operations you can perform on it is to either destroy or re-assign it to something else (assignments are discussed elsewhere).</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There's a piece here I don't fully understand about "forwarding <a href="#BM_(reference)%2Fi">reference</a>s". See <a href="https://github.com/AnthonyCalandra/modern-cpp-features#forwarding-references">here</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<a name="H_Size"></a><h3>Size</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FSize)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p><code>sizeof</code> is a unary operator that returns the size of its operand in bytes as a <code>size_t</code> type. If the operand is a ...</p>
<ul>
<li>
<p>data type or a variable, it'll return the number of bytes needed to hold that type. For example, ...</p>
<ul>
<li><code>sizeof char</code> is guaranteed to be 1.</li>
<li><code>sizeof (char &amp;)</code> is guaranteed to be 1.</li>
<li><code>sizeof (char *)</code> is platform dependent, typically either 4 or 8.</li>
<li><code>char * x { "hi" }; sizeof x</code> is equivalent to <code>sizeof (char *)</code> (see above).</li>
</ul>
</li>
<li>
<p>an expression such as a structure/<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> literal, array literal, or string literal, it'll return the number of bytes needed to hold it. For example, ...</p>
</li>
<li>
<p><code>sizeof "hi"</code> is 3 (added 1 for the null terminator at the end)</p>
</li>
<li>
<p><code>sizeof { 5, 5, 4 }</code> is platform dependent, typically either 12 or 24.</p>
</li>
<li>
<p><code>sizeof (int[3])</code> is platform dependent, typically either 12 or 24.</p>
</li>
<li>
<p><code>x = int[n]; sizeof x</code> is invalid C++ (<a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>s <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d on stack are not allowed in C++).</p>
</li>
</ul>
<p>In other words, <code>sizeof</code> returns the size of things known at <a href="#BM_(compile-time)%2Fi">compile-time</a>. If a variable is passed in, it outputs the size of the data type. For example, if the data type is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">struct</a> of type <code>MyStruct</code>, it'll return the number of bytes used to store a <code>MyStruct</code>. However, if the data type is a <a href="#BM_(pointer)%2Fi">pointer</a> to <code>MyStruct</code>, it'll return the number of bytes to hold that <a href="#BM_(pointer)%2Fi">pointer</a>. That is, you can't use it to get the size of something like a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamically allocated array</a> of integers.</p>
<p>In certain cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may add padding to <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (e.g. byte boundary alignments or performance reasons), meaning that the size returned by <code>sizeof</code> for an <a href="#BM_(object%7Cinstance)%2Fi">object</a> shouldn't be used to make inferences about the characteristics of that <a href="#BM_(object%7Cinstance)%2Fi">object</a>. For example, a <code>long double</code> may get reported as being 16 bytes, but that doesn't necessarily mean that a <code>long double</code> is a 128-bit quad floating point. It could be that only 12 of those bytes are used to represent the floating point number while the remainder is just padding for alignment reasons.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>As shown in the examples above, the <code>sizeof</code> a C++ <a href="#BM_(reference)%2Fi">reference</a> is equivalent to the raw size. For example, <code>sizeof char == sizeof (char &amp;)</code>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The last example is valid in C99 (called a <a href="#BM_(VLA)%2F">VLA</a> -- <a href="#BM_(variable%20length%20array)%2Fi">variable length array</a>) but not C++. The reason is C++ has std::vector and std::array that give you basically the same thing as variable arrays.</p>
<p>In C, where <a href="#BM_(VLA)%2F">VLA</a>s are allowed, doing a <code>sizeof</code> on a <a href="#BM_(VLA)%2F">VLA</a> is undefined.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Remember that <code>sizeof</code> is a unary operator, similar to how the negative sign is a unary operator that negates whatever is to the right of it. People usually structure its usage in code as if it were a function (e.g. <code>sizeof(x)</code> vs <code>sizeof x</code>). This sometimes causes confusion for people coming from other languages.</p>
</div>
<a name="H_Aliasing"></a><h3>Aliasing</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FAliasing)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>The <code>using</code> keyword is used to give synonyms to types. Other than having a new name, a <a href="#BM_(type%20alias)%2Fi">type alias</a> is the exact same as the originating type.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> IntegerButWithNewName = <span class="hljs-type">int</span>;
<span class="hljs-type">int</span> x {<span class="hljs-number">42</span>};
IntegerButWithNewName y {<span class="hljs-number">42</span>};    <span class="hljs-comment">// equivalent to:  int y {42};</span>
IntegerButWithNewName z {x + y}; <span class="hljs-comment">// equivalent to:  int z {x + y};</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">float</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">short</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(IntegerButWithNewName x)</span></span>;  <span class="hljs-comment">// NOT ALLOWED -- this overload is equivalent to the overload above</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>To allow for use-cases such as the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing case in the example above, the cleanest solution is to wrap the type in a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a></p>
</div>
<p>The benefit of <a href="#BM_(type%20alias)%2Fi">type alias</a>ing is that it helps shorten type names, which can be especially useful when using a <a href="#BM_(template)%2Fi">template</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> BasicGraph = DirectedGraph::Graph&lt;std::string, std::map&lt;std::string, std::string&gt;, std::string, std::map&lt;std::string, std::string&gt;&gt;;

<span class="hljs-function">BasicGraph <span class="hljs-title">removeLimbs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BasicGraph &amp;g)</span></span>;
</code></pre>
<a name="H_Constant"></a><h3>Constant</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FConstant)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>For types, any part of that type can be made unmodifiable by adding a <code>const</code> immediately after it.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a {<span class="hljs-number">5</span>};                <span class="hljs-comment">// a is changeable   -- set to 5</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">const</span> x {a};          <span class="hljs-comment">// x is unchangeable -- set to 5 (value in a)</span>
<span class="hljs-type">int</span> * <span class="hljs-keyword">const</span> y {&amp;a};       <span class="hljs-comment">// y is an unchangeable pointer to a changeable int -- set to a (points to a)</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> z {&amp;x}; <span class="hljs-comment">// z is an unchangeable pointer to a unchangeable int -- set to x (points to x)</span>
</code></pre>
<p>The simplest way to interpret <code>const</code>-ness of a type is to read it from right-to-left.</p>
<p><img src="svgbob_fd16b9b8d1538355ffda7cde58e62b3e35887712.svg" alt="Kroki diagram output"></p>
<p>One caveat to the above is that a type beginning with <code>const</code> is equivalent to the first part of that type having <code>const</code> applied on it.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};  <span class="hljs-comment">// equivalent to int const x {5}</span>
</code></pre>
<p>All of the examples above were for <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>s. Appending a <code>const</code> on a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type works exactly the same way: None of its <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are modifiable ever, even by its own <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>}
};

MyStruct <span class="hljs-keyword">const</span> inst {};
inst.x = <span class="hljs-number">5</span>;  <span class="hljs-comment">// compiler error</span>
</code></pre>
<a name="H_Volatile"></a><h3>Volatile</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FVolatile)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unlike in Java, The <code>volatile</code> keyword in C++ is <em>not</em> used for thread-safety.</p>
</div>
<p>Adding the keyword <code>volatile</code> before a type makes it immune to <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> optimizations such as operation re-ordering and removal. Mutations and accesses, no matter how irrelevant they may seem, are kept in-place and in-order by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-type">int</span> x {a};
    x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y {x};
    <span class="hljs-type">int</span> x {y};
    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// at this point, x is always 6</span>
}
</code></pre>
<p>A <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> might be able to deduce that the function above always returns 6, and as such may replace the operations it performs with simply just returning 6. Adding <code>volatile</code> to the type of the variable prevents this from happening.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> x {a};  <span class="hljs-comment">// marked as volatile</span>
    x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y {x};
    <span class="hljs-type">int</span> x {y};
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>Using <code>volatile</code> is important when working with embedded devices, where platform-specific memory locations often need to be accessed in a specific order / at specific intervals in seemingly useless ways (e.g. kicking a watchdog by writing 0 to a memory location but never reading that memory location).</p>
<a name="H_Type%20Deduction"></a><h3>Type Deduction</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FType%20Deduction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
</ul>
</div>
<p>The keyword <code>auto</code> may be used during a variable declaration to deduce the resulting type of that variable from whatever it's being initialized with.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> a { <span class="hljs-number">1</span> };  <span class="hljs-comment">// int</span>
<span class="hljs-keyword">auto</span> b { <span class="hljs-number">1L</span> }; <span class="hljs-comment">// long</span>
<span class="hljs-keyword">auto</span> c { &amp;a }; <span class="hljs-comment">// int *</span>
<span class="hljs-keyword">auto</span> d { *c }; <span class="hljs-comment">// int</span>
<span class="hljs-keyword">auto</span> &amp;e { a }; <span class="hljs-comment">// int &amp;  &lt;-- THIS IS A SPECIAL CASE. YOU ALWAYS NEED TO USE auto&amp; FOR REFERENCES</span>
</code></pre>
<p>Note that the last variable in the example above explicitly the ampersand (&amp;) to declare e as a <a href="#BM_(reference)%2Fi">reference</a> type. This is required because <a href="#BM_(reference)%2Fi">reference</a> initialization works the same way as normal initialization (<code>auto</code> can't disambiguate).</p>
<p>In addition to <code>auto</code>, it's possible to copy the type from ...</p>
<ul>
<li>some existing entity (e.g. en existing variable)</li>
<li>the result of an expression (e.g. <code>(x + 13L) / 2</code>)</li>
</ul>
<p>... using <code>decltype()</code> . This is useful in scenarios where it's difficult or impossible to determine the exact type (e.g. <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x{};
<span class="hljs-keyword">decltype</span>((x + <span class="hljs-number">13L</span>) / <span class="hljs-number">2</span>) myNum{}; <span class="hljs-comment">// myNum type is whatever type "(x + 13L) / 2" evaluates to</span>
</code></pre>
<a name="H_Common%20Attributes"></a><h3>Common Attributes</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FCommon%20Attributes)_TOPIC%2F"></a><strong></strong></p>
<p>If a variable has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it sees it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-type">int</span> my_variable;
</code></pre>
<a name="H_Implicit%20Conversion"></a><h3>Implicit Conversion</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FImplicit%20Conversion)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
</ul>
</div>
<p>An <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> is when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is converted (cast) automatically, without code explicitly changing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to a different type. For example, <code>long x {1}</code> implicitly converts the <code>int</code> literal in the initializer to a <code>long</code>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">long</span> y {x};  <span class="hljs-comment">// int to long</span>
</code></pre>
<p>The most common types of implicit conversions are ...</p>
<ul>
<li>when a <a href="#BM_(pointer)%2Fi">pointer</a> of a certain type gets implicitly converted to a void <a href="#BM_(pointer)%2Fi">pointer</a> (e.g. <code>int *</code> to <code>void *</code>).</li>
<li>when a numeric type gets converted to another numeric type via <a href="#BM_(promotion%20rule)%2Fi">promotion rule</a>s (e.g. <code>int</code> to <code>float</code>).</li>
<li>when a numeric type gets converted to a bool type (e.g. <code>0</code> to <code>false</code>)</li>
</ul>
<p>Depending on the operation performed or how an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is initialized, the results of an implicit conversion may do something specific to that platform and/or <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> implementation.</p>
<table>
<thead>
<tr>
<th>Source Type</th>
<th>Destination Type</th>
<th>Behaviour</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>Floating Point</td>
<td>Implementation-specific behaviour if can't fit in destination (speculation).</td>
</tr>
<tr>
<td>Floating Point</td>
<td>Integer</td>
<td>Rounded to integer (speculation - how?), implementation-specific behaviour if can't fit in destination (speculation).</td>
</tr>
<tr>
<td>Integer</td>
<td>Integer</td>
<td>Signed destination and value can't fit, implementation-specific behaviour. Unsigned destination and value can't fit, truncates higher-order bits.</td>
</tr>
<tr>
<td>Floating Point</td>
<td>Floating Point</td>
<td>Implementation-specific behaviour if value can't fit in destination.</td>
</tr>
<tr>
<td>Any Numeric</td>
<td>Boolean</td>
<td>0 converts to <code>false</code>, otherwise <code>true</code>.</td>
</tr>
<tr>
<td>Any <a href="#BM_(pointer)%2Fi">Pointer</a></td>
<td>Boolean</td>
<td><code>nullptr</code> converts to <code>false</code>, otherwise <code>true</code>.</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends to always use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> because when you do, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> produces warnings about types not fitting. However, those warnings don't seem to cover everything, at least that's the impression I get from what I've tried.</p>
</div>
<a name="H_Explicit%20Conversion"></a><h3>Explicit Conversion</h3>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
</ul>
</div>
<p>An <a href="#BM_(explicit%20type%20conversion)%2Fi">explicit type conversion</a> is the opposite of an <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>. It's when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is explicitly converted (cast) to another type in code.</p>
<pre class="hljs"><code><span class="hljs-type">long</span> x {<span class="hljs-number">5L</span>};
<span class="hljs-type">int</span> y {<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x)};   <span class="hljs-comment">// long to int</span>
</code></pre>
<p><a href="#BM_(explicit%20type%20conversion)%2Fi">Explicit type conversion</a>s come in two forms:</p>
<ul>
<li><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s are the official way to cast in C++.</li>
<li>C-style casts are the legacy way to cast in C++.</li>
</ul>
<p><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s should be preferred over C-style casts. Any C-style cast can be performed through a <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>.</p>
<a name="H_Named%20Conversions"></a><h4>Named Conversions</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion%2FNamed%20Conversions)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion function</a>s are a set of (seemingly <a href="#BM_(template)%2Fi">template</a>d) functions to convert an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s types. These functions provide safety mechanisms that aren't available in other older ways of casting.</p>
<ul>
<li>
<p><code>const_cast</code> removes the <code>const</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> from an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s type.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyType &amp;t)</span> </span>{
    T &amp;<span class="hljs-type">moddable_t</span> { <span class="hljs-built_in">const_cast</span>&lt;MyType &amp;&gt;(t) };
}
</code></pre>
<p>Performing this type of conversion should only be done in extreme situations since it breaks contracts.</p>
</li>
<li>
<p><code>static_cast</code> forces the reverse of an implicit conversion.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
<span class="hljs-type">int</span> *b { a };  <span class="hljs-comment">// ok, implicit conversion (decay to pointer)</span>
<span class="hljs-type">void</span> *c { b }; <span class="hljs-comment">// ok, implicit conversion</span>
<span class="hljs-type">int</span> *d { c };  <span class="hljs-comment">// error, can't go in reverse</span>
<span class="hljs-type">int</span> *e { <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(c) }; <span class="hljs-comment">// ok</span>
</code></pre>
<p>In the above example, a <code>uint32_t *</code> implicitly converts to <code>void *</code>, but not the reverse. A <code>static_cast</code> makes going in reverse possible. However, that doesn't mean it's always safe to do. For example, <code>uint32_t</code> reads may need to be aligned to 4 byte boundaries on certain platforms. If the <code>void *</code> was arbitrary data (e.g. coming in over a network), it might cause a crash to just treat it as a <code>uint32_t *</code> and start reading.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why does a <code>uint32_t*</code> implicitly convert to a <code>void *</code>? Recall that <code>void *</code> just means "<a href="#BM_(pointer)%2Fi">pointer</a> to something unknown", which is something the language is okay automatically / implicitly converting.</p>
</div>
</li>
<li>
<p><code>reinterpret_cast</code> forces a reinterpretation of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> into an entirely different type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
<span class="hljs-type">int</span> *b { a };   <span class="hljs-comment">// ok, implicit conversion (decay to pointer)</span>
<span class="hljs-type">short</span> *c { b }; <span class="hljs-comment">// error, you can't convert from an int* to a short* (not even with a static_cast because it's not an implicit conversion)</span>
<span class="hljs-type">short</span> *d { <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">int</span> *&gt;; } <span class="hljs-comment">// ok</span>
</code></pre>
</li>
<li>
<p><code>narrow_cast</code> is similar to <code>static_cast</code> for numerics, except it ensures that no information loss occurred.</p>
<pre class="hljs"><code><span class="hljs-type">uint32_t</span> a { <span class="hljs-number">70000</span> };                     <span class="hljs-comment">// ok</span>
<span class="hljs-type">uint16_t</span> b { <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(a) };  <span class="hljs-comment">// ok, but since uint16_t has a max of65535, this object is mangled</span>
<span class="hljs-type">uint16_t</span> c { <span class="hljs-built_in">narrow_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(a) };  <span class="hljs-comment">// runtime exception, narrow_cast sees that the object will be mangled</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Is this part of the standard? The book seems to give the code for <code>narrow_cast</code> and looking online it looks like people have their own implementations?</p>
</div>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FAny)_TOPIC%2F">Library Functions/Containers/Any</a> (<code>any_cast</code> for an "any" container)</li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a> (<code>clock_cast</code> for converting times between different types of clocks)</li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F">Library Functions/Time/Durations</a> (<code>duration_cast</code> for converting between different types of durations)</li>
</ul>
</div>
<a name="H_C-style%20Casts"></a><h4>C-style Casts</h4>
<p><a name="BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion%2FC-style%20Casts)_TOPIC%2F"></a><strong></strong></p>
<p>C-style casts are similar to casts seen in Java. The type is bracketed before whatever is being evaluated.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x { (<span class="hljs-type">int</span>) <span class="hljs-number">9999999999L</span> };
</code></pre>
<p>The problem with C-style casting is that it doesn't provide the same safety mechanisms as <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>s do (e.g. inadvertently strip the <code>const</code>-ness). <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">Named conversion</a>s provide these safety mechanisms and as such should be preferred over C-style casts. Any C-style cast can be performed using a <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>.</p>
<a name="H_Object%20Lifecycle"></a><h2>Object Lifecycle</h2>
<p><a name="BM_(Core%20Language%5C%2FObject%20Lifecycle)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>In C++, an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is a region of memory that has a type and a value (e.g. a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(object%7Cinstance)%2Fi">instance</a>, an integer, a <a href="#BM_(pointer)%2Fi">pointer</a> to an integer, etc..). Contrary to other more high-level languages (e.g. Java), C++ <a href="#BM_(object%7Cinstance)%2Fi">object</a>s aren't exclusive to <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es (e.g. a boolean is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>).</p>
<p>An <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s life cycle passes through the following stages:</p>
<ol>
<li>memory <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d</li>
<li><a href="#BM_(constructor)%2Fi">constructor</a> invoked</li>
<li><a href="#BM_(destructor)%2Fi">destructor</a> invoked</li>
<li>memory <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d</li>
</ol>
<p>The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> starts from when its memory is <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and ends when that memory is <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. An <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a>, on the other hand, starts when its <a href="#BM_(constructor)%2Fi">constructor</a> <em>completes</em> (meaning the <a href="#BM_(constructor)%2Fi">constructor</a> finishes) and ends when its <a href="#BM_(destructor)%2Fi">destructor</a> is <em>invoked</em> (meaning when the <a href="#BM_(destructor)%2Fi">destructor</a> starts).</p>
<p><img src="svgbob_5382fe6e4bca4e56d9147249ff0bb4082202935e.svg" alt="Kroki diagram output"></p>
<p>Since C++ doesn't have a garbage collector performing cleanup like other high-level languages, it's the user's responsibility to ensure <a href="#BM_(object%7Cinstance)%2Fi">object</a> <a href="#BM_(lifetime)%2Fi">lifetime</a>s. The user is responsible for knowing when <a href="#BM_(object%7Cinstance)%2Fi">object</a>s should be destroyed and ensuring that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are only accessed within their <a href="#BM_(lifetime)%2Fi">lifetime</a>.</p>
<p>The typical <a href="#BM_(storage%20duration)%2Fi">storage duration</a>s supported by C++ are...</p>
<ul>
<li><a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a> - scoped to duration of some function within the program.</li>
<li><a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static storage duration</a> - scoped to the entire duration of the program.</li>
<li><a href="#BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi">thread storage duration</a> - scoped to the entire duration of a thread in the program.</li>
<li><a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic storage duration</a> - <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d on request of the user.</li>
</ul>
<a name="H_Static%20Objects"></a><h3>Static Objects</h3>
<p><a name="BM_(Core%20Language%5C%2FObject%20Lifecycle%2FStatic%20Objects)_TOPIC%2F"></a><strong></strong></p>
<p>By default, an <a href="#BM_(object%7Cinstance)%2Fi">object</a> declared within a function is said to be an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a>. <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">Automatic object</a>s have <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a>s: start at the beginning of the block and finish at the end of the block. When the keyword <code>static</code> (or <code>extern</code> in some cases) is added to the declaration, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of the function changes.</p>
<p>At global scope, if an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is declared as <code>static</code> or <code>extern</code>, <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> spans the entire duration of the program. The difference between the two is essentially just visibility:</p>
<ul>
<li><code>static</code> makes it so it's accessible to only the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's declared in.</li>
<li><code>extern</code> makes it so it's accessible to other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s as well as the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's declared in.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a { <span class="hljs-number">0</span> }; <span class="hljs-comment">// static variable</span>
<span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b { <span class="hljs-number">1</span> }; <span class="hljs-comment">// static variable (accessible outside translation unit)</span>
</code></pre>
<p>At function scope, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s declared as <code>static</code> starts at the first invocation of that function and ends when the program exits.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> z {<span class="hljs-number">0</span>}; <span class="hljs-comment">// static variable</span>
    z += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> z;
}
</code></pre>
<p>At <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> level, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of a <a href="#BM_%5Cb(member)%2Fi">member</a> (<a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> or <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>) declared as <code>static</code> is essentially the same as if it were declared at global scope (they aren't bound to an individual <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the same way a normal <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> or <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is). The only differences are that the <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a> is accessed on the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself using the scoped resolution operator (::) and that <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a>s that are <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s must be initialized at global scope.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m;         <span class="hljs-comment">// static member (field initialized at end)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">// static member (method)</span>
        m += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> m;
    }
};

X::m = <span class="hljs-number">0</span>;                <span class="hljs-comment">// initialize static member</span>
</code></pre>
<p>If the <code>thread_local</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> is added before <code>static</code> (or <code>extern</code>), each thread gets its own copy of the <a href="#BM_(object%7Cinstance)%2Fi">object</a>. That is, the <a href="#BM_(storage%20duration)%2Fi">storage duration</a> essentially gets changed to when the thread starts and ends.</p>
<p><code>thread_local static</code> can be shortened to just <code>thread_local</code> (it's assumed to be static).</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
<span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b {<span class="hljs-number">1</span>};
<span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> c {<span class="hljs-number">2</span>};
</code></pre>
<a name="H_Dynamic%20Objects"></a><h3>Dynamic Objects</h3>
<p><a name="BM_(Core%20Language%5C%2FObject%20Lifecycle%2FDynamic%20Objects)_TOPIC%2F"></a><strong></strong></p>
<p>An <a href="#BM_(object%7Cinstance)%2Fi">object</a> can be created in an ad-hoc manner, such that its <a href="#BM_(storage%20duration)%2Fi">storage duration</a> is entirely controlled by the user. The operator ...</p>
<ul>
<li><code>new</code> <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>s a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> and calls its <a href="#BM_(constructor)%2Fi">constructor</a>.</li>
<li><code>delete</code> calls the <a href="#BM_(destructor)%2Fi">destructor</a> of some <a href="#BM_(object%7Cinstance)%2Fi">object</a> and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>s it.</li>
</ul>
<p>Both keywords work with <a href="#BM_(pointer)%2Fi">pointer</a>s: <code>new</code> returns a <a href="#BM_(pointer)%2Fi">pointer</a> while <code>delete</code> requires a <a href="#BM_(pointer)%2Fi">pointer</a>. To create a new <a href="#BM_(object%7Cinstance)%2Fi">object</a>, use <code>new</code> followed by the type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> };
*ptr = <span class="hljs-number">0</span>;
<span class="hljs-keyword">delete</span> ptr;
</code></pre>
<p><a href="#BM_(object%7Cinstance)%2Fi">Object</a>s may be initialized directly within the <code>new</code> invocation just as if it were an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> initialization. The only caveat is that <a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a> and <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> won't work because the equal sign is already being used during <code>new</code> (speculation -- it doesn't work but I don't know the exact reason). As such, <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> is the best way to initialize a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">0</span>} }; <span class="hljs-comment">// initialize to 0</span>
<span class="hljs-keyword">delete</span> ptr;
</code></pre>
<p>The same process can be used to create an array of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. Unlike <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> arrays, <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s don't have a constant size array length restriction. However, the return value of <code>new</code> will decay from an array type to a <a href="#BM_(pointer)%2Fi">pointer</a> type.</p>
<p>When deleting a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> array, square brackets need to be appended to <code>delete</code> operator: <code>delete[]</code>. Doing so ensures that the <a href="#BM_(destructor)%2Fi">destructor</a> for each <a href="#BM_(object%7Cinstance)%2Fi">object</a> in the array gets invoked before <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len] };  <span class="hljs-comment">// len is some non-constant positive integer, decayed to pointer type because array length can be non-constant.</span>
<span class="hljs-keyword">delete</span>[] ptr;
</code></pre>
<p><a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> may be used when declaring <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s so long as the size of the array is at least the size of the initialization list.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * ptr1 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };  <span class="hljs-comment">// initialize the first 3 elems of a 10 elem array</span>
<span class="hljs-type">int</span> * ptr2 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };   <span class="hljs-comment">// throws exception  (size too small for initializer list)</span>
<span class="hljs-type">int</span> * ptr3 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };   <span class="hljs-comment">// okay -- so long as n &gt;= 3</span>
<span class="hljs-keyword">delete</span>[] ptr1;
<span class="hljs-keyword">delete</span>[] ptr2;
<span class="hljs-keyword">delete</span>[] ptr3;
</code></pre>
<p>By default, <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s are stored on a block of memory called the <a href="#BM_(heap%7Cfree%20store)%2Fi">heap</a>, also sometimes referred to as the <a href="#BM_(heap%7Cfree%20store)%2Fi">free store</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing section to see how the <code>new</code> and <code>delete</code> operators may be overridden to customize where and how a specific type gets stored.</p>
<p>The <code>new</code> and <code>delete</code> operators may also be overridden globally rather than per-type. See the new header.</p>
</div>
<a name="H_Functions"></a><h2>Functions</h2>
<p><a name="BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ function declarations and definitions have the following form: <code>prefix-modifiers return-type name(parameters) suffix-modifiers</code></p>
<ul>
<li>
<p><strong>return-type</strong> (required) - Type returned by function.</p>
</li>
<li>
<p><strong>name</strong>: (required) - Name of function.</p>
</li>
<li>
<p><strong>parameters</strong> (required) - Parameter list of function.</p>
</li>
<li>
<p><strong>prefix-<a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a function.</p>
<p>(e.g. <code>static</code>, <code>virtual</code>,  <code>constexpr</code>, <code>[[noreturn]]</code>, <code>inline</code>, ...)</p>
</li>
<li>
<p><strong>suffix-<a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Markers controlling the behaviour / properties of a function.</p>
<p>(e.g. <code>noexcept</code>, <code>const</code>,  <code>final</code>, <code>override</code>, <code>volatile</code>, ...)</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}
</code></pre>
<p>In C++, functions that are ...</p>
<ul>
<li><a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s (assigned to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>) are called <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s.</li>
<li>global are called <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</li>
</ul>
<p>This section deals with <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Some of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s listed above are for <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s, not <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s.</p>
</div>
<a name="H_Overloading"></a><h3>Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FOverloading)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">Function overload</a>ing is when there are multiple functions with the same name in the same scope. For <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, each <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> must have the same return type and a unique set of parameters.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0.0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a != b; }
</code></pre>
<p>When an <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overloaded function</a> is called, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will try to match argument types against parameter types to figure out which <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overloaded function</a> to call. If no exact match can be found, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> attempts to obtain a correct set of types through a set of conversions.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> num { <span class="hljs-number">1</span> };
<span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// calls the first overload in the code above:  bool test(int a);</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See argument matching section.</p>
</div>
<a name="H_Argument%20Matching"></a><h3>Argument Matching</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FArgument%20Matching)_TOPIC%2F"></a><strong></strong></p>
<p>When a function is called but the arguments types don't match the parameter list types, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> attempts to obtain a correct set of types through a set of conversions on the arguments. For example, if a parameter expects a <a href="#BM_(reference)%2Fi">reference</a> to a constant <a href="#BM_(object%7Cinstance)%2Fi">object</a> but what gets passed into the argument is an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, the argument is automatically converted to a constant <a href="#BM_(object%7Cinstance)%2Fi">object</a> and its <a href="#BM_(reference)%2Fi">reference</a> is used.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> &amp;obj)</span> </span>{ ... }

<span class="hljs-type">int</span> x {};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// x is turned into a "const int" and passed in as a reference</span>
</code></pre>
<p>For floating point and integral types, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will widen or <em>narrow</em> the if the exact type isn't found.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> a)</span> </span>{
    std::cout &lt;&lt; a;
    <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;
}

<span class="hljs-type">float</span> x {<span class="hljs-number">1.5</span>};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// automatic narrowing</span>
</code></pre>
<p>Similarly, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will convert between signed and unsigned integral types if the exact integral type isn't found.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a)</span> </span>{
    std::cout &lt;&lt; a;
    <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;
}

<span class="hljs-type">int64_t</span> x {<span class="hljs-number">10</span>};
<span class="hljs-built_in">test</span>(x); <span class="hljs-comment">// automatic narrowing and change to unsigned</span>
</code></pre>
<p>When <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>s are involved, the candidate with the arguments matching most closely is the one chosen.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The exact rules here seem hard to definitively pin down. If you have two <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>s of a function, one accepting int16 and int64, it'll fail when you try to call it with int8 claiming that it's too ambiguous. The best thing to do is to just ask the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to either warn on implicit conversion (<code>-Wconversion</code>) flag or on narrowing implicit conversion (<code>-Wnarrowing</code> / <code>-Wno-narrowing</code>). These flags may not be included under <code>-Wall</code>.</p>
</div>
<a name="H1_Type%20Deduction"></a><h3>Type Deduction</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FType%20Deduction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates)_TOPIC%2F">Core Language/Templates</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FType%20Deduction)_TOPIC%2F">Core Language/Variables/Type Deduction</a></li>
</ul>
</div>
<p>Similar to variable declarations, the <code>auto</code> keyword is also usable to deduce a function's parameter and return types based on usage.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;
}
</code></pre>
<p>The use of <code>auto</code> is essentially short-hand for a function <a href="#BM_(template)%2Fi">template</a>. In the example above, each unique set of types used when invoking <code>add()</code> is a <a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>.</p>
<pre class="hljs"><code><span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);     <span class="hljs-comment">// uses  int add(int x)</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">6</span>);     <span class="hljs-comment">// uses  int add(int x)</span>
<span class="hljs-built_in">test</span>(<span class="hljs-number">5ULL</span>);  <span class="hljs-comment">// uses  unsigned long long add(unsigned long long x)</span>
</code></pre>
<p>When using <code>auto</code> for a return type, you can optionally add a <code>-&gt;</code> immediately after the parameter list followed by a type expression that defines what expression should generate the returning type.</p>
<pre class="hljs"><code><span class="hljs-comment">// return type should be whatever type the result of x + 5LL is, which is long long</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x+<span class="hljs-number">5LL</span>)</span> </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why is the above useful? Using <code>auto</code> on functions is discouraged because function definitions act as documentation. The <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> is with <a href="#BM_(template)%2Fi">template</a>s, where the types depend in potentially complex ways on <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
<p>By adding the type expression in, you're re-introducing a form of documentation.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Try running functions with auto through <a href="https://cppinsights.io">here</a> to get a feel for how this transforms to function <a href="#BM_(template)%2Fi">template</a>s.</p>
</div>
<a name="H_Main%20Function"></a><h3>Main Function</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FMain%20Function)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<p>The entry-point to any C++ program is the <code>main</code> function, which can take one of three possible forms:</p>
<ol>
<li>
<p><code>int main()</code></p>
<p>No arguments.</p>
</li>
<li>
<p><code>int main(int argc, char* argv[])</code></p>
<p>Command-line arguments, where <code>argv</code> is an array of size <code>argc</code> containing the null-terminated command-line arguments. On most modern platforms, the first argument is the path of the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
</li>
<li>
<p><code>int main(int argc, char* argv[], EXTRA_PLATFORM_SPECIFIC_PARAMS)</code></p>
<p>Same as the above except extra arguments are supplied that are platform-specific.</p>
</li>
</ol>
<p>All three forms return an integer known as an exit code. On most modern day platforms, an exit code of 0 means success. If the code doesn't return an exit code, 0 is assumed.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; argv[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Should <code>argv</code> be <code>const char * const *</code>? In that you shouldn't be able to change the strings or the string <a href="#BM_(pointer)%2Fi">pointer</a> at each array index.</p>
</div>
<a name="H_Variadic"></a><h3>Variadic</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FVariadic)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCore%20Types)_TOPIC%2F">Core Language/Variables/Core Types</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<p>A <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> function is one that takes in a variable number of arguments, sometimes called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s in other languages. A function can be made <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> by placing <code>...</code> as the final parameter. The arguments for this final parameter are called the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments.</p>
<p>The <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments for a function are accessible through functionality provided by the cstdargs header.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdargs&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-type">float</span> sum {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        sum += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">return</span> sum /= n;
}
</code></pre>
<ul>
<li><code>va_list</code> - Access point to <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments.</li>
<li><code>va_start</code> - Initializes access to <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments (requires the <code>va_list</code> variable and the expected count of <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments).</li>
<li><code>va_args</code> - Gets the next <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> argument (requires the <code>va_list</code> variable and the expected type).</li>
<li><code>va_end</code> - Tears down access to the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments (requires the <code>va_list</code> variable).</li>
</ul>
<p>In addition, the <code>va_copy()</code> can be used to copy one <code>va_list</code> to another. The source will need to be initialized before the copy (via <code>va_start</code>). Once <code>va_copy</code> returns, copy will already be initialized (no need for <code>va_start</code>) but will need to be torn down before the function exits (via <code>va_end</code>).</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdargs&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">add_and_mult</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    va_list args2;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-built_in">va_copy</span>(args2, args);  <span class="hljs-comment">// 1st param is dst, 2nd param is src</span>
    <span class="hljs-type">float</span> res {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        res += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        res *= <span class="hljs-built_in">va_args</span>(args2, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args2);
    <span class="hljs-keyword">return</span> res;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends against using <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> functions due to confusing usage and having to explicitly know the count and types of the <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> arguments before hand (can become security problem if screwed up). Instead it recommends using <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> <a href="#BM_(template)%2Fi">template</a>s for functions instead.</p>
</div>
<a name="H_No%20Exception"></a><h3>No Exception</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FNo%20Exception)_TOPIC%2F"></a><strong></strong></p>
<p>In certain cases, it'll be impossible for a function to throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. Either the function (and the functions it calls into) never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> or the conditions imposed by the function make it impossible for any <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> to be thrown. In such cases, a function may be marked with the <code>noexcept</code> keyword. This keyword allows the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to perform certain optimizations that it otherwise wouldn't have been able to, but it doesn't necessarily mean that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will check to ensure an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> can't be thrown.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">noexcept</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions this is documented in "Item 16 of Effective Modern C++ by Scott Meyers". It goes on to say that, unless specified otherwise, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> assumes <a href="#BM_(move%20constructor)%2Fi">move constructor</a>s / move-assignment operators can throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> if they try to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> memory but the system doesn't have any. This prevents it from making certain optimizations.</p>
</div>
<a name="H1_Common%20Attributes"></a><h3>Common Attributes</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FCommon%20Attributes)_TOPIC%2F"></a><strong></strong></p>
<p>If a function has no possibility of ever gracefully returning to the caller, adding a <code>[[noreturn]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to make certain optimizations and provide / remove relevant warnings around that function.</p>
<pre class="hljs"><code>[[noreturn]] <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-string">"error"</span>;
}
</code></pre>
<p>If a function returns something and it's of vital importance that the return value should be used by the invoker, adding a <code>[[nodicard]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning.</p>
<pre class="hljs"><code>[[nodiscard]] <span class="hljs-function">Result <span class="hljs-title">perform</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    <span class="hljs-comment">// perform some computation</span>
    <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> ERROR_CODE;
    }
    <span class="hljs-keyword">return</span> SUCCESS_CODE;
}
</code></pre>
<p>If a function's parameter isn't used but it's inclusion in the parameter list is intentional, adding a <code>[[maybe_used]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to remove any warnings that it might otherwise show up about it being unused.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, [[maybe_unused]] <span class="hljs-type">int</span> c)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>If a function has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it's being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Coroutines"></a><h3>Coroutines</h3>
<p><a name="BM_(Core%20Language%5C%2FFunctions%2FCoroutines)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a></li>
</ul>
</div>
<p>A coroutine that can suspend its own execution and have it be continued at a later time. Similar to async functions in Javascript, C++ coroutines can work with promise <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (<a href="#BM_(object%7Cinstance)%2Fi">object</a>s that do work asynchronously). A function can be made into a coroutine by using any of the following:</p>
<ul>
<li><code>co_await</code> - suspend execution waiting for a promise to finish.</li>
<li><code>co_yield</code> - suspend execution and optionally return a value.</li>
<li><code>co_return</code> - complete execution and optionally return a value.</li>
</ul>
<p>The return value of a coroutine is a "promise type", a C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that has a specific structure and specific set of functionality that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> calls to determine and control the coroutine's state.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is deeply convoluted and requires a lot more digging and documentation, possibly in its own section instead of sub-section under the Function header.</p>
</div>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resumable</span> {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span>; <span class="hljs-comment">// forward declaration</span>
    <span class="hljs-built_in">Resumable</span>(std::coroutine_handle&lt;promise_type&gt; coro) : <span class="hljs-built_in">coro</span>(coro) {}
    ~<span class="hljs-built_in">Resumable</span>() {
        coro.<span class="hljs-built_in">destroy</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{ coro.<span class="hljs-built_in">destroy</span>(); }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>{ coro.<span class="hljs-built_in">resume</span>(); }
<span class="hljs-keyword">private</span>:
    std::coroutine_handle&lt;promise_type&gt; coro;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resumable</span>::promise_type {
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Resumable</span>(std::coroutine_handle&lt;Resumable::promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">suspend_never</span>(); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">suspend_never</span>(); }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{
        current_value = value;
        <span class="hljs-keyword">return</span> std::suspend_always{};
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>{ }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{ }
    <span class="hljs-type">int</span> current_value;
};

<span class="hljs-function">Resumable <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{
    <span class="hljs-keyword">while</span> (start &lt; end) {
        <span class="hljs-keyword">co_yield</span> start;
        std::cout &lt;&lt; start &lt;&lt; <span class="hljs-string">'\n'</span>;
        start++;
    }
    <span class="hljs-keyword">co_return</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> x {<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)};
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 0</span>
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 1</span>
    x.<span class="hljs-built_in">resume</span>();  <span class="hljs-comment">// prints 2</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It's said that the coroutine state is kept on the stack, resulting in C++ coroutines being a performance hog. Maybe it's possible to use a custom allocator to work around performance problems?</p>
</div>
<a name="H_Enumerations"></a><h2>Enumerations</h2>
<p><a name="BM_(Core%20Language%5C%2FEnumerations)_TOPIC%2F"></a><strong></strong></p>
<p>C++ <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>s are declared using <code>enum class</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MyEnum</span> {
   OptionA,
   OptionB,
   OptionC
};

MyEnum x {MyEnum::OptionC};

<span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">case</span> MyEnum::OptionA:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> MyEnum::OptionB:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> MyEnum::OptionC:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>An <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> may be brought into scope via <code>using</code> to remove the need to prefix with the <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>'s name.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span>;
    <span class="hljs-keyword">case</span> OptionA:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> OptionB:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> OptionC:
        ...
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It's possible to remove the <code>class</code> from <code>enum class</code>, which heavily loosens type-safety and scope. By removing <code>class</code>, the options within have thei<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>s implicitly converted to integers and you don't need the resolution scope operator (their options are accessible at the same level as an <a href="#BM_(enumeration%7Cenum)%2Fi">enum</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> { <span class="hljs-comment">// no class keyword</span>
   OptionA,
   OptionB,
   OptionC
};

MyEnum x {OptionC}; <span class="hljs-comment">// this is okay -- don't have to use MyEnum::OptionC</span>
<span class="hljs-type">int</span> y {OptionC};    <span class="hljs-comment">// this is okay -- options are integers</span>
</code></pre>
<p>You should prefer <code>enum class</code>.</p>
</div>
<a name="H_Classes"></a><h2>Classes</h2>
<p><a name="BM_(Core%20Language%5C%2FClasses)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are declared using either the <code>struct</code> keyword or <code>class</code> keyword. When ...</p>
<ul>
<li><code>struct</code> is used, the default visibility of <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a>s is public.</li>
<li><code>class</code> is used, the default visibility of <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a>s is private.</li>
</ul>
<p>Public and private visibility are the same as in most other languages: private <a href="#BM_%5Cb(member)%2Fi">member</a>s aren't accessible outside the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> while public <a href="#BM_%5Cb(member)%2Fi">member</a>s are. In C++ nomenclature, ...</p>
<ul>
<li><a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s are commonly referred to as <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>s.</li>
<li><a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are commonly referred to as <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>{
        count += <span class="hljs-number">1</span>;
        flag = <span class="hljs-literal">false</span>;
    }
};
</code></pre>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that contain only data are called <a href="#BM_(plain-old-data%20class%7Cplain-old%20data%20class%7Cplain%20old%20data%20class%7Cplain-old-data%20structure%7Cplain-old%20data%20structure%7Cplain%20old%20data%20structure%7Cplain-old-data%20struct%7Cplain-old%20data%20struct%7Cplain%20old%20data%20struct)%2Fi">plain-old-data class</a>es (<a href="#BM_(POD)%2F">POD</a>), and they're typically created using the <code>struct</code> keyword so as their <a href="#BM_%5Cb(member)%2Fi">member</a>s are all accessible by default.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count;
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
   <span class="hljs-type">bool</span> flag;
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>C++ guarantees that a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>'s <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s will be sequentially stored in memory, but they may be padded / aligned based on the platform. Be aware when using the <a href="#BM_(sizeof)%2Fi">sizeof</a> operator.</p>
</div>
<a name="H_This%20Pointer"></a><h3>This Pointer</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
</ul>
</div>
<p>Non-static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have access to an implicit <a href="#BM_(pointer)%2Fi">pointer</a> called <code>this</code>, which allows for accessing that <a href="#BM_(object%7Cinstance)%2Fi">instance</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s. As long as the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> doesn't conflict with any parameter name of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked, the usage of that name will implicitly <a href="#BM_(reference)%2Fi">reference</a> the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>.</p>
<p>The <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator (-&gt;) allows for <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a <a href="#BM_(pointer)%2Fi">pointer</a> and accessing a <a href="#BM_%5Cb(member)%2Fi">member</a> on the result in a more concise form.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">f1</span>(<span class="hljs-type">int</span> count) {
        <span class="hljs-keyword">this</span>-&gt;count = count;  <span class="hljs-comment">// equivalent to (*this).count = count</span>
        flag = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-built_in">f2</span>(<span class="hljs-type">int</span> count, <span class="hljs-type">bool</span> flag) {
        <span class="hljs-keyword">this</span>-&gt;count = count;  <span class="hljs-comment">// equivalent to (*this).count = count</span>
        <span class="hljs-keyword">this</span>-&gt;flag = flag;    <span class="hljs-comment">// equivalent to (*this).flag = flag</span>
    }
}
</code></pre>
<a name="H1_Constant"></a><h3>Constant</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConstant)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FConstant)_TOPIC%2F">Core Language/Variables/Constant</a></li>
</ul>
</div>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>const</code> before the type has the same meaning as a <code>const</code> variable at global scope: It's unmodifiable.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>const</code> after the parameter list indicates that the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>'s <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s won't be modified (read-only). This is a deep check rather than a shallow check, meaning that the entire call graph is considered when checking for modification.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inner</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
        x = n;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
    Inner inner;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        a = <span class="hljs-number">5</span>;  <span class="hljs-comment">// NOT okay -- no mutation allowed</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        inner.x = <span class="hljs-number">15</span>; <span class="hljs-comment">// NOT okay -- no mutation allowed, even though this is deeper down</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        inner.<span class="hljs-built_in">change</span>(<span class="hljs-number">15</span>); <span class="hljs-comment">// NOT okay -- method being invoked must be const (otherwise mutation might happen)</span>
    }
};
</code></pre>
<a name="H1_Volatile"></a><h3>Volatile</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FVolatile)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FVolatile)_TOPIC%2F">Core Language/Variables/Volatile</a></li>
</ul>
</div>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>volatile</code> before the type has the same meaning as a <code>volatile</code> variable at global scope: The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't optimize its access.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>volatile</code> after the parameter list indicates that all <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s should be treated as <code>volatile</code> (access won't be optimized away or re-ordered). This is a deep check rather than a shallow check, meaning that the entire call graph requires <code>volatile</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Another way to think of this is that the <code>volatile</code> on a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> makes it treat the <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> as if the variable that was declaring it were <code>volatile</code> -- meaning all of its <a href="#BM_%5Cb(member)%2Fi">member</a>s are treated as <code>volatile</code> recursively down the <a href="#BM_(object%7Cinstance)%2Fi">object</a> tree.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inner</span> {
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-keyword">volatile</span> </span>{
        x = n;
        x = n;
        x = n;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-type">int</span> a {<span class="hljs-number">0</span>};
    <span class="hljs-type">int</span> b {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> </span>{
        a = b;
        b = a;
        inner.<span class="hljs-built_in">change</span>(<span class="hljs-number">15</span>); 
    }
};
</code></pre>
<a name="H2_Common%20Attributes"></a><h3>Common Attributes</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FCommon%20Attributes)_TOPIC%2F"></a><strong></strong></p>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> has been deprecated, adding a <code>[[deprecated]]</code> <a href="#BM_(attribute)%2Fi">attribute</a> will allow the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning if it sees it being used.</p>
<pre class="hljs"><code>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"Warning -- this is going away in the next release"</span>)]]
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<a name="H_Static"></a><h3>Static</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FStatic)_TOPIC%2F"></a><strong></strong></p>
<p>For <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>static</code> before the type indicates that the function is independent of any <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type: a <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> points the same memory across all <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s.</p>
<p>For <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <code>static</code> before the return type indicates that the function is independent of any <a href="#BM_(object%7Cinstance)%2Fi">instance</a>s of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type, meaning that the only <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s that a <code>static</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> can access are <code>static</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s.</p>
<p><code>static</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s and <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s are accessed using the <a href="#BM_(scope%20resolution)%2Fi">scope resolution</a> (::) operator, where the scope is the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a {<span class="hljs-number">1</span>};
    <span class="hljs-type">int</span> b {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> <span class="hljs-title">double_it</span><span class="hljs-params">()</span> </span>{
        a *= <span class="hljs-number">2</span>; 
    }
};

X::<span class="hljs-built_in">double_it</span>();  <span class="hljs-comment">// call using scoped resolution</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Be careful, <code>static</code> has a different meaning for functions than it does for <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FObject%20Lifecycle%2FStatic%20Objects)_TOPIC%2F">Core Language/Object Lifecycle/Static Objects</a></li>
<li><a href="#BM_(Core%20Language%5C%2FLinker%20Behaviour%2FStatic%20Linkage)_TOPIC%2F">Core Language/Linker Behaviour/Static Linkage</a></li>
</ul>
</div>
<a name="H_Construction"></a><h3>Construction</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are allowed one or more <a href="#BM_(constructor)%2Fi">constructor</a>s that initialize the <a href="#BM_(object%7Cinstance)%2Fi">object</a>. Similar to Java, each <a href="#BM_(constructor)%2Fi">constructor</a> should have the same name as the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself, no return type, and a unique parameter list.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyStruct</span>() {
        count = <span class="hljs-number">0</span>;
        flag = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-type">int</span> initialCount, <span class="hljs-type">bool</span> initialFlag) {
        <span class="hljs-keyword">this</span>-&gt;count = initialCount;
        <span class="hljs-keyword">this</span>-&gt;flag = initialFlag;
    }
}
</code></pre>
<p>The above <a href="#BM_(constructor)%2Fi">constructor</a>s are using the <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator (-&gt;) to access the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>. Non-static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have access to an implicit <a href="#BM_(pointer)%2Fi">pointer</a> called <code>this</code>, which allows for accessing that <a href="#BM_(object%7Cinstance)%2Fi">instance</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s. The <a href="#BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi">member-of-pointer</a> operator allows for <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> a <a href="#BM_(pointer)%2Fi">pointer</a> and accessing a <a href="#BM_%5Cb(member)%2Fi">member</a> on the result in a more concise form.</p>
<pre class="hljs"><code><span class="hljs-keyword">this</span>-&gt;count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// equivalent to (*this).member = 0</span>
</code></pre>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> offers <a href="#BM_(constructor)%2Fi">constructor</a>s, the least error-prone way to invoke it is to use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>: <code>MyStruct x { 5, true }</code>. The reason is that C++ has so many <a href="#BM_(object%20initialization)%2Fi">object initialization</a> foot-guns that, while simpler <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s may work (e.g. <code>MyStruct x(5, true)</code>), those <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s may end up being interpreted by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> as something else that's entirely different (e.g. function declaration).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This ambiguity is often referred to as the "most vexing parse" problem.</p>
</div>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a>es that don't have any <a href="#BM_(constructor)%2Fi">constructor</a>s declared get an implicit <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> that zeros out the memory of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (speculation). If the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a <a href="#BM_(POD)%2F">POD</a>, a <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> that is ...</p>
<ul>
<li>empty will zero out the memory for all <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s, (implicit default <a href="#BM_(constructor)%2Fi">constructor</a>).</li>
<li>non-empty will set the individual <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s, in the order they're declared in.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count;
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];
   <span class="hljs-type">bool</span> flag;
};

MyStruct a;                    <span class="hljs-comment">// initialized to zeroed out memory (via implicit constructor)</span>
MyStruct b {};                 <span class="hljs-comment">// initialized to zeroed out memory (via implicit constructor)</span>
MyStruct b {<span class="hljs-number">5</span>, <span class="hljs-string">"steve"</span>, <span class="hljs-literal">true</span>}; <span class="hljs-comment">// initialized to supplied arguments</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/49802943">here</a> for more information. The = operator won't result in a copy or anything like that (meaning performance won't suffer).</p>
</div>
<p>If a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> does explicitly declare <a href="#BM_(constructor)%2Fi">constructor</a>s, the implicit <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> won't be generated. If desired, a <a href="#BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi">zero-arg</a> <a href="#BM_(constructor)%2Fi">constructor</a> may be declared with the default behaviour of the implicit zero arg <a href="#BM_(constructor)%2Fi">constructor</a> by adding <code>= default</code> instead of a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> body.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyStruct</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-type">int</span> initialCount, <span class="hljs-type">bool</span> initialFlag) {
        <span class="hljs-keyword">this</span>-&gt;count = initialCount;
        <span class="hljs-keyword">this</span>-&gt;flag = initialFlag;
    }
}
</code></pre>
<p>A <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> may be initialized to a value either through <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a> or the <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer list</a>. For <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>s, the initialization is done directly in the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>'s declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
   <span class="hljs-type">int</span> count {<span class="hljs-number">5</span>};
   <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>] {<span class="hljs-string">"steve"</span>};
   <span class="hljs-type">bool</span> flag {<span class="hljs-literal">true</span>};
};
</code></pre>
<p>In contrast, a <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer list</a> is a comma separated list of <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>s for the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. It's specified just before a <a href="#BM_(constructor)%2Fi">constructor</a>'s body.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-built_in">MyStruct</span>(): count{<span class="hljs-number">0</span>}, flag{<span class="hljs-literal">false</span>} {
    }
}
</code></pre>
<p>Each item in the comma separated list is called a <a href="#BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi">member initializer</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>How is this better than <a href="#BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi">default member initialization</a>, where initialization is done directly after the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> declaration? According to <a href="https://stackoverflow.com/a/48098997">this</a>, it's more-or-less the same?</p>
</div>
<a name="H_Destruction"></a><h3>Destruction</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FDestruction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are allowed an explicit cleanup function called a <a href="#BM_(destructor)%2Fi">destructor</a> (e.g. closing an open file handle, zeroing out memory for security purposes, etc..). A <a href="#BM_(destructor)%2Fi">destructor</a> is declared similarly to a <a href="#BM_(constructor)%2Fi">constructor</a>, the only differences being ...</p>
<ol>
<li>a tilde must appear just before the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> / function name.</li>
<li>it doesn't take in any arguments.</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> count {<span class="hljs-number">5</span>};
    <span class="hljs-type">bool</span> flag {<span class="hljs-literal">true</span>};

    <span class="hljs-keyword">public</span>:
    ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
<p><a href="#BM_(destructor)%2Fi">Destructor</a>s must never be called directly by the user. Treat any <a href="#BM_(destructor)%2Fi">destructor</a> as if it were marked with <code>noexcept</code>. That is, an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> should never be thrown in a <a href="#BM_(destructor)%2Fi">destructor</a>. When an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> gets thrown, the call stack unwinds. As each function exits, the <a href="#BM_(destructor)%2Fi">destructor</a>s for <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic variable</a>s of that function get invoked. Another <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> getting thrown while one is already in flight means two <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s would be in flight, which isn't supported.</p>
<p>If a <a href="#BM_(destructor)%2Fi">destructor</a> isn't declared, an empty one is implicitly generated.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>When inheritance is involved, it's almost always to make the <a href="#BM_(destructor)%2Fi">destructor</a> a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a>.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FInheritance)_TOPIC%2F">Core Language/Classes/Inheritance</a></li>
</ul>
</div>
<a name="H_Copying"></a><h3>Copying</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p>There are two built-in mechanisms for copying in C++: the <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> and <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a>.</p>
<p>A <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is a <a href="#BM_(constructor)%2Fi">constructor</a> that has a single parameter, a <a href="#BM_(reference)%2Fi">reference</a> to a <code>const</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a default <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> if one hasn't been explicitly declared by the user. The <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> of this default <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is to copy each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> individually, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<p><a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">Member-wise copy</a>ing may not be the correct way to copy in certain cases, in which case a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> should be explicitly provided with the correct <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) {
        <span class="hljs-keyword">this</span>-&gt;db = DatabaseConnection {orig.db.host, orig.db.port}; <span class="hljs-comment">// make a new db connection instead of using orig's</span>
        <span class="hljs-keyword">this</span>-&gt;max = orig.max;
    }
}


MyStruct x {host, port};
MyStruct y {x}; <span class="hljs-comment">// both x and y are independent and equal, but y has its own DatabaseConnection</span>
</code></pre>
<p>Similarly, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked when the assignment operator is used, called an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>. Unlike <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>s, <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> is required to clean up any resources in the destination <a href="#BM_(object%7Cinstance)%2Fi">object</a> prior to copying. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> if one hasn't been explicitly declared by the user. The <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> of this default <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is to assign each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> individually, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) { <span class="hljs-comment">// only do if assigning to self</span>
            <span class="hljs-keyword">this</span>-&gt;db.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// close existing db connection</span>
            <span class="hljs-keyword">this</span>-&gt;db = DatabaseConnection {orig.db.host, orig.db.port}; <span class="hljs-comment">// make a new db connection</span>
            <span class="hljs-keyword">this</span>-&gt;max = orig.max;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return self -- this should always be the case??</span>
    }
}
</code></pre>
<p>To suppress the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> from allowing copying or assignment of an <a href="#BM_(object%7Cinstance)%2Fi">object</a>, add <code> = delete</code> after both signatures instead of specifying a body. This is important if the <a href="#BM_(object%7Cinstance)%2Fi">object</a> holds on to an uncopyable resource such as a lock.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">delete</span>;
    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">delete</span>;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If using the defaults, the book recommends explicitly declaring the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s but adding <code> = default</code> after both signatures instead of specifying a body. The reason is that the default is almost always wrong, so if you tack this on it makes it explicit to others that you intended this.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">default</span>;
    MyStruct&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyStruct &amp;orig) = <span class="hljs-keyword">default</span>;
}
</code></pre>
<p>ALSO, there's ambiguity around when the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates default move/copy/<a href="#BM_(destructor)%2Fi">destructor</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s. It might be <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specific. The book recommends that if you're using the defaults, always set them to <code>= default</code> (or do <code>= delete</code> to disallow them).</p>
<p><a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> MyStruct {
...</p>
<pre><code>// copy
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// move
MyStruct(MyStruct &amp;&amp;orig) = default;
MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
// destructor
~MyStruct() = default;
</code></pre>
<p>}
```</p>
</div>
<a name="H_Moving"></a><h3>Moving</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F">Core Language/Classes/Copying</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
</ul>
</div>
<p>There are two built-in mechanisms for moving in C++: the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> and <a href="#BM_(move%20assignment)%2Fi">move assignment</a>. Moving is different from copying in that moving actually guts the insides (data) of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> and transfers it into another, leaving that <a href="#BM_(object%7Cinstance)%2Fi">object</a> in an invalid state. If the scenario allows for it, moving is oftentimes more efficient than copying.</p>
<p>A <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is a <a href="#BM_(constructor)%2Fi">constructor</a> that has a single parameter, an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type. By default, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are implicitly provided with a default <a href="#BM_(move%20constructor)%2Fi">move constructor</a> if one hasn't been explicitly declared by the user. The move semantics of this default <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is to <em>copy</em> each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> rather than actually move anything, called a <a href="#BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi">member-wise copy</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    <span class="hljs-built_in">MyStruct</span>(MyStruct &amp;&amp;orig) <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">this</span>-&gt;str_ptr = orig.str_ptr;
        <span class="hljs-keyword">this</span>-&gt;max = orig.max;
        orig.str_ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// mark orig object as invalid</span>
        orig.max = <span class="hljs-number">-1</span>; <span class="hljs-comment">// mark orig object as invalid</span>
    }
}

MyStruct a {};
MyStruct &amp;&amp;b = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// get rvalue reference for a</span>
MyStruct c {b};               <span class="hljs-comment">// move a into c (gut it into c) via the move constructor</span>
<span class="hljs-comment">// b is in an invalid state</span>
</code></pre>
<p>In the example above, the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> has <code>noexcept</code> set to indicate that it will never throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. <a href="#BM_(move%20constructor)%2Fi">Move constructor</a>s that can throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s are problematic for the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to use. If a <a href="#BM_(move%20constructor)%2Fi">move constructor</a> throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, the source <a href="#BM_(object%7Cinstance)%2Fi">object</a> will likely enter into an inconsistent state, meaning the program will likely be in an inconsistent state. As such, if the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> sees that the <a href="#BM_(move%20constructor)%2Fi">move constructor</a> can throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, it'll prefer to copy it instead.</p>
<p>Similarly to the <a href="#BM_(move%20constructor)%2Fi">move constructor</a>, <a href="#BM_(move%20assignment)%2Fi">move assignment</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> invoked when the assignment operator is used, called an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>. It has the same parameter list and it shouldn't throw <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s either (<code>noexcept</code>), the only difference is that it returns a <a href="#BM_(reference)%2Fi">reference</a> to itself at the end.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    ...

    MyStruct&amp; <span class="hljs-keyword">operator</span>=(MyStruct &amp;&amp;orig) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) { <span class="hljs-comment">// only do if assigning to self</span>
            <span class="hljs-keyword">this</span>-&gt;str_ptr = orig.str_ptr;
            <span class="hljs-keyword">this</span>-&gt;max = orig.max;
            orig.str_ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// mark orig object as invalid</span>
            orig.max = <span class="hljs-number">-1</span>; <span class="hljs-comment">// mark orig object as invalid</span>
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return self -- this should always be the case??</span>
    }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There's ambiguity around when the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates default move/copy/<a href="#BM_(destructor)%2Fi">destructor</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s. It might be <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> specific. The book recommends that if you're using the defaults, always set them to <code>= default</code> (or do <code>= delete</code> to disallow them).</p>
<pre><code>class MyStruct {
    ...

    // copy
    MyStruct(MyStruct &amp;&amp;orig) = default;
    MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
    // move
    MyStruct(MyStruct &amp;&amp;orig) = default;
    MyStruct&amp; operator=(MyStruct &amp;&amp;orig) = default;
    // destructor
    ~MyStruct() = default;
}
</code></pre>
</div>
<a name="H_Inheritance"></a><h3>Inheritance</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FInheritance)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstruction)_TOPIC%2F">Core Language/Classes/Construction</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FDestruction)_TOPIC%2F">Core Language/Classes/Destruction</a></li>
</ul>
</div>
<p>In C++, a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inherits another <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> by, just after its name, appending a colon (:) followed by the name of the parent <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyChild</span> : MyParent {
};
</code></pre>
<p>Like in most other <a href="#BM_(object%7Cinstance)%2Fi">object</a> oriented languages, a child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>...</p>
<ul>
<li>can access the non-private <a href="#BM_%5Cb(member)%2Fi">member</a>s of any of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es it inherits.</li>
<li>is assignable to the type of any of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es it inherits.</li>
</ul>
<pre class="hljs"><code>MyChild c {};
MyParent p {x}; <span class="hljs-comment">// MyChild inherits from MyParent, meaning that it's assignable to MyParent</span>
</code></pre>
<p>To be able to override a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in a child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the same way as it's done in other languages (e.g. Java), the base call must have the <code>virtual</code> keyword prepended on the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, making it a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>. Similarly, any <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> that overrides a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> should have the <code>override</code> keyword appended just after the parameter list.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><code>override</code> isn't strictly required, but it's a hint that the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> can use to prevent you from making a mistake (e.g. it sees <code>override</code> but what's being overridden isn't <code>virtual</code>). It's similar to Java's <code>@Override</code> annotation.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">()</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
};
</code></pre>
<p>If the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> and child <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> have the exact same non-<a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>, which <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> gets called depends on the type of the variable.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ ... }
};


MyChild c {};
MyChild  &amp;cref {x};
MyParent &amp;pref {x};
cref.<span class="hljs-built_in">non_virt_method</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// calls MyChild::non_virt_method()</span>
pref.<span class="hljs-built_in">non_virt_method</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// calls MyParent::non_virt_method() even though object is a MyChild</span>
</code></pre>
<p>To prevent a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> from being overridable at all, add the <code>final</code> keyword just after the parameter list.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> </span>{ ... }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{ ... }  <span class="hljs-comment">// ERROR HERE -- not allowed</span>
};
</code></pre>
<p>Similarly, to prevent the entire <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself from being inheritable, add the <code>final</code> keyword just after the name.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> <span class="hljs-keyword">final</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{ ... }
};
</code></pre>
<p>C++ chains <a href="#BM_(constructor)%2Fi">constructor</a> and <a href="#BM_(destructor)%2Fi">destructor</a> invocations appropriately as expected. The one caveat is that <a href="#BM_(destructor)%2Fi">destructor</a>, if not a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>, will use the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> resolution mechanism described above: If the type of the variable doesn't match the <a href="#BM_(object%7Cinstance)%2Fi">object</a> (variable type is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but <a href="#BM_(object%7Cinstance)%2Fi">object</a> is not), the wrong <a href="#BM_(destructor)%2Fi">destructor</a> gets invoked, resulting in <a href="#BM_(object%7Cinstance)%2Fi">object</a> potentially not cleaning up resources (e.g. closing file handles).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    ~<span class="hljs-built_in">MyParent</span>() { ... };
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyChild</span> : MyParent {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    ~<span class="hljs-built_in">MyChild</span>() { ... };
};


MyParent *c {<span class="hljs-keyword">new</span> MyChild{}};
<span class="hljs-keyword">delete</span> c;  <span class="hljs-comment">// calls MyParent's destructor instead of MyChild's destructor</span>
</code></pre>
<p>When inheritance is involved, it's almost always a good idea to enforce a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>. Since not having a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a> sometimes makes sense (e.g. user determined that it's safe to omit it and as such omitted it to improve performance), the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> won't produce a warning if it isn't virtual.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>{ ... };
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() { ... };
};
</code></pre>
<a name="H_Interfaces"></a><h3>Interfaces</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FInterfaces)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FInheritance)_TOPIC%2F">Core Language/Classes/Inheritance</a></li>
</ul>
</div>
<p>Interfaces and abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are supported in C++, but not in the same way as other high-level languages. The C++ approach to interfaces is to explicitly mark certain <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s as requiring an implementation. This is done by appending <code>= 0</code> to the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">virt_method</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">non_virt_method</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};
</code></pre>
<p>A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> that is both a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> and requires an implementation is called a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>. A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that contains all <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s is called a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi">pure virtual class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() {};  <span class="hljs-comment">// also okay to do   "virtual ~MyParent() = default"</span>
};
</code></pre>
<p>As shown in the example above, a <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi">pure virtual class</a> should have a <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>. While not required, failing to do so means that the wrong <a href="#BM_(destructor)%2Fi">destructor</a> may get invoked if the type of the variable doesn't match the <a href="#BM_(object%7Cinstance)%2Fi">object</a> (variable type is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but <a href="#BM_(object%7Cinstance)%2Fi">object</a> is not), resulting in <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> resources being left open (e.g. file handles).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See inheritance section for a more thorough explanation.</p>
</div>
<a name="H_Operator%20Overloading"></a><h3>Operator Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
<li><a href="#BM_(Core%20Language%5C%2FOperators)_TOPIC%2F">Core Language/Operators</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es support <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing.</p>
<p>Operators are <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>-able in two ways. To <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> an operator the first way, introduce a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> but instead of naming it, add the <code>operator</code> keyword followed by the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed. The parameters and return type of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> need to match whatever types the operator is intended to deal with.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...

    <span class="hljs-comment">// MyClass + int -- notice whitespace between 'operator' keyword and operator -- this is okay.</span>
    MyClass <span class="hljs-keyword">operator</span> +(<span class="hljs-type">int</span> rhs) <span class="hljs-keyword">const</span> {
        MyClass ret { <span class="hljs-keyword">this</span>-&gt;value + x };
        <span class="hljs-keyword">return</span> ret;
    };

    <span class="hljs-comment">// MyClass + MyClass</span>
    MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;rhs) <span class="hljs-keyword">const</span> {
        MyClass ret { <span class="hljs-keyword">this</span>-&gt;value + rhs.value };
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-comment">// MyClass += MyClass</span>
    MyClass&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyClass &amp;rhs) {
        <span class="hljs-keyword">this</span>-&gt;value += x-&gt;value;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>
<p>To <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> an operator the second way, introduce a function (not a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>) using the <code>operator</code> keyword followed by the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed. In the examples above, the left-hand side was the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>. When using this second way, a left-hand side needs to be explicitly provided as the first parameter while the right-hand side is the second argument.</p>
<pre class="hljs"><code><span class="hljs-comment">// MyClass + int</span>
MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-type">int</span> rhs) {
    MyClass ret { lhs.value + x };
    <span class="hljs-keyword">return</span> ret;
};

<span class="hljs-comment">// MyClass + MyClass</span>
MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">// MyClass += MyClass</span>
MyClass &amp; <span class="hljs-keyword">operator</span>+=(MyClass &amp;rhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    lhs.value += rhs.value;
    <span class="hljs-keyword">return</span> lhs;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Evidently the two ways described above aren't equivalent. The second way has some added benefits. See <a href="https://stackoverflow.com/a/10958716">here</a>.</p>
</div>
<p>Note how the <code>const</code> keyword is added to the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in cases where the operator shouldn't modify itself. Similarly, when the argument for a parameter shouldn't be changed, <code>const</code> is used on that parameter. <code>const</code>-ness depends on the scenario. For example, the second <code>operator+</code> requires two <a href="#BM_(reference)%2Fi">reference</a>s to <code>const</code> types.</p>
<pre class="hljs"><code>MyClass <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyClass &amp;lhs, <span class="hljs-keyword">const</span> MyClass &amp;rhs) {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p>Those <code>const</code>s ensure that the operands aren't changed in the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>. Imagine that you're performing <code>x = y + z</code>. It doesn't make sense for <code>y</code> or <code>z</code> to get modified.</p>
<p>The signature could have just as well been modified to be the types themselves rather than <code>const</code> <a href="#BM_(reference)%2Fi">reference</a>s, in which case both the left-hand side and right-hand side would get copied on invocation of the <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> (modifications to copies don't matter).</p>
<pre class="hljs"><code>MyClass <span class="hljs-keyword">operator</span>+(MyClass lhs, MyClass rhs) {
    MyClass ret { lhs.value + rhs.value };
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://gist.github.com/beached/38a4ae52fcadfab68cb6de05403fa393">here</a> for a list of operators and their signatures (still incomplete).</p>
<p>There's also the option to create operators that allow for implicit type casting and explicit type casting. See the type casting section for more information.</p>
</div>
<a name="H_Three-way%20Comparison%20Overloading"></a><h3>Three-way Comparison Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FThree-way%20Comparison%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p>The <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">three-way comparison operator</a>, also called the <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a>, is a more terse way of providing comparison operators for a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. Typically, if a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is sortable and comparable, it should provide <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s for the typical comparison operators:</p>
<ul>
<li>equality (==)</li>
<li>inequality (!=)</li>
<li>less-than (&lt;)</li>
<li>less-than or equal (&lt;=)</li>
<li>greater-than (&gt;)</li>
<li>greater-than or equal (&gt;=)</li>
</ul>
<p>The <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">three-way comparison operator</a> bundles <em>at least</em> the last four of those (potentially all of them) into a single operator, where the symbol for that operator is an equal-sign sandwiched between angle brackets (&lt;=&gt;).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">int</span> hour;
    <span class="hljs-type">int</span> minute;
};

std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(MyClass&amp; lhs, MyClass&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">if</span> (lhs.hour &lt; rhs.hour) {
        <span class="hljs-keyword">return</span> std::strong_ordering::less;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lhs.hour &gt; rhs.hour) {
        <span class="hljs-keyword">return</span> std::strong_ordering::greater;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (lhs.minute &lt; rhs.minute) {
            <span class="hljs-keyword">return</span> std::strong_ordering::less;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lhs.minute &gt; rhs.minute) {
            <span class="hljs-keyword">return</span> std::strong_ordering::greater;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> std::strong_ordering::equal;
        }
    }
}

<span class="hljs-comment">// Test</span>
MyClass lunch_time {<span class="hljs-number">12</span>, <span class="hljs-number">00</span>};
MyClass sleep_time {<span class="hljs-number">22</span>, <span class="hljs-number">00</span>};
std::cout &lt;&lt; <span class="hljs-string">"&lt;= via spaceship operator: "</span> &lt;&lt; (lunch_time &lt;= sleep_time) &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// You can also call the spaceship operator directly:   std::strong_ordering res {lunch_time &lt;=&gt; sleep_time}</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Not sure why but when the above <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> is a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> (instead of a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>) the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> starts producing a bunch of warnings.</p>
</div>
<p>Note that the above is comparing each <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a> in the order it's declared. The default <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> implementation of the <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a> will do exactly the same thing. Had the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inherited from some other <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the default implementation would first compare the parent <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es (left-right order -- C++ has multiple inheritance) before comparing the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s in the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">int</span> hour;
    <span class="hljs-type">int</span> minute;
    std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(MyClass&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;
};
</code></pre>
<p>In addition, a default <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> implementation provides both equality (==) and inequality (!=) support. The <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> implementation in the first example does not support either -- their <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s need to be added manually.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/58780946">here</a> for reasoning.</p>
</div>
<p>There are three types of ordering supported by the <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a>:</p>
<ul>
<li>
<p><code>std::strong_ordering</code> - equality (==) means that one <a href="#BM_(object%7Cinstance)%2Fi">object</a> may be substituted for the other (they are the same).</p>
<p>Possible values:</p>
<ul>
<li><code>std::strong_ordering::less</code> for less-than</li>
<li><code>std::strong_ordering::greater</code> for greater-than</li>
<li><code>std::strong_ordering::equal</code> for equality</li>
</ul>
<p>Examples:</p>
<ul>
<li>Comparing circles by their radius. A circle with a radius of 5 is the same as another circle with a radius of 5.</li>
</ul>
</li>
<li>
<p><code>std::weak_ordering</code> - equality (==) means that one <a href="#BM_(object%7Cinstance)%2Fi">object</a> substitution isn't guaranteed (they may not be the same even though they're equivalent).</p>
<p>Possible values:</p>
<ul>
<li><code>std::weak_ordering::less</code> for less-than</li>
<li><code>std::weak_ordering::greater</code> for greater-than</li>
<li><code>std::weak_ordering::equivalent</code> for equivalence (note that this is NOT equality -- it's equivalence)</li>
</ul>
<p>Examples:</p>
<ul>
<li>Comparing rectangles by their area: A rectangle that's 1-by-15 has the same area as a rectangle that's 5-by-3, but those rectangles are not the same.</li>
<li>Comparing strings while ignoring case: The string <code>"hello world"</code> is equivalent to <code>"HELLO WORLD"</code>, but the two strings aren't the same.</li>
</ul>
</li>
<li>
<p><code>std::partial_ordering</code> -- same as <code>std::weak_ordering</code>, but with the addition that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s may not be comparable at all.</p>
<p>Possible values:</p>
<ul>
<li><code>std::partial_ordering::less</code> for less-than</li>
<li><code>std::partial_ordering::greater</code> for greater-than</li>
<li><code>std::partial_ordering::equivalent</code> for equivalence (Note that this is NOT equality -- it's equivalence)</li>
<li><code>std::partial_ordering::unordered</code> the <a href="#BM_(object%7Cinstance)%2Fi">object</a>s weren't comparable</li>
</ul>
<p>Examples:</p>
<ul>
<li>Comparing floating point numbers: The number <code>3.5</code> is not comparable at all to <code>NaN</code> (not a number).</li>
</ul>
</li>
</ul>
<p>The return type defined for the <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> provides context to the user as to how the <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are comparable.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Source of ordering types is <a href="https://news.ycombinator.com/item?id=20551212">here</a>.</p>
<p><a href="https://news.ycombinator.com/item?id=20550165">Here</a> talks about the importance of choosing the right ordering type.</p>
<p>The rectangle example was lifted from <a href="https://blog.tartanllama.xyz/spaceship-operator/">here</a>.</p>
</div>
<a name="H_Conversion%20Overloading"></a><h3>Conversion Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConversion%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FImplicit%20Conversion)_TOPIC%2F">Core Language/Variables/Implicit Conversion</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FExplicit%20Conversion)_TOPIC%2F">Core Language/Variables/Explicit Conversion</a></li>
</ul>
</div>
<p>C++ <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es support both <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>s and <a href="#BM_(explicit%20type%20conversion)%2Fi">explicit type conversion</a>s via <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing. <a href="#BM_(implicit%20type%20conversion)%2Fi">Implicit type conversion</a>s are represented as <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s where the name of the operator being <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed is the destination type and the return type is omitted.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt; value / <span class="hljs-number">42</span>;
    }
};
...
MyClass cls {};
<span class="hljs-type">int</span> x {cls}; <span class="hljs-comment">// triggers operator overload method</span>
</code></pre>
<p><a href="#BM_(explicit%20type%20conversion)%2Fi">Explicit type conversion</a>s are enabled the same way as <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a>s, except the <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is preceded by the <code>explicit</code> keyword. The <code>explicit</code> keyword makes it so that conversion to that type requires a <code>static_cast</code></p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt; value / <span class="hljs-number">42</span>;
    }
};
...
MyClass cls {};
<span class="hljs-type">int</span> x {<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(cls)};  <span class="hljs-comment">// static_cast required to trigger operator overload method</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends not preferring explicit over implicit because implicit is a source for confusion.</p>
<p>Do these still qualify as <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s? Return types should be there.</p>
</div>
<a name="H_Const%20%2F%20Volatile%20Overloading"></a><h3>Const / Volatile Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FConst%20%2F%20Volatile%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConstant)_TOPIC%2F">Core Language/Classes/Constant</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FVolatile)_TOPIC%2F">Core Language/Classes/Volatile</a></li>
</ul>
</div>
<p>In addition to following the same <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing rules as <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> may be <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed based on whether the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a> is to a <code>volatile</code> and / or <code>const</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"non-const non-volatile\n"</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"const non-volatile\n"</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"non-const volatile\n"</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> counter;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_data</span><span class="hljs-params">()</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"const volatile\n"</span>;
        <span class="hljs-keyword">return</span> counter;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> counter;
};


MyClass c1{};
c1.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "non-const non-volatile"</span>
<span class="hljs-keyword">const</span> MyClass c2{};
c2.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "const non-volatile"</span>
<span class="hljs-keyword">volatile</span> MyClass c3{};
c3.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "non-const volatile"</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span> MyClass c4{};
c4.<span class="hljs-built_in">get_data</span>(); <span class="hljs-comment">// prints "const volatile"</span>
</code></pre>
<a name="H_Reference%20Overloading"></a><h3>Reference Overloading</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FReference%20Overloading)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<p>In addition to following the same <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>ing rules as <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a>s, a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> may be <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ed based on whether the <code>this</code> <a href="#BM_(reference)%2Fi">reference</a> is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a> or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a>. To target ...</p>
<ul>
<li><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a>, add an ampersand (&amp;) after the parameter list</li>
<li><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r-value</a>, add two ampersands (&amp;&amp;) after the parameter list</li>
</ul>
<p>The benefit of <a href="#BM_(reference)%2Fi">reference</a> <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing is being able to define a version of the function with efficient move semantics when the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is transient.</p>
<pre class="hljs"><code><span class="hljs-comment">// THIS EXAMPLE WAS LIFTED FROM https://docs.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170#ref-qualifiers</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>() {<span class="hljs-comment">/*expensive initialization*/</span>}
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> &amp; </span>{
        std::cout &lt;&lt; <span class="hljs-string">"lvalue\n"</span>;
        <span class="hljs-keyword">return</span> _data;
    }
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> &amp;&amp; </span>{
        std::cout &lt;&lt; <span class="hljs-string">"rvalue\n"</span>;
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(_data);
    }
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; _data;
};


MyClass c {};
<span class="hljs-keyword">auto</span> v {c.<span class="hljs-built_in">get_data</span>()}; <span class="hljs-comment">// get a copy. prints "lvalue".</span>
<span class="hljs-keyword">auto</span> v2 {<span class="hljs-built_in">C</span>().<span class="hljs-built_in">get_data</span>()}; <span class="hljs-comment">// get the original. prints "rvalue"</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The website said <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l-value</a>, but does it mean <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">gl-value</a>?</p>
</div>
<a name="H_Functors"></a><h3>Functors</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a></li>
</ul>
</div>
<p>A <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, also called a <a href="#BM_(functor%7Cfunction%20object)%2Fi">function object</a>, is a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can invoke as if it were a function because it has an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> for function-call.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};

MyFunctor inst{};
<span class="hljs-built_in">inst</span>(<span class="hljs-number">15</span>);  <span class="hljs-comment">// computes -15 + 5</span>
</code></pre>
<p><a href="#BM_(functor%7Cfunction%20object)%2Fi">Functor</a>s are useful because they allow for state (via <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s) and parameterization (via <a href="#BM_(constructor)%2Fi">constructor</a> arguments) but still retain a function-like syntax.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unlike normal functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s cannot be assigned to <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s. See section on <a href="#BM_(function%20pointer)%2Fi">function pointer</a>s.</p>
</div>
<a name="H_Lambdas"></a><h3>Lambdas</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FLambdas)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F">Core Language/Classes/Functors</a></li>
</ul>
</div>
<p><a href="#BM_(lambda)%2Fi">Lambda</a>s are unnamed <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s (not functions) that are expressed in a succinct form. <a href="#BM_(lambda)%2Fi">Lambda</a>s in C++ work similarly to <a href="#BM_(lambda)%2Fi">lambda</a>s in other high-level languages. They allow for capturing <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope and pulling them into the body, where they can be used for whatever processing the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s body performs.</p>
<pre class="hljs"><code><span class="hljs-comment">// as a function</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> x) {
        <span class="hljs-keyword">this</span>-&gt;x = x;
    };
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};

MyFunction f1{}
<span class="hljs-built_in">f1</span>(<span class="hljs-number">42</span>);

<span class="hljs-comment">// as a lambda</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-keyword">auto</span> f2 = [=] (<span class="hljs-type">int</span> y) { <span class="hljs-keyword">return</span> -y + x; };

<span class="hljs-built_in">f2</span>(<span class="hljs-number">42</span>);
</code></pre>
<p>The general syntax of a <a href="#BM_(lambda)%2Fi">lambda</a> is as follows: <code>[captures] (parameters) modifiers -&gt; return-type { body }</code>.</p>
<ul>
<li>
<p><strong>capture</strong> (required) - <a href="#BM_(object%7Cinstance)%2Fi">Object</a>s to pull in from outer scopes.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z / <span class="hljs-number">2</span>; };           <span class="hljs-comment">// no capture</span>
<span class="hljs-keyword">auto</span> f2 = [x, y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };   <span class="hljs-comment">// explicitly copy x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f3 = [&amp;x, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; }; <span class="hljs-comment">// explicitly reference x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f4 = [=] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };      <span class="hljs-comment">// automatically copy x and y from outer scope</span>
<span class="hljs-keyword">auto</span> f5 = [&amp;] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };      <span class="hljs-comment">// automatically reference x and y from outer scope</span>
<span class="hljs-type">int</span> t {<span class="hljs-number">1</span>};
<span class="hljs-keyword">auto</span> f6 = [&amp;, y] () -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + t; };        <span class="hljs-comment">// automatically reference x and t but force y to be a copy</span>
</code></pre>
<p>Capture lists are essentially the <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>'s <a href="#BM_(constructor)%2Fi">constructor</a>. When the capture was pulled in ...</p>
<ul>
<li>because it was explicitly stated, it's called a <a href="#BM_(named%20capture)%2Fi">named capture</a>.</li>
<li>automatically, it's called a <a href="#BM_(default%20capture)%2Fi">default capture</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book recommends against <a href="#BM_(default%20capture)%2Fi">default capture</a>s.</p>
</div>
<p><a href="#BM_(named%20capture)%2Fi">Named capture</a>s can also be initializer expressions by adding an equal sign after the name of the capture.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> y {<span class="hljs-number">6</span>};
<span class="hljs-keyword">auto</span> f1 = [modified_x=x/<span class="hljs-number">2</span>, y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };
</code></pre>
<p>If used within an enclosing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a> can be captured.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [*<span class="hljs-keyword">this</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z / <span class="hljs-number">2</span>; };  <span class="hljs-comment">// capture a COPY OF *this and pass it in as a pointer</span>
<span class="hljs-keyword">auto</span> f1 = [<span class="hljs-keyword">this</span>] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> z / <span class="hljs-number">2</span>; };   <span class="hljs-comment">// capture this as pointer</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It's mentioned that prior to C++20, automatic copy capturing (<code>[=]</code>) would pull in <code>this</code>. That feature has been deprecated.</p>
</div>
</li>
<li>
<p><strong>parameters</strong> (optional) - Parameter list of <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };
<span class="hljs-keyword">auto</span> f2 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">99</span>) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };  <span class="hljs-comment">// default args</span>
<span class="hljs-keyword">auto</span> f3 = [] (<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) { <span class="hljs-keyword">return</span> x + y; };            <span class="hljs-comment">// generic params (compiler deduces types based on usage)</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F">Core Language/Templates/Type Deduction</a> (<code>decltype</code> may be used with <code>auto</code> parameter types)</li>
</ul>
</div>
</li>
<li>
<p><strong><a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s</strong> (optional) - Function <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-keyword">constexpr</span> -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };  <span class="hljs-comment">// constant expression</span>
</code></pre>
</li>
<li>
<p><strong>return-type</strong> (optional) - Return type.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) { <span class="hljs-keyword">return</span> x + y; };                    <span class="hljs-comment">// deduced by compiler if not set</span>
<span class="hljs-keyword">auto</span> f2 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y; };
<span class="hljs-keyword">auto</span> f3 = [] (<span class="hljs-type">int</span> x, <span class="hljs-keyword">auto</span> y) -&gt; <span class="hljs-keyword">decltype</span>(x+y) { <span class="hljs-keyword">return</span> x + y; };  <span class="hljs-comment">// generic param + decltype (compiler sets return type to resulting type of x + y)</span>
</code></pre>
</li>
<li>
<p><strong>body</strong> (required) - Function body.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f1 = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) { <span class="hljs-keyword">return</span> x + y; };
</code></pre>
</li>
</ul>
<p>If the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> decides that a <a href="#BM_(lambda)%2Fi">lambda</a> can be turned into a <a href="#BM_(constant%20expression)%2Fi">constant expression</a>, it will automatically do so. Alternatively, you can force a <a href="#BM_(lambda)%2Fi">lambda</a> to be a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> by adding <code>constexpr</code> as one of the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>In many cases, you need to return a <a href="#BM_(lambda)%2Fi">lambda</a> from a function. The easiest way to do this is to set the function's return type to <code>auto</code> and return the <a href="#BM_(lambda)%2Fi">lambda</a> as if it were any other variable.</p>
</div>
<a name="H_Friends"></a><h3>Friends</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FFriends)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FThis%20Pointer)_TOPIC%2F">Core Language/Classes/This Pointer</a></li>
</ul>
</div>
<p>A friend is a function or <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that can access the non-public <a href="#BM_%5Cb(member)%2Fi">member</a>s of some other <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that it wasn't declared in.</p>
<p>For friend functions, the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be accessed needs to declare the function's prototype (function declaration) before implementations of a friend function (function definition) can exist. The prototype is included in the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> just like any other <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, but the <code>friend</code> prefix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> is tacked on.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// prototype</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span> </span>{  <span class="hljs-comment">// implementation -- friend of MyClass</span>
    <span class="hljs-keyword">return</span> -(n + obj.x);
}

<span class="hljs-comment">// test</span>
MyClass obj{};
<span class="hljs-type">int</span> t = <span class="hljs-built_in">addAndNegate</span>(obj,<span class="hljs-number">5</span>);
</code></pre>
<p>For friend <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be accessed needs to specify which outside <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is able to access it using <code>friend class</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>;  <span class="hljs-comment">// state that MyFriend can access MyClass's non-public members</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, <span class="hljs-type">int</span> n)</span> </span>{  <span class="hljs-comment">// function in MyFriend accessing non-public members of MyClass</span>
        <span class="hljs-keyword">return</span> -(n + obj.x);
    }
};


<span class="hljs-comment">// test</span>
MyFriend obj_friend{};
MyClass obj{};
<span class="hljs-type">int</span> t = obj_friend.<span class="hljs-built_in">addAndNegate</span>(obj,<span class="hljs-number">5</span>);
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <code>class</code> in <code>friend class</code> may be omitted if <code>MyFriend</code> was already declared before <code>MyClass</code>. Adding the word <code>class</code> is a <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a> -- it tells the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to just believe that it exists even though it may not have come across it yet.</p>
</div>
<p>Friend functions and friend <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es may also target <a href="#BM_(template)%2Fi">template</a>d types.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">addAndNegate</span><span class="hljs-params">(MyClass&amp; obj, T n)</span></span>;  <span class="hljs-comment">// every addAndNegate(MyClass&amp;, T) will be a friend</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">0</span>};
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is how C++ provides its equivalent of Java's <code>Object.toString()</code>. For each <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you want to be able to print as a string, you implement a <a href="#BM_(template)%2Fi">template</a>d friend function of the left-shift <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> (&lt;&lt;) that targets the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <code>ostream</code>, making it usable in something like <code>std::cout</code>.</p>
<pre class="hljs"><code>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> MyClass &amp;obj) {
    os &lt;&lt; obj.x &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> os;
}
</code></pre>
<p>It seems like a convoluted way to do it.</p>
</div>
<a name="H_User-defined%20Literals"></a><h3>User-defined Literals</h3>
<p><a name="BM_(Core%20Language%5C%2FClasses%2FUser-defined%20Literals)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p>C++ provides a way for users to define their own literals through the use of <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing, called <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s. <a href="#BM_(user-defined%20literal)%2Fi">User-defined literal</a>s wrap built-in literals and perform some operation to convert them to either another type or anothe<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>. It's identified by a unique suffix that starts with an underscore (e.g. <code>_km</code>).</p>
<p>The <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> is identified by two quotes followed by the suffix.</p>
<pre class="hljs"><code>Distance <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _km (<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) {
    <span class="hljs-keyword">return</span> Distance {n * <span class="hljs-number">1000.0</span>};
}

Distance <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _mi (<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) {
    <span class="hljs-keyword">return</span> Distance {n * <span class="hljs-number">1609.34</span>};
}

Distance d { <span class="hljs-number">1.2</span>_km + <span class="hljs-number">4.0</span>_mi };
</code></pre>
<p>As stated above, <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s must wrap an existing built-in <a href="#BM_(literal%20type)%2Fi">literal type</a>.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>integral</td>
<td><code>return_type operator"" identifier (unsigned long long int)</code></td>
</tr>
<tr>
<td>floating point</td>
<td><code>return_type operator"" identifier (long double)</code></td>
</tr>
<tr>
<td>character</td>
<td><code>return_type operator"" identifier (char)</code></td>
</tr>
<tr>
<td>wide character</td>
<td><code>return_type operator"" identifier (wchar_t)</code></td>
</tr>
<tr>
<td>utf-8 character</td>
<td><code>return_type operator"" identifier (char8_t)</code></td>
</tr>
<tr>
<td>utf-16 character</td>
<td><code>return_type operator"" identifier (char16_t)</code></td>
</tr>
<tr>
<td>utf-32 character</td>
<td><code>return_type operator"" identifier (char32_t)</code></td>
</tr>
<tr>
<td>character string</td>
<td><code>return_type operator"" identifier (char *, size_t)</code></td>
</tr>
<tr>
<td>wide character string</td>
<td><code>return_type operator"" identifier (wchar_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-8 string</td>
<td><code>return_type operator"" identifier (char8_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-16 string</td>
<td><code>return_type operator"" identifier (char16_t *, size_t)</code></td>
</tr>
<tr>
<td>utf-32 string</td>
<td><code>return_type operator"" identifier (char32_t *, size_t)</code></td>
</tr>
<tr>
<td>raw</td>
<td><code>return_type operator"" identifier (const char *)</code></td>
</tr>
</tbody>
</table>
<p>Note that, for ...</p>
<ul>
<li>numerics, the widest possible C++ type is used for both integral (unsigned long long int) and floating point (long double).</li>
<li>characters, each character type gets its own definition.</li>
<li>strings, each string type gets its own definition.</li>
</ul>
<p>The last definition in the table above, raw, will get a character string of any numeric literal used.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * <span class="hljs-keyword">operator</span><span class="hljs-string">""</span> _as_str (<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * n) {
    std::cout &lt;&lt; <span class="hljs-string">"input str: "</span> &lt;&lt; n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-number">123.5e+12</span>_as_str;  <span class="hljs-comment">// outputs "input str: 123.5e+12"</span>
</code></pre>
<p>The standard C++ library makes use of <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s in various places, but its identifiers don't require an underscore (_) prefix.</p>
<ul>
<li>Date-time API (chrono header): <code>std:chrono::duration d  { 2h + 15ms }</code>.</li>
<li>Complex numbers API (complex header): <code>std::complex&lt;double&gt; { (1.0 + 2.0i) * (3.0 + 4.0i) }</code>.</li>
<li>String API (string): <code>std::string str { "hello"s + "world"s }</code>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F">Library Functions/Time/Durations</a></li>
</ul>
</div>
<a name="H_Templates"></a><h2>Templates</h2>
<p><a name="BM_(Core%20Language%5C%2FTemplates)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p><a href="#BM_(template)%2Fi">Template</a>s are loosely similar to generics in other high-level languages such as Java. A <a href="#BM_(template)%2Fi">template</a> defines a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function where some of the types and code are unknown, called <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. Each <a href="#BM_(template%20parameter)%2Fi">template parameter</a> in a <a href="#BM_(template)%2Fi">template</a> either maps to a ...</p>
<ul>
<li>a type (e.g. <code>int</code>).</li>
<li>an integra<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">l value</a> available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>5</code>).</li>
<li>floating point value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>5.5f</code>).</li>
<li>an <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>MyEnum::Value</code>).</li>
<li><a href="#BM_(object%7Cinstance)%2Fi">object</a> <a href="#BM_(pointer)%2Fi">pointer</a> type value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>&amp;MyClass::MyStaticField</code>).</li>
<li><a href="#BM_(function%20pointer)%2Fi">function pointer</a> type value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>&amp;MyClass::MyStaticMember</code>).</li>
<li><code>std::nullptr_t</code> value available at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>nullptr</code>).</li>
</ul>
<p><a href="#BM_(template)%2Fi">Template</a>s are created using the <code>template</code> keyword, where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are a comma separated list sandwiched within angle brackets. When the user makes use of a <a href="#BM_(template)%2Fi">template</a>, its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s get substituted with what the user specified.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
        <span class="hljs-keyword">return</span> (var1 + var2) * N;
    }
};
</code></pre>
<p>As shown above, each <a href="#BM_(template%20parameter)%2Fi">template parameter</a> for a ...</p>
<ul>
<li>type substitution is prefixed with the keyword <code>typename</code>. The keyword <code>class</code> may be used instead of <code>typename</code>. The meaning is exactly the same (<code>typename</code> should be preferred).</li>
<li>value substitution is prefixed with the type name.</li>
</ul>
<p>To use a <a href="#BM_(template)%2Fi">template</a>, use it just as you would a non-<a href="#BM_(template)%2Fi">template</a> but provide substitutions (<a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>). To instantiate a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(template)%2Fi">template</a>, use the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> as if it were a normal <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but immediately after the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> name add in a comma separated list of <a href="#BM_(template%20parameter)%2Fi">template parameter</a> substitutions sandwiched within angle brackets. These substitutions should be in the same order as the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s.</p>
<pre class="hljs"><code>MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; obj {}; <span class="hljs-comment">// X = float, Y = int, Z = int, N = 2</span>
<span class="hljs-type">float</span> x {obj.<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>Declaring <a href="#BM_(template)%2Fi">template</a>d functions is done in the same manner as <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, and using <a href="#BM_(template)%2Fi">template</a>d functions is done similarly to <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es: Use the function as if it were a normal function but immediately after the function name add in a comma separated list of substitutions sandwiched within angle brackets.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * N;
}

<span class="hljs-comment">// use</span>
<span class="hljs-type">float</span> x {<span class="hljs-built_in">perform</span>&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>When the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are for types only (not values), it's possible to leave out substitutions during usage. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will deduce the types from the argument you pass in and substitute them automatically.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> var1 + var2;
}

<span class="hljs-comment">// use</span>
<span class="hljs-type">float</span> x {<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};  <span class="hljs-comment">// template arguments omitted, deduced by compiler</span>
</code></pre>
<p>It's possible to supply a default substitution for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> by appending it with <code>=</code> followed by the substitution, called <a href="#BM_(default%20template%20argument)%2Fi">default template argument</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y = <span class="hljs-type">long</span>, <span class="hljs-keyword">typename</span> Z = <span class="hljs-type">long</span>&gt;
X <span class="hljs-built_in">perform</span>(Y &amp;var1, Z &amp;var2) {
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>You would think that once a default is supplied, all other <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s after it need a default as well. For whatever reason the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> isn't erroring out when I do this.</p>
</div>
<p>Similarly, it's possible to use <a href="#BM_(template)%2Fi">template</a>s with <a href="#BM_(type%20alias)%2Fi">type alias</a>ing to create shorthand names where only some of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s need to be set, called <a href="#BM_(partial%20template)%2Fi">partial template</a>s.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-keyword">using</span> MyClassPartialTemplate = MyClass&lt;<span class="hljs-type">float</span>, Y, Z, <span class="hljs-number">42</span>&gt;;

<span class="hljs-comment">// use</span>
MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt; x{}; 
MyClassPartialTemplate&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; y{};  <span class="hljs-comment">// same type as previous line</span>
</code></pre>
<p>Normally, C++ code is split into two files: a header file that contains declarations (e.g. function signatures) and a C++ file that contains definitions (e.g. function signatures with their bodies). When accessing C++ code that isn't local, typically only the declarations of that non-local code need to be included. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> binds those non-local declarations to their definitions when it comes time to build the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<p><a href="#BM_(template)%2Fi">Template</a>s work differently from Java generics in that the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> generates a new code for each unique set of substitutions it sees used (<a href="#BM_(template%20instantiation)%2Fi">template instantiation</a>). Doing so produces more code than if there was only one copy, but also ensures any performance optimizations unique to that specific set of substitutions. Also, because each usage of a <a href="#BM_(template)%2Fi">template</a> may result in newly generated code, that usage typically needs access to both the declaration and definition. The simplest way to handle this is to put the entirety of the <a href="#BM_(template)%2Fi">template</a> (both definition and declaration) into a header, which gets included into the same file as the usage.</p>
<a name="H2_Type%20Deduction"></a><h3>Type Deduction</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FType%20Deduction)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FFunctors)_TOPIC%2F">Core Language/Classes/Functors</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FLambdas)_TOPIC%2F">Core Language/Classes/Lambdas</a></li>
</ul>
</div>
<p>To automatically derive the type of something to be passed in as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>, use <code>decltype()</code>. This is useful in scenarios where it's difficult or impossible to determine the exact type for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>. Function-like <a href="#BM_(object%7Cinstance)%2Fi">object</a>s (e.g. functions, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s) is one such scenario.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FUNC_TYPE&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perform</span><span class="hljs-params">(FUNC_TYPE * func)</span> </span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-number">55</span>);
}

<span class="hljs-comment">// use</span>
<span class="hljs-keyword">auto</span> my_lambda = [](<span class="hljs-type">int</span> x) { std::cout &lt;&lt; x; };
<span class="hljs-built_in">perform</span>&lt;<span class="hljs-keyword">decltype</span>(my_lambda)&gt;(my_lambda};
</code></pre>
<p><code>decltype()</code> can take in either an entity (as shown above) or an expression.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> N&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perform</span><span class="hljs-params">(N n)</span> </span>{
    std::cout &lt;&lt; n;
}

<span class="hljs-comment">// use</span>
MyClass myClass{}
<span class="hljs-built_in">perform</span>&lt;<span class="hljs-keyword">decltype</span>(myClass.numVar + <span class="hljs-number">1L</span>)&gt;(my_lambda}; <span class="hljs-comment">// N set to whatever type "myClass.numVar + 1L" evaluates to</span>
</code></pre>
<a name="H_Concepts"></a><h3>Concepts</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FConcepts)_TOPIC%2F"></a><strong></strong></p>
<p>In certain cases, a set of types substituted in for a <a href="#BM_(template)%2Fi">template</a> won't produce working code.</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
<p>In the example above, <code>X perform(Y &amp;var1, Z &amp;var2) { ... }</code> needs <code>Y</code> and <code>Z</code> to be types that support the plus operator (+) on each other (e.g. <code>int</code> and <code>short</code>). Setting them to types that don't support the plus operator typically causes cryptic compilation error, especially if the user is only making use of the <a href="#BM_(template)%2Fi">template</a> and isn't familiar with its innards.</p>
<p>To mitigate these problems, <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>s may be provided within a <a href="#BM_(template)%2Fi">template</a>: A <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> is a predicate, evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> (not <a href="#BM_(runtime)%2Fi">runtime</a>), to determine if the substituted types on some <a href="#BM_(template)%2Fi">template</a> have the properties needed to be used within it. <a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a>s themselves are <a href="#BM_(template)%2Fi">template</a>s where the <code>concept</code> keyword is used followed by a named expression that returns a <code>bool</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
<span class="hljs-keyword">concept</span> MyConcept = std::is_default_constructible&lt;T1&gt;::value
        &amp;&amp; std::is_default_constructible&lt;T2&gt;::value
        &amp;&amp; <span class="hljs-built_in">requires</span>(T1 a, T2 b) {
            { a + b } -&gt; std::same_as&lt;TR&gt;;
            { a * b } -&gt; std::same_as&lt;TR&gt;;
            { std::hash&lt;T1&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
            { std::hash&lt;T2&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
        };
</code></pre>
<p>The <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> above checks a combination of three types: <code>T1</code>, <code>T2</code>, and <code>TR</code>. The first two checks are done through functionality provided by the type_traits header. In the example above, <code>std::is_default_constructible</code> provides a <a href="#BM_(compile-time)%2Fi">compile-time</a> check to ensure the types <code>T1</code> and <code>T2</code> both have a default initializer (e.g. default <a href="#BM_(constructor)%2Fi">constructor</a>). Examples of other checks baked provided by the type_traits header (and concepts header):</p>
<ul>
<li><code>std::is_signed</code> - ensures a type is signed.</li>
<li><code>std::is_unsigned</code> - ensures a type is unsigned.</li>
<li><code>std::is_integral</code> - ensures a type is an integer (e.g. <code>short int</code>, <code>int</code>, <code>unsigned long long int</code>, etc..)</li>
<li><code>std::is_pod</code> - ensures a type is a <a href="#BM_(POD)%2F">POD</a>.</li>
<li><code>std::is_fundamental</code> - ensures a type is a <a href="#BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi">fundamental type</a>.</li>
<li><code>std::is_abstract</code> - ensures a type is an abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (has at least one <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual function</a>).</li>
<li><code>std::is_copy_constructible</code> - ensures type has a <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>.</li>
<li><code>std::is_copy_assignable</code> - ensures type has <a href="#BM_(copy%20assignment)%2Fi">copy assignment</a>.</li>
<li><code>std::is_move_constructible</code> - ensures type has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a>.</li>
<li><code>std::is_nothrow_move_constructible</code> - ensures type has a <a href="#BM_(move%20constructor)%2Fi">move constructor</a> that never throws an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> (<code>noexcept</code>).</li>
<li><code>std::is_move_assignable</code> - ensures type has <a href="#BM_(move%20assignment)%2Fi">move assignment</a>.</li>
</ul>
<p>The remaining checks are done through a <code>requires</code> clause, which lists out the required set of expressions the substituted types must support and the resulting type of each of those expressions. The example above lists that types <code>T1</code> and <code>T2</code> are ...</p>
<ol>
<li>addable, returning an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type <code>TR</code>.</li>
<li>multiply-able, returning an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of type <code>TR</code>.</li>
<li>hashable (when passed into <code>std::hash()</code>, returns an <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's convertible to <code>size_t</code>).</li>
</ol>
<p>Each item in the list has the syntax <code>{ EXPRESSION } -&gt; RESULT</code>, where the result is wrapped with functionality from the concepts header. This functionality describes how the result of the expression should behave. In the example above, ...</p>
<ul>
<li><code>std::same_as&lt;TR&gt;</code> means that the expression should return the exact type as specified by <code>TR</code>.</li>
<li><code>std::convertible_to&lt;std::size_t&gt;</code> means that the expression should return a type that can implicitly convert to <code>std::size_t</code> (e.g. a <code>short</code> can implicitly convert to an <code>int</code> without requiring any kind of casting).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book says that these are / are related to "type functions". I can't find much information on this or how to create new "type functions".</p>
</div>
<p>Use the <code>requires</code> keyword immediately after the <a href="#BM_(template)%2Fi">template</a> to target a set of <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s to a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-keyword">requires</span> MyConcept&lt;T1, T2, T1&gt;  <span class="hljs-comment">// refers to the concept defined in the example above</span>
<span class="hljs-function">T1 <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(T1 &amp;var1, T2 &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
<p><a href="#BM_(concept)_TEMPLATE%2Fi">Concept</a> may also be directly embedded into the <a href="#BM_(template)%2Fi">template</a> itself.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-keyword">requires</span> std::is_default_constructible&lt;T1&gt;::value   <span class="hljs-comment">// same as above, but "MyConcept&lt;T1, T2, T1&gt;" has been embedded</span>
            &amp;&amp; std::is_default_constructible&lt;T2&gt;::<span class="hljs-function">value
            &amp;&amp; <span class="hljs-title">requires</span><span class="hljs-params">(T1 a, T2 b)</span> </span>{
                { a + b } -&gt; std::same_as&lt;T1&gt;;
                { a * b } -&gt; std::same_as&lt;T!&gt;;
                { std::hash&lt;T1&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
                { std::hash&lt;T2&gt;{}(a) } -&gt; std::convertible_to&lt;std::<span class="hljs-type">size_t</span>&gt;;
            };
<span class="hljs-function">T1 <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(T1 &amp;var1, T2 &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
<p>If a <a href="#BM_(concept)_TEMPLATE%2Fi">concept</a> only checks a single type, it's possible to use it just by substituting its name in place of the <code>typename</code> / <code>class</code> for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> that requires it (as opposed to using <code>requires</code> shown above).</p>
<pre class="hljs"><code><span class="hljs-comment">// concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> SingleTypeConcept = <span class="hljs-built_in">requires</span>(T a, T b) {
            { a + b } -&gt; std::same_as&lt;T&gt;;
            { a * b } -&gt; std::same_as&lt;T&gt;;
        };

<span class="hljs-comment">// usage of concept</span>
<span class="hljs-keyword">template</span> &lt;SingleTypeConcept X&gt;  <span class="hljs-comment">// this line is updated -- "typename T" replaced with "SingleTypeConcept T"</span>
<span class="hljs-function">X <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(X &amp;var1, X &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
<a name="H1_Variadic"></a><h3>Variadic</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FVariadic)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> function is one that takes in a variable number of arguments, sometimes called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s in other languages. A <a href="#BM_(template)%2Fi">template</a> can be made <a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a> by placing a final <a href="#BM_(template%20parameter)%2Fi">template parameter</a> with <code>...</code> preceding the name, where this <a href="#BM_(template%20parameter)%2Fi">template parameter</a> is referred to as <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>.</p>
<p>One common use-case for <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>s is invoking functions where the parameter list isn't known before hand.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function">X <span class="hljs-title">create</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> X {args...};
}
</code></pre>
<p>Another less common use-case is specifying the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to inherit from (multiple inheritance).</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> : R... {
    <span class="hljs-built_in">X</span>(<span class="hljs-keyword">const</span> R&amp;... args) : <span class="hljs-built_in">R</span>(args)... { <span class="hljs-comment">// member initializer list calls constructors of base class</span>
    }
}
</code></pre>
<p>Another less common use-case is to repeatedly apply some operator or function.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T t)</span> </span>{
    <span class="hljs-keyword">return</span> t;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; first, R... rest)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(first) + <span class="hljs-built_in">sum</span>(rest...);
}
</code></pre>
<p>Alternatively, rather than using recursion to exhaustively apply a binary operator, a <a href="#BM_(fold%20expression)%2Fi">fold expression</a> may be applied to the <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>. A <a href="#BM_(fold%20expression)%2Fi">fold expression</a> applies a binary operator to the contents of a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a> and returns the final result.</p>
<p>The syntax for <a href="#BM_(fold%20expression)%2Fi">fold expression</a>s is <code>...</code> and the <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>'s name sandwiched in between the operator, all encapsulated within a pair of brackets. Which side of the operator the <code>...</code> appears at defines if the <a href="#BM_(fold%20expression)%2Fi">fold expression</a> will be left <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> or right <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(R... args)</span> </span>{
    R l_ass_res = (... - args);  <span class="hljs-comment">// ((((a-b)-c)-d)-...)</span>
    R r_ass_res = (args - ...);  <span class="hljs-comment">// (...-(w-(x-(y-z))))</span>
    <span class="hljs-keyword">return</span> l_ass_res + r_ass_res;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Just a heads up that, depending on the operator, <a href="#BM_(associativity%7Cassociative)%2Fi">associativity</a> matters. For example <code>((5-4)-3)</code> is not equal to <code>(5-(4-3))</code>.</p>
</div>
<p>To get the size of a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a>, add <code>...</code> after the <code>sizeof</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">calculate_size</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">sizeof</span>...(args);
}
</code></pre>
<p><a href="#BM_(parameter%20pack)%2Fi">Parameter pack</a>s are used internally within C++'s implementation of analogues to Python's tuples and zip: <code>std::pair</code>, <code>std::tuple</code>, and <code>std::zip</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Examples adapted from <a href="https://crascit.com/2015/03/21/practical-uses-for-variadic-templates/">here</a>.</p>
</div>
<a name="H_Specialization"></a><h3>Specialization</h3>
<p><a name="BM_(Core%20Language%5C%2FTemplates%2FSpecialization)_TOPIC%2F"></a><strong></strong></p>
<p>Given a specific set of substitutions for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s of a <a href="#BM_(template)%2Fi">template</a>, a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is code that overrides the <a href="#BM_(template)%2Fi">template</a> generated code. Oftentimes <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are introduced because they're more memory or computationally efficient than the standard <a href="#BM_(template)%2Fi">template</a> generated code. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>ic example is a <a href="#BM_(template)%2Fi">template</a> that holds on to an array. Most C++ implementations represent a <code>bool</code> as a single byte, however it's more compact to store an array of <code>bool</code>s as a set of bits.</p>
<p>Declare a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> with the <code>template</code> keyword but without any <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s (empty angle brackets). The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function that follows should list out substitutions after its name and the code within it should be real (non-<a href="#BM_(template)%2Fi">template</a>d).</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// template specialization for bool: bit-wise or</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-type">bool</span> <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b) {
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
<p><a href="#BM_(template%20specialization)%2Fi">Template specialization</a> doesn't have to substitute all <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s. When a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> only provides substitutes for some of its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s, leaving other <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s as-is or partially refined, it's called a <a href="#BM_(partial%20template)%2Fi">partial template</a> specialization.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">R <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
};

<span class="hljs-comment">// template specialization for pointers of unknown type: already return false</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">bool</span>, X*&gt; {
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(X * a, X* b)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(partial%20template)%2Fi">Partial template</a> specializations for functions aren't supported (yet?). See <a href="https://stackoverflow.com/a/8061522">here</a>.</p>
</div>
<p>In certain cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> is able to deduce the types for a specialization from its usage, meaning explicitly listing substitutions after the name may not be required.</p>
<pre class="hljs"><code><span class="hljs-comment">// first example without explicitly listing out substitutions</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b)</span> </span>{  <span class="hljs-comment">// type removed after name: "sum&lt;bool&gt;" to just "sum"</span>
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
<a name="H_Unions"></a><h2>Unions</h2>
<p><a name="BM_(Core%20Language%5C%2FUnions)_TOPIC%2F"></a><strong></strong></p>
<p>C++ <a href="#BM_(union)%2Fi">union</a>s are a set of variables that point to the same underlying memory. Each <a href="#BM_(union)%2Fi">union</a> takes up only as much memory as its largest <a href="#BM_%5Cb(member)%2Fi">member</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> {
   <span class="hljs-type">char</span> raw[<span class="hljs-number">100</span>];
   <span class="hljs-type">short</span> num_int;
   <span class="hljs-type">double</span> num_dbl;
}

MyUnion x;
<span class="hljs-comment">// set all bytes of raw to 0</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i {<span class="hljs-number">0</span>}; i &lt; <span class="hljs-built_in">sizeof</span>(x.raw); i++) {
   x.raw[i] = <span class="hljs-number">0</span>;
}
<span class="hljs-comment">// since all members of the union start at the same memory location, these</span>
<span class="hljs-comment">// will by likely both be 0 (unless short or double has a byte size of over</span>
<span class="hljs-comment">// 100).</span>
<span class="hljs-type">int</span> x = x.num_in;
<span class="hljs-type">int</span> y = x.num_dbl;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FContainers%2FVariant)_TOPIC%2F">Library Functions/Containers/Variant</a> (consider using this instead of <a href="#BM_(union)%2Fi">union</a>s)</li>
</ul>
</div>
<a name="H_Namespaces"></a><h2>Namespaces</h2>
<p><a name="BM_(Core%20Language%5C%2FNamespaces)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>Namespaces are C++'s way of organizing code into a logical hierarchy / avoiding naming conflicts, similar to packages in Java or Python. Unlike packages, namespaces don't use the filesystem to define their logical hierarchy. Instead, the hierarchy is specified directly in code using <code>namespace</code> blocks.</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> FirstLevel {
    <span class="hljs-keyword">namespace</span> MiddleLevel {
        <span class="hljs-keyword">namespace</span> LastLevel {
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
                <span class="hljs-type">int</span> count;
                <span class="hljs-type">bool</span> flag;
            };
        }
    }
}
</code></pre>
<p>The nesting in the example above is avoidable via the scope operator (::).</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> FirstLevel::MiddleLevel::LastLevel {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
        <span class="hljs-type">int</span> count;
        <span class="hljs-type">bool</span> flag;
    };
}
</code></pre>
<p>To use the symbols within a namespace, either include them directly or bring all symbols within the namespace to the forefront via the <code>using</code> keyword (similar to Java's <code>import</code> or Python's <code>from</code> / <code>import</code>).</p>
<pre class="hljs"><code><span class="hljs-comment">// Use namespace directly.</span>
FirstLevel:MiddleLevel::LastLevel::MyStruct x{};

<span class="hljs-comment">// Bring all symbols within a namespace to the forefront.</span>
<span class="hljs-keyword">using</span> FirstLevel:MiddleLevel::LastLevel;
MyStruct y{};

<span class="hljs-comment">// Bring a single symbol within a namespace to the forefront.</span>
<span class="hljs-keyword">using</span> FirstLevel:MiddleLevel::LastLevel::MyStruct;
MyStruct z{};
</code></pre>
<a name="H_Linker%20Behaviour"></a><h2>Linker Behaviour</h2>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FObject%20Lifecycle)_TOPIC%2F">Core Language/Object Lifecycle</a></li>
</ul>
</div>
<p><a href="#BM_(specifier%7Cmodifier)%2Fi">Modifier</a>s on a variable or function declaration are used to control how the <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> behaves. Specifically, the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>s can ask the <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> to automatically ...</p>
<ul>
<li>merge the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>inline</code>)</li>
<li>find the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>extern</code>)</li>
<li>keep hidden the item that has the <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied (<code>static</code>).</li>
</ul>
<a name="H_Static%20Linkage"></a><h3>Static Linkage</h3>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour%2FStatic%20Linkage)_TOPIC%2F"></a><strong></strong></p>
<p>A static function or variable is one that's only visible to other code in the same <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will make sure that the function doesn't intermingle with other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s.</p>
<p>Static functions/variables have the <code>static</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is only for non-<a href="#BM_%5Cb(member)%2Fi">member</a>s (not belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<p>The meaning of <code>static</code> changes when the function or variables belongs to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>). When applied on a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a>, it means that it isn't bound to any <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> -- it can't access <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s belonging to an <a href="#BM_(object%7Cinstance)%2Fi">instance</a>.</p>
</div>
<a name="H_Inline%20Linkage"></a><h3>Inline Linkage</h3>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour%2FInline%20Linkage)_TOPIC%2F"></a><strong></strong></p>
<p>An inline function or variable is one that may be defined in multiple different <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will make sure all <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s use a single <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of that function/variable even though it may have been defined multiple times.</p>
<p>Inline functions/variables have the <code>inline</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">inline</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/1759575">this</a>. Typically, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> applies <code>inline</code> automatically based on what it sees, meaning that it isn't something that should be added by the programmer in most cases. The only <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> to that seems to be <a href="#BM_(template)%2Fi">template</a>s? See some of the other answers in the linked stack overflow question.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The original intent of <code>inline</code> was to indicate to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that embedding a copy of the function for an invocation was preferred over an function call. The reason being that in certain cases the code would be faster if it were embedded rather than having it branch into a function call.</p>
</div>
<a name="H_External%20Linkage"></a><h3>External Linkage</h3>
<p><a name="BM_(Core%20Language%5C%2FLinker%20Behaviour%2FExternal%20Linkage)_TOPIC%2F"></a><strong></strong></p>
<p>An external function or variable is a one that's usable within the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> but isn't defined. The <a href="#BM_(linker%7Cexecutable)%2Fi">linker</a> will sort out where the function is when the time comes.</p>
<p><a href="#BM_(external%20linkage)%2Fi">External linkage</a> functions/variables have the <code>extern</code> <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> applied.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Sounds similar to <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a> but across different <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s?</p>
</div>
<a name="H_Control%20Flow"></a><h2>Control Flow</h2>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow)_TOPIC%2F"></a><strong></strong></p>
<p>C++ flow control structures are similar to those in other high-level languages (e.g. Java), with the <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> that ...</p>
<ul>
<li>it's possible to have initializer statements in control structures other than for loops.</li>
<li>jumping to arbitrary labels are allowed (goto statements).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>An important caveat about loops in C++ from <a href="https://en.cppreference.com/w/cpp/language/while">cpp</a><a href="#BM_(reference)%2Fi">reference</a>.com:</p>
<blockquote>
<p>As part of the C++ forward progress guarantee, the behavior is undefined if a loop that has no observable behavior (does not make calls to I/O functions, access <a href="#BM_(volatile)%2Fi">volatile</a> <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, or perform atomic or synchronization operations) does not terminate. <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a>s are permitted to remove such loops.</p>
</blockquote>
</div>
<a name="H_If%20Statement"></a><h3>If Statement</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FIf%20Statement)_TOPIC%2F"></a><strong></strong></p>
<p>If statements follow a similar structure to if statements in Java. The only major difference is that an initializer statement is allowed before the condition in the initial <code>if</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()}; r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" div by 5"</span>;
} <span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
}
</code></pre>
<p>In the example above, an initializer statement has been added that sets a variable to a random number. That variable is only accessible inside the different branches of the if statement.</p>
<a name="H_Switch%20Statement"></a><h3>Switch Statement</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FSwitch%20Statement)_TOPIC%2F"></a><strong></strong></p>
<p>Switch statements follow a similar structure to switch statements in Java. The only major difference is that an initializer statement is allowed before the condition.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()}; r % <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
    std::cout &lt;&lt; <span class="hljs-string">"this should never happen"</span>;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>To indicate to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that a fallthrough case is intended behaviour, use the <code>[[fallthrough]]</code> <a href="#BM_(attribute)%2Fi">attribute</a>.</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (x) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: [[fallthrough]]
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" even"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
    std::cout &lt;&lt; <span class="hljs-string">"this should never happen"</span>;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<a name="H_For%20Loop"></a><h3>For Loop</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FFor%20Loop)_TOPIC%2F"></a><strong></strong></p>
<p>For loops follow a similar structure to for loop in Java.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i {<span class="hljs-number">0</span>}; i &lt; <span class="hljs-number">10</span>; i++)  {
    std::cout &lt;&lt; i;
}
</code></pre>
<p>Similarly, an analog to Java's for-each loop exists called range-based for loops. The only major difference is that an initializer statement is allowed before the range declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()}; <span class="hljs-type">int</span> val : array)  {
    std::cout &lt;&lt; (r + val) &lt;&lt; <span class="hljs-string">' '</span>;
}
</code></pre>
<a name="H_While%20Loop"></a><h3>While Loop</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FWhile%20Loop)_TOPIC%2F"></a><strong></strong></p>
<p>While and do-while loops follow a similar structure to their counterparts in Java.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span>};
<span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" "</span>;
    r--;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span>};
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" "</span>;
    r--;
} <span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// semicolon required at the end</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Unlike other control structures, these loops cannot have initializer statements.</p>
</div>
<a name="H_Goto%20Statement"></a><h3>Goto Statement</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FGoto%20Statement)_TOPIC%2F"></a><strong></strong></p>
<p>Unlike most other high-level languages (e.g. Java), C++ allows the use of goto statements. However, note that goto statements are generally considered bad practice and should somehow be refactored to higher-level constructs (e.g. loops, if statements, etc..).</p>
<pre class="hljs"><code>retry:
<span class="hljs-type">int</span> r {<span class="hljs-built_in">rand</span>()};
<span class="hljs-keyword">if</span> (r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">goto</span> retry;
}
std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">" odd"</span>;
</code></pre>
<a name="H_Branching%20Likelihood"></a><h3>Branching Likelihood</h3>
<p><a name="BM_(Core%20Language%5C%2FControl%20Flow%2FBranching%20Likelihood)_TOPIC%2F"></a><strong></strong></p>
<p>Conditional branching operations in flow control statements may have the <code>[[likely]]</code> and <code>[[unlikely]]</code> <a href="#BM_(attribute)%2Fi">attribute</a>s applied to hint at the likelihood / unlikelihood that of the path execution will take. This allows for better optimization by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (based on your assumptions).</p>
<pre class="hljs"><code><span class="hljs-built_in">switch</span> (exit_code) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    <span class="hljs-comment">// happy path</span>
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    <span class="hljs-comment">// recognized error path</span>
    <span class="hljs-keyword">break</span>;
    [[unlikely]] <span class="hljs-keyword">default</span>:
    <span class="hljs-comment">// unrecognized error path</span>
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_valid</span>(email)) [[likely]] {
    <span class="hljs-comment">// happy path</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// error path</span>
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) [[unlikely]] {
  <span class="hljs-comment">// do something</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I read something online saying you shouldn't use both <code>[[likely]]</code> and <code>[[unlikely]]</code> on the same switch/if/while/etc...</p>
</div>
<a name="H_Attributes"></a><h2>Attributes</h2>
<p><a name="BM_(Core%20Language%5C%2FAttributes)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ <a href="#BM_(attribute)%2Fi">attribute</a>s are similar to annotations in Java, providing information to the user / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> about the code that it's applied to. Unlike Java, C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s are free to pick and choose which <a href="#BM_(attribute)%2Fi">attribute</a>s they support and how they support them. There is no guarantee what action a <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will take, if any, when it sees an <a href="#BM_(attribute)%2Fi">attribute</a> (e.g. <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warnings).</p>
<p>An <a href="#BM_(attribute)%2Fi">attribute</a> is applied by nesting it in double square brackets (e.g. <code>[[noreturn]]</code>) and placing it as a <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> on the function.</p>
<pre class="hljs"><code>[[noreturn]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fail</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">throw</span> std::runtime_error { <span class="hljs-string">"Failed"</span> };
}
</code></pre>
<p>Common <a href="#BM_(attribute)%2Fi">attribute</a>s:</p>
<table>
<thead>
<tr>
<th><a href="#BM_(attribute)%2Fi">Attribute</a></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[deprecated("msg")]]</code></td>
<td>Indicates that a function is deprecated. Message is optional.</td>
</tr>
<tr>
<td><code>[[noreturn]]</code></td>
<td>Indicates that a function doesn't return.</td>
</tr>
<tr>
<td><code>[[fallthrough]]</code></td>
<td>Indicates that a switch case was explicitly designed to fall through to the next case (no <code>break</code> / <code>return</code> / etc.. intended).</td>
</tr>
<tr>
<td><code>[[nodiscard]]</code></td>
<td>Indicates that a function's result should be used somehow (produce <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> warning).</td>
</tr>
<tr>
<td><code>[[maybe_unused]]</code></td>
<td>Indicates that a function's result doesn't have to be used (avoid compile warning).</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FCommon%20Attributes)_TOPIC%2F">Core Language/Variables/Common Attributes</a></li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions%2FCommon%20Attributes)_TOPIC%2F">Core Language/Functions/Common Attributes</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCommon%20Attributes)_TOPIC%2F">Core Language/Classes/Common Attributes</a></li>
</ul>
</div>
<a name="H_Constant%20Expressions"></a><h2>Constant Expressions</h2>
<p><a name="BM_(Core%20Language%5C%2FConstant%20Expressions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>A <a href="#BM_(constant%20expression)%2Fi">constant expression</a> is an expression that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, such that any invocation of it gets swapped out for the result computed at <a href="#BM_(compile-time)%2Fi">compile-time</a>. It comes in two forms: variable and function.</p>
<p>A <a href="#BM_(constant%20expression)%2Fi">constant expression</a> variable requires using <code>constexpr</code> instead of <code>const</code>. The difference between a <code>const</code> variable and <code>constexpr</code> variable is that the former only guarantees the variable is unmodifiable. It doesn't actually guarantee that the expression within is evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span> + <span class="hljs-number">5</span>};      <span class="hljs-comment">// COULD BE evaluated at run-time or compile-time, but guaranteed to be unmodifiable</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> y {<span class="hljs-number">5</span> + <span class="hljs-number">5</span>};  <span class="hljs-comment">// MUST BE evaluated at compile-time and guaranteed to be unmodifiable</span>
</code></pre>
<p>Similarly, a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> function requires prefixing <code>constexpr</code> to a function. The entire compilation can be terminated at any point through the use of <code>static_assert</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fibonacci</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fibonacci</span>(n<span class="hljs-number">-2</span>);
    }
}

<span class="hljs-type">int</span> x {<span class="hljs-built_in">fibonacci</span>(<span class="hljs-number">7</span>)}; <span class="hljs-comment">// at compile-time, fibonacci(7) is executed and its return value substituted into the initializer</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>An alternate version of <a href="#BM_(constant%20expression)%2Fi">constant expression</a> functions, called <a href="#BM_(immediate%20function)%2Fi">immediate function</a>s, have the restriction that they must produce a <a href="#BM_(compile-time)%2Fi">compile-time</a> constant. An <a href="#BM_(immediate%20function)%2Fi">immediate function</a> requires prefixing <code>consteval</code> to a function instead of <code>constexpr</code>.</p>
<p>What's the point of this? According to <a href="https://stackoverflow.com/a/53347377">here</a>...</p>
<blockquote>
<p>constexpr functions may be evaluated at compile time or run time, and need not produce a constant in all cases.</p>
</blockquote>
<p>Here's an example from <a href="https://github.com/AnthonyCalandra/modern-cpp-features">here</a>...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
  <span class="hljs-keyword">return</span> n * n;
}

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> r {<span class="hljs-built_in">sqr</span>(<span class="hljs-number">100</span>)}; <span class="hljs-comment">// OK</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">100</span>};
<span class="hljs-type">int</span> r2 {<span class="hljs-built_in">sqr</span>(x)}; <span class="hljs-comment">// ERROR: the value of 'x' is not usable in a constant expression</span>
                 <span class="hljs-comment">// OK if `sqr` were a `constexpr` function</span>
</code></pre>
</div>
<p>The restrictions on <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s are vast. At a high-level, a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> is only allowed inputs and outputs that are <a href="#BM_(literal%20type)%2Fi">literal type</a>s:</p>
<ul>
<li><strong>Scalar</strong>: Floating point types, integral types, <a href="#BM_(pointer)%2Fi">pointer</a> types, <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a> types, <code>std::nullptr_t</code>, etc..</li>
<li><strong><a href="#BM_(reference)%2Fi">Reference</a></strong></li>
<li><strong>Array</strong>: Every element must be a literal.</li>
<li><strong><a href="#BM_(class%7C%5Cbstruct)%2Fi">Class</a></strong>: <a href="#BM_(constructor)%2Fi">Constructor</a> must be a <a href="#BM_(constant%20expression)%2Fi">constant expression</a>. Non-<a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> initializers using <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>, <a href="#BM_(equals%3F%20initialization)%2Fi">equals initialization</a>, or <a href="#BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi">brace-plus-equals initialization</a> must use <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s. The <a href="#BM_(destructor)%2Fi">destructor</a> must be a trivial <a href="#BM_(destructor)%2Fi">destructor</a> (non-virtual, does nothing, and all base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(destructor)%2Fi">destructor</a>s do nothing).</li>
<li><strong><a href="#BM_(union)%2Fi">Union</a></strong>: Must have at least one non-<a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a> that is a <a href="#BM_(literal%20type)%2Fi">literal type</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The rules here are vast and complicated. The above might not be entirely correct, may be missing some conditions, or may not cover certain aspects. In the type_traits header, there's a function called <code>std::is_literal_type</code> that can be used to test if a type is a <a href="#BM_(literal%20type)%2Fi">literal type</a>.</p>
</div>
<p>There are several benefits to <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s. First, <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s help with reducing the use of hard coded numbers whose origins are obtuse, called magic numbers. A <a href="#BM_(constant%20expression)%2Fi">constant expression</a> uses the computation to get to that obtuse magic number rather than the number itself, meaning it's easier to understand and requires less effort to tweak (via the parameters of the <a href="#BM_(constant%20expression)%2Fi">constant expression</a>).</p>
<p>Second, there exists a special type of <a href="#BM_(compile-time)%2Fi">compile-time</a> if-else where the chosen path is the only one in which code is generated for. These <a href="#BM_(compile-time)%2Fi">compile-time</a> if-elses, identified by the <code>constexpr</code> keyword immediately after the <code>if</code>, use <a href="#BM_(constant%20expression)%2Fi">constant expression</a>s in their conditionals when deciding which path to choose. These are use-cases such as ...</p>
<ul>
<li>omitting parts of a program from compilation (e.g. demonstration software).</li>
<li>working around <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>-specific / platform-specific inconsistencies (e.g. only include code if <code>int</code>'s ma<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">x value</a> is above some threshold).</li>
<li>performing specific actions based on the types chosen for <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s (e.g. include code path 1 if <a href="#BM_(pointer)%2Fi">pointer</a>, otherwise code path 2).</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(y == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span> </span>{
    <span class="hljs-comment">// constant expression y is equivalent to the number of bytes for an int, so compile this block</span>
    ...
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// constant expression y is NOT equivalent to the number of bytes for an int, so compile this block</span>
    ...
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Type information is queryable at <a href="#BM_(compile-time)%2Fi">compile-time</a> through the type_traits. Information about numeric types is queryable at <a href="#BM_(compile-time)%2Fi">compile-time</a> using numeric_limits, cstdlib, and cfloat headers.</p>
<p>Those are what you would commonly use in <code>if constexpr</code> blocks. They help with building portable software.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>All of this seems to replace the need for C <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros <code>#define</code> / <code>#ifdef</code> / etc...</p>
</div>
<a name="H_Exceptions"></a><h2>Exceptions</h2>
<p><a name="BM_(Core%20Language%5C%2FExceptions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p>C++ <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s work similarly to <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s in other languages, except that there is no <code>finally</code> block. The idea behind this is that resources should be bound to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a> (<a href="#BM_(destructor)%2Fi">destructor</a>). As the call stack unwinds and the <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a>s that each function owns are destroyed, the <a href="#BM_(destructor)%2Fi">destructor</a>s of those <a href="#BM_(object%7Cinstance)%2Fi">object</a>s should be cleaning up any resources that would have been cleaned up by the <code>finally</code> block. This concept is referred to as resource acquisition is initialization (<a href="#BM_(RAII%7CCADRe)%2F">RAII</a>).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What does accordingly mean? For example, wrap the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamically allocated object</a> in a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> where <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> happens in the <a href="#BM_(constructor)%2Fi">constructor</a> / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a> happens in the <a href="#BM_(destructor)%2Fi">destructor</a>. An <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic object</a> of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type will clean up properly when the function exits.</p>
</div>
<p>To throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, use the <code>throw</code> keyword followed by the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to throw. Most <a href="#BM_(object%7Cinstance)%2Fi">object</a> types are throwable, but thrown <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are typically limited to types either in or derived from those in the stdexcept header.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">no_negatives_check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> std::runtime_error { <span class="hljs-string">"no negatives"</span> };
    }
}
</code></pre>
<p>Similar to Java and Python, C++ provides a standard set of <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>s in stdexcept complete with a hierarchy.</p>
<p><img src="svgbob_0347537f32e15529524b9ab7c34cb1f41f86ec3a.svg" alt="Kroki diagram output"></p>
<p>To catch an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> potentially being thrown, wrap code in a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block. Typical inheritance rules apply when catching an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>. For example, catching a <code>std:runtime_error</code> type will also catch anything that <a href="#BM_(extends%3F%7Csubclass)%2Fi">extends</a> from it as well (e.g. <code>std:overflow_error</code>).</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">55</span>);
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// do something</span>
}
</code></pre>
<p>To catch any <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> regardless of type, use <code>...</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-comment">// do something, note the exception object is not accessible here</span>
}
</code></pre>
<p>Multiple catches may exist in the same <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block.</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">no_negatives_check</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// will throw an exception</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::range_error &amp;e) {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// do something -- this block will get chosen</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-keyword">const</span> std::exception &amp;e) {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-comment">// do something, note the exception object is not accessible here</span>
}
</code></pre>
<a name="H_Structured%20Binding"></a><h2>Structured Binding</h2>
<p><a name="BM_(Core%20Language%5C%2FStructured%20Binding)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables)_TOPIC%2F">Core Language/Variables</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FReferences)_TOPIC%2F">Core Language/Variables/References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FFunctions)_TOPIC%2F">Core Language/Functions</a>: Just enough to know how to define and use one.</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses)_TOPIC%2F">Core Language/Classes</a>: Just enough to know how to define and use one.</li>
</ul>
</div>
<p><a href="#BM_(structured%20binding)%2Fi">Structured binding</a> declaration is a C++ language feature similar to Python's unpacking of lists and tuples. Given an array or a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, the values contained within are unpackable to individual variables.</p>
<pre class="hljs"><code><span class="hljs-comment">// array example</span>
<span class="hljs-type">int</span> x[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
<span class="hljs-keyword">auto</span> [a, b] = x;  <span class="hljs-comment">// a is a copy of x[0], b is a copy of x[1]</span>
<span class="hljs-keyword">auto</span> &amp;[c, d] = x; <span class="hljs-comment">// c is a REFERENCE to a[0], d is a REFERENCE to a[1]</span>

<span class="hljs-comment">// class example</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;
};
MyStruct y {<span class="hljs-number">5</span>,<span class="hljs-literal">true</span>};
<span class="hljs-keyword">auto</span> [i, j] = y;  <span class="hljs-comment">// i is a copy of y.count, b is a copy of y.flag</span>
<span class="hljs-keyword">auto</span> &amp;[k, l] = y; <span class="hljs-comment">// k is a REFERENCE to y.count, l is a REFERENCE to y.flag</span>
</code></pre>
<a name="H_Expression%20Categories"></a><h2>Expression Categories</h2>
<p><a name="BM_(Core%20Language%5C%2FExpression%20Categories)_TOPIC%2F"></a><strong></strong></p>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">Value categories</a> are a classification of expressions in C++. At their core, these categories are used for determining when <a href="#BM_(object%7Cinstance)%2Fi">object</a>s get <em>moved</em> vs copied, where a move means that the guts of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> are scooped out and transferred to another <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<p><img src="svgbob_636a9684b4155de37000338d0777e9a56174ac26.svg" alt="Kroki diagram output"></p>
<p>This is explicitly categorizing expressions, not <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, variables or types. Each expression is categorized as either an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>, or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>.</p>
<p>A <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is an expression that generates some transient result, where that result is typically either used for assignment or passed into a function invocation by <em>moving</em> it.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> a { <span class="hljs-number">0</span> }; <span class="hljs-comment">// move -- 0 is being generated and MOVED into a (the expression 0 is a prvalue)</span>
<span class="hljs-comment">//      ^</span>
<span class="hljs-comment">//      |</span>
<span class="hljs-comment">//   rvalue</span>

<span class="hljs-type">int</span> b { a }; <span class="hljs-comment">// copy -- a already exists and its being COPIED into b (the expression a is NOT a prvalue)</span>
</code></pre>
<p>In essence, the way to think of a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is that it's an expression that meets the following 3 conditions ...</p>
<ol>
<li>
<p>can't have the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator used on it.</p>
<pre class="hljs"><code>MyStruct* a {&amp;<span class="hljs-built_in">MyStruct</span>(<span class="hljs-literal">true</span>)}; <span class="hljs-comment">// error -- right-hand expression is transient, not a var that you can get the address of   </span>
<span class="hljs-type">int</span>* b {&amp;(<span class="hljs-number">5</span>)}                  <span class="hljs-comment">// error -- right-hand expression is a literal, not a var that you can get the address of</span>
<span class="hljs-type">int</span>* c {&amp;<span class="hljs-built_in">get_int</span>()}            <span class="hljs-comment">// error -- right-hand expression is the return val of function, not a var that you can get the address of</span>
</code></pre>
</li>
<li>
<p>can have its guts be scooped out and moved into something else.</p>
<pre class="hljs"><code>x = <span class="hljs-number">55</span> + y;  <span class="hljs-comment">// expression 55 + y is evaluated and the result is MOVED into x (its guts are scooped out and moved into x)</span>
</code></pre>
</li>
<li>
<p>doesn't persist once the expression has been executed.</p>
<pre class="hljs"><code>x = <span class="hljs-number">55</span> + y;  <span class="hljs-comment">// expression 55 + y is a prvalue -- doesn't persist after this line (its not something you can access)</span>
x = c;       <span class="hljs-comment">// expression c is NOT a prvalue -- DOES persist after this line (it IS something you can keep accessing)</span>
</code></pre>
</li>
</ol>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The name <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> is short for pure right value. It's called that because <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> expressions are usually found on the right side of an assignment.</p>
</div>
<p>An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> is an expression that is the opposite of a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>. An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expression CAN use the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator (opposite of point 1 above), it CANNOT have guts scooped out and moved into something else (opposite of point 2 above), and it DOES persist (opposite of point 3 above). The typical example of an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> is an expression that's solely a variable name or function name.</p>
<pre class="hljs"><code>x = y;  <span class="hljs-comment">// both x and y are lvalue</span>
x = <span class="hljs-number">0</span>;  <span class="hljs-comment">// x is an lvalue while 0 is a prvalue</span>
</code></pre>
<p>The key takeaway with <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>s is that you might be able to <em>copy</em> over its contents to something else, but you can't scoop out its guts and <em>move</em> it over to something different. Doing so would make whatever that <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> points to no longer usable.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The name <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> is short for left value. It's called that because <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expressions are usually found on the left side of an assignment.</p>
</div>
<p>An <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> is an expression which can have the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator used on it but also <em>can be moved</em>. The general idea with an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> expression is that the <a href="#BM_(object%7Cinstance)%2Fi">object</a> it represents is nearing the end of its <a href="#BM_(lifetime)%2Fi">lifetime</a> and as such moving its guts is fine. There are a very limited number of cases where this happens or is required.</p>
<pre class="hljs"><code>MyObject a {};
MyObject &amp;&amp;b {std::<span class="hljs-built_in">move</span>(a)};  <span class="hljs-comment">// get rvalue reference</span>
MyObject c {b};               <span class="hljs-comment">// move a into c (gut it into c) via the move constructor</span>
<span class="hljs-comment">// b is in an invalid state</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The example above is using features that haven't been introduced yet (std::move, <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a>s, <a href="#BM_(move%20constructor)%2Fi">move constructor</a>). Just ignore it if you don't know those pieces yet. They're explained in other sections.</p>
</div>
<p>This is in contrast to <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> expressions, which the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator is usable on but <em>CANNOT be moved</em>. If the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator works on it, regardless of if it's moveable (<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>) or not (<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>), it's called a <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">glvalue</a>.</p>
<p><img src="svgbob_2a2d0a00b43ce9677954ebe489b0081560222ce3.svg" alt="Kroki diagram output"></p>
<p>Similarly, if it's an expression that can be <em>moved</em> (gutted), it's called an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> regardless of if the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator can be used on it or not.</p>
<p><img src="svgbob_cfa8451d53907631139a68a6093bf7bd5bf2c0c4.svg" alt="Kroki diagram output"></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="http://zhaoyan.website/xinzhi/cpp/html/cppsu32.html">here</a> for what I used to clarify what's going on here.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FRvalue%20References)_TOPIC%2F">Core Language/Variables/Rvalue References</a></li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a></li>
</ul>
</div>
<a name="H_Iterators"></a><h2>Iterators</h2>
<p><a name="BM_(Core%20Language%5C%2FIterators)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FOperator%20Overloading)_TOPIC%2F">Core Language/Classes/Operator Overloading</a></li>
</ul>
</div>
<p><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Iterator</a>s in C++ are similar to <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s in Java. In Java, <a href="#BM_(object%7Cinstance)%2Fi">object</a>s that...</p>
<ul>
<li>produce an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> typically implement the <code>Iterable</code> interface (e.g. <code>ArrayList</code>)</li>
<li>are <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s must implement the <code>Iterator</code> interface.</li>
</ul>
<p>In C++, there is no requirement to <a href="#BM_(extends%3F%7Csubclass)%2Fi">extend</a> from any base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es or interfaces. Instead, any type can act as an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> so long as it supports as set of operators:</p>
<ul>
<li><code>!=</code> - test if the position of one <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> doesn't match the position of another <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> (e.g. <code>my_iterator != end_iterator</code>).</li>
<li><code>++</code> - move to the next item (e.g. <code>my_iterator++</code>).</li>
<li><code>*</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>) - access the next item (e.g. <code>int value {*my_iterator}</code>).</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Notice that the operators are more or less array / <a href="#BM_(pointer)%2Fi">pointer</a> behaviour. Given something like <code>int *</code> pointing to the beginning of an array, ...</p>
<ul>
<li>incrementing it by 1 (<code>++</code>) moves it to the next element of the array via <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a>.</li>
<li><a href="#BM_(dereference%7Cdereferencing)%2Fi">dereferencing</a> it (<code>*</code>) provides the value at the array element it points to.</li>
<li>testing it using inequality (<code>!=</code>) is a way to check if it hasn't gone past the last array element.</li>
</ul>
<p>An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> is basically a set of operators that walk elements in the same way as you would an array. A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can implement the <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s and behave the same way.</p>
</div>
<p>Similarly, any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can act as an iterable by implementing begin and end <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>s, commonly referred to as a range:</p>
<ul>
<li><code>begin()</code> - returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> pointing to the first item.</li>
<li><code>end()</code> - returns an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> pointing to <em>past-the-end</em> (just after the last element).</li>
</ul>
<pre class="hljs"><code>MyIterator it {collection.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">while</span> (it != collection.<span class="hljs-built_in">end</span>()) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
    ++iterator;
}
</code></pre>
<p>C++ iterables and <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s can be used together in range-based for loops.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (MyIterator it : collection) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
}
</code></pre>
<p>In total, 5 kinds of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s are supported by C++. The kind of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> described above is called an <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> and it typically requires an equality <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> (<code>operator ==()</code>) in addition to inequality. <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Input iterator</a>s are the closest thing to a standard Java <code>Iterator</code> -- read-only and forward-only. Other kinds of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s require different <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s.</p>
<ul>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Input iterator</a>, steps forward one element at a time and reads items of the container.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Output iterator</a>, steps forward one element at a time and writes items of the container.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Forward iterator</a>, combination of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> and <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a>.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Bidirectional iterator</a>, <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> with the ability to move back.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">Random access iterator</a>, <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> with the ability to jump to different positions.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input</th>
<th>Output</th>
<th>Forward</th>
<th>Bidirectional</th>
<th>Random access</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>++it</code> and <code>it++</code> (move forward)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>--it</code> and <code>it--</code> (move backward)</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 == it2</code> and<code>it1 != it2</code> (test if at same position)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &lt; it2</code> (test if before)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &lt;= it2</code> (test if before or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &gt; it2</code> (test if after)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 &gt;= it2</code> (test if after or at)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>x = *it</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and get)</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>*it = x</code> (<a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a> and set)</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 += n</code> and <code>it1 + n</code> (add integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 -= n</code> and <code>it1 - n</code> (subtract integer)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it2 - it1</code> (subtract <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s to get positional difference)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>it1 + it2</code> (add <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Note that the adding of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s is listed above but is not supported by any of the <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> types. It's there to make it explicit that adding together two <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s isn't a thing.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>If you're dealing with the STL, there's also special <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> implementations that allow insertions rather than setting elements. See <code>insert_iterator</code>, <code>back_insert_iterator</code>, and <code>front_insert_iterator</code>.</p>
</div>
<a name="H_Modules"></a><h2>Modules</h2>
<p><a name="BM_(Core%20Language%5C%2FModules)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Source is <a href="https://vector-of-bool.github.io/2019/03/10/modules-1.html">this website</a>.</p>
</div>
<p>C++ modules change how C++ source code files interface with each other. Normally, a C++ source / header file would use <code>#include &lt;...&gt;</code> directives to pull in other source code files that it needs access to. Those outside source code files provided things like <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros, function declarations, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> declarations, global variable constants, <a href="#BM_(forward%20declaration)%2Fi">forward declaration</a>s, <a href="#BM_(template)%2Fi">template</a>s, etc...</p>
<p>Instead of dealing with source code files directly, C++ modules allow for independently "compiling" source code files and importing them for use into different source code files, similar to how a Java source code file imports compiled Java <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> files for use. Modules reduce some of the complexities of using header files but certain functionality is also gone. Specifically, before modules go through compilation, <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> macros and <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives aren't included.</p>
<p>To create a module from a single file, add <code>export module</code> followed by the name of the module in the beginning of the file. Then, prefix <code>export</code> to any function, <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, etc.. that the module should expose.</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>To make use of a module in some other source code, use <code>import</code> followed by the module's name.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> my_module;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
}
</code></pre>
<p>Similar to how non-module C++ source code is broken up into a source file containing definitions and accompanying header file containing declarations, a module may also be broken up into separate definition and declaration files. The declarations go in a file with <code>export module</code> at the top (as shown above) and the definitions go in a file with just <code>module</code>. Declaration files aren't allowed to use <code>export</code> at all.</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;

<span class="hljs-comment">// my_module_impl.cpp</span>
<span class="hljs-keyword">module</span> my_module;  <span class="hljs-comment">// no "export" in module declaration, meaning export not allowed anywhere else in this file</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>Modules may be broken up into several pieces using module partitions, with each piece in its own file, using colons (:).</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module:addition;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
<span class="hljs-keyword">export</span> my_module:multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :addition;        <span class="hljs-comment">// export everything under my_module:addition partition</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :multiplication;  <span class="hljs-comment">// export everything under my_module:multiplication partition</span>
</code></pre>
<p>Module partitions may be made non-exportable as well, similar to the definition / declaration example earlier. The parent would need to re-define anything it wants to explicitly export.</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module:addition;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
my_module:multiplication;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">import</span> :addition;
<span class="hljs-keyword">import</span> :multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;      <span class="hljs-comment">// explicitly export this function (imported from my_module:addition partition)</span>
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>; <span class="hljs-comment">// explicitly export this function (imported from my_module:multiplication partition)</span>
</code></pre>
<p>Note that there can only ever be 1 parent for a partition. All partitions are a part of their parent module, not modules themselves. The parent module must import all of its partitions using either <code>import</code> or <code>export import</code> as shown in the examples above. No module can directly import a partition that doesn't belong to it.</p>
<p>One way to work around these restrictions is to simply make the partitions their own modules. The most common way to do this is to replace the colons (:) in each partition name with a dot (.), making sure to use the full name in the import lines (because the pieces being imported are no longer partitions of the parent module).</p>
<pre class="hljs"><code><span class="hljs-comment">// my_module_addition.cpp</span>
<span class="hljs-keyword">export</span> my_module.addition;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// my_module_multiplication.cpp</span>
<span class="hljs-keyword">export</span> my_module.multiplication;
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-comment">// my_module.cpp</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> my_module;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> my_module.addition;        <span class="hljs-comment">// export everything under my_module.addition (FULL NAME USED)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> my_module.multiplication;  <span class="hljs-comment">// export everything under my_module.multiplication (FULL NAME USED)</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Last I recall using this, each <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> required a special flag to turn on modules. Just because your code uses modules doesn't mean the internal C++ libraries (e.g. standard <a href="#BM_(template)%2Fi">template</a> library, <code>cstdint</code>, etc..) are going to expose things as modules. You still have to include those using the <code>#include &lt;...&gt;</code> directives (maybe -- I think I remember there being some roundabout way of getting modules to work).</p>
</div>
<a name="H_Preprocessor"></a><h2>Preprocessor</h2>
<p><a name="BM_(Core%20Language%5C%2FPreprocessor)_TOPIC%2F"></a><strong></strong></p>
<p>The <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> is a component of the C++ <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>. Before the programming statements in a source code file are compiled, the processor goes over the file looking for <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives. <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">Preprocessor</a> directives either...</p>
<ol>
<li>perform some basic text manipulation.</li>
<li>signal certain things to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> (e.g. use a specific feature, turn off a specific feature, etc..).</li>
</ol>
<p>The first case (text manipulation) is primarily what the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> is used for. Unlike normal C++ programming statements, <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives start with the pound sign (#) and shouldn't include a semicolon (;) at the end.</p>
<p>To include one file in another file, use <code>#include</code>. Local files should be wrapped in quotes while files coming from libraries should be wrapped in angled brackets.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>          <span class="hljs-comment">// library header</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OtherClass.hpp"</span>  <span class="hljs-comment">// local header</span></span>
</code></pre>
<p>To replace strings in a file with another string, use <code>#define</code>.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 500</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-type">int</span> y {INITIAL_VALUE};
</code></pre>
<p>To replace strings in a file with a <em>parameterized replacement</em>, use <code>#define</code> with parenthesis.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADDED_VALUE(x, y) x + y - 15</span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-type">int</span> y {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)};
</code></pre>
<p>To stop replacing a string, use <code>#undef</code>.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 500</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> INITIAL_VALUE</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_VALUE 8</span>
<span class="hljs-type">int</span> y {INITIAL_VALUE};
</code></pre>
<p>To conditionally include / ignore portions of a file, use an <code>#ifdef</code> / <code>#else</code> / <code>#endif</code> block.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>Similarly, <code>#ifndef</code> may be used to conditionally include / ignore portions of a file (<code>#ifndef</code> -- note the n, if NOT defined).</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {<span class="hljs-built_in">ADDED_VALUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)};
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {INITIAL_VALUE};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>Conditional inclusion <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">preprocessor</a> directives come in an alternate form that allows for more flexible conditions: <code>#if</code> / <code>#elif</code> /<code>#else</code> / <code>#endif</code> block.</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined INITIAL_VALUE</span>
<span class="hljs-type">int</span> x {<span class="hljs-number">1</span>}
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> INITIAL_VALUE &gt; 50</span>
<span class="hljs-type">int</span> x {INITIAL_VALUE - <span class="hljs-number">50</span>}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-type">int</span> x {INITIAL_VALUE}
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p><a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a> / compilation options may be controlled through <code>#pragma</code>s. I've left <code>#pragma</code>s out of the document because they're specific to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> and platform.</p>
</div>
<a name="H_Inconsistent%20Behaviour"></a><h2>Inconsistent Behaviour</h2>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<p>High-level languages are typically very consistent. For example, except for a handful of small things, Java's <a href="#BM_(runtime)%2Fi">runtime</a> and core libraries are consistent across different platforms (e.g. Windows vs Linux), architectures (e.g. ARM vs x86), and <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s (e.g. OpenJDK vs Eclipse <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>). C++ has much less consistency than those other high-level languages because it has to support more platforms and architectures. In addition, having less consistency sometimes allows for more aggressive optimization during compilation.</p>
<p>Inconsistencies comes in three different types:</p>
<ul>
<li>Implementation-defined behaviour: Behaviour varies between implementations, where that behaviour is valid (e.g. no hard crash) and documented.</li>
<li>Unspecified behaviour: Behaviour varies between implementations, where that behaviour is valid (e.g. no hard crash) but <em>not</em> documented.</li>
<li>Undefined behaviour: Behaviour is unrestricted (e.g. maybe hard crash, bad computation, or expected computation) and not documented.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Valid</th>
<th>Documented</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implementation-defined behaviour</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Unspecified behaviour</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Undefined behaviour</td>
<td>MAYBE</td>
<td>NO</td>
</tr>
</tbody>
</table>
<a name="H_Implementation-defined%20Behaviour"></a><h3>Implementation-defined Behaviour</h3>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour%2FImplementation-defined%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<p>Implementation-defined behaviour is behaviour that varies between implementations, where that behaviour is valid (e.g. no hard crash) and documented. The obvious example is with numeric data types: <code>short</code>, <code>int</code>, <code>float</code>, etc.. will each have a different minimum and maximum across different platforms:</p>
<ul>
<li><code>short</code> is from <code>SHORT_MIN</code> to <code>SHORT_MAX</code>.</li>
<li><code>int</code> is from <code>INT_MIN</code> to <code>INT_MAX</code>.</li>
<li>...</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Someone posted <a href="http://eel.is/c++draft/impldefindex">this</a> as a comprehensive list of implementation-defined behaviour.</p>
</div>
<a name="H_Unspecified%20Behaviour"></a><h3>Unspecified Behaviour</h3>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour%2FUnspecified%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<p>Unspecified behaviour is behaviour that varies between implementations, where that behaviour is valid (e.g. no hard crash) but <em>not</em> documented. The obvious example is the order in which operands are evaluated in an expression. For example, consider the following statement ...</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-built_in">bird_func</span>() / <span class="hljs-built_in">cow_func</span>()};
</code></pre>
<p>The results of <code>bird_func()</code> and <code>cow_func()</code> may be gotten in any order prior to performing the division. There is no requirement as to which one gets invoked first. The division itself with the correct operands in the correct spots, but which function gets called first is up to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// option1  -- bird_func() evaluated first</span>
<span class="hljs-type">int</span> a {<span class="hljs-built_in">bird_func</span>()};
<span class="hljs-type">int</span> b {<span class="hljs-built_in">cow_func</span>()};
<span class="hljs-type">int</span> x {a / b};

<span class="hljs-comment">// option2  -- cow_func() evaluated first</span>
<span class="hljs-type">int</span> b {<span class="hljs-built_in">cow_func</span>()};
<span class="hljs-type">int</span> a {<span class="hljs-built_in">bird_func</span>()};
<span class="hljs-type">int</span> x {a / b};
</code></pre>
<p>Another example is the memory representation of core types (e.g. integral types). The platform's memory layout could be either big-endian, little-endian, or some other uncommon memory layout.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-comment">// big endian:    00 00 00 05  (e.g. ARM)</span>
<span class="hljs-comment">// little endian: 05 00 00 00  (e.g. x86)</span>
</code></pre>
<p>The above doesn't matter unless you're trying to read raw contents of core types (e.g. for serializing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to disk).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I wasn't able to find a comprehensive list of what the C++ spec considers as unspecified behaviour.</p>
</div>
<a name="H_Undefined%20Behaviour"></a><h3>Undefined Behaviour</h3>
<p><a name="BM_(Core%20Language%5C%2FInconsistent%20Behaviour%2FUndefined%20Behaviour)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FPointers)_TOPIC%2F">Core Language/Variables/Pointers</a></li>
<li><a href="#BM_(Core%20Language%5C%2FVariables%2FArrays)_TOPIC%2F">Core Language/Variables/Arrays</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>According to documentation online: "<a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">Compiler</a>s are not required to diagnose or do anything meaningful when undefined behaviour is present. Correct C++ programs are free of undefined behaviour". Not exactly sure how to fix some scenarios to be "free" of undefined behaviour. Specifically, there are a lot of cases where signed integer overflow (described below) happens, but that's undefined behaviour. I read online that the way to handle these cases is to test at the beginning of the function if overflow is possible and bail out if it is, but there's no built-in C++ mechanism to do that.</p>
<p>The statement and the examples below, were lifted from <a href="https://en.cppreference.com/w/cpp/language/ub">here</a>.</p>
</div>
<p>Undefined behaviour is behaviour that is unrestricted and not documented. The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> may do anything for code producing undefined behaviour. For example, code producing undefined behaviour could end up ...</p>
<ul>
<li>causing a hard crash.</li>
<li>doing exactly what the author of the source code originally intended for.</li>
<li>doing something different than what the author of the source code originally intended for.</li>
<li>causing the program to not immediately crash, but potentially much later.</li>
</ul>
<p>None of the examples have to be consistent. For example, it could produce a hard crash some of the time and the intended results the rest of the time.</p>
<ul>
<li>
<p>Signed integer overflow</p>
<p>Although signed integers are guaranteed to be two's complement (as of C++20), what happens when a signed integer overflows is still undefined behaviour. In many cases, the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will treat signed integer operations as if overflowing isn't possible. For example, consider the following function ...</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x &lt; x + <span class="hljs-number">1</span>;
}
</code></pre>
<p>What may happen: The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>s will optimize away the return expression to always return <code>true</code>. Had signed integer overflow NOT been undefined behaviour, the function would return <code>true</code> except in the case where <code>x == INT_MAX</code>: When <code>x == INT_MIN</code>, the expression <code>x + 1</code> would rollover to <code>INT_MIN</code>, leading <code>x &lt; x + 1</code> to evaluate to <code>false</code>.</p>
</li>
<li>
<p>Array out of bounds access</p>
<p>Array out of bounds access typically ends up touching memory past the array's boundaries.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> data[<span class="hljs-number">5</span>] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
data[<span class="hljs-number">65535</span>] {<span class="hljs-number">15</span>};
</code></pre>
<p>What may happen: Out of bounds data access will result in either...</p>
<ul>
<li>the reading/writing of some other <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s memory (e.g. corruption of another <a href="#BM_(object%7Cinstance)%2Fi">object</a>, if writing).</li>
<li>the reading/writing of memory not assigned to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</li>
<li>a crash.</li>
</ul>
</li>
<li>
<p>Uninitialized scalar</p>
<p>Uninitialized scalars are scalars that are read before being written to.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x;
std:cout &lt;&lt; x; <span class="hljs-comment">// what's in x? </span>
</code></pre>
<p>What may happen: Uninitialized scalars contain junk data (e.g. whatever was in the memory before).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Scalar typically means arithmetic type or <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a> type. See <a href="https://stackoverflow.com/a/14822074">this</a>.</p>
</div>
</li>
<li>
<p>Invalid scalar</p>
<p>When a scalar gets reinterpreted as something else (e.g. a byte array) and its contents are manipulated, reading from that original scalar is undefined behaviour.</p>
<pre class="hljs"><code><span class="hljs-comment">// EXAMPLE FROM https://en.cppreference.com/w/cpp/language/ub</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">bool</span> b {<span class="hljs-literal">true</span>};
    <span class="hljs-keyword">unsigned</span> <span class="hljs-type">char</span>* p {<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;b)};
    *p {<span class="hljs-number">10</span>};
    <span class="hljs-comment">// reading from b is now UB</span>
    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span>;
}
</code></pre>
<p>What may happen: modifications on the reinterpretation are treated as if it never happened.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Scalar typically means arithmetic type or <a href="#BM_(pointer)%2Fi">pointer</a> / <a href="#BM_(reference)%2Fi">reference</a> type. See <a href="https://stackoverflow.com/a/14822074">this</a>.</p>
</div>
</li>
<li>
<p>Null <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a></p>
<pre class="hljs"><code><span class="hljs-comment">// EXAMPLE FROM https://en.cppreference.com/w/cpp/language/ub</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>{
    <span class="hljs-type">int</span> x {*p};
    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// Either UB above or this branch is never taken</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span>* p {<span class="hljs-literal">nullptr</span>};
    <span class="hljs-keyword">return</span> *p;        <span class="hljs-comment">// Unconditional UB</span>
}
</code></pre>
<p>What may happen: Trying to read or write to a <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>d <code>nullptr</code> will cause a crash.</p>
</li>
<li>
<p>Side-effect free infinite loops</p>
<p>A side-effect free infinite loop is a loop that goes on forever but doesn't change anything outside of its own scope (e.g. no global variable is changed, nothing is printed to standard out, etc..).</p>
<pre class="hljs"><code><span class="hljs-comment">// EXAMPLE FROM https://en.cppreference.com/w/cpp/language/ub</span>
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (((a*a*a) == ((b*b*b)+(c*c*c)))) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    a++;
    <span class="hljs-keyword">if</span> (a&gt;MAX) { a=<span class="hljs-number">1</span>; b++; }
    <span class="hljs-keyword">if</span> (b&gt;MAX) { b=<span class="hljs-number">1</span>; c++; }
    <span class="hljs-keyword">if</span> (c&gt;MAX) { c=<span class="hljs-number">1</span>;}
}
</code></pre>
<p>What may happen: Side-effect free infinite loops are removed entirely.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I wasn't able to find a comprehensive list of what the C++ spec considers as undefined behaviour. The above examples were taken from <a href="https://en.cppreference.com/w/cpp/language/ub">cpp</a><a href="#BM_(reference)%2Fi">reference</a>.</p>
</div>
<a name="H_Library%20Functions"></a><h1>Library Functions</h1>
<p><a name="BM_(Library%20Functions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Core%20Language)_TOPIC%2F">Core Language</a></li>
</ul>
</div>
<p>By default, C++ comes packages with the C++ standard library. You can think of this as C++'s equivalent of core Java packages: collection <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es in <code>java.util</code>, thread <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es in <code>java.util.concurrent</code>, IO <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es in <code>java.io</code>, etc... In addition, several third-party C++ libraries exist that provide commonly needed functionality. You can think of these are as C++'s equivalent to common Java libraries: Guava, Apache Commons, etc...</p>
<p>Common third-party C++ libraries:</p>
<ul>
<li><a href="https://www.boost.org/">Boost</a></li>
<li><a href="https://abseil.io/">Absiel</a> (Google)</li>
<li><a href="https://github.com/facebook/folly">Folly</a> (Facebook)</li>
</ul>
<p>The subsections below detail important functionality across the many C++ libraries in existence. If the functionality being documented is for a third party library, it'll be signalled in some way (e.g. namespace / header files / comments used in sample code will make it apparent).</p>
<a name="H_Allocators"></a><h2>Allocators</h2>
<p><a name="BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F"></a><strong></strong></p>
<p>Allocators allow for customizing how <a href="#BM_(object%7Cinstance)%2Fi">object</a>s are <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. Some library APIs allow you to provide a custom allocators rather than using the typical <code>new</code>/<code>new[]</code> and <code>delete</code>/<code>delete[]</code> operators. In certain scenarios where performance is important (e.g. gaming, simulations, high-frequency trading, etc..), custom allocators are often used. A custom allocator could increase performance by ...</p>
<ul>
<li>using alternate data structures (e.g. finding free memory to assign to a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> is faster).</li>
<li>using an <a href="#BM_(object%7Cinstance)%2Fi">object</a> pool (e.g. an <a href="#BM_(object%7Cinstance)%2Fi">object</a> put back into the pool and taken out again may not need to be fully re-initialized).</li>
<li>attempting to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> related <a href="#BM_(object%7Cinstance)%2Fi">object</a>s closer together in memory (e.g. less cache misses).</li>
</ul>
<p>By default, libraries that support custom allocators will default to <code>std::allocator</code>, which just wraps the <code>new</code>/<code>new[]</code> and <code>delete</code>/<code>delete[]</code> operators.</p>
<p>To implement a custom allocator, you need to create a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es with a single <a href="#BM_(template%20parameter)%2Fi">template parameter</a> representing the type being <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> must have the following traits...</p>
<ol>
<li>a default <a href="#BM_(constructor)%2Fi">constructor</a>.</li>
<li>a <a href="#BM_(constructor)%2Fi">constructor</a> to "rebind" another allocator (copy).</li>
<li>a nested <a href="#BM_(type%20alias)%2Fi">type alias</a> <code>value_type</code> corresponding to the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</li>
<li>an <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</li>
<li>a <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>.</li>
<li><a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s for equality inequality.</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocator</span> {
    <span class="hljs-keyword">using</span> value_type = T;  <span class="hljs-comment">// 3</span>

    <span class="hljs-built_in">MyAllocator</span>() <span class="hljs-keyword">noexcept</span>{ }  <span class="hljs-comment">// 1</span>
    
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-built_in">MyAllocator</span>(<span class="hljs-keyword">const</span> MyAllocator&lt;U&gt;&amp;) <span class="hljs-keyword">noexcept</span> { }  <span class="hljs-comment">// 2 (why is this here? https://docs.microsoft.com/en-us/cpp/standard-library/allocator-class?view=msvc-170#allocator)</span>
    
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>{ <span class="hljs-comment">// 4</span>
        <span class="hljs-keyword">auto</span> ret = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(T) * n);
        std::cout &lt;&lt; <span class="hljs-string">"allocated!"</span> &lt;&lt; ret &lt;&lt; <span class="hljs-string">"\n"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(ret);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* p, <span class="hljs-type">size_t</span> n)</span> </span>{ <span class="hljs-comment">//5</span>
        std::cout &lt;&lt; <span class="hljs-string">"deallocated!"</span> &lt;&lt; ret &lt;&lt; <span class="hljs-string">"\n"</span>;
        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MyAllocator&lt;T1&gt;&amp;, <span class="hljs-keyword">const</span> MyAllocator&lt;T2&gt;&amp;) { <span class="hljs-comment">// 6 (why is this here? https://stackoverflow.com/a/30654267)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// always because this class retains no state</span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> MyAllocator&lt;T1&gt;&amp;, <span class="hljs-keyword">const</span> MyAllocator&lt;T2&gt;&amp;) { <span class="hljs-comment">// 6 (why is this here? https://stackoverflow.com/a/30654267)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// always because this class retains no state</span>
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I don't fully understand what the <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> and the <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s are for. The <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> seems to be for cases where you pass in an allocator to some container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (e.g. <code>vector</code>) but that container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> needs to <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a> more than just the type you're interested in. For example, the allocator may be for creating <code>int</code>s (e.g. <a href="#BM_(template%20parameter)%2Fi">template parameter</a> <code>T</code> = <code>int</code>) but the container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> you're storing those <code>int</code>s may have book keeping structures that it wraps each <code>int</code> in (e.g. each <code>int</code> is wrapped as a <code>Node</code> <a href="#BM_(object%7Cinstance)%2Fi">object</a> which also contains some extra <a href="#BM_(pointer)%2Fi">pointer</a>s). This <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> "repurposes" the allocator, allowing you to to pass in <code>MyAllocator&lt;int&gt;</code> but have it repurposed to <code>MyAllocator&lt;SomeOtherTypeHere&gt;</code>.</p>
<p>But if you're copying the guts of one allocator into another but both keep on allocating and deallocating, won't they trip up over each other?</p>
<p>I haven't been able to find answers online as to what's going on here. The book just seems to hand wave it away.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Why not just do <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ing for the new operator? The answer seems to be that allocators are simpler to deal with and handle wider scenarios (such as the concatenating example in the note above).</p>
</div>
<a name="H_Smart%20Pointers"></a><h2>Smart Pointers</h2>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FAllocators)_TOPIC%2F">Library Functions/Allocators</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FMoving)_TOPIC%2F">Core Language/Classes/Moving</a> (refresher)</li>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FCopying)_TOPIC%2F">Core Language/Classes/Copying</a> (refresher)</li>
</ul>
</div>
<p><a href="#BM_(smart%20pointer)%2Fi">Smart pointer</a>s are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that wrap <a href="#BM_(pointer)%2Fi">pointer</a>s to dynamically <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. These wrappers provide some level of automated <a href="#BM_(pointer)%2Fi">pointer</a> management / memory management through the use of move semantics, <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>, and <a href="#BM_(RAII%7CCADRe)%2F">RAII</a>.</p>
<p>The subsections below document some common <a href="#BM_(smart%20pointer)%2Fi">smart pointer</a>s and their usages.</p>
<a name="H_Scoped%20Pointer"></a><h3>Scoped Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FScoped%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<p>(non-moveable, non-copyable)</p>
<p>A scoped <a href="#BM_(pointer)%2Fi">pointer</a> wraps a <a href="#BM_(pointer)%2Fi">pointer</a> to an existing <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> / <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a> and invokes <code>delete</code> / <code>delete[]</code> on it once it exits the current scope. It explicitly turns off <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> and move semantics, meaning that copying a scoped <a href="#BM_(pointer)%2Fi">pointer</a> or moving it isn't allowed.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x == <span class="hljs-number">123L</span>) {
    boost::scoped_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
    x += *ptr; <span class="hljs-comment">// like a real pointer, use indirection operator / member of pointer operator </span>
} <span class="hljs-comment">// ptr destroyed via delete operator at the end of if block (RAII)</span>
</code></pre>
<p>Scoped <a href="#BM_(pointer)%2Fi">pointer</a>s come in two flavours:</p>
<ul>
<li><code>scoped_ptr</code>: <a href="#BM_(pointer)%2Fi">pointer</a> to a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>.</li>
<li><code>scoped_array</code>: <a href="#BM_(pointer)%2Fi">pointer</a> to a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>.</li>
</ul>
<pre class="hljs"><code>boost::scoped_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
boost::scoped_array&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>] {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>} }};
</code></pre>
<p>Although the official move semantics of a scoped <a href="#BM_(pointer)%2Fi">pointer</a> are to deny moves, it does provide a ...</p>
<ul>
<li><code>swap()</code> function that lets you swap the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s between two scoped <a href="#BM_(pointer)%2Fi">pointer</a>s.</li>
<li><code>destroy()</code> function that destroys the current <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> and sets it to the argument passed in, if any.</li>
</ul>
<p>In addition, it's possible to have an unset scoped <a href="#BM_(pointer)%2Fi">pointer</a> (<code>nullptr</code>). An unset scoped <a href="#BM_(pointer)%2Fi">pointer</a> won't attempt to destroy an <a href="#BM_(object%7Cinstance)%2Fi">object</a> when it goes out of scope.</p>
<a name="H_Unique%20Pointer"></a><h3>Unique Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FUnique%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FScoped%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Scoped Pointer</a></li>
</ul>
</div>
<p>(moveable, non-copyable)</p>
<p>A unique <a href="#BM_(pointer)%2Fi">pointer</a> supports all the same features a scoped <a href="#BM_(pointer)%2Fi">pointer</a>, except that it also supports moving: The ownership of the <a href="#BM_(pointer)%2Fi">pointer</a> that unique <a href="#BM_(pointer)%2Fi">pointer</a> has is transferrable to another unique <a href="#BM_(pointer)%2Fi">pointer</a> via move semantics (e.g. assignment operator <a href="#BM_(move%20constructor)%2Fi">move constructor</a>). Like scoped <a href="#BM_(pointer)%2Fi">pointer</a>, a unique <a href="#BM_(pointer)%2Fi">pointer</a> doesn't support copying.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x == <span class="hljs-number">123L</span>) {
    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
    x += *ptr;
    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 { std::<span class="hljs-built_in">move</span>(ptr) };  <span class="hljs-comment">// ALLOWED: move ptr into ptr2 -- ptr is invalid after this point</span>
    x -= *ptr2;
}
</code></pre>
<p>Unlike scoped <a href="#BM_(pointer)%2Fi">pointer</a>s, a unique <a href="#BM_(pointer)%2Fi">pointer</a> uses the same <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> for both <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s and <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>s.</p>
<pre class="hljs"><code>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>] {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>} }};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Look at the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s in the example above. It's important that you add <code>[]</code> into the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> when you're dealing with arrays so the destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a> operator (<code>delete[]</code>) gets used. If the destroy <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> operator (<code>delete</code>) is used for an array, it's undefined behaviour. Likewise, don't add <code>[]</code> into the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> if you aren't dealing with arrays.</p>
</div>
<p>In older versions of C++, the <a href="#BM_(template)%2Fi">template</a>d function <code>std::make_unique()</code> was provided to create unique <a href="#BM_(pointer)%2Fi">pointer</a>s because the normal way (shown in the example above) has subtle edge cases that could result in memory leaks. Newer versions of C++ fixed the memory leak problem, so using <code>std::make_unique()</code> isn't necessary but it's still available for backwards compatibility.</p>
<pre class="hljs"><code><span class="hljs-comment">// following two are equivalent</span>
std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>);  <span class="hljs-comment">// make_unique automatically calls new</span>
</code></pre>
<p>Unique <a href="#BM_(pointer)%2Fi">pointer</a>s don't support custom allocators: You pass the <a href="#BM_(pointer)%2Fi">pointer</a> you want to track directly into the <a href="#BM_(constructor)%2Fi">constructor</a> or create it via <code>std::make_unique()</code>. But, unique <a href="#BM_(pointer)%2Fi">pointer</a>s do support taking in a function-like <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. function, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, <a href="#BM_(lambda)%2Fi">lambda</a>) to invoke instead of using <code>delete</code> / <code>delete[]</code> on the tracked <a href="#BM_(pointer)%2Fi">pointer</a>. This is useful in cases where the <a href="#BM_(pointer)%2Fi">pointer</a> being tracked ...</p>
<ul>
<li>wasn't created using <code>new</code> / <code>new[]</code> (e.g. <code>FILE *</code> created using <code>fopen()</code>).</li>
<li>needs to have deletion logged (e.g. print out whenever the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is deleted).</li>
<li>is associated with extra resources that need to be handled in some way on release.</li>
</ul>
<p>For example, a unique <a href="#BM_(pointer)%2Fi">pointer</a> that points to a memory mapped file region shouldn't call <code>delete[]</code> when it goes out of scope because it isn't actually pointing to a <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic array</a>. Instead, it should invoke the relevant function(s) that release a memory mapped file region.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> custom_deleter = [](<span class="hljs-type">int</span>* x) {
    std::cout &lt;&lt; <span class="hljs-string">"Deleting an int at "</span> &lt;&lt; x;
    <span class="hljs-keyword">delete</span> x;
};
std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(custom_deleter)&gt; ptr{ <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>}, custom_deleter };
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Types have to match -- if the unique pointer is for an "int", the custom deleter should take in an "int *"</span>
</code></pre>
<a name="H_Shared%20Pointer"></a><h3>Shared Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FShared%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FUnique%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Unique Pointer</a></li>
</ul>
</div>
<p>(moveable, copyable)</p>
<p>A shared <a href="#BM_(pointer)%2Fi">pointer</a> tracks the number of copies it has in existence and only destroys the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> it points to once the number of copies reaches 0 (<a href="#BM_(reference)%2Fi">reference</a> counting). The <a href="#BM_(reference)%2Fi">reference</a> count increments when a new copy is made (e.g. <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a>) and decrements when a copy is destroyed (e.g. goes out of scope). Moves don't modify the <a href="#BM_(reference)%2Fi">reference</a> count.</p>
<pre class="hljs"><code>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} }; <span class="hljs-comment">// ref count 1</span>
<span class="hljs-keyword">if</span> (x == <span class="hljs-number">123L</span>) {
    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptrCopy { ptr }; <span class="hljs-comment">// ref count 2</span>
    x += *ptrCopy;
} <span class="hljs-comment">// ref count back to 1 because ptrCopy destroyed here</span>
x -= *ptr2;
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Theres a version of shared <a href="#BM_(pointer)%2Fi">pointer</a> in Boost and one in the C++ standard library. The Boost version is legacy.</p>
</div>
<p>The construction of shared <a href="#BM_(pointer)%2Fi">pointer</a>s is similar to the construction of unique <a href="#BM_(pointer)%2Fi">pointer</a>s. You can either call the <a href="#BM_(constructor)%2Fi">constructor</a> directly or you can use the <a href="#BM_(template)%2Fi">template</a>d function <code>std::make_shared()</code>. Where as <code>std::make_unique()</code> was a legacy creation mechanism for unique <a href="#BM_(pointer)%2Fi">pointer</a>s, <code>std::make_shared()</code> is the preferred creation mechanism for shared <a href="#BM_(pointer)%2Fi">pointer</a>s. That's because shared <a href="#BM_(pointer)%2Fi">pointer</a>s require a "control block" that holds onto tracking information (e.g. <a href="#BM_(reference)%2Fi">reference</a> counts), and using <code>std:make_shared()</code> <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>s that control block along with the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> in one single <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> (better performance: one <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> vs two <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a>s).</p>
<pre class="hljs"><code>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>) };  <span class="hljs-comment">// allocates the control block and object together</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };
std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; ptr { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>] {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>} }};
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book says that sometimes you want to avoid <code>std::make_shared</code> because you might need the control block even if the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> goes away (mentions weak <a href="#BM_(pointer)%2Fi">pointer</a>s). This isn't possible if the control block and the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> are <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d as one, because if they're <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d as one then you can't individually delete them (you can only delete both things at once).</p>
</div>
<p>Like unique <a href="#BM_(pointer)%2Fi">pointer</a>, shared <a href="#BM_(pointer)%2Fi">pointer</a>'s <a href="#BM_(constructor)%2Fi">constructor</a> may take in a custom deleter. In addition, it may also take in a custom allocator. The custom allocator has nothing to do with the underlying <a href="#BM_(pointer)%2Fi">pointer</a> -- it gets used for allocating and deallocating the control block.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> object_deleter = [](<span class="hljs-type">int</span>* x) {
    std::cout &lt;&lt; <span class="hljs-string">"Deleting an int at "</span> &lt;&lt; x;
    <span class="hljs-keyword">delete</span> x;
};
<span class="hljs-keyword">auto</span> control_block_allocator { std::allocator&lt;<span class="hljs-type">void</span>&gt;{}} ;
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr{ <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>}, object_deleter, control_block_allocator };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There are no <a href="#BM_(template%20parameter)%2Fi">template parameter</a> for the deleter or allocator. You just pass them in as the last two <a href="#BM_(constructor)%2Fi">constructor</a> arguments and it should just work. The book is saying that they were left out for "complicated reason".</p>
</div>
<p>It isn't possible to use a custom allocator with <code>std::make_shared()</code>. It forces the use of <code>new</code> / <code>new[]</code> and <code>delete</code> / <code>delete[]</code> for single combined <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> of the control block and the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>. To perform a single combined <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and use a custom allocator for that <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a>, you need to use <code>std::allocate_shared()</code> instead.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> my_allocator { std::allocator&lt;<span class="hljs-type">void</span>&gt;{}} ;
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr{ std::<span class="hljs-built_in">allocate_shared</span>&lt;<span class="hljs-type">int</span>&gt;(my_allocator, <span class="hljs-number">5</span>) };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>There is no <a href="#BM_(template%20parameter)%2Fi">template parameter</a> for the allocator. You just pass it in as the first <a href="#BM_(constructor)%2Fi">constructor</a> argument and it should just work.</p>
<p>There is no custom deleter with <code>std::allocate_shared</code> because the deletion happens via the allocator. Both the control block and the <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a> are being <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d together.</p>
</div>
<p>In certain cases, a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> may want to return shared <a href="#BM_(pointer)%2Fi">pointer</a>s to itself (a shared <a href="#BM_(pointer)%2Fi">pointer</a> to its <code>this</code> <a href="#BM_(pointer)%2Fi">pointer</a>). A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> can't ...</p>
<ul>
<li>maintain a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a> that's a shared <a href="#BM_(pointer)%2Fi">pointer</a> to itself: That shared <a href="#BM_(pointer)%2Fi">pointer</a>'s <a href="#BM_(reference)%2Fi">reference</a> count would never reach 0 because the <a href="#BM_(object%7Cinstance)%2Fi">object</a> itself will always be holding onto a copy of that shared <a href="#BM_(pointer)%2Fi">pointer</a>.</li>
<li>provide a function to generate shared <a href="#BM_(pointer)%2Fi">pointer</a>s to itself: There will be multiple shared <a href="#BM_(pointer)%2Fi">pointer</a>s leading to the same <a href="#BM_(object%7Cinstance)%2Fi">object</a>, meaning that if one of those shared <a href="#BM_(pointer)%2Fi">pointer</a>s were to reach a <a href="#BM_(reference)%2Fi">reference</a> count of 0 it would delete the <a href="#BM_(object%7Cinstance)%2Fi">object</a> while the other shared <a href="#BM_(pointer)%2Fi">pointer</a>s would still think the <a href="#BM_(object%7Cinstance)%2Fi">object</a> still exists (dangling <a href="#BM_(pointer)%2Fi">pointer</a>).</li>
</ul>
<p>To work around these problems, C++ provides the <code>std::enable_shared_from_this</code> base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can inherit from.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; {
    <span class="hljs-function">shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPointer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">// special function provided by the base class</span>
    }
}
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/712307">here</a> for more information.</p>
</div>
<a name="H_Weak%20Pointer"></a><h3>Weak Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FWeak%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FShared%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Shared Pointer</a></li>
</ul>
</div>
<p>A weak <a href="#BM_(pointer)%2Fi">pointer</a> is essentially a shared <a href="#BM_(pointer)%2Fi">pointer</a> that doesn't increment or decrement the <a href="#BM_(reference)%2Fi">reference</a> count. At any moment, it can generate an actual shared <a href="#BM_(pointer)%2Fi">pointer</a> via its <code>lock()</code> <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a>, thereby increasing the <a href="#BM_(reference)%2Fi">reference</a> count.</p>
<pre class="hljs"><code>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp1 { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} }; <span class="hljs-comment">// ref count = 1</span>
std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp{ sp };              <span class="hljs-comment">// ref count = 1</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 { wp.<span class="hljs-built_in">lock</span>() };   <span class="hljs-comment">// ref count = 2</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 { wp.<span class="hljs-built_in">lock</span>() };   <span class="hljs-comment">// ref count = 3</span>
</code></pre>
<p>If the shared <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(reference)%2Fi">reference</a> count has already reached 0 when <code>lock()</code> is invoked, the returned shared <a href="#BM_(pointer)%2Fi">pointer</a> will be empty.</p>
<pre class="hljs"><code>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp {};  <span class="hljs-comment">// unset weak pointer</span>
{
    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {<span class="hljs-number">5</span>} };  <span class="hljs-comment">// create a new shared pointer</span>
    wp = sp;                                  <span class="hljs-comment">// assign the shared pointer ot the weak pointer</span>
} <span class="hljs-comment">// scope ends, shared pointer destroyed (reference count drops from 1 to 0, meaning object is deleted)</span>
std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp { wp.<span class="hljs-built_in">lock</span>() };
<span class="hljs-type">bool</span> isEmpty = (sp == std::<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// isEmpty will be true</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Theres a version of weak <a href="#BM_(pointer)%2Fi">pointer</a> in Boost and one in the C++ standard library. The Boost version is legacy. Each weak <a href="#BM_(pointer)%2Fi">pointer</a> version is tied to the shared <a href="#BM_(pointer)%2Fi">pointer</a> from its library. For example, if you're using the weak <a href="#BM_(pointer)%2Fi">pointer</a> in Boost, you need to use it with the shared <a href="#BM_(pointer)%2Fi">pointer</a> from Boost.</p>
</div>
<p>The typical use-cases for weak <a href="#BM_(pointer)%2Fi">pointer</a>s are ...</p>
<ul>
<li>caching (e.g. only calculate data if weak <a href="#BM_(pointer)%2Fi">pointer</a> is unset).</li>
<li>cyclical <a href="#BM_(reference)%2Fi">reference</a>s (e.g. data structures such as cyclical graphs).</li>
</ul>
<p>For cyclical <a href="#BM_(reference)%2Fi">reference</a>s point above, what it means is that shared <a href="#BM_(pointer)%2Fi">pointer</a>s forming a cycle will never reach a <a href="#BM_(reference)%2Fi">reference</a> count of 0.</p>
<p><img src="svgbob_25474d39768e24b30a0b2722d8a979da4683892a.svg" alt="Kroki diagram output"></p>
<p>In the example above...</p>
<ul>
<li>A has a shared <a href="#BM_(pointer)%2Fi">pointer</a> to C (<a href="#BM_(reference)%2Fi">reference</a> count = 1)</li>
<li>C has a shared <a href="#BM_(pointer)%2Fi">pointer</a> to B (<a href="#BM_(reference)%2Fi">reference</a> count = 1)</li>
<li>B has a shared <a href="#BM_(pointer)%2Fi">pointer</a> to A (<a href="#BM_(reference)%2Fi">reference</a> count = 1)</li>
</ul>
<p>Nothing else holds these shared <a href="#BM_(pointer)%2Fi">pointer</a>s. They all <a href="#BM_(reference)%2Fi">reference</a> each other, meaning that none of the shared <a href="#BM_(pointer)%2Fi">pointer</a> <a href="#BM_(reference)%2Fi">reference</a> counts will never reach 0 (memory leak).</p>
<a name="H_Intrusive%20Pointer"></a><h3>Intrusive Pointer</h3>
<p><a name="BM_(Library%20Functions%5C%2FSmart%20Pointers%2FIntrusive%20Pointer)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FSmart%20Pointers%2FShared%20Pointer)_TOPIC%2F">Library Functions/Smart Pointers/Shared Pointer</a></li>
</ul>
</div>
<p>An intrusive <a href="#BM_(pointer)%2Fi">pointer</a> invokes the <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> <code>intrusive_ptr_add_ref()</code> on any <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and <code>intrusive_ptr_release()</code> on any <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>. Both functions take in a single argument: a <a href="#BM_(pointer)%2Fi">pointer</a> of the type being <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d / <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d.</p>
<pre class="hljs"><code><span class="hljs-type">size_t</span> cnt {};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intrusive_ptr_add_ref</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>{
    cnt++;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intrusive_ptr_release</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>{
    cnt--;
}

boost::intrusive_ptr&lt;<span class="hljs-type">int</span>&gt; a { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>{<span class="hljs-number">5</span>} };     <span class="hljs-comment">// after this, cnt will be 1</span>
{
    boost::intrusive_ptr&lt;<span class="hljs-type">int</span>&gt; b { <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>{<span class="hljs-number">6</span>} }; <span class="hljs-comment">// after this, cnt will be 2</span>
    boost::intrusive_ptr&lt;<span class="hljs-type">int</span>&gt; c { a };          <span class="hljs-comment">// after this, cnt will be 3</span>
} <span class="hljs-comment">// at the end of this scope, cnt will be 1 again</span>
</code></pre>
<p>Where as a shared <a href="#BM_(pointer)%2Fi">pointer</a> keeps a count of how many copies of itself are live (<a href="#BM_(reference)%2Fi">reference</a> count), an intrusive <a href="#BM_(pointer)%2Fi">pointer</a> is typically used for keeping count of how many of some specific <em><a href="#BM_(pointer)%2Fi">pointer</a> type</em> are live. In the example above it's tracking <code>int</code>, but you can track more types by simply <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">overload</a>ing <code>intrusive_ptr_add_ref()</code> and <code>intrusive_ptr_release()</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The book mentions that this is useful in cases where the OS or framework requires some cleanup operation once the last <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of some type goes away (e.g. the old school Windows component <a href="#BM_(object%7Cinstance)%2Fi">object</a> model).</p>
</div>
<a name="H_Containers"></a><h2>Containers</h2>
<p><a name="BM_(Library%20Functions%5C%2FContainers)_TOPIC%2F"></a><strong></strong></p>
<p>Containers are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that wrap one or more other <a href="#BM_(object%7Cinstance)%2Fi">object</a>s, such as collections (e.g. lists and maps). These wrappers either provide some type of extra functionality or provide abstractions that make code easier to handle and reason about.</p>
<p>The subsections below document some common container <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and their usages.</p>
<a name="H_Optional"></a><h3>Optional</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FOptional)_TOPIC%2F"></a><strong></strong></p>
<p>An optional <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a container that either holds on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> or is empty (similar to Java or Python's optional <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<pre class="hljs"><code><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;  <span class="hljs-comment">// nullopt = empty optional</span>
    }
    <span class="hljs-keyword">return</span> std::optional&lt;<span class="hljs-type">int</span>&gt; { x * x };
}
</code></pre>
<p>As shown in the example above, the typical usecase for optional is to have a function return an empty optional on failure.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Other strategies for reporting failure are throwing an error and returning an error code along with the <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</div>
<p>In addition to the optional provided by the C++ standard library, Boost provides its ony version of optional <code>boost::optional</code> as well as provides a optional-like boolean type  called tribool: <code>boost::logic::tribool</code>. A tribool has a third state in addition to true and false, called indeterminate. Boolean operations where one of the operands is a boolean value and the other is indeterminate will always result in false (tribools convert to booleans via implicit conversion).</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FConversion%20Overloading)_TOPIC%2F">Core Language/Classes/Conversion Overloading</a> (refresher -- tribool <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> implements implicit conversion semantics)</li>
</ul>
</div>
<pre class="hljs"><code>boost::logic::tribool tb { boost::logic::indeterminate };
<span class="hljs-type">bool</span> x {tb == <span class="hljs-literal">true</span>};  <span class="hljs-comment">// false</span>
<span class="hljs-type">bool</span> y {tb == <span class="hljs-literal">false</span>}; <span class="hljs-comment">// false</span>
<span class="hljs-type">bool</span> z {!tb};         <span class="hljs-comment">// false</span>
</code></pre>
<p>The typical usecase for tribool is for operations that take a long time to complete. A tribool may be set as indeterminate while the operation is running, then be set to true (success) or false (failure) once the operation completes.</p>
<a name="H_Tuple"></a><h3>Tuple</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FTuple)_TOPIC%2F"></a><strong></strong></p>
<p>A tuple <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a <a href="#BM_(template)%2Fi">template</a>d <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that holds on to an arbitrary number of elements of arbitrary types. The number of elements and types of elements must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a>, and any code accessing those elements must know which element its accessing at <a href="#BM_(compile-time)%2Fi">compile-time</a>.</p>
<pre class="hljs"><code>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>, MyClass&gt; my_tuple{ <span class="hljs-number">1</span>, <span class="hljs-number">500L</span>, MyClass{} };
<span class="hljs-keyword">auto</span>&amp; x { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; y { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; z { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(my_tuple) };
<span class="hljs-comment">// OR you can use structured binding</span>
<span class="hljs-keyword">auto</span>&amp; [x, y, z] = my_tuple;
</code></pre>
<p>Note how the elements are being accessed using <code>std::get()</code>, which requires the index being accessed passed in as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>. Elements your code accesses <em>must be known at <a href="#BM_(compile-time)%2Fi">compile-time</a></em>, meaning you can't evaluate some expression at run-time to determine which index to access like you can with tuples in other high-level languages (e.g. Python).</p>
<p>If all the types in for a tuple are different, the type itself can be passed into <code>std::get()</code>.</p>
<pre class="hljs"><code>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>, MyClass&gt; my_tuple{ <span class="hljs-number">1</span>, <span class="hljs-number">500L</span>, MyClass{} };
<span class="hljs-keyword">auto</span>&amp; x { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; y { std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">long</span>&gt;(my_tuple) };
<span class="hljs-keyword">auto</span>&amp; z { std::<span class="hljs-built_in">get</span>&lt;MyClass&gt;(my_tuple) };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I guess the way to think about tuples is that they're short-hand for <a href="#BM_(POD)%2F">POD</a>s. Declaring a tuple is like creating a custom <a href="#BM_(POD)%2F">POD</a> where each element of the tuple is <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a> of the <a href="#BM_(POD)%2F">POD</a>.</p>
</div>
<p>Pairs are special case of tuples where they're restricted to exactly two elements. Accessing the elements in a pair is done through the <code>first</code> and <code>second</code> <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">member variable</a>s.</p>
<pre class="hljs"><code>std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt; my_pair{ <span class="hljs-number">1</span>, <span class="hljs-number">500L</span> };
<span class="hljs-keyword">auto</span>&amp; x {my_pair-&gt;first};
<span class="hljs-keyword">auto</span>&amp; y {my_pair-&gt;second};
<span class="hljs-comment">// OR you can use structured binding</span>
<span class="hljs-keyword">auto</span>&amp; [x, y] = inimitable_duo;
</code></pre>
<p>Boost also provides a version of pair, <code>boost::compressed_pair</code>, except that it's slightly more efficient when either <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s points to an empty <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EmptyClass</span> {};

std::pair&lt;<span class="hljs-type">int</span>, EmptyClass&gt; p {<span class="hljs-number">5</span>, EmptyClass{} };
boost::compressed_pair&lt;<span class="hljs-type">int</span>, EmptyClass&gt; cp {<span class="hljs-number">5</span>, EmptyClass{} };  <span class="hljs-comment">// this one consumes less memory</span>
</code></pre>
<a name="H_Any"></a><h3>Any</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FAny)_TOPIC%2F"></a><strong></strong></p>
<p>An any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a container that can hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of unknown type (a type that isn't known at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</p>
<pre class="hljs"><code>std::any container {};
container.emplace&lt;MyClass&gt; { arg1, arg2 };
<span class="hljs-keyword">auto</span> v1 = std::<span class="hljs-built_in">any_cast</span>&lt;MyClass&gt;(container); <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">auto</span> v2 = std::<span class="hljs-built_in">any_cast</span>&lt;BadType&gt;(container); <span class="hljs-comment">// should throws std::bad_any_cast</span>
</code></pre>
<p>To place an <a href="#BM_(object%7Cinstance)%2Fi">object</a> into the container, use <code>emplace()</code>. This <em>creates</em> a new <a href="#BM_(object%7Cinstance)%2Fi">object</a> and places it into the container, destroying the <a href="#BM_(object%7Cinstance)%2Fi">object</a> previously held. The type of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is passed in as a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument while the function arguments are used to initialize that <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. passed directly to <a href="#BM_(constructor)%2Fi">constructor</a>).</p>
<p>Accessing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> within the container is done via <code>std::any_cast()</code>. The function argument is the container itself and the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument is the type of  <a href="#BM_(object%7Cinstance)%2Fi">object</a> <em>you think</em> is being held. If the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is of a different type, the function throws <code>std::bad_any_cast</code> instead of returning the <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The closest Java analog I could think of is the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> hierarchy where all Java <a href="#BM_(object%7Cinstance)%2Fi">object</a>s have to derive from <code>java.lang.Object</code>. You can accept a type of <code>Java.lang.Object</code> and cast it at <a href="#BM_(runtime)%2Fi">runtime</a> to the correct type (or one of its ancestors). The C++ any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> provides similar functionality to that.</p>
</div>
<p>Boost also provides a version of this container, <code>boost::any</code>.</p>
<a name="H_Variant"></a><h3>Variant</h3>
<p><a name="BM_(Library%20Functions%5C%2FContainers%2FVariant)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Library Functions/Containers/Any</li>
<li>Library Functions/Containers/Tuple</li>
</ul>
</div>
<p>A variant <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a type-restricted form of the <code>std::any</code>. Where as with the <code>std::any</code> you can hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of any type, with <code>std::variant</code> you can hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of one of several predefined types.</p>
<pre class="hljs"><code>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, MyClass&gt; container {};  <span class="hljs-comment">// may hold on to either int, float, or MyClass</span>
container.emplace&lt;MyClass&gt; { arg1, arg2 };
<span class="hljs-keyword">auto</span> v1 = std::<span class="hljs-built_in">get</span>&lt;MyClass&gt;(container);     <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">auto</span> v2 = std::<span class="hljs-built_in">get_if</span>&lt;MyClass&gt;(container);  <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">auto</span> v3 = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-type">int</span>&gt;(container);      <span class="hljs-comment">// returns nullptr</span>
<span class="hljs-keyword">auto</span> v4 = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(container);         <span class="hljs-comment">// throws std::bad_variant_exception</span>
<span class="hljs-keyword">auto</span> which_type = container.<span class="hljs-built_in">index</span>();    <span class="hljs-comment">// returns 2</span>
</code></pre>
<p>To determine which of the allowed types is currently held, use <code>index()</code>.</p>
<p>To access data, use <code>std::get()</code> where the <a href="#BM_(template%20parameter)%2Fi">template parameter</a> argument is the type you're interested in (similar to how data access is done in <code>std::tuple</code>). If the variant isn't holding an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the type trying to be extracted, <code>std::get()</code> will throw <code>std::bad_variant_exception</code>. To avoid an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>, use <code>std::get_if()</code> -- it will return <code>nullptr</code> rather than throw an <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>.</p>
<p>Unlike <code>std::any</code>, <code>std::variant</code> cannot be left unset (it must hold on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>). Initially, it creates and holds on to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the first type in its allowed types list. That means the first type in its allowed types list must be constructible with empty initializer arguments (e.g. default <a href="#BM_(constructor)%2Fi">constructor</a>). In the example above, the first allowed type is <code>int</code>, meaning that the variant starts off by holding on to an <code>int</code> created using an empty initializer (will have value of 0).</p>
<p>The easiest way to work around this problem is to set the first type to <code>std::monostate</code>. This allows your variant to be unset. Trying to call <code>std::get()</code> on an unset variant throws <code>std::bad_variant_access</code>.</p>
<pre class="hljs"><code>std::variant&lt;std::monostate, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>, MyClass&gt; container {};  <span class="hljs-comment">// may hold on to nothing, int, float, or MyClass</span>
<span class="hljs-keyword">auto</span> which_type = container.<span class="hljs-built_in">index</span>();     <span class="hljs-comment">// returns 0</span>
<span class="hljs-keyword">auto</span> v1 = std::<span class="hljs-built_in">get</span>&lt;MyClass&gt;(container);  <span class="hljs-comment">// throws std::bad_variant_access</span>
</code></pre>
<p>If you have a set of single parameter functions with the same name (<a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a>), where those parameters contains all the types in a variant's allowed types list, you can use <code>std::visit()</code> to automatically pull out the <a href="#BM_(object%7Cinstance)%2Fi">object</a> contained in the variant and call the appropriate <a href="#BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi">function overload</a> with that <a href="#BM_(object%7Cinstance)%2Fi">object</a> as the argument.</p>
<pre class="hljs"><code>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; container {};  <span class="hljs-comment">// may hold on to either int, float</span>
<span class="hljs-comment">// call into a generic lambda / functor</span>
<span class="hljs-keyword">auto</span> res1 = std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp; x) { <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> * x; }, container);
<span class="hljs-comment">// call into an overloaded free function (via a generic lambda / functor)</span>
<span class="hljs-keyword">auto</span> res2 = std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span> &amp;x) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">my_function</span>(x); }, container);
<span class="hljs-comment">// call into a specific lambda / functor based on type currently being held</span>
std::<span class="hljs-built_in">visit</span>(
    overloaded {
        [](<span class="hljs-type">int</span>&amp; x) { std::cout &lt;&lt; <span class="hljs-string">"int"</span> &lt;&lt; x; },
        [](<span class="hljs-type">float</span>&amp; x) { std::cout &lt;&lt; <span class="hljs-string">"float"</span> &lt;&lt; x; },
        [](<span class="hljs-keyword">auto</span> &amp;) { std::cout &lt;&lt; <span class="hljs-string">"OTHER"</span>; }
    },
    container
);
</code></pre>
<p>Boost also provides a version of this container, <code>boost::variant</code>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FUnions)_TOPIC%2F">Core Language/Unions</a> (variants are similar to <a href="#BM_(union)%2Fi">union</a>s but type-safe)</li>
</ul>
</div>
<a name="H_Time"></a><h2>Time</h2>
<p><a name="BM_(Library%20FunctionsTime%5C%2FTime)_TOPIC%2F"></a><strong></strong></p>
<p>Similar to Java's <code>java.time</code> package, the C++ standard library offers several <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that represent various time-based constructs. This includes timestamps, durations, calendar representations, timezones, and various helper functions.</p>
<p>The subsections below document some common time-related <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es and their usages.</p>
<a name="H_Timestamps"></a><h3>Timestamps</h3>
<p><a name="BM_(Library%20FunctionsTime%5C%2FTime%2FTimestamps)_TOPIC%2F"></a><strong></strong></p>
<p>Time points are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that represent some point in type. They're typically created by clocks, which are are <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es that measure time. Each clock has a set of specifics:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Epoch</td>
<td>When does it start from? (e.g. since boot, app launch, Jan 1, 1970 00:00:00 UTC, etc..)</td>
</tr>
<tr>
<td>Tick Period</td>
<td>How often does it update? (e.g. once per millisecond)</td>
</tr>
<tr>
<td>Monotonicity</td>
<td>Could it go back in time? (e.g. time returned is before a previous time returned)</td>
</tr>
<tr>
<td>Leap Seconds</td>
<td>Does it include leap seconds?</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Monotonicity is important. In certain cases the clock could go back in time (e.g. inaccurate clocks are a thing, leap seconds, updates from NTP server, etc..).</p>
</div>
<a name="H_Clocks"></a><h4>Clocks</h4>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F"></a><strong></strong></p>
<p>There are multiple types of clock. Each type of clock has the following set of important type traits that you can use to obtain key details about it:</p>
<ul>
<li><code>T::period</code> - Reports tick period of the clock in seconds (<code>std::ratio</code>)</li>
<li><code>T::is_steady</code> - Reports monotonicity of the clock (<code>bool</code>).</li>
<li><code>T::now()</code> - Get the current time (<code>std::chrono::time_point</code>).</li>
</ul>
<pre class="hljs"><code>std::cout &lt;&lt; <span class="hljs-string">"Ticks per Second: "</span> &lt;&lt; std::chrono::system_clock::period::den &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="hljs-string">"Monotonic:        "</span> &lt;&lt; std::chrono::system_clock::is_steady &lt;&lt; std::endl;
std::chrono::time_point&lt;std::chrono::system_clock&gt; time { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<p>Note how the <code>std::chrono::time_point</code> type returned by the clock above is <a href="#BM_(template)%2Fi">template</a>d to the clock's type. The return type of a clock's <code>now()</code> typically won't be able to intermingle with one returned by another type of clock. To do that, you need to use <code>std::chrono::clock_cast&lt;SRC, DST&gt;()</code> first to convert it.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> sys_pt { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> utc_pt { <span class="hljs-built_in">clock_cast</span>&lt;std::chrono::system_clock, std::chrono::utc_clock&gt;(sys_pt) };
</code></pre>
<p>Common types of clock are listed below.</p>
<ul>
<li>
<p><code>std::chrono::system_clock</code></p>
<p>This clock is the system clock (e.g. wrist watch -- it tells you what time it is). Its epoch is whatever the epoch of the system's clock is (e.g. Jan 1, 1970 at midnight on most systems). Leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
</li>
<li>
<p><code>std::chrono::steady_clock</code></p>
<p>This clock is used to measure time intervals (e.g. stop watch -- measure how long something takes). Its guaranteed to be monotonic, meaning each time you query it for the time it'll be greater than or equal to the result of your last query (e.g. <code>next_time &gt;= prev_time</code>). Epoch is unspecified and leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Would it make sense to include leap seconds here if this is a "stop watch"? I don't think so, but nothing is mentioned about leap seconds when I look up the docs online.</p>
</div>
</li>
<li>
<p><code>std::chrono::high_resolution_clock</code></p>
<p>This clock is guaranteed to have the shortest possible tick period available (e.g. gaming, real-time systems, etc..). Its epoch and leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Would it make sense to include leap seconds here if this is supposed to be used for high-precision timing? I don't think so, but nothing is mentioned about leap seconds when I look up the docs online.</p>
</div>
</li>
<li>
<p><code>std::chrono::utc_clock</code> (Coordinated Universal Time)</p>
<p>This clock is guaranteed to have an epoch of Jan 1, 1970 at midnight UTC and includes leap seconds.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::utc_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> ls_info { <span class="hljs-built_in">get_leap_second_info</span>(now) };
std::cout &lt;&lt; ls_info.elapsed;       <span class="hljs-comment">// leap seconds elapsed since epoch until time_point</span>
std::cout &lt;&lt; ls_info.is_leap_second <span class="hljs-comment">// did time_point fall on a leap second?</span>
</code></pre>
</li>
<li>
<p><code>std::chrono::tai_clock</code> (International Atomic Time)</p>
<p>This clock is guaranteed to have an epoch of Dec 31, 1957 at 23:59:50 UTC and <em>does not</em> include leap seconds.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::tai_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I'm not sure what this point of this clock is? Is it slowing down time / speeding up time based on the rate of "real" time vs atomic time?</p>
</div>
</li>
<li>
<p><code>std::chrono::gps_clock</code> (Global Positioning System)</p>
<p>This clock is guaranteed to have an epoch of Jan 6, 1980 at midnight UTC and <em>does not</em> include leap seconds.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::gps_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I'm not sure what this point of this clock is? Is it slowing down time / speeding up time based on the rate of "real" time vs gps time? (e.g. GPS time is roughly ~38 microseconds faster per day)</p>
</div>
</li>
<li>
<p><code>std::chrono::file_clock</code></p>
<p>This clock is used for file times (alias for <code>std::filesystem::file_time_type::clock</code>).  Its epoch and leap second inclusions are unspecified.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> now { std::chrono::gps_clock::<span class="hljs-built_in">now</span>() };
</code></pre>
</li>
</ul>
<p>Boost has a similar set of clocks: <code>boost::chrono::system_clock</code>, <code>boost::chrono::steady_clock</code>, <code>boost::chrono::high_resolution_clock</code>, <code>boost::chrono::process_cpu_clock</code>, etc... But, Boost clocks can't intermingle with clocks from the C++ standard library (e.g. <code>clock_cast()</code> won't work).</p>
<a name="H_Conversions"></a><h4>Conversions</h4>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FConversions)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDate%20and%20Time)_TOPIC%2F">Library Functions/Time/Date and Time</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Timezone functionality doesn't seem to be implemented as of clang or GCC as of yet, meaning the code below that uses timezones fails to compile.</p>
</div>
<p>To convert a time point from the system clock to a date and time representation, use <code>std::chrono::floor()</code> to cut out the relevant durations before using them to create the date and time <a href="#BM_(object%7Cinstance)%2Fi">object</a>s...</p>
<pre class="hljs"><code><span class="hljs-comment">// SOURCE: https://stackoverflow.com/a/15958113</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;

<span class="hljs-keyword">auto</span> tp = system_clock::<span class="hljs-built_in">now</span>();
<span class="hljs-keyword">auto</span> tp_rounded = <span class="hljs-built_in">floor</span>&lt;days&gt;(tp);
year_month_day ymd { tp_rounded };
hh_mm_ss time { <span class="hljs-built_in">floor</span>&lt;milliseconds&gt;(tp - tp_rounded) };
</code></pre>
<p>The process is similar for converting a <em>zoned</em> time point (time point associated with a timezone) ..</p>
<pre class="hljs"><code><span class="hljs-comment">// SOURCE: https://stackoverflow.com/a/15958113</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;

<span class="hljs-keyword">auto</span> tp = zoned_time{<span class="hljs-built_in">current_zone</span>(), system_clock::<span class="hljs-built_in">now</span>()}.<span class="hljs-built_in">get_local_time</span>();
<span class="hljs-keyword">auto</span> tp_rounded = <span class="hljs-built_in">floor</span>&lt;days&gt;(tp_rounded);
year_month_day ymd {tp - tp_rounded};
hh_mm_ss time {<span class="hljs-built_in">floor</span>&lt;milliseconds&gt;(tp-dp)};
</code></pre>
<p>To go the other way around (date and time <a href="#BM_(object%7Cinstance)%2Fi">object</a>s to time point), use the <code>std::chrono::local_days</code> / <code>std::chrono::sys_days</code> aliases (they alias <code>std::chrono::time_point</code>).</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;

std::chrono::year_month_day date { January / <span class="hljs-number">27</span>d / <span class="hljs-number">2022</span>y };
std::chrono::hh_mm_ss time { <span class="hljs-number">8</span>h + <span class="hljs-number">30</span>m + <span class="hljs-number">45</span>s };

<span class="hljs-keyword">auto</span> tp = std::chrono::local_days { date } + time;  <span class="hljs-comment">// or use sys_days for system time</span>
</code></pre>
<a name="H_Durations"></a><h3>Durations</h3>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a></li>
</ul>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>🔍SEE ALSO🔍</strong></p>
<ul>
<li><a href="#BM_(Core%20Language%5C%2FClasses%2FUser-defined%20Literals)_TOPIC%2F">Core Language/Classes/User-defined Literals</a> (variants are similar to <a href="#BM_(union)%2Fi">union</a>s but type-safe)</li>
</ul>
</div>
<p>A duration is <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that represents some amount of time.</p>
<pre class="hljs"><code><span class="hljs-comment">// use helper functions</span>
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">hours</span>(<span class="hljs-number">1</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">minutes</span>(<span class="hljs-number">60</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3600</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">3600000</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">3600000000</span>) };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">nanoseconds</span>(<span class="hljs-number">3600000000000</span>) };

<span class="hljs-comment">// use user-defined literals</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals; <span class="hljs-comment">// import the literals</span>
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">1</span>h };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">60</span>m };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600</span>s };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600000</span>ms };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600000000u</span>s };
<span class="hljs-keyword">auto</span> hour { <span class="hljs-number">3600000000000</span>ns };
</code></pre>
<p>Subtracting two time points produces the duration in between them.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> before_tp { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> after_tp { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
std::chrono::duration d { after_tp - before_tp };
</code></pre>
<p>Similarly, adding a duration to a time point moves it accordingly.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> before_tp { std::chrono::steady_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> hour { std::chrono::<span class="hljs-built_in">hours</span>(<span class="hljs-number">1</span>) };
<span class="hljs-keyword">auto</span> after_tp { before_tp + hour };  <span class="hljs-comment">// move up by 1 hr</span>
</code></pre>
<p>A duration <a href="#BM_(object%7Cinstance)%2Fi">object</a> has a tick period. For example, <code>std::chrono::hours(1)</code> and <code>std::chrono::minutes(60)</code> both represent exactly 1 hour (equality operator (==) returns true), but the former has a tick period of 1 hour and the latter has a tick period if 1 minute. To get the number of ticks in a duration, use <code>count()</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// NOTE if you're calling a method of a user-defined literal, you need a space before the dot</span>
<span class="hljs-keyword">auto</span> x {<span class="hljs-number">3600</span>s .<span class="hljs-built_in">count</span>()}; <span class="hljs-comment">// x will be 3600</span>
<span class="hljs-keyword">auto</span> y {<span class="hljs-number">1</span>h .<span class="hljs-built_in">count</span>()};    <span class="hljs-comment">// y will be 1</span>
<span class="hljs-keyword">auto</span> z {<span class="hljs-number">3600</span>s == <span class="hljs-number">1</span>h};    <span class="hljs-comment">// z will be true</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>I've read online that you shouldn't use <code>count()</code> unless absolutely necessary because it breaks a lot of the abstraction / encapsulation that the library does.</p>
</div>
<p><code>std::chrono::duration_cast&lt;DST&gt;</code> may be used to convert one type of duration to another.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> x { std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(<span class="hljs-number">1</span>h) };
<span class="hljs-keyword">auto</span> y { std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(<span class="hljs-number">3600</span>s) };
<span class="hljs-keyword">auto</span> xTicks { x.<span class="hljs-built_in">count</span>() }; <span class="hljs-comment">// xTicks will be 3600</span>
<span class="hljs-keyword">auto</span> yTicks { y.<span class="hljs-built_in">count</span>() }; <span class="hljs-comment">// xTicks will be 1</span>
<span class="hljs-keyword">auto</span> z { std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(<span class="hljs-number">3599</span>s) };
<span class="hljs-keyword">auto</span> zTicks { z.<span class="hljs-built_in">count</span>() }; <span class="hljs-comment">// zTicks will be 0 (ROUNDS DOWN TO 0 -- not enough seconds for 1 hour)</span>
</code></pre>
<a name="H_Date%20and%20Time"></a><h3>Date and Time</h3>
<p><a name="BM_(Library%20Functions%5C%2FTime%2FDate%20and%20Time)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FTimestamps%2FClocks)_TOPIC%2F">Library Functions/Time/Timestamps/Clocks</a></li>
<li><a href="#BM_(Library%20Functions%5C%2FTime%2FDurations)_TOPIC%2F">Library Functions/Time/Durations</a></li>
</ul>
</div>
<p>Date and time functionality build on durations and time points by providing things like calendar representations, time of day representations (e.g. 12-hour vs 24-hour), timezone conversions, etc..</p>
<p>Calendar <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es represent some exact region (e.g. 5th, 1st, last, etc..) of a some specific calendar granularity (day, month, year, weekday).</p>
<table>
<thead>
<tr>
<th></th>
<th>Day</th>
<th>Day of Week</th>
<th>Month</th>
<th>Year</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::chrono::day</code></td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td>31</td>
</tr>
<tr>
<td><code>std::chrono::weekday</code></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>Tuesday</td>
</tr>
<tr>
<td><code>std::chrono::weekday_indexed</code></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>3rd Tuesday of unknown month</td>
</tr>
<tr>
<td><code>std::chrono::weekday_last</code></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>last weekday of unknown month</td>
</tr>
<tr>
<td><code>std::chrono::month</code></td>
<td></td>
<td></td>
<td>X</td>
<td></td>
<td>January</td>
</tr>
<tr>
<td><code>std::chrono::month_day</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
<td>December 25</td>
</tr>
<tr>
<td><code>std::chrono::month_day_last</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
<td>last day of January</td>
</tr>
<tr>
<td><code>std::chrono::month_weekday</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>3rd Tuesday of January</td>
</tr>
<tr>
<td><code>std::chrono::month_weekday_last</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>last weekday of January</td>
</tr>
<tr>
<td><code>std::chrono::year</code></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month</code></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>January 2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month_day</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>January 26, 2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month_day_last</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>last day of January 2022</td>
</tr>
<tr>
<td><code>std::chrono::year_month_weekday</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>3rd Tuesday of January</td>
</tr>
<tr>
<td><code>std::chrono::year_month_weekday_last</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>last weekday of January 2022</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-comment">// create jan 27 2022 as year_month_day</span>
std::chrono::year y { <span class="hljs-number">2022</span> };
std::chrono::month m { <span class="hljs-number">1</span> };
std::chrono::day d { <span class="hljs-number">27</span> };
std::chrono::year_month_day today { y, m, d };
</code></pre>
<p>Adding or subtracting a duration to a calendar <a href="#BM_(object%7Cinstance)%2Fi">object</a> adjusts it accordingly.</p>
<pre class="hljs"><code>std::chrono::year_month_day today { y, m, d };

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;
today += <span class="hljs-number">5</span>d;  <span class="hljs-comment">// add 5 days to today</span>
</code></pre>
<p>If the calendar <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> captures a full date (e.g. <code>year_month_day</code>, <code>year_month_weekday</code>, etc..), it's convertible to a time point via <code>std::chrono::local_days</code> / <code>std::chrono::sys_days</code>.</p>
<pre class="hljs"><code>std::chrono::year y { <span class="hljs-number">2022</span> };
std::chrono::month m { <span class="hljs-number">1</span> };
std::chrono::day d { <span class="hljs-number">27</span> };
std::chrono::year_month_day today { y, m, d };

std::chrono::local_days today_tp { today };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Which should you use? I'm not sure the difference. <code>std::chrono::sys_days</code> is shorthand for <code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::days&gt;</code>, which is the time point type for the system clock. <code>std::chrono::local_days</code> expands to the same thing but for the local clock. I'm not sure what local clock actually is. It wasn't listed as one of the clocks.</p>
</div>
<p>Similarly, a time point is convertible to a full date calendar <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> sys_tp { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> sys_tp_rounded { std::chrono::<span class="hljs-built_in">floor</span>&lt;std::chrono::days&gt;(sys_tp) };  <span class="hljs-comment">// round tp down to days</span>
std::chrono::year_month_day ymd{ sys_tp_rounded };
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What type is <code>sys_tp_rounded</code>? It's <code>std::chrono::sys_days</code>, which is shorthand for <code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::days&gt;</code>. The <code>std::chrono::year_month_day</code> <a href="#BM_(constructor)%2Fi">constructor</a> also accepts <code>std::chrono::local_days</code> -- I'm unsure which clock generates that (maybe utc clock?).</p>
</div>
<p>If two calendar <a href="#BM_(object%7Cinstance)%2Fi">object</a>s both capture a full date but are of different types, you can still compare them by first converting them to time points.</p>
<pre class="hljs"><code><span class="hljs-comment">// as year_month_day</span>
std::chrono::year y { <span class="hljs-number">2022</span> };
std::chrono::month m { <span class="hljs-number">1</span> };
std::chrono::day d { <span class="hljs-number">27</span> };
std::chrono::year_month_day today1 { y, m, d };
<span class="hljs-comment">// as year_month_weekday</span>
std::chrono::weekday thurs { <span class="hljs-number">4</span> };
std::chrono::weekday_indexed _4th_thurs { thurs, <span class="hljs-number">4</span> };
std::chrono::year_month_weekday today2 { y, m, _4th_thurs };
<span class="hljs-comment">// convert both to time point</span>
std::chrono::local_days today1_tp {today1};
std::chrono::local_days today2_tp {today2};
<span class="hljs-comment">// compare -- they both represent the same date so they should be equal</span>
<span class="hljs-keyword">auto</span> sameDay = today1_tp == today2_tp; <span class="hljs-comment">// returns true</span>
</code></pre>
<p>Calendar <a href="#BM_(object%7Cinstance)%2Fi">object</a>s can be created more intuitively via a set of <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>s, constants, and <a href="#BM_(user-defined%20literal)%2Fi">user-defined literal</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;

year_month_day today1 { January / <span class="hljs-number">27</span>d / <span class="hljs-number">2022</span>y };
year_month_weekday today2 { <span class="hljs-number">2022</span>y / January / Thursday[<span class="hljs-number">4</span>] };
year_month_weekday_last today3 { <span class="hljs-number">2022</span>y / January / Thursday[last] };
<span class="hljs-comment">// all 3 of the above represent the same date</span>
</code></pre>
<p>The <code>std::chrono::hh_mm_ss</code> <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is a container for the time that's elapsed since midnight (also known as time of day).</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> tp { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> tp_rounded { std::chrono::<span class="hljs-built_in">floor</span>&lt;days&gt;(tp) };
std::chrono::year_month_day ymd{ tp_rounded };

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">time_duration</span> <span class="hljs-params">( std::chrono::floor&lt;milliseconds&gt;(tp - tp_rounded) )</span></span>;
std::chrono::hh_mm_ss time{ time_duration };
<span class="hljs-comment">// the variables below are of duration type</span>
<span class="hljs-keyword">auto</span> h = time.<span class="hljs-built_in">hours</span>();
<span class="hljs-keyword">auto</span> m = time.<span class="hljs-built_in">minutes</span>();
<span class="hljs-keyword">auto</span> s = time.<span class="hljs-built_in">seconds</span>();
<span class="hljs-keyword">auto</span> ms = time.<span class="hljs-built_in">subseconds</span>();
</code></pre>
<p>Several time-related helper functions are provided to deal with 12-hour vs 24-hour time.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> hour_of_day { time.<span class="hljs-built_in">hours</span>() }; <span class="hljs-comment">// using object from example above</span>

<span class="hljs-keyword">auto</span> am { std::chrono::<span class="hljs-built_in">is_am</span>(hour_of_day) };
<span class="hljs-keyword">auto</span> pm { std::chrono::<span class="hljs-built_in">is_pm</span>(hour_of_day) };

<span class="hljs-keyword">auto</span> hour_of_day_12 { std::chrono::<span class="hljs-built_in">make_12</span>(hour_of_day) };        <span class="hljs-comment">// as 12-hour format</span>
<span class="hljs-keyword">auto</span> hour_of_day_24 { std::chrono::<span class="hljs-built_in">make_12</span>(hour_of_day_12, pm) }; <span class="hljs-comment">// back to 24-hour format</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Timezone functionality doesn't seem to be implemented as of clang or GCC as of yet, meaning the code below fails to compile. It does seem to be implemented in MSVC though.</p>
</div>
<p>Timezones are accessible through a timezone database.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> my_tzdb = std::chrono::<span class="hljs-built_in">get_tzdb</span>(); <span class="hljs-comment">// also get_tzdb_list()</span>

<span class="hljs-keyword">const</span> std::chrono::time_zone* la_tz = my_tzdb.<span class="hljs-built_in">locate_zone</span>(<span class="hljs-string">"America/Los_Angeles"</span>);
<span class="hljs-keyword">const</span> std::chrono::time_zone* local_tz = my_tzdb.<span class="hljs-built_in">current_zone</span>();
</code></pre>
<p>You can apply a timezone to a time point, then convert it to the appropriate date and time <a href="#BM_(object%7Cinstance)%2Fi">object</a>s.</p>
<pre class="hljs"><code><span class="hljs-comment">// From https://stackoverflow.com/a/15958113</span>
<span class="hljs-keyword">auto</span> tp { std::chrono::system_clock::<span class="hljs-built_in">now</span>() };
<span class="hljs-keyword">auto</span> ztp { std::chrono::zoned_time {local_tz, tp}.<span class="hljs-built_in">get_local_time</span>() };
<span class="hljs-keyword">auto</span> ztp_rounded { std::chrono::<span class="hljs-built_in">floor</span>&lt;days&gt;(ztp) };
std::chrono::year_month_day ymd { tp_rounded };
std::chrono::hh_mm_ss time { std::chrono::<span class="hljs-built_in">floor</span>&lt;milliseconds&gt;(ztp - ztp_rounded) };
</code></pre>
<p>Similarly, you can construct a zoned time point from date and time details.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;

std::chrono::year_month_day date { January / <span class="hljs-number">27</span>d / <span class="hljs-number">2022</span>y };
std::chrono::hh_mm_ss time { <span class="hljs-number">8</span>h + <span class="hljs-number">30</span>m + <span class="hljs-number">45</span>s };

<span class="hljs-keyword">auto</span> tp = std::chrono::local_days { date } + time;  <span class="hljs-comment">// or use sys_days for system time</span>
</code></pre>
<a name="H_Random%20Numbers"></a><h2>Random Numbers</h2>
<p><a name="BM_(Library%20FunctionsTime%5C%2FRandom%20Numbers)_TOPIC%2F"></a><strong></strong></p>
<p>The C++ standard library provides random number generators out of the box. For ...</p>
<ul>
<li>non-cryptographic scenarios, use <code>std::mt19937_64</code>, an implementation of Mersenne Twister.</li>
<li>cryptographic scenarios, use <code>std::random_device</code>, which tries to use an unpredictable hardware source (but may not).</li>
</ul>
<p>The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es are <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s, where each invocation generates a random integral.</p>
<pre class="hljs"><code>std::mt19937_64 mt_rand{ <span class="hljs-number">12345</span> };  <span class="hljs-comment">// seed value of 12345</span>
std::cout &lt;&lt; <span class="hljs-built_in">mt_rand</span>() &lt;&lt; std::endl;

std::random_device secure_rand {}; <span class="hljs-comment">// doesn't take a seed</span>
std::cout &lt;&lt; <span class="hljs-built_in">secure_rand</span>() &lt;&lt; std::endl;
</code></pre>
<p>To have a random number generator return a distribution other than a normal distribution, you can use one of the distribution wrappers.</p>
<pre class="hljs"><code>std::mt19937_64 rng{ <span class="hljs-number">12345</span> };
std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; uniform_dist{ <span class="hljs-number">0</span>, <span class="hljs-number">10</span> };
<span class="hljs-keyword">auto</span> value = <span class="hljs-built_in">uniform_dist</span>(rng);
</code></pre>
<ul>
<li><code>std::uniform_int_distribution</code></li>
<li><code>std::uniform_real_distribution</code> (like the above but for floating point types)</li>
<li><code>std::normal_distribution</code> (a tweaked normal distribution)</li>
<li>etc..</li>
</ul>
<p>Boost provides a set of distributions as well.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Are there friendly wrappers here? What if I want the random number generator to give me a float, bool, or an alphanumeric string instead of an int?</p>
</div>
<a name="H_Numeric%20Limits"></a><h2>Numeric Limits</h2>
<p><a name="BM_(Library%20FunctionsTime%5C%2FNumeric%20Limits)_TOPIC%2F"></a><strong></strong></p>
<p>Recall that C++'s numeric types are wishy-washy (e.g. there is no guarantee as to how large an <code>int</code> is, just that it must be greater than or equal to <code>short</code>). The <code>std::numeric_limits</code> <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> allows you to get <a href="#BM_(compile-time)%2Fi">compile-time</a> information about a numeric type, such as signed-ness, min, max, etc..</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> a = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::is_integer;      <span class="hljs-comment">// false</span>
<span class="hljs-keyword">auto</span> b = std::numeric_limits&lt;<span class="hljs-type">uint16_t</span>&gt;::is_integer;   <span class="hljs-comment">// true</span>
<span class="hljs-keyword">auto</span> c = std::numeric_limits&lt;<span class="hljs-type">uint16_t</span>&gt;::has_infinity; <span class="hljs-comment">// false</span>
</code></pre>
<ul>
<li><code>std::numeric_limits&lt;T&gt;::is_signed</code> - if the type is signed</li>
<li><code>std::numeric_limits&lt;T&gt;::is_integer</code> - if the type is an integral</li>
<li><code>std::numeric_limits&lt;T&gt;::has_infinity</code> - if the type supports infinity (e.g. floats do)</li>
<li><code>std::numeric_limits&lt;T&gt;::has_quiet_NaN</code> - if the type can be set to not-a-number (e.g. IEEE floats can be set to not a number)</li>
<li><code>std::numeric_limits&lt;T&gt;::round_style</code> - rounding mode for a type</li>
<li><code>std::numeric_limits&lt;T&gt;::is_iec559</code> - if the type is an IEEE float.</li>
<li><code>std::numeric_limits&lt;T&gt;::lowest()</code> - maximum negative value.</li>
<li><code>std::numeric_limits&lt;T&gt;::max()</code> - maximum value.</li>
<li><code>std::numeric_limits&lt;T&gt;::min()</code> - smallest representable value (different from <code>::lowest()</code>).</li>
<li><code>std::numeric_limits&lt;T&gt;::quiet_NaN()</code> - get a not-a-numbe<a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">r value</a>.</li>
<li>etc..</li>
</ul>
<p>Boost's Integer library also provides additional functionality for determining information about numerics (e.g. which one is the fastest for the platform you're on).</p>
<a name="H_Numeric%20Conversions"></a><h2>Numeric Conversions</h2>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<p>TODO: Boost Numeric Conversions section in chapter 12</p>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(preprocessor%7Ctranslation%20unit)%2Fi"></a><strong>processor</strong> - A tool that takes in a C++ source file and performs basic manipulation on it to produce what's called a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See compilation section.</p>
</div>
</li>
<li>
<p><a name="BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi"></a><strong>compiler</strong> - A tool that takes in a <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> to produce an intermediary format called an <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See compilation section.</p>
</div>
</li>
<li>
<p><a name="BM_(linker%7Cexecutable)%2Fi"></a><strong>linker</strong> - A tool that takes multiple <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">object file</a>s to produce an <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>. <a href="#BM_(linker%7Cexecutable)%2Fi">Linker</a>s are also responsible for finding libraries used by the program and integrating them into the <a href="#BM_(linker%7Cexecutable)%2Fi">executable</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See compilation section.</p>
</div>
</li>
<li>
<p><a name="BM_(enumeration%7Cenum)%2Fi"></a><strong>enumeration</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> that can be set to one of a set of possibilities.</p>
<pre class="hljs"><code><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MyEnum</span> {
   OptionA,
   OptionB,
   OptionC
};

MyEnum x {MyEnum::OptionC};
</code></pre>
</li>
<li>
<p><a name="BM_(class%7C%5Cbstruct)%2Fi"></a><strong>class</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> that pairs together data and the functions that operate on that data.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">long</span> y) {
        <span class="hljs-keyword">this</span>-&gt;x = x;
        <span class="hljs-keyword">this</span>-&gt;y = y;
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;x += z;
        <span class="hljs-keyword">return</span> y + z;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">long</span> y;
}
</code></pre>
</li>
<li>
<p><a name="BM_(union)%2Fi"></a><strong>union</strong> - A <a href="#BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi">user-defined type</a> where all <a href="#BM_%5Cb(member)%2Fi">member</a>s share the same memory location (different representations of the same data).</p>
<pre class="hljs"><code><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> {
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">long</span> y;
}
</code></pre>
</li>
<li>
<p><a name="BM_(plain-old-data%20class%7Cplain-old%20data%20class%7Cplain%20old%20data%20class%7Cplain-old-data%20structure%7Cplain-old%20data%20structure%7Cplain%20old%20data%20structure%7Cplain-old-data%20struct%7Cplain-old%20data%20struct%7Cplain%20old%20data%20struct)%2Fi"></a><strong>plain-old-data class</strong> <a name="BM_(POD)%2F"></a><strong></strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that contains only data, not functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Podo</span> {
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">long</span> y;
}
</code></pre>
</li>
<li>
<p><a name="BM_%5Cb(member)%2Fi"></a><strong>member</strong> - Data or function belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(method%7C%5Cbmember%20function)%2Fi"></a><strong>member function</strong> - Function belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> that is a function).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    ...
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x + y; }
};
</code></pre>
</li>
<li>
<p><a name="BM_(free%20function%7Cnon-member%20function)%2Fi"></a><strong>free function</strong> - Function not belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> -x; }
</code></pre>
</li>
<li>
<p><a name="BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi"></a><strong>field</strong> - Variable belonging to a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (<a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> <a href="#BM_%5Cb(member)%2Fi">member</a> that is a variable).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-type">int</span> x;
};
</code></pre>
</li>
<li>
<p><a name="BM_(class%20invariant)%2Fi"></a><strong>class invariant</strong> - When using some <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, a <a href="#BM_(class%20invariant)%2Fi">class invariant</a> is a feature of that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that is always true (never varies). For example, if a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> is used to hold on to an IP and port combination, and it ensures that the port can never be 0, that's a <a href="#BM_(class%20invariant)%2Fi">class invariant</a>.</p>
</li>
<li>
<p><a name="BM_(fundamental%20type%7Cbuilt-in%20type)%2Fi"></a><strong>fundamental type</strong> - C++ type that's built into the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> itself rather than being declared through code. Examples include <code>void</code>, <code>bool</code>, <code>int</code>, <code>char</code>, etc..</p>
</li>
<li>
<p><a name="BM_(user%5B%5Cs%5C-%5Ddefined%20type)%2Fi"></a><strong>user-defined type</strong> - A type that's defined by a user, typically derived from existing types. Examples include <a href="#BM_(enumeration%7Cenum)%2Fi">enumeration</a>s, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es, <a href="#BM_(union)%2Fi">union</a>s, etc..</p>
</li>
<li>
<p><a name="BM_(object%20initialization)%2Fi"></a><strong>object initialization</strong> - The process by which a C++ program initializes an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (e.g. an <code>int</code>, array of <code>int</code>s, <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> type, etc..).</p>
</li>
<li>
<p><a name="BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi"></a><strong>braced initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where braces are used to set values (e.g. <code>int x {1}</code>, <code>MyStruct x{ 1, true }</code>, etc..). <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">Braced initialization</a> is often the least error-prone form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a>, where other forms may introduce ambiguity.</p>
<pre class="hljs"><code>MyStruct x{<span class="hljs-built_in">int</span>(a), <span class="hljs-built_in">int</span>(b)};  <span class="hljs-comment">// call the constructor taking in two ints</span>
<span class="hljs-function">MyStruct <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-type">int</span>(a), <span class="hljs-type">int</span>(b))</span></span>;  <span class="hljs-comment">// possibly interpreted as function declaration -- equiv to MyStruct(int a, int b)</span>

<span class="hljs-type">float</span> a{<span class="hljs-number">1</span>}, b{<span class="hljs-number">2</span>};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span> <span class="hljs-params">(a/b)</span></span>; <span class="hljs-comment">// no compiler warning generated about narrowing (why? -- book doesn't say)</span>
<span class="hljs-type">int</span> b {a/b}; <span class="hljs-comment">// compiler warning generated about narrowing</span>
</code></pre>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is also called <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">uniform initialization</a>.</p>
</div>
</li>
<li>
<p><a name="BM_(equals%3F%20initialization)%2Fi"></a><strong>equals initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where the equals sign is used (e.g. <code>int x = 5</code>).</p>
</li>
<li>
<p><a name="BM_(brace%5Bsd%5D%3F%5B%5C-%5Cs%5Dplus%5B%5C-%5Cs%5Dequals%3F%20initialization)%2Fi"></a><strong>braces-plus-equals initialization</strong> - A form of <a href="#BM_(object%20initialization)%2Fi">object initialization</a> where both the equals sign and braces are used for initialization (e.g. <code>MyStruct x = { 1, true }</code>). This is mostly equivalent to <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See <a href="https://stackoverflow.com/a/20733537">here</a>. Even though there's an equal sign (=), there is no <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> / move semantics.</p>
</div>
</li>
<li>
<p><a name="BM_(constructor)%2Fi"></a><strong>constructor</strong> - A function used for initializing an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> : MyParent {
    ...
    <span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some setup here</span>
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(destructor)%2Fi"></a><strong>destructor</strong> - A function used for cleanup when an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is destroyed.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> : MyParent {
    ...
    ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
<p>See also: <a href="#BM_(virtual%20destructor)%2Fi">virtual destructor</a>.</p>
</li>
<li>
<p><a name="BM_(pointer)%2Fi"></a><strong>pointer</strong> - A data type used to point to a different piece of memory (e.g. <code>int yPtr { &amp;y }</code>).</p>
</li>
<li>
<p><a name="BM_(reference)%2Fi"></a><strong>reference</strong> - A data type used to point to a different piece of memory, but in a more sanitized / less confusing manner (e.g. <code>int &amp;yRef { y };</code>).</p>
</li>
<li>
<p><a name="BM_(sizeof)%2Fi"></a><strong>sizeof</strong> - A unary operator that returns the size of a type or <a href="#BM_(object%7Cinstance)%2Fi">object</a> (known at <a href="#BM_(compile-time)%2Fi">compile-time</a>).</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">size_t</span> x_size {<span class="hljs-keyword">sizeof</span> x};
</code></pre>
</li>
<li>
<p><a name="BM_(address%5B%5C-%5Cs%5Dof)%2Fi"></a><strong>address-of (&amp;)</strong> - A unary operator used to obtain the memory <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address of</a> an <a href="#BM_(object%7Cinstance)%2Fi">object</a> (<a href="#BM_(pointer)%2Fi">pointer</a>) (e.g. <code>int *ptr {&amp;x}</code>).</p>
</li>
<li>
<p><a name="BM_(dereference%7Cdereferencing)%2Fi"></a><strong>dereference (*)</strong> - A unary operator used to obtain the <a href="#BM_(object%7Cinstance)%2Fi">object</a> at some memory address (e.g. <code>int x {*ptr}</code>).</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dpointer)%2Fi"></a><strong>member-of-pointer (-&gt;)</strong> - An operator that <a href="#BM_(dereference%7Cdereferencing)%2Fi">dereference</a>s a <a href="#BM_(pointer)%2Fi">pointer</a> and accesses a <a href="#BM_%5Cb(member)%2Fi">member</a> of the <a href="#BM_(object%7Cinstance)%2Fi">object</a> pointed to (e.g. <code>ptr-&gt;x</code>).</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dof%5B%5C-%5Cs%5Dobject)%2Fi"></a><strong>member-of-object (.)</strong> - An operator that accesses a <a href="#BM_%5Cb(member)%2Fi">member</a> of an <a href="#BM_(object%7Cinstance)%2Fi">object</a> to (e.g. <code>obj.x</code>).</p>
</li>
<li>
<p><a name="BM_(pointer%20arithmetic)%2Fi"></a><strong>pointer arithmetic</strong> - Adding or subtracting integer types to a <a href="#BM_(pointer)%2Fi">pointer</a> will move that <a href="#BM_(pointer)%2Fi">pointer</a> by the number of bytes that makes up its underlying type (e.g. <code>uint32_t *ptrB = ptrA + 1</code> will set <code>ptrB</code> to 4 bytes ahead of ptrA).</p>
</li>
<li>
<p><a name="BM_(reseat)%2Fi"></a><strong>reseating</strong> - The concept of a variable that points to something updating to point to something else. <a href="#BM_(pointer)%2Fi">Pointer</a>s can be <a href="#BM_(reseat)%2Fi">reseat</a>ed, but <a href="#BM_(reference)%2Fi">reference</a>s cannot.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">int</span> *p {&amp;x};
<span class="hljs-type">int</span> y {<span class="hljs-number">7</span>};
p = &amp;y; <span class="hljs-comment">// reseat p</span>
</code></pre>
</li>
<li>
<p><a name="BM_(member%20initializer%20list%7Cmember%20initialization%20list%7Cmember%20initializer)%2Fi"></a><strong>member initializer list</strong> - A comma separated list of <a href="#BM_(object%20initialization)%2Fi">object initialization</a>s for the <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a>s of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> appearing just before a <a href="#BM_(constructor)%2Fi">constructor</a>'s body.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">bool</span> flag;

    <span class="hljs-built_in">MyStruct</span>(): count{<span class="hljs-number">0</span>}, flag{<span class="hljs-literal">false</span>} {
    }
}
</code></pre>
</li>
<li>
<p><a name="BM_(default%20member%20initializer%7Cdefault%20member%20initialization)%2Fi"></a><strong>default member initialization</strong> - The <a href="#BM_(object%20initialization)%2Fi">object initialization</a> of a <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> directly where that <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is declared.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-type">int</span> my_var {<span class="hljs-number">5</span>};
};
</code></pre>
</li>
<li>
<p><a name="BM_(object%7Cinstance)%2Fi"></a><strong>object</strong> - A region of memory that has a type and a value (e.g. <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, an integer, a <a href="#BM_(pointer)%2Fi">pointer</a> to an integer, etc..).</p>
</li>
<li>
<p><a name="BM_(allocation%7Callocate)%2Fi"></a><strong>allocation</strong> - The act of reserving memory for an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(deallocation%7Cdeallocate)%2Fi"></a><strong>deallocation</strong> - The act of releasing the memory used by an <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
</li>
<li>
<p><a name="BM_(storage%20duration)%2Fi"></a><strong>storage duration</strong> - The duration between an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(allocation%7Callocate)%2Fi">allocation</a> and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocation</a>.</p>
</li>
<li>
<p><a name="BM_(lifetime)%2Fi"></a><strong>lifetime</strong> - The duration between when an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(constructor)%2Fi">constructor</a> <em>completes</em> (meaning the <a href="#BM_(constructor)%2Fi">constructor</a> finishes) and when its <a href="#BM_(destructor)%2Fi">destructor</a> is <em>invoked</em> (meaning when the <a href="#BM_(destructor)%2Fi">destructor</a> starts).</p>
</li>
<li>
<p><a name="BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi"></a><strong>automatic object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's declared within an enclosing code block. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the block and finish at the end of the block.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-type">int</span> automatic_object {x + <span class="hljs-number">5</span>};
    <span class="hljs-keyword">return</span> automatic_object;
}
</code></pre>
</li>
<li>
<p><a name="BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi"></a><strong>static object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's declared using <code>static</code> or <code>extern</code>. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the program and finish at the end of the program.</p>
</li>
<li>
<p><a name="BM_(local%20static%20object%7Clocal%20static%20variable%7Clocal%20static%20storage%20duration)%2Fi"></a><strong>local static object</strong> - A <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static object</a> but declared at function scope. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the first invocation of the function and finish at the end of the program.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_func</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> local_static_object {<span class="hljs-number">0</span>};
    local_static_object++;
    <span class="hljs-keyword">return</span> local_static_object;
}
</code></pre>
</li>
<li>
<p><a name="BM_(static%20field%7Cstatic%20member)%2Fi"></a><strong>static member</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's a <a href="#BM_%5Cb(member)%2Fi">member</a> of a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> but bound globally rather than on an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. A <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static field</a> is essentially a <a href="#BM_(static%20object%7Cstatic%20variable%7Cstatic%20storage%20duration)%2Fi">static object</a> that's accessible through the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> itself (not an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>). Similarly, a static <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> is essentially a global function that's accessed through the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> (not an <a href="#BM_(object%7Cinstance)%2Fi">instance</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> my_var {<span class="hljs-number">5</span>};
};
</code></pre>
</li>
<li>
<p><a name="BM_(thread%5B%5C-%5Cs%5Dlocal%20object%7Cthread%5B%5C-%5Cs%5Dlocal%20variable%7Cthread%5B%5C-%5Cs%5Dlocal%20storage%20duration%7Cthread%20storage%20duration)%2Fi"></a><strong>thread local object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> where each thread has access to its own copy. The <a href="#BM_(storage%20duration)%2Fi">storage duration</a> of these <a href="#BM_(object%7Cinstance)%2Fi">object</a>s start at the beginning of the thread and finish when the thread ends.</p>
</li>
<li>
<p><a name="BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi"></a><strong>dynamically allocated object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that's <a href="#BM_(allocation%7Callocate)%2Fi">allocate</a>d and <a href="#BM_(deallocation%7Cdeallocate)%2Fi">deallocate</a>d at the user's behest, meaning that it's <a href="#BM_(storage%20duration)%2Fi">storage duration</a> is also controlled by the user.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> * x { <span class="hljs-keyword">new</span> x {<span class="hljs-number">5</span>} };
<span class="hljs-keyword">delete</span> x;
</code></pre>
</li>
<li>
<p><a name="BM_(internal%20linkage)%2Fi"></a><strong>internal linkage</strong> - A variable only visible to the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> it's in.</p>
</li>
<li>
<p><a name="BM_(external%20linkage)%2Fi"></a><strong>external linkage</strong> - A variable visible to the <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s that it's in as well as other <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a>s.</p>
</li>
<li>
<p><a name="BM_(scope%20resolution)%2Fi"></a><strong>scope resolution (::)</strong> - An operator that's used to access <a href="#BM_(static%20field%7Cstatic%20member)%2Fi">static member</a>s (e.g. <code>MyStruct::static_func()</code>).</p>
</li>
<li>
<p><a name="BM_(extends%3F%7Csubclass)%2Fi"></a><strong>extend</strong> - Another way of expressing <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> inheritance (e.g. B <a href="#BM_(extends%3F%7Csubclass)%2Fi">extends</a> A is equivalent to saying B is a child of A).</p>
</li>
<li>
<p><a name="BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi"></a><strong>exception</strong> - An <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a> operation accepts an <a href="#BM_(object%7Cinstance)%2Fi">object</a> and unwinds the call stack until reaching a special region specifically intended to stop the unwinding for <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of that type, called a <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">try-catch</a> block. <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">Exception</a>s are a way for code to signal that something unexpected / <a href="#BM_(exception%7Ctry%5B%5C-%5Cs%5Dcatch)%2Fi">exception</a>al happened.</p>
</li>
<li>
<p><a name="BM_(structured%20binding)%2Fi"></a><strong>structured binding</strong> - A language feature that allows for unpacking an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_%5Cb(member)%2Fi">member</a>s / array's elements into a set of variables (e.g. <code>auto [x, y] { two_elem_array }</code>).</p>
</li>
<li>
<p><a name="BM_(copy%20semantics)%2Fi"></a><strong>copy semantics</strong> - The rules used for making copies of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of some type. A copy, once made, should be equivalent to its source. A modification on the copy shouldn't modify the source as well.</p>
</li>
<li>
<p><a name="BM_(member%5B%5C-%5Cs%5Dwise%20copy)%2Fi"></a><strong>member-wise copy</strong> - The default <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> for <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es. Each individual <a href="#BM_(field%7C%5Cbmember%20variable%7C%5Cbmember%20field)%2Fi">field</a> is copied.</p>
</li>
<li>
<p><a name="BM_(copy%20constructor)%2Fi"></a><strong>copy constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> with a single parameter that takes in a <a href="#BM_(reference)%2Fi">reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type (e.g. <code>T(const T &amp;) { ... }</code>). A <a href="#BM_(copy%20constructor)%2Fi">copy constructor</a> is used to specify the <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a> for that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(copy%20assignment)%2Fi"></a><strong>copy assignment</strong> - An assignment <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> that copies one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another (e.g. <code>x = y</code>). <a href="#BM_(copy%20assignment)%2Fi">Copy assignment</a> requires that resources in the destination <a href="#BM_(object%7Cinstance)%2Fi">object</a> be cleaned up prior to performing the copy.</p>
</li>
<li>
<p><a name="BM_(RAII%7CCADRe)%2F"></a><strong>RAII</strong> - Short for resource acquisition is initialization, the concept that the life cycle of some resource (e.g. open file, database <a href="#BM_(object%7Cinstance)%2Fi">object</a>, etc..) is bound to an <a href="#BM_(object%7Cinstance)%2Fi">object</a>'s <a href="#BM_(lifetime)%2Fi">lifetime</a> via it's <a href="#BM_(constructor)%2Fi">constructor</a> and <a href="#BM_(destructor)%2Fi">destructor</a>.</p>
<p>Sometimes also referred to as <a href="#BM_(constructor)%2Fi">constructor</a> acquires <a href="#BM_(destructor)%2Fi">destructor</a> releases (<a href="#BM_(RAII%7CCADRe)%2F">CADRe</a>).</p>
</li>
<li>
<p><a name="BM_(moved%5B%5C-%5Cs%5Dfrom%20object%7Cmoved%5B%5C-%5Cs%5Dfrom%20state)%2Fi"></a><strong>moved-from object</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> is moved to another <a href="#BM_(object%7Cinstance)%2Fi">object</a>, that <a href="#BM_(object%7Cinstance)%2Fi">object</a> enters a special state where the only possible operation allowed on it is either destruction or re-assignment.</p>
</li>
<li>
<p><a name="BM_(move%20constructor)%2Fi"></a><strong>move constructor</strong> - A <a href="#BM_(constructor)%2Fi">constructor</a> with a single parameter that takes in an <a href="#BM_(rvalue%20reference)%2Fi">rvalue reference</a> to an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of the same type (e.g. <code>T(T &amp;&amp;) { ... }</code>). A <a href="#BM_(move%20constructor)%2Fi">move constructor</a> is used to specify the move semantics for that <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
</li>
<li>
<p><a name="BM_(move%20assignment)%2Fi"></a><strong>move assignment</strong> - An assignment <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> that moves one <a href="#BM_(object%7Cinstance)%2Fi">object</a> into another (e.g. <code>x = y</code>).</p>
</li>
<li>
<p><a name="BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi"></a><strong>value categories</strong> - A classification hierarchy for C++ expressions. Any C++ expression falls into one of the following categories: <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a>, or <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a>.</p>
<p>The intent of this hierarchy is to enable the <em>moving</em> of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s. In this case, moving doesn't mean copying. It means gutting out the contents of one <a href="#BM_(object%7Cinstance)%2Fi">object</a> and moving it into another <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<p><img src="svgbob_98c47b0782577adc03415029a6512cbe5425620a.svg" alt="Kroki diagram output"></p>
<ul>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">prvalue</a> - An expression that, once evaluated, is a transient / temporary <a href="#BM_(object%7Cinstance)%2Fi">object</a>.</p>
<pre class="hljs"><code>(x + <span class="hljs-number">51</span>) / n    <span class="hljs-comment">// this is a prvalue      (the result is temporary, needing to go somewhere)</span>
x               <span class="hljs-comment">// this is NOT a prvalue  (the result of x is just x -- it's an exist object)</span>
</code></pre>
</li>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a> - An expression that, once evaluated, is an addressable <a href="#BM_(object%7Cinstance)%2Fi">object</a> (NOT transient / NOT temporary / the <a href="#BM_(address%5B%5C-%5Cs%5Dof)%2Fi">address-of</a> operator is usable on it).</p>
<pre class="hljs"><code>(x + <span class="hljs-number">51</span>) / n    <span class="hljs-comment">// this is NOT an lvalue (the result is temporary, needing to go somewhere)</span>
x               <span class="hljs-comment">// this is a lvalue      (the result of x is just x -- it's an exist object)</span>
</code></pre>
</li>
<li>
<p><a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">xvalue</a> - An expression that, similar to <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, is an addressable <a href="#BM_(object%7Cinstance)%2Fi">object</a>. But, unlike <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">lvalue</a>, the <a href="#BM_(object%7Cinstance)%2Fi">object</a> is marked as being near the end of its <a href="#BM_(lifetime)%2Fi">lifetime</a>.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See the expression categories for more information.</p>
</div>
</li>
<li>
<p><a name="BM_(variable%20length%20array)%2Fi"></a><strong>variable length array</strong> <a name="BM_(VLA)%2F"></a><strong></strong> - A feature of C99 that allows for declaring an <a href="#BM_(automatic%20object%7Cautomatic%20variable%7Cautomatic%20storage%20duration)%2Fi">automatic storage duration</a> array whose length is determined at <a href="#BM_(runtime)%2Fi">runtime</a> (non-constant length). This feature is not available in C++ because C++ provides higher-level abstractions for collections of <a href="#BM_(object%7Cinstance)%2Fi">object</a>s in its STL (speculation).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-type">int</span> x[] = <span class="hljs-type">int</span>[n];  <span class="hljs-comment">// okay in C99, but not in C++</span>
}
</code></pre>
</li>
<li>
<p><a name="BM_(rvalue%20reference)%2Fi"></a><strong>rvalue reference</strong> - A data type that's more-or-less the same as a <a href="#BM_(reference)%2Fi">reference</a> but conveys to the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> that the data it's pointing to is an <a href="#BM_(value%20categories%7Cvalue%20category%7Cpr%5B%5Cs%5C-%5D%3Fvalue%7Cl%5B%5Cs%5C-%5D%3Fvalue%7Cx%5B%5Cs%5C-%5D%3Fvalue%7Cr%5B%5Cs%5C-%5D%3Fvalue%7Cgl%5B%5Cs%5C-%5D%3Fvalue)%2Fi">rvalue</a> (e.g. <code>MyType &amp;&amp;rref { y }</code>).</p>
</li>
<li>
<p><a name="BM_(virtual%20method%7Cvirtual%20function)%2Fi"></a><strong>virtual method</strong> - A <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> in a base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that is overridable by any <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that inherits from that base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x + <span class="hljs-keyword">this</span>-&gt;y;
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi"></a><strong>pure virtual method</strong> - A <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a> that requires an implementation (no implementation has been provided by the base <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that declares it). For a <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> to be instantiable, it cannot have any <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s (similar to an abstract <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> in Java).</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    ...
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    ...
};
</code></pre>
</li>
<li>
<p><a name="BM_(pure%5B%5C-%5Cs%5Dvirtual%20class)%2Fi"></a><strong>pure virtual class</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that only contains <a href="#BM_(pure%5B%5C-%5Cs%5Dvirtual%20method%7Cpure%5B%5C-%5Cs%5Dvirtual%20function)%2Fi">pure virtual method</a>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyParent</span> {
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">v2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyParent</span>() {};  <span class="hljs-comment">// also okay to do   "virtual ~MyParent() = default"</span>
};
</code></pre>
</li>
<li>
<p><a name="BM_(virtual%20destructor)%2Fi"></a><strong>virtual destructor</strong> - A <a href="#BM_(destructor)%2Fi">destructor</a> that's a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual method</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> : MyParent {
    ...
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyStruct</span>() {
        <span class="hljs-comment">// do some cleanup here</span>
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(vtable)%2Fi"></a><strong>vtable</strong> - A table of <a href="#BM_(pointer)%2Fi">pointer</a>s to <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a>s, generated by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>. When a <a href="#BM_(virtual%20method%7Cvirtual%20function)%2Fi">virtual function</a> gets invoked (<a href="#BM_(runtime)%2Fi">runtime</a>) <a href="#BM_(vtable)%2Fi">vtable</a>s are used to determine which <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">method</a> implementation to use.</p>
</li>
<li>
<p><a name="BM_(template)%2Fi"></a><strong>template</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> or function where parts of the code are intended for substitution (by other code). At <a href="#BM_(compile-time)%2Fi">compile-time</a>, a user supplies a set of substitutions for each usage of a <a href="#BM_(template)%2Fi">template</a>, customizing it for the specific use-case that user is dealing with.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-function">X <span class="hljs-title">add</span><span class="hljs-params">(Y y, Z z)</span> </span>{
    <span class="hljs-keyword">return</span> y + z;
}
</code></pre>
</li>
<li>
<p><a name="BM_(template%20parameter)%2Fi"></a><strong>template parameter</strong> - An identifier within the <a href="#BM_(template)%2Fi">template</a>. At compile time, any time a <a href="#BM_(template)%2Fi">template</a> is used its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s are substituted with code that the usage supplies.</p>
<p>A <a href="#BM_(template%20parameter)%2Fi">template parameter</a> may be used multiple times throughout the <a href="#BM_(template)%2Fi">template</a>. At <a href="#BM_(compile-time)%2Fi">compile-time</a>, each usage is substituted with the same piece of code.</p>
<pre class="hljs"><code><span class="hljs-comment">// X, Y, Z, and N are template parameters</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z, <span class="hljs-type">int</span> N&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">X <span class="hljs-title">perform</span><span class="hljs-params">(Y &amp;var1, Z &amp;var2)</span> </span>{
        <span class="hljs-keyword">return</span> (var1 + var2) * N;
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(template%20instantiation)%2Fi"></a><strong>template instantiation</strong> - The process of substituting the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s in a <a href="#BM_(template)%2Fi">template</a> with real code.</p>
<pre class="hljs"><code>MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; obj {}; <span class="hljs-comment">// X = float, Y = int, Z = int, N = 2</span>
<span class="hljs-type">float</span> x { obj.<span class="hljs-built_in">perform</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) };
</code></pre>
</li>
<li>
<p><a name="BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi"></a><strong>named conversion</strong> - A set of language features / functions used for converting types (casting): <code>const_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>, and <code>narrow_cast</code>.</p>
</li>
<li>
<p><a name="BM_(concept)_TEMPLATE%2Fi"></a><strong>concept</strong> - A <a href="#BM_(compile-time)%2Fi">compile-time</a> check to ensure that the type substituted for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a> matches a set of requirements (e.g. the type supports certain operators).</p>
<pre class="hljs"><code><span class="hljs-comment">// concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> TR&gt;
<span class="hljs-keyword">concept</span> MyConcept = std::is_default_constructible&lt;T1&gt;::value
        &amp;&amp; std::is_default_constructible&lt;T2&gt;::value
        &amp;&amp; <span class="hljs-built_in">requires</span>(T1 a, T2 b) {
            { a + b } -&gt; std::same_as&lt;TR&gt;;
            { a * b } -&gt; std::same_as&lt;TR&gt;;
        };

<span class="hljs-comment">// usage of concept</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-function"><span class="hljs-keyword">requires</span> MyConcept&lt;T1, T2, T1&gt;
T1 <span class="hljs-title">add_and_multiply</span><span class="hljs-params">(T1 &amp;var1, T2 &amp;var2)</span> </span>{
    <span class="hljs-keyword">return</span> (var1 + var2) * var2;
}
</code></pre>
</li>
<li>
<p><a name="BM_(compile-time)%2Fi"></a><strong>compile-time</strong> - Used in <a href="#BM_(reference)%2Fi">reference</a> to something that happens during the compilation process.</p>
</li>
<li>
<p><a name="BM_(runtime)%2Fi"></a><strong>runtime</strong> - Used in <a href="#BM_(reference)%2Fi">reference</a> to something that happens when the compiled program is running.</p>
</li>
<li>
<p><a name="BM_%5Cb(zero-arg%7Cno-arg)%5Cb%2Fi"></a><strong>zero-arg</strong> - Short for zero argument. A function with zero parameters.</p>
</li>
<li>
<p><a name="BM_(parameter%20pack)%2Fi"></a><strong>parameter pack</strong> - In the context of <a href="#BM_(template)%2Fi">template</a>s, a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a> is a single <a href="#BM_(template%20parameter)%2Fi">template parameter</a> declaration that can take in zero or more substitutions (<a href="#BM_(variadic%7Cvararg)%2Fi">variadic</a>).</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span>... R&gt;
<span class="hljs-function">X <span class="hljs-title">create</span><span class="hljs-params">(R... args)</span> </span>{
    <span class="hljs-keyword">return</span> X {args...};
}
</code></pre>
</li>
<li>
<p><a name="BM_(variadic%7Cvararg)%2Fi"></a><strong>variadic</strong> - A function that takes in a variable number of arguments, sometimes also called <a href="#BM_(variadic%7Cvararg)%2Fi">vararg</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, ...)</span> </span>{
    va_list args;
    <span class="hljs-built_in">va_start</span>(args, n);
    <span class="hljs-type">float</span> sum {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">while</span> (<span class="hljs-type">size_t</span> i {<span class="hljs-number">0</span>}; i &lt; n; i++) {
        sum += <span class="hljs-built_in">va_args</span>(args, <span class="hljs-type">float</span>);
    }
    <span class="hljs-built_in">va_end</span>(args);
    <span class="hljs-keyword">return</span> sum /= n;
}
</code></pre>
</li>
<li>
<p><a name="BM_(template%20specialization)%2Fi"></a><strong>template specialization</strong> - Given a specific substitutions set substitutions for the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s of a <a href="#BM_(template)%2Fi">template</a>, a <a href="#BM_(template%20specialization)%2Fi">template specialization</a> is code that overrides the <a href="#BM_(template)%2Fi">template</a> generated code. Oftentimes <a href="#BM_(template%20specialization)%2Fi">template specialization</a>s are introduced because they're more memory or computationally efficient than the standard <a href="#BM_(template)%2Fi">template</a> generated code.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// template specialization for bool: bit-wise or</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-type">bool</span> <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-type">bool</span> a, <span class="hljs-type">bool</span> b) {
    <span class="hljs-keyword">return</span> a | b;
}
</code></pre>
</li>
<li>
<p><a name="BM_(partial%20template%20specialization%20%7C%20template%20partial%20specialization)%2Fi"></a><strong>partial template specialization</strong> - A <a href="#BM_(template%20specialization)%2Fi">template specialization</a> where not all of the <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s have been removed.</p>
<pre class="hljs"><code><span class="hljs-comment">// template</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-function">R <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
};

<span class="hljs-comment">// template specialization for pointers of unknown type: already return false</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">bool</span>, X*&gt; {
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sum</span><span class="hljs-params">(X * a, X* b)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</code></pre>
</li>
<li>
<p><a name="BM_(partial%20template)%2Fi"></a><strong>partial template</strong> - A <a href="#BM_(template)%2Fi">template</a> with some of its <a href="#BM_(template%20parameter)%2Fi">template parameter</a>s set (not all).</p>
<pre class="hljs"><code><span class="hljs-comment">// declare</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Y, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-keyword">using</span> MyClassPartialTemplate = MyClass&lt;<span class="hljs-type">float</span>, Y, Z, <span class="hljs-number">42</span>&gt;;

<span class="hljs-comment">// use</span>
MyClass&lt;<span class="hljs-type">float</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt; x{}; 
MyClassPartialTemplate&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; y{};  <span class="hljs-comment">// same type as previous line</span>
</code></pre>
</li>
<li>
<p><a name="BM_(default%20template%20argument)%2Fi"></a><strong>default template argument</strong> - The default substitute in use for a <a href="#BM_(template%20parameter)%2Fi">template parameter</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y = <span class="hljs-type">long</span>, <span class="hljs-keyword">typename</span> Z = <span class="hljs-type">long</span>&gt;
X <span class="hljs-built_in">perform</span>(Y &amp;var1, Z &amp;var2) {
    <span class="hljs-keyword">return</span> var1 + var2;
}
</code></pre>
</li>
<li>
<p><a name="BM_(heap%7Cfree%20store)%2Fi"></a><strong>heap</strong> - An implementation-specific block of memory used for <a href="#BM_(dynamic%20object%7Cdynamic%20array%7Cdynamically%20allocated%20object%7Cdynamically%20allocated%20array%7Cdynamic%20storage%20duration)%2Fi">dynamic object</a>s. Also called the <a href="#BM_(heap%7Cfree%20store)%2Fi">free store</a>.</p>
</li>
<li>
<p><a name="BM_(implicit%20type%20conversion)%2Fi"></a><strong>implicit type conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is converted automatically, without code explicitly changing the <a href="#BM_(object%7Cinstance)%2Fi">object</a> to a different type (e.g. <code>long x {1}</code> implicitly converts the <code>int</code> literal in the initializer to the <code>long</code> type).</p>
</li>
<li>
<p><a name="BM_(explicit%20type%20conversion)%2Fi"></a><strong>explicit type conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is explicitly converted to another type: casting and <a href="#BM_(named%20conversion%20function%7Cnamed%20conversion%7Cconst%5B_%5Cs%5Dcast%7Cstatic%5B_%5Cs%5Dcast%7Creinterpret%5B_%5Cs%5Dcast%7Cnarrow%5B_%5Cs%5Dcast)%2Fi">named conversion</a>s.</p>
</li>
<li>
<p><a name="BM_(promotion%20rule)%2Fi"></a><strong>promotion rule</strong> - An <a href="#BM_(implicit%20type%20conversion)%2Fi">implicit type conversion</a> that may occur when an operator's operands are of differing integral and floating point types. For example, adding an integral type with a smaller integral type will cause the result to be of the same type as the larger type.</p>
<pre class="hljs"><code><span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
<span class="hljs-type">long</span> y {<span class="hljs-number">5L</span>};
<span class="hljs-keyword">auto</span> z {x + y};  <span class="hljs-comment">// z will be long</span>
</code></pre>
</li>
<li>
<p><a name="BM_(narrowing%20conversion)%2Fi"></a><strong>narrowing conversion</strong> - When an <a href="#BM_(object%7Cinstance)%2Fi">object</a> of a certain type is truncated to a lesser type (e.g. <code>int</code> to <code>short</code>).</p>
<p><a href="#BM_(narrowing%20conversion)%2Fi">Narrowing conversion</a>s may be implicit during <a href="#BM_(object%20initialization)%2Fi">object initialization</a>. To erroneous cases of narrowing, use <a href="#BM_(brace%20initialization%7Cbraced%20initialization%7Cuniform%20initialization)%2Fi">braced initialization</a> to force the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> to generate a warning.</p>
</li>
<li>
<p><a name="BM_(constant%20expression)%2Fi"></a><strong>constant expression</strong> - A function that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a>, such that at run-time any invocation of it simply returns the result computed at <a href="#BM_(compile-time)%2Fi">compile-time</a>. <a href="#BM_(constant%20expression)%2Fi">Constant expression</a>s are represented as functions prefixed with <code>constexpr</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span>;
}
</code></pre>
</li>
<li>
<p><a name="BM_(immediate%20function)%2Fi"></a><strong>immediate function</strong> - A function that gets evaluated at <a href="#BM_(compile-time)%2Fi">compile-time</a> and must produce a <a href="#BM_(compile-time)%2Fi">compile-time</a> constant. <a href="#BM_(immediate%20function)%2Fi">Immediate function</a>s expressions are represented as functions prefixed with <code>consteval</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span>;
}
</code></pre>
</li>
<li>
<p><a name="BM_(literal%20type)%2Fi"></a><strong>literal type</strong> - A type that's usable in a <a href="#BM_(constant%20expression)%2Fi">constant expression</a> (for parameters and return), meaning that <a href="#BM_(object%7Cinstance)%2Fi">object</a>s of this type can have a value that's knowable at <a href="#BM_(compile-time)%2Fi">compile-time</a> (e.g. <code>nullptr</code>).</p>
</li>
<li>
<p><a name="BM_(volatile)%2Fi"></a><strong>volatile</strong> - A <a href="#BM_(volatile)%2Fi">volatile</a> variable's usage in code is immune to <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> optimizations such as operation re-ordering and removal. Mutations and accesses, no matter how irrelevant they may seem, are kept in-place and in-order by the <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
x = <span class="hljs-number">5</span>;
x = <span class="hljs-number">6</span>;
x = <span class="hljs-number">7</span>;
</code></pre>
</li>
<li>
<p><a name="BM_(type%20alias)%2Fi"></a><strong>type alias</strong> - A synonym (different name) for an existing type.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> BasicGraph = DirectedGraph::Graph&lt;std::string, std::map&lt;std::string, std::string&gt;, std::string, std::map&lt;std::string, std::string&gt;&gt;;

<span class="hljs-function">BasicGraph <span class="hljs-title">removeLimbs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BasicGraph &amp;g)</span></span>;
</code></pre>
</li>
<li>
<p><a name="BM_(attribute)%2Fi"></a><strong>attribute</strong> - A tag applied to code that provides information to the user / <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> about whatever it is that it's applied to. Similar to Java annotations.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) [[likely]] {
    <span class="hljs-keyword">return</span> x + y;
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">report_error</span>();
}
</code></pre>
</li>
<li>
<p><a name="BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi"></a><strong>iterator</strong> - A type used to access elements within some sequence (e.g. array, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> representing a list, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> representing an infinite stream of <code>int</code>s, etc..). An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> requires a specific set of operators to be implemented, where those operators function similar to accessing memory using <a href="#BM_(pointer%20arithmetic)%2Fi">pointer arithmetic</a> / arrays.</p>
<pre class="hljs"><code>MyIterator it {collection.<span class="hljs-built_in">begin</span>()};
<span class="hljs-keyword">while</span> (it != collection.<span class="hljs-built_in">end</span>()) {
    MyObject value {*it};
    <span class="hljs-comment">// do something with value here</span>
    ++iterator;
}
</code></pre>
<p>Five types of <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a>s exist:</p>
<ul>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that can only move forward in the sequence one element at a time and can only read elements of the sequence.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that can only move forward in the sequence one element at a time and can only write elements of the sequence.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that combines the functionality of both <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">input iterator</a> and <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">output iterator</a>.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that has the same functionality as <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">forward iterator</a> but also allows for moving backward in the sequence one element at a time, meaning it
can move forward as well as backward.</li>
<li><a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">random access iterator</a> - An <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">iterator</a> that has the same functionality as <a href="#BM_(input%20iterator%7Coutput%20iterator%7Cforward%20iterator%7Cbi-%3Fdirectional%20iterator%7Crandom%20access%20iterator%7Citerator)%2Fi">bidirectional iterator</a> but also allows randomly jumping to different elements within the sequence.</li>
</ul>
</li>
<li>
<p><a name="BM_(specifier%7Cmodifier)%2Fi"></a><strong>modifier</strong> - Optional marker that alters a function. With functions, a <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a> may be required to go either before the return type (prefix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>) or after the parameter list (suffix <a href="#BM_(specifier%7Cmodifier)%2Fi">modifier</a>).</p>
<pre class="hljs"><code><span class="hljs-comment">//                  modifier here</span>
<span class="hljs-comment">//                    vvvvvvvv</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">noexcept</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}
</code></pre>
<p><a href="#BM_(specifier%7Cmodifier)%2Fi">Modifier</a>s are also sometimes referred to as <a href="#BM_(specifier%7Cmodifier)%2Fi">specifier</a>s.</p>
</li>
<li>
<p><a name="BM_(fold%20expression)%2Fi"></a><strong>fold expression</strong> - Exhaustively applies a binary operator to the contents of a <a href="#BM_(parameter%20pack)%2Fi">parameter pack</a> and returns the final result.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... R&gt;
T <span class="hljs-title">test</span><span class="hljs-params">(R... args)</span> </span>{
    R l_ass_res {... - args};  <span class="hljs-comment">// ((((a-b)-c)-d)-...)</span>
    R r_ass_res {args - ...};  <span class="hljs-comment">// (...-(w-(x-(y-z))))</span>
    <span class="hljs-keyword">return</span> l_ass_res + r_ass_res;
}
</code></pre>
</li>
<li>
<p><a name="BM_(associativity%7Cassociative)%2Fi"></a><strong>associativity</strong> - In the context of binary operators, <a href="#BM_(associativity%7Cassociative)%2Fi">associativity</a> refers to the order in which an expression with a chain of the same binary operator is evaluated. The term ...</p>
<ul>
<li>
<p>left <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> means that the chain is evaluated left-to-right (left-most first, right-most last).</p>
<pre class="hljs"><code>a ? b ? c ? d == (((a ? b) ? c) ? d)
</code></pre>
</li>
<li>
<p>right <a href="#BM_(associativity%7Cassociative)%2Fi">associative</a> means that the chain is evaluated right-to-left (right-most first, left-most last).</p>
<pre class="hljs"><code>a ? b ? c ? d == (a ? (b ? (c ? d)))
</code></pre>
</li>
</ul>
</li>
<li>
<p><a name="BM_(function%20pointer)%2Fi"></a><strong>function pointer</strong> - A <a href="#BM_(pointer)%2Fi">pointer</a> to a function.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-built_in">int</span> (*p)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {add};
<span class="hljs-built_in">p</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// invoke</span>
</code></pre>
</li>
<li>
<p><a name="BM_(functor%7Cfunction%20object)%2Fi"></a><strong>functor</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that you can invoke as if it were a function because it has an <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a> for the <a href="#BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi">function-call operator</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctor</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> x {<span class="hljs-number">5</span>};
};
</code></pre>
</li>
<li>
<p><a name="BM_(function%5B%5Cs%5C-%5Dcall%20operator)%2Fi"></a><strong>function call operator</strong> - The operator used for making function calls (parenthesis), may be <a href="#BM_(operator%20overload%7Coverloaded%20operator)%2Fi">operator overload</a>ed on <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>es to turn them into <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; }
</code></pre>
</li>
<li>
<p><a name="BM_(lambda)%2Fi"></a><strong>lambda</strong> - Shorthand notation for an unnamed <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> -z; };
</code></pre>
</li>
<li>
<p><a name="BM_(named%20capture)%2Fi"></a><strong>named capture</strong> - Pulling in <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope into a <a href="#BM_(lambda)%2Fi">lambda</a> by explicitly listing their names in the capture clause, adding <code>&amp;</code> before each name if wanting to pull it in by <a href="#BM_(reference)%2Fi">reference</a> rather than by copy.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [&amp;x, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; }; <span class="hljs-comment">// x and y from outer scope</span>
</code></pre>
</li>
<li>
<p><a name="BM_(default%20capture)%2Fi"></a><strong>default capture</strong> - Pulling in <a href="#BM_(object%7Cinstance)%2Fi">object</a>s from the outer scope into a <a href="#BM_(lambda)%2Fi">lambda</a> automatically (based on their usage) but putting either an <code>=</code> (for copying into <a href="#BM_(lambda)%2Fi">lambda</a>) or <code>&amp;</code> (for referencing into <a href="#BM_(lambda)%2Fi">lambda</a>) in the capture clause.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [=] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> x + y + z; };
</code></pre>
</li>
<li>
<p><a name="BM_(init%20capture%7Cinitializer%20capture)%2Fi"></a><strong>init capture</strong> - An initializer expression used as a <a href="#BM_(lambda)%2Fi">lambda</a> <a href="#BM_(named%20capture)%2Fi">named capture</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">auto</span> f = [new_x=x/<span class="hljs-number">2</span>, &amp;y] (<span class="hljs-type">int</span> z) -&gt; <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> new_x + y + z; };
</code></pre>
</li>
<li>
<p><a name="BM_(callable%20object)%2Fi"></a><strong>callable object</strong> - An <a href="#BM_(object%7Cinstance)%2Fi">object</a> that can be invoked: a function, <a href="#BM_(functor%7Cfunction%20object)%2Fi">functor</a>, or <a href="#BM_(lambda)%2Fi">lambda</a>.</p>
</li>
<li>
<p><a name="BM_(function%20overload%7Coverloaded%20function%7Coverload)%2Fi"></a><strong>function overload</strong> - A function that has the same name as another function within the same scope.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a != <span class="hljs-number">0.0</span>; }
</code></pre>
</li>
<li>
<p><a name="BM_(operator%20overload%7Coverloaded%20operator)%2Fi"></a><strong>operator overload</strong> - A function that gets invoked when a certain operator is used with some specific <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>. The function can be either a <a href="#BM_(free%20function%7Cnon-member%20function)%2Fi">free function</a> or a <a href="#BM_(method%7C%5Cbmember%20function)%2Fi">member function</a> of the <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> the operator is intended for.</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span> {
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> -y + x; } <span class="hljs-comment">// function call operator</span>
   ...
};
</code></pre>
</li>
<li>
<p><a name="BM_(forward%20declaration)%2Fi"></a><strong>forward declaration</strong> - To use a function, <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a>, variable, etc.. within some C++ code, only its declaration is needed, not its definition (implementation). The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> will ensure that the usage points to the implementation when the time comes.</p>
<p>The <a href="#BM_(compiler%7Cobject%20file%7Cobject%20code)%2Fi">compiler</a> needs this to handle cyclical <a href="#BM_(reference)%2Fi">reference</a>s. It can also significantly reduce build times.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span>; <span class="hljs-comment">// forward declaration of MyClassA</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassB</span>; <span class="hljs-comment">// forward declaration of MyClassB</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClassA &amp;objA, MyClassB &amp;objB)</span></span>; <span class="hljs-comment">// forward declaration of a function</span>


<span class="hljs-comment">// implement myFunction, using MyClassA and MyClassB before implementation is defined</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClassA &amp;objA, MyClassB &amp;objB)</span> </span>{
    ...
}
<span class="hljs-comment">// implement MyClassA, using MyClassB before implementation is defined</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span> {
    ...
<span class="hljs-keyword">private</span>:
    MyClassB objB;
}
<span class="hljs-comment">// implement MyClassB</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassA</span> {
    ...
<span class="hljs-keyword">private</span>:
    MyClassA objA;
}
</code></pre>
</li>
<li>
<p><a name="BM_(user-defined%20literal)%2Fi"></a><strong>user-defined literal</strong> - A literal suffix defined by a user, where when that suffix is applied to some literal, some computation is performed.</p>
<pre class="hljs"><code>Distance d {<span class="hljs-number">42.0</span>_km};  <span class="hljs-comment">// the suffix _km converts the literal 42.0 to an instance of the Distance type</span>
</code></pre>
</li>
<li>
<p><a name="BM_(module%20unit)%2Fi"></a><strong>module unit</strong> - A <a href="#BM_(preprocessor%7Ctranslation%20unit)%2Fi">translation unit</a> that contains a module declaration.</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> MyModule;  <span class="hljs-comment">// module declaration</span>

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
   <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
</li>
<li>
<p><a name="BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi"></a><strong>three-way comparison operator</strong> - Given two <a href="#BM_(object%7Cinstance)%2Fi">object</a>s <code>a</code> and <code>b</code>, the <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">three-way comparison operator</a> determines if <code>a &lt; b</code>, <code>a == b</code>, or <code>a &gt; b</code>.</p>
<p>The symbol for the operator is an equal-sign sandwiched between angle brackets: <code>a &lt;=&gt; b</code>. This operator is sometimes called the <a href="#BM_(three-way%20comparison%20operator%7C3-way%20comparison%20operator%7Cspaceship%20operator)%2Fi">spaceship operator</a> because it's said that the symbol for the operator looks like a spaceship.</p>
</li>
<li>
<p><a name="BM_(smart%20pointer)%2Fi"></a><strong>smart pointer</strong> - A <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> that wraps a <a href="#BM_(pointer)%2Fi">pointer</a> to a dynamically <a href="#BM_(object%7Cinstance)%2Fi">object</a>. The <a href="#BM_(class%7C%5Cbstruct)%2Fi">class</a> provides some level of automated <a href="#BM_(pointer)%2Fi">pointer</a> management / memory management through the use of move semantics, <a href="#BM_(copy%20semantics)%2Fi">copy semantics</a>, and <a href="#BM_(RAII%7CCADRe)%2F">RAII</a>.</p>
</li>
</ul>
<p>


</p>
<p>
</p>
<p></p>

        </body></html>